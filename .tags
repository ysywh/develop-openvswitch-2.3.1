!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
A	.\lib\meta-flow.c	2500;"	d	file:
A	.\lib\meta-flow.c	2513;"	d	file:
ABORTED	.\python\ovs\db\idl.py	/^    ABORTED = "aborted"          # ovsdb_idl_txn_abort() called.$/;"	v	class:Transaction
ACTION_FOR_EACH	.\lib\ofp-actions.c	625;"	d	file:
ACTIVE	.\lib\netdev-dummy.c	/^    ACTIVE      \/* Connect to listener. *\/$/;"	e	enum:dummy_packet_conn_type	file:
ACTIVE_TIMEOUT	.\ofproto\ofproto-dpif-ipfix.c	/^    ACTIVE_TIMEOUT = 0x02,$/;"	e	enum:ipfix_flow_end_reason	file:
ADD	.\ofproto\bond.c	/^    ADD,        \/* Add the rule to ofproto's flow table. *\/$/;"	e	enum:bond_op	file:
ADD	.\ofproto\in-band.c	/^    ADD,                       \/* Add the rule to ofproto's flow table. *\/$/;"	e	enum:in_band_op	file:
ADD_ALL_VLANS_CMD	.\utilities\ovs-vlan-bug-workaround.c	34;"	d	file:
ADVERTISED_Asym_Pause	.\lib\netdev-linux.c	92;"	d	file:
ADVERTISED_Pause	.\lib\netdev-linux.c	89;"	d	file:
AES128_H	.\lib\aes128.h	26;"	d
AF_INET	.\include\sparse\sys\socket.h	/^    AF_INET,$/;"	e	enum:__anon32
AF_INET6	.\include\sparse\sys\socket.h	/^    AF_INET6,$/;"	e	enum:__anon32
AF_NETLINK	.\include\sparse\sys\socket.h	/^    AF_NETLINK,$/;"	e	enum:__anon32
AF_PACKET	.\include\sparse\sys\socket.h	/^    AF_PACKET,$/;"	e	enum:__anon32
AF_UNIX	.\include\sparse\sys\socket.h	/^    AF_UNIX,$/;"	e	enum:__anon32
AF_UNSPEC	.\include\sparse\sys\socket.h	/^    AF_UNSPEC,$/;"	e	enum:__anon32
ALIGNED_CAST	.\lib\util.h	234;"	d
ALWAYS_INLINE	.\lib\compiler.h	34;"	d
ALWAYS_INLINE	.\lib\compiler.h	46;"	d
ARP_ETH_HEADER_LEN	.\lib\packets.h	563;"	d
ARP_HRD_ETHERNET	.\lib\packets.h	557;"	d
ARP_OP_RARP	.\lib\packets.h	561;"	d
ARP_OP_REPLY	.\lib\packets.h	560;"	d
ARP_OP_REQUEST	.\lib\packets.h	559;"	d
ARP_PRO_IP	.\lib\packets.h	558;"	d
ARRAY_SIZE	.\lib\util.h	108;"	d
ASSERT_OVSL	.\datapath\datapath.h	152;"	d
ASSIGN_CONTAINER	.\lib\util.h	229;"	d
ASYNC_APPEND_H	.\lib\async-append.h	17;"	d
ATOMIC	.\lib\ovs-atomic-c11.h	26;"	d
ATOMIC	.\lib\ovs-atomic-clang.h	24;"	d
ATOMIC	.\lib\ovs-atomic-gcc4+.h	25;"	d
ATOMIC	.\lib\ovs-atomic-gcc4.7+.h	22;"	d
ATOMIC	.\lib\ovs-atomic-pthreads.h	26;"	d
ATOMIC_BOOL_LOCK_FREE	.\lib\ovs-atomic-gcc4+.h	27;"	d
ATOMIC_BOOL_LOCK_FREE	.\lib\ovs-atomic-pthreads.h	28;"	d
ATOMIC_CHAR_LOCK_FREE	.\lib\ovs-atomic-gcc4+.h	28;"	d
ATOMIC_CHAR_LOCK_FREE	.\lib\ovs-atomic-pthreads.h	29;"	d
ATOMIC_FLAG_INIT	.\lib\ovs-atomic-flag-gcc4.7+.h	27;"	d
ATOMIC_FLAG_INIT	.\lib\ovs-atomic-gcc4+.h	146;"	d
ATOMIC_FLAG_INIT	.\lib\ovs-atomic-pthreads.h	92;"	d
ATOMIC_INT_LOCK_FREE	.\lib\ovs-atomic-gcc4+.h	30;"	d
ATOMIC_INT_LOCK_FREE	.\lib\ovs-atomic-pthreads.h	31;"	d
ATOMIC_LLONG_LOCK_FREE	.\lib\ovs-atomic-gcc4+.h	32;"	d
ATOMIC_LLONG_LOCK_FREE	.\lib\ovs-atomic-pthreads.h	33;"	d
ATOMIC_LONG_LOCK_FREE	.\lib\ovs-atomic-gcc4+.h	31;"	d
ATOMIC_LONG_LOCK_FREE	.\lib\ovs-atomic-pthreads.h	32;"	d
ATOMIC_POINTER_LOCK_FREE	.\lib\ovs-atomic-gcc4+.h	33;"	d
ATOMIC_POINTER_LOCK_FREE	.\lib\ovs-atomic-pthreads.h	34;"	d
ATOMIC_SHORT_LOCK_FREE	.\lib\ovs-atomic-gcc4+.h	29;"	d
ATOMIC_SHORT_LOCK_FREE	.\lib\ovs-atomic-pthreads.h	30;"	d
ATOMIC_TYPES	.\python\ovs\db\types.py	/^ATOMIC_TYPES = [VoidType, IntegerType, RealType, BooleanType, StringType,$/;"	v
ATOMIC_VAR_INIT	.\lib\ovs-atomic-clang.h	26;"	d
ATOMIC_VAR_INIT	.\lib\ovs-atomic-gcc4+.h	46;"	d
ATOMIC_VAR_INIT	.\lib\ovs-atomic-gcc4.7+.h	33;"	d
ATOMIC_VAR_INIT	.\lib\ovs-atomic-pthreads.h	45;"	d
AUTOTEST	.\tests\automake.mk	/^AUTOTEST = $(AUTOM4TE) --language=autotest$/;"	m
AUTOTEST_PATH	.\tests\automake.mk	/^AUTOTEST_PATH = utilities:vswitchd:ovsdb:vtep:tests$/;"	m
Action	.\python\compat\argparse.py	/^class Action(_AttributeHolder):$/;"	c
ActivateHandler	.\xenserver\usr_lib_xsconsole_plugins-base_XSFeatureVSwitch.py	/^    def ActivateHandler(cls):$/;"	m	class:XSFeatureVSwitch
Active	.\python\ovs\reconnect.py	/^    class Active(object):$/;"	c	class:Reconnect
ArgumentDefaultsHelpFormatter	.\python\compat\argparse.py	/^class ArgumentDefaultsHelpFormatter(HelpFormatter):$/;"	c
ArgumentError	.\python\compat\argparse.py	/^class ArgumentError(Exception):$/;"	c
ArgumentParser	.\python\compat\argparse.py	/^class ArgumentParser(_AttributeHolder, _ActionsContainer):$/;"	c
ArgumentTypeError	.\python\compat\argparse.py	/^class ArgumentTypeError(Exception):$/;"	c
Atom	.\python\ovs\db\data.py	/^class Atom(object):$/;"	c
AtomicType	.\python\ovs\db\types.py	/^class AtomicType(object):$/;"	c
BACKTRACE_H	.\lib\backtrace.h	18;"	d
BACKTRACE_MAX_FRAMES	.\lib\backtrace.h	64;"	d
BADARG	.\lib\getopt_long.c	56;"	d	file:
BADCH	.\lib\getopt_long.c	55;"	d	file:
BAD_UPCALL	.\ofproto\ofproto-dpif-upcall.c	/^    BAD_UPCALL,                 \/* Some kind of bug somewhere. *\/$/;"	e	enum:upcall_type	file:
BE16S_TO_BE32	.\lib\byte-order.h	84;"	d
BE16S_TO_BE32	.\lib\byte-order.h	89;"	d
BFD_DEST_PORT	.\lib\bfd.h	19;"	d
BFD_H	.\lib\bfd.h	16;"	d
BFD_PACKET_LEN	.\lib\bfd.h	18;"	d
BFD_VERSION	.\lib\bfd.c	85;"	d	file:
BITMAP_FOR_EACH_1	.\lib\bitmap.h	107;"	d
BITMAP_H	.\lib\bitmap.h	18;"	d
BITMAP_N_LONGS	.\lib\bitmap.h	38;"	d
BITMAP_ULONG_BITS	.\lib\bitmap.h	24;"	d
BM_AB	.\ofproto\bond.h	/^    BM_AB   \/* Active Backup. *\/$/;"	e	enum:bond_mode
BM_SLB	.\ofproto\bond.h	/^    BM_SLB, \/* Source Load Balance. *\/$/;"	e	enum:bond_mode
BM_TCP	.\ofproto\bond.h	/^    BM_TCP, \/* Transport Layer Load Balance. *\/$/;"	e	enum:bond_mode
BOND_BUCKETS	.\ofproto\bond.c	58;"	d	file:
BOND_H	.\ofproto\bond.h	18;"	d
BOND_MASK	.\ofproto\bond.c	57;"	d	file:
BS_CLOSED	.\ofproto\bundles.c	/^    BS_CLOSED$/;"	e	enum:bundle_state	file:
BS_OPEN	.\ofproto\bundles.c	/^    BS_OPEN,$/;"	e	enum:bundle_state	file:
BUFFER_SIZE	.\lib\async-append-aio.c	/^enum { BUFFER_SIZE = 65536 };$/;"	e	enum:__anon36	file:
BUILD_ASSERT	.\lib\util.h	42;"	d
BUILD_ASSERT	.\lib\util.h	50;"	d
BUILD_ASSERT	.\lib\util.h	57;"	d
BUILD_ASSERT_DECL	.\lib\util.h	43;"	d
BUILD_ASSERT_DECL	.\lib\util.h	53;"	d
BUILD_ASSERT_DECL	.\lib\util.h	58;"	d
BUILD_ASSERT_DECL_GCCONLY	.\lib\util.h	63;"	d
BUILD_ASSERT_DECL_GCCONLY	.\lib\util.h	66;"	d
BUILD_ASSERT_GCCONLY	.\lib\util.h	62;"	d
BUILD_ASSERT_GCCONLY	.\lib\util.h	65;"	d
BUILD_ASSERT__	.\lib\util.h	46;"	d
BUILD_BUG_ON_INVALID	.\datapath\linux\compat\include\linux\bug.h	8;"	d
BUILD_CLANG	.\utilities\ovs-dev.py	/^BUILD_CLANG = OVS_SRC + "\/_build-clang"$/;"	v
BUILD_GCC	.\utilities\ovs-dev.py	/^BUILD_GCC = OVS_SRC + "\/_build-gcc"$/;"	v
BUNDLES_H	.\ofproto\bundles.h	19;"	d
BUNDLE_H	.\lib\bundle.h	17;"	d
BUNDLE_MAX_SLAVES	.\lib\bundle.c	34;"	d	file:
BV_ACCEPT	.\ofproto\bond.h	/^    BV_ACCEPT,                  \/* Accept this packet. *\/$/;"	e	enum:bond_verdict
BV_DROP	.\ofproto\bond.h	/^    BV_DROP,                    \/* Drop this packet. *\/$/;"	e	enum:bond_verdict
BV_DROP_IF_MOVED	.\ofproto\bond.h	/^    BV_DROP_IF_MOVED            \/* Drop if we've learned a different port. *\/$/;"	e	enum:bond_verdict
BYTEQ_H	.\lib\byteq.h	17;"	d
BYTES_TO_BE32	.\lib\byte-order.h	82;"	d
BYTES_TO_BE32	.\lib\byte-order.h	87;"	d
BYTE_ORDER_H	.\lib\byte-order.h	17;"	d
Backoff	.\python\ovs\reconnect.py	/^    class Backoff(object):$/;"	c	class:Reconnect
BaseType	.\python\ovs\db\types.py	/^class BaseType(object):$/;"	c
BooleanType	.\python\ovs\db\types.py	/^BooleanType = AtomicType("boolean", False, (bool,))$/;"	v
BuildPane	.\xenserver\usr_lib_xsconsole_plugins-base_XSFeatureVSwitch.py	/^    def BuildPane(self):$/;"	m	class:VSwitchControllerDialogue
CACHE_LINE_SIZE	.\lib\util.h	152;"	d
CASE_MFF_REGS	.\lib\meta-flow.h	152;"	d
CASE_MFF_REGS	.\lib\meta-flow.h	155;"	d
CASE_MFF_REGS	.\lib\meta-flow.h	158;"	d
CASE_MFF_REGS	.\lib\meta-flow.h	161;"	d
CASE_MFF_REGS	.\lib\meta-flow.h	164;"	d
CASE_MFF_REGS	.\lib\meta-flow.h	168;"	d
CASE_MFF_REGS	.\lib\meta-flow.h	172;"	d
CASE_MFF_REGS	.\lib\meta-flow.h	176;"	d
CCALL	.\lib\compiler.h	197;"	d
CCM_ACCEPT_LEN	.\lib\cfm.c	61;"	d	file:
CCM_LEN	.\lib\cfm.c	60;"	d	file:
CCM_MAID_LEN	.\lib\cfm.c	62;"	d	file:
CCM_OPCODE	.\lib\cfm.c	63;"	d	file:
CCM_RDI_MASK	.\lib\cfm.c	64;"	d	file:
CFM_FAULT_N_REASONS	.\lib\cfm.h	/^    CFM_FAULT_N_REASONS$/;"	e	enum:cfm_fault_bit_index
CFM_FAULT_REASON	.\lib\cfm.c	196;"	d	file:
CFM_FAULT_REASON	.\lib\cfm.c	198;"	d	file:
CFM_FAULT_REASON	.\lib\cfm.h	40;"	d
CFM_FAULT_REASON	.\lib\cfm.h	42;"	d
CFM_FAULT_REASON	.\lib\cfm.h	47;"	d
CFM_FAULT_REASON	.\lib\cfm.h	50;"	d
CFM_FAULT_REASONS	.\lib\cfm.h	/^    CFM_FAULT_REASONS$/;"	e	enum:cfm_fault_bit_index
CFM_FAULT_REASONS	.\lib\cfm.h	/^    CFM_FAULT_REASONS$/;"	e	enum:cfm_fault_reason
CFM_FAULT_REASONS	.\lib\cfm.h	31;"	d
CFM_H	.\lib\cfm.h	17;"	d
CFM_HEALTH_INTERVAL	.\lib\cfm.c	65;"	d	file:
CFM_MAX_RMPS	.\lib\cfm.c	43;"	d	file:
CFM_RANDOM_VLAN	.\lib\cfm.h	29;"	d
CF_BARE	.\lib\table.h	/^    CF_BARE,                    \/* String format without most punctuation. *\/$/;"	e	enum:cell_format
CF_JSON	.\lib\table.h	/^    CF_JSON                     \/* JSON. *\/$/;"	e	enum:cell_format
CF_STRING	.\lib\table.h	/^    CF_STRING,                  \/* String format. *\/$/;"	e	enum:cell_format
CHECK	.\tests\test-lockfile.c	40;"	d	file:
CHECK	.\tests\test-vconn.c	58;"	d	file:
CHECKSUM_COMPLETE	.\datapath\linux\compat\include\linux\skbuff.h	96;"	d
CHECKSUM_PARTIAL	.\datapath\linux\compat\include\linux\skbuff.h	93;"	d
CHECK_ERRNO	.\tests\test-vconn.c	70;"	d	file:
CHECK_PYFILES	.\tests\automake.mk	/^CHECK_PYFILES = \\$/;"	m
CHILD	.\tests\test-lockfile.c	/^static enum { PARENT, CHILD }$/;"	e	enum:__anon157	file:
CLASSIFIER_H	.\lib\classifier.h	18;"	d
CLIENT	.\lib\stream-ssl.c	/^    CLIENT,$/;"	e	enum:session_type	file:
CLOCK_MONOTONIC	.\lib\timeval.c	48;"	d	file:
CLOCK_REALTIME	.\lib\timeval.c	52;"	d	file:
CLS_CURSOR_FOR_EACH	.\lib\classifier.h	328;"	d
CLS_CURSOR_FOR_EACH_SAFE	.\lib\classifier.h	334;"	d
CLS_FIELD	.\tests\test-classifier.c	70;"	d	file:
CLS_FIELD	.\tests\test-classifier.c	72;"	d	file:
CLS_FIELD	.\tests\test-classifier.c	84;"	d	file:
CLS_FIELD	.\tests\test-classifier.c	89;"	d	file:
CLS_FIELDS	.\tests\test-classifier.c	/^    CLS_FIELDS$/;"	e	enum:__anon156	file:
CLS_FIELDS	.\tests\test-classifier.c	48;"	d	file:
CLS_MAX_INDICES	.\lib\classifier.c	/^    CLS_MAX_INDICES = 3   \/* Maximum number of lookup indices per subtable. *\/$/;"	e	enum:__anon38	file:
CLS_MAX_TRIES	.\lib\classifier.h	/^    CLS_MAX_TRIES = 3    \/* Maximum number of prefix trees per classifier. *\/$/;"	e	enum:__anon39
CLS_N_FIELDS	.\tests\test-classifier.c	/^    CLS_N_FIELDS$/;"	e	enum:__anon156	file:
CLS_SUBTABLE_CACHE_FOR_EACH	.\lib\classifier.c	250;"	d	file:
CLS_SUBTABLE_CACHE_FOR_EACH_CONTINUE	.\lib\classifier.c	255;"	d	file:
CLS_SUBTABLE_CACHE_FOR_EACH_REVERSE	.\lib\classifier.c	260;"	d	file:
CLZ_STEP	.\lib\util.c	982;"	d	file:
CLZ_STEP	.\lib\util.c	994;"	d	file:
CMSG_ALIGN	.\include\sparse\sys\socket.h	59;"	d
CMSG_DATA	.\include\sparse\sys\socket.h	61;"	d
CMSG_FIRSTHDR	.\include\sparse\sys\socket.h	64;"	d
CMSG_LEN	.\include\sparse\sys\socket.h	62;"	d
CMSG_NXTHDR	.\include\sparse\sys\socket.h	66;"	d
CMSG_SPACE	.\include\sparse\sys\socket.h	63;"	d
COLLECTORS_H	.\ofproto\collectors.h	18;"	d
COMMAND_LINE_H	.\lib\command-line.h	18;"	d
COMPACT_MIN_MSEC	.\ovsdb\file.c	43;"	d	file:
COMPACT_RETRY_MSEC	.\ovsdb\file.c	47;"	d	file:
COMPAT_H	.\datapath\compat.h	20;"	d
COMPILER_H	.\lib\compiler.h	18;"	d
CONFIG_NET_IPGRE_DEMUX	.\datapath\linux\compat\include\linux\kconfig.h	7;"	d
CONNECT	.\python\ovs\reconnect.py	/^CONNECT = 'connect'$/;"	v
CONNECTIVITY_H	.\lib\connectivity.h	18;"	d
CONNMGR_H	.\ofproto\connmgr.h	18;"	d
CONST1	.\lib\sha1.c	68;"	d	file:
CONST2	.\lib\sha1.c	69;"	d	file:
CONST3	.\lib\sha1.c	70;"	d	file:
CONST4	.\lib\sha1.c	71;"	d	file:
CONSTANT_HTONL	.\lib\byte-order.h	58;"	d
CONSTANT_HTONL	.\lib\byte-order.h	65;"	d
CONSTANT_HTONLL	.\lib\byte-order.h	59;"	d
CONSTANT_HTONLL	.\lib\byte-order.h	70;"	d
CONSTANT_HTONS	.\lib\byte-order.h	57;"	d
CONSTANT_HTONS	.\lib\byte-order.h	62;"	d
CONST_CAST	.\lib\util.h	86;"	d
CONTAINER_OF	.\lib\util.h	210;"	d
CONTROL_PORT	.\python\ovstest\args.py	/^CONTROL_PORT = 15531$/;"	v
COOKIE_BITS	.\ofproto\pktbuf.c	45;"	d	file:
COOKIE_MAX	.\ofproto\pktbuf.c	46;"	d	file:
COVERAGE	.\tests\automake.mk	/^COVERAGE = coverage$/;"	m
COVERAGE_ADD	.\lib\coverage.h	87;"	d
COVERAGE_CLEAR_INTERVAL	.\lib\coverage.h	40;"	d
COVERAGE_DEFINE	.\lib\coverage.h	62;"	d
COVERAGE_DEFINE__	.\lib\coverage.h	95;"	d
COVERAGE_FILE	.\tests\automake.mk	/^COVERAGE_FILE='$(abs_srcdir)\/.coverage'$/;"	m
COVERAGE_H	.\lib\coverage.h	18;"	d
COVERAGE_INC	.\lib\coverage.h	84;"	d
COVERAGE_RUN_INTERVAL	.\lib\coverage.h	37;"	d
CRC32C_H	.\lib\crc32c.h	19;"	d
CSUM_H	.\lib\csum.h	18;"	d
CSUM_MANGLED_0	.\datapath\linux\compat\include\net\checksum.h	36;"	d
CTRL_ATTR_FAMILY_ID	.\lib\netlink-protocol.h	/^        CTRL_ATTR_FAMILY_ID,$/;"	e	enum:__anon63
CTRL_ATTR_FAMILY_NAME	.\lib\netlink-protocol.h	/^        CTRL_ATTR_FAMILY_NAME,$/;"	e	enum:__anon63
CTRL_ATTR_HDRSIZE	.\lib\netlink-protocol.h	/^        CTRL_ATTR_HDRSIZE,$/;"	e	enum:__anon63
CTRL_ATTR_MAX	.\lib\netlink-protocol.h	138;"	d
CTRL_ATTR_MAX	.\lib\netlink-protocol.h	168;"	d
CTRL_ATTR_MAX	.\lib\netlink-protocol.h	169;"	d
CTRL_ATTR_MAXATTR	.\lib\netlink-protocol.h	/^        CTRL_ATTR_MAXATTR,$/;"	e	enum:__anon63
CTRL_ATTR_MCAST_GROUPS	.\lib\netlink-protocol.h	170;"	d
CTRL_ATTR_MCAST_GRP_ID	.\lib\netlink-protocol.h	/^    CTRL_ATTR_MCAST_GRP_ID,$/;"	e	enum:__anon65
CTRL_ATTR_MCAST_GRP_MAX	.\lib\netlink-protocol.h	179;"	d
CTRL_ATTR_MCAST_GRP_NAME	.\lib\netlink-protocol.h	/^    CTRL_ATTR_MCAST_GRP_NAME,$/;"	e	enum:__anon65
CTRL_ATTR_MCAST_GRP_UNSPEC	.\lib\netlink-protocol.h	/^    CTRL_ATTR_MCAST_GRP_UNSPEC,$/;"	e	enum:__anon65
CTRL_ATTR_OPS	.\lib\netlink-protocol.h	/^        CTRL_ATTR_OPS,$/;"	e	enum:__anon63
CTRL_ATTR_OP_FLAGS	.\lib\netlink-protocol.h	/^        CTRL_ATTR_OP_FLAGS,$/;"	e	enum:__anon64
CTRL_ATTR_OP_ID	.\lib\netlink-protocol.h	/^        CTRL_ATTR_OP_ID,$/;"	e	enum:__anon64
CTRL_ATTR_OP_MAX	.\lib\netlink-protocol.h	147;"	d
CTRL_ATTR_OP_UNSPEC	.\lib\netlink-protocol.h	/^        CTRL_ATTR_OP_UNSPEC,$/;"	e	enum:__anon64
CTRL_ATTR_UNSPEC	.\lib\netlink-protocol.h	/^        CTRL_ATTR_UNSPEC,$/;"	e	enum:__anon63
CTRL_ATTR_VERSION	.\lib\netlink-protocol.h	/^        CTRL_ATTR_VERSION,$/;"	e	enum:__anon63
CTRL_CMD_DELFAMILY	.\lib\netlink-protocol.h	/^        CTRL_CMD_DELFAMILY,$/;"	e	enum:__anon62
CTRL_CMD_DELOPS	.\lib\netlink-protocol.h	/^        CTRL_CMD_DELOPS,$/;"	e	enum:__anon62
CTRL_CMD_GETFAMILY	.\lib\netlink-protocol.h	/^        CTRL_CMD_GETFAMILY,$/;"	e	enum:__anon62
CTRL_CMD_GETOPS	.\lib\netlink-protocol.h	/^        CTRL_CMD_GETOPS,$/;"	e	enum:__anon62
CTRL_CMD_MAX	.\lib\netlink-protocol.h	125;"	d
CTRL_CMD_NEWFAMILY	.\lib\netlink-protocol.h	/^        CTRL_CMD_NEWFAMILY,$/;"	e	enum:__anon62
CTRL_CMD_NEWOPS	.\lib\netlink-protocol.h	/^        CTRL_CMD_NEWOPS,$/;"	e	enum:__anon62
CTRL_CMD_UNSPEC	.\lib\netlink-protocol.h	/^        CTRL_CMD_UNSPEC,$/;"	e	enum:__anon62
CTZ_STEP	.\lib\util.c	958;"	d	file:
CTZ_STEP	.\lib\util.c	970;"	d	file:
CannotListenError	.\python\ovstest\rpcserver.py	/^from twisted.internet.error import CannotListenError$/;"	i
ChangeState	.\xenserver\usr_lib_xsconsole_plugins-base_XSFeatureVSwitch.py	/^    def ChangeState(self, inState):$/;"	m	class:VSwitchControllerDialogue
ClientFactory	.\python\ovstest\tcp.py	/^from twisted.internet.protocol import Factory, ClientFactory, Protocol$/;"	i
ColumnSchema	.\python\ovs\db\schema.py	/^class ColumnSchema(object):$/;"	c
ConfigurationFile	.\xenserver\opt_xensource_libexec_InterfaceReconfigure.py	/^class ConfigurationFile(object):$/;"	c
ConnectInProgress	.\python\ovs\reconnect.py	/^    class ConnectInProgress(object):$/;"	c	class:Reconnect
Connection	.\python\ovs\jsonrpc.py	/^class Connection(object):$/;"	c
ConsoleHandlerRoutine	.\lib\fatal-signal.c	/^BOOL WINAPI ConsoleHandlerRoutine(DWORD dwCtrlType)$/;"	f
ConstraintViolation	.\python\ovs\db\data.py	/^class ConstraintViolation(error.Error):$/;"	c
CreateProcess	.\build-aux\ltmain.sh	/^   CreateProcess().  We must quote the arguments since Win32 CreateProcess()$/;"	f
DAEMON_H	.\lib\daemon.h	18;"	d
DAEMON_LONG_OPTIONS	.\lib\daemon.h	47;"	d
DAEMON_LONG_OPTIONS	.\lib\daemon.h	89;"	d
DAEMON_OPTION_ENUMS	.\lib\daemon.h	40;"	d
DAEMON_OPTION_ENUMS	.\lib\daemon.h	81;"	d
DAEMON_OPTION_HANDLERS	.\lib\daemon.h	54;"	d
DAEMON_OPTION_HANDLERS	.\lib\daemon.h	97;"	d
DAEMON_PRIVATE_H	.\lib\daemon-private.h	18;"	d
DATAPATH_H	.\datapath\datapath.h	20;"	d
DATA_PORT	.\python\ovstest\args.py	/^DATA_PORT = 15532$/;"	v
DBDIR	.\python\ovs\dirs.py	/^        DBDIR = "%s\/openvswitch" % sysconfdir$/;"	v
DBDIR	.\python\ovs\dirs.py	/^DBDIR = os.environ.get("OVS_DBDIR")$/;"	v
DECLARE_EXTERN_PER_THREAD_DATA	.\lib\ovs-thread.h	294;"	d
DECLARE_EXTERN_PER_THREAD_DATA	.\lib\ovs-thread.h	350;"	d
DEF	.\ofproto\ofproto-dpif-ipfix.c	762;"	d	file:
DEF	.\ofproto\ofproto-dpif-ipfix.c	832;"	d	file:
DEFAULT_MAX	.\python\ovs\db\types.py	/^    DEFAULT_MAX = 1$/;"	v	class:Type
DEFAULT_MIN	.\python\ovs\db\types.py	/^    DEFAULT_MIN = 1$/;"	v	class:Type
DEFAULT_PORT	.\utilities\ovs-benchmark.c	36;"	d	file:
DEFAULT_STACK_COST	.\datapath\actions.c	668;"	d	file:
DEFAULT_TEST_BRIDGE	.\python\ovstest\tests.py	/^DEFAULT_TEST_BRIDGE = "ovstestbr0"$/;"	v
DEFAULT_TEST_PORT	.\python\ovstest\tests.py	/^DEFAULT_TEST_PORT = "ovstestport0"$/;"	v
DEFAULT_TEST_TUN	.\python\ovstest\tests.py	/^DEFAULT_TEST_TUN = "ovstestport1"$/;"	v
DEFAULT_TTL	.\lib\netdev-vport.c	48;"	d	file:
DEFINE_COMPAT_PNET_REG_FUNC	.\datapath\linux\compat\include\net\net_namespace.h	23;"	d
DEFINE_COMPAT_PNET_REG_FUNC	.\datapath\linux\compat\include\net\net_namespace.h	49;"	d
DEFINE_EXTERN_PER_THREAD_DATA	.\lib\ovs-thread.h	309;"	d
DEFINE_EXTERN_PER_THREAD_DATA	.\lib\ovs-thread.h	361;"	d
DEFINE_FLEX_ARRAY	.\datapath\linux\compat\include\linux\flex_array.h	58;"	d
DEFINE_INST	.\lib\ofp-actions.c	1522;"	d	file:
DEFINE_INST	.\lib\ofp-actions.c	1546;"	d	file:
DEFINE_INST	.\lib\ofp-actions.c	1554;"	d	file:
DEFINE_INST	.\lib\ofp-actions.c	1556;"	d	file:
DEFINE_INST	.\lib\ofp-actions.c	1643;"	d	file:
DEFINE_INST	.\lib\ofp-actions.c	1648;"	d	file:
DEFINE_INST	.\lib\ofp-actions.c	1690;"	d	file:
DEFINE_INST	.\lib\ofp-actions.c	1701;"	d	file:
DEFINE_INST	.\lib\ofp-actions.h	738;"	d
DEFINE_INST	.\lib\ofp-actions.h	740;"	d
DEFINE_INST	.\lib\ofp-actions.h	744;"	d
DEFINE_INST	.\lib\ofp-actions.h	746;"	d
DEFINE_OFPACT	.\lib\ofp-actions.h	115;"	d
DEFINE_OFPACT	.\lib\ofp-actions.h	117;"	d
DEFINE_OFPACT	.\lib\ofp-actions.h	123;"	d
DEFINE_OFPACT	.\lib\ofp-actions.h	125;"	d
DEFINE_OFPACT	.\lib\ofp-actions.h	670;"	d
DEFINE_OFPACT	.\lib\ofp-actions.h	702;"	d
DEFINE_PER_THREAD_MALLOCED_DATA	.\lib\ovs-thread.h	422;"	d
DEFINE_STATIC_PER_THREAD_DATA	.\lib\ovs-thread.h	279;"	d
DEFINE_STATIC_PER_THREAD_DATA	.\lib\ovs-thread.h	312;"	d
DEL	.\ofproto\bond.c	/^    DEL,        \/* Delete the rule from the ofproto's flow table. *\/$/;"	e	enum:bond_op	file:
DEL	.\ofproto\in-band.c	/^    DEL                        \/* Delete the rule from ofproto's flow table. *\/$/;"	e	enum:in_band_op	file:
DEL_ALL_VLANS_CMD	.\utilities\ovs-vlan-bug-workaround.c	35;"	d	file:
DESC_STR_LEN	.\include\openflow\openflow-common.h	395;"	d
DHCP_CLIENT_PORT	.\lib\dhcp.h	26;"	d
DHCP_H	.\lib\dhcp.h	18;"	d
DHCP_HEADER_LEN	.\lib\dhcp.h	28;"	d
DHCP_SERVER_PORT	.\lib\dhcp.h	25;"	d
DHPARAMS_H	.\lib\dhparams.h	18;"	d
DIAG_ADMIN_DOWN	.\lib\bfd.c	/^    DIAG_ADMIN_DOWN = 7,          \/* Administratively Down. *\/$/;"	e	enum:diag	file:
DIAG_CPATH_DOWN	.\lib\bfd.c	/^    DIAG_CPATH_DOWN = 6,          \/* Concatenated Path Down. *\/$/;"	e	enum:diag	file:
DIAG_ECHO_FAILED	.\lib\bfd.c	/^    DIAG_ECHO_FAILED = 2,         \/* Echo Function Failed. *\/$/;"	e	enum:diag	file:
DIAG_EXPIRED	.\lib\bfd.c	/^    DIAG_EXPIRED = 1,             \/* Control Detection Time Expired. *\/$/;"	e	enum:diag	file:
DIAG_FWD_RESET	.\lib\bfd.c	/^    DIAG_FWD_RESET = 4,           \/* Forwarding Plane Reset. *\/$/;"	e	enum:diag	file:
DIAG_MASK	.\lib\bfd.c	144;"	d	file:
DIAG_NONE	.\lib\bfd.c	/^    DIAG_NONE = 0,                \/* No Diagnostic. *\/$/;"	e	enum:diag	file:
DIAG_PATH_DOWN	.\lib\bfd.c	/^    DIAG_PATH_DOWN = 5,           \/* Path Down. *\/$/;"	e	enum:diag	file:
DIAG_RCPATH_DOWN	.\lib\bfd.c	/^    DIAG_RCPATH_DOWN = 8          \/* Reverse Concatenated Path Down. *\/$/;"	e	enum:diag	file:
DIAG_RMT_DOWN	.\lib\bfd.c	/^    DIAG_RMT_DOWN = 3,            \/* Neighbor Signaled Session Down. *\/$/;"	e	enum:diag	file:
DIRS_H	.\lib\dirs.h	18;"	d
DISCONNECT	.\python\ovs\reconnect.py	/^DISCONNECT = 'disconnect'$/;"	v
DIV_ROUND_UP	.\datapath\linux\compat\include\linux\kernel.h	56;"	d
DIV_ROUND_UP	.\lib\util.h	111;"	d
DPDK_PORT_WATCHDOG_INTERVAL	.\lib\netdev-dpdk.c	52;"	d	file:
DPIF_FP_CREATE	.\lib\dpif.h	/^    DPIF_FP_CREATE = 1 << 0,    \/* Allow creating a new flow. *\/$/;"	e	enum:dpif_flow_put_flags
DPIF_FP_MODIFY	.\lib\dpif.h	/^    DPIF_FP_MODIFY = 1 << 1,    \/* Allow modifying an existing flow. *\/$/;"	e	enum:dpif_flow_put_flags
DPIF_FP_ZERO_STATS	.\lib\dpif.h	/^    DPIF_FP_ZERO_STATS = 1 << 2 \/* Zero the stats of an existing flow. *\/$/;"	e	enum:dpif_flow_put_flags
DPIF_H	.\lib\dpif.h	387;"	d
DPIF_LINUX_H	.\lib\dpif-linux.h	18;"	d
DPIF_NETDEV_H	.\lib\dpif-netdev.h	18;"	d
DPIF_N_UC_TYPES	.\lib\dpif.h	/^    DPIF_N_UC_TYPES$/;"	e	enum:dpif_upcall_type
DPIF_OP_EXECUTE	.\lib\dpif.h	/^    DPIF_OP_EXECUTE,$/;"	e	enum:dpif_op_type
DPIF_OP_FLOW_DEL	.\lib\dpif.h	/^    DPIF_OP_FLOW_DEL,$/;"	e	enum:dpif_op_type
DPIF_OP_FLOW_PUT	.\lib\dpif.h	/^    DPIF_OP_FLOW_PUT = 1,$/;"	e	enum:dpif_op_type
DPIF_PORT_FOR_EACH	.\lib\dpif.h	487;"	d
DPIF_PROVIDER_H	.\lib\dpif-provider.h	18;"	d
DPIF_UC_ACTION	.\lib\dpif.h	/^    DPIF_UC_ACTION,             \/* OVS_ACTION_ATTR_USERSPACE action. *\/$/;"	e	enum:dpif_upcall_type
DPIF_UC_MISS	.\lib\dpif.h	/^    DPIF_UC_MISS,               \/* Miss in flow table. *\/$/;"	e	enum:dpif_upcall_type
DP_MAX_PORTS	.\datapath\datapath.h	35;"	d
DP_NETDEV_HEADROOM	.\lib\dpif-netdev.h	/^enum { DP_NETDEV_HEADROOM = 2 + VLAN_HEADER_LEN };$/;"	e	enum:__anon44
DP_N_STATS	.\lib\dpif-netdev.c	/^    DP_N_STATS$/;"	e	enum:dp_stat_type	file:
DP_STAT_HIT	.\lib\dpif-netdev.c	/^    DP_STAT_HIT,                \/* Packets that matched in the flow table. *\/$/;"	e	enum:dp_stat_type	file:
DP_STAT_LOST	.\lib\dpif-netdev.c	/^    DP_STAT_LOST,               \/* Packets not passed up to the client. *\/$/;"	e	enum:dp_stat_type	file:
DP_STAT_MISS	.\lib\dpif-netdev.c	/^    DP_STAT_MISS,               \/* Packets that did not match. *\/$/;"	e	enum:dp_stat_type	file:
DP_VPORT_HASH_BUCKETS	.\datapath\datapath.h	36;"	d
DRAIN_TSC	.\lib\netdev-dpdk.c	/^enum { DRAIN_TSC = 200000ULL };$/;"	e	enum:__anon56	file:
DSCP_DEFAULT	.\lib\socket-util.h	78;"	d
DSCP_DEFAULT	.\python\ovs\stream.py	/^    DSCP_DEFAULT = IPTOS_PREC_INTERNETCONTROL >> 2$/;"	v	class:Stream
DS_EMPTY_INITIALIZER	.\lib\dynamic-string.h	41;"	d
DUMMY_H	.\lib\dummy.h	18;"	d
DYNAMIC_STRING_H	.\lib\dynamic-string.h	18;"	d
DatabaseCache	.\xenserver\opt_xensource_libexec_InterfaceReconfigure.py	/^class DatabaseCache(object):$/;"	c
DatagramProtocol	.\python\ovstest\udp.py	/^from twisted.internet.protocol import DatagramProtocol$/;"	i
Datapath	.\xenserver\opt_xensource_libexec_InterfaceReconfigure.py	/^class Datapath(object):$/;"	c
DatapathBridge	.\xenserver\opt_xensource_libexec_InterfaceReconfigure.py	/^        from InterfaceReconfigureBridge import DatapathBridge$/;"	i
DatapathBridge	.\xenserver\opt_xensource_libexec_InterfaceReconfigureBridge.py	/^class DatapathBridge(Datapath):$/;"	c
DatapathFactory	.\xenserver\opt_xensource_libexec_InterfaceReconfigure.py	/^def DatapathFactory():$/;"	f
DatapathVswitch	.\xenserver\opt_xensource_libexec_InterfaceReconfigure.py	/^        from InterfaceReconfigureVswitch import DatapathVswitch$/;"	i
DatapathVswitch	.\xenserver\opt_xensource_libexec_InterfaceReconfigureVswitch.py	/^class DatapathVswitch(Datapath):$/;"	c
Datum	.\python\ovs\db\data.py	/^class Datum(object):$/;"	c
DbSchema	.\python\ovs\db\schema.py	/^class DbSchema(object):$/;"	c
EMSG	.\lib\getopt_long.c	60;"	d	file:
END_OF_FLOW_DETECTED	.\ofproto\ofproto-dpif-ipfix.c	/^    END_OF_FLOW_DETECTED = 0x03,$/;"	e	enum:ipfix_flow_end_reason	file:
ENTROPY_H	.\lib\entropy.h	17;"	d
ENV	.\utilities\ovs-dev.py	/^ENV = os.environ$/;"	v
EOF	.\python\ovs\jsonrpc.py	/^EOF = ovs.util.EOF$/;"	v
EOF	.\python\ovs\reconnect.py	/^EOF = ovs.util.EOF$/;"	v
EOF	.\python\ovs\util.py	/^EOF = -1$/;"	v
ERROR	.\python\ovs\db\idl.py	/^    ERROR = "error"              # Commit failed due to a hard error.$/;"	v	class:Transaction
ERR_CAST	.\datapath\linux\compat\include\linux\err.h	/^static inline void *ERR_CAST(const void *ptr)$/;"	f
ETHTOOL_GFLAGS	.\lib\netdev-linux.c	98;"	d	file:
ETHTOOL_SFLAGS	.\lib\netdev-linux.c	101;"	d	file:
ETH_ADDR_ARGS	.\lib\packets.h	217;"	d
ETH_ADDR_FMT	.\lib\packets.h	215;"	d
ETH_ADDR_LEN	.\lib\packets.h	70;"	d
ETH_ADDR_SCAN_ARGS	.\lib\packets.h	232;"	d
ETH_ADDR_SCAN_FMT	.\lib\packets.h	231;"	d
ETH_ALEN	.\include\linux\if_ether.h	28;"	d
ETH_FLAG_LRO	.\lib\dpif-linux.c	63;"	d	file:
ETH_HEADER_LEN	.\lib\packets.h	256;"	d
ETH_PAYLOAD_MAX	.\lib\packets.h	258;"	d
ETH_PAYLOAD_MIN	.\lib\packets.h	257;"	d
ETH_P_8021AD	.\datapath\linux\compat\include\linux\if_ether.h	11;"	d
ETH_P_802_3_MIN	.\datapath\linux\compat\include\linux\if_ether.h	7;"	d
ETH_TOTAL_MAX	.\lib\packets.h	260;"	d
ETH_TOTAL_MIN	.\lib\packets.h	259;"	d
ETH_TYPE_ARP	.\lib\packets.h	236;"	d
ETH_TYPE_CFM	.\lib\cfm.c	51;"	d	file:
ETH_TYPE_IP	.\lib\packets.h	235;"	d
ETH_TYPE_IPV6	.\lib\packets.h	240;"	d
ETH_TYPE_LACP	.\lib\packets.h	241;"	d
ETH_TYPE_MIN	.\lib\packets.h	254;"	d
ETH_TYPE_MPLS	.\lib\packets.h	243;"	d
ETH_TYPE_MPLS_MCAST	.\lib\packets.h	244;"	d
ETH_TYPE_RARP	.\lib\packets.h	242;"	d
ETH_TYPE_VLAN	.\lib\packets.h	238;"	d
ETH_TYPE_VLAN_8021AD	.\lib\packets.h	239;"	d
ETH_TYPE_VLAN_8021Q	.\lib\packets.h	237;"	d
ETH_VLAN_TOTAL_MAX	.\lib\packets.h	261;"	d
EXECUTE_ACTIONS_H	.\lib\odp-execute.h	19;"	d
Error	.\python\ovs\db\error.py	/^class Error(Exception):$/;"	c
Error	.\xenserver\opt_xensource_libexec_InterfaceReconfigure.py	/^class Error(Exception):$/;"	c
FACILITIES	.\python\ovs\vlog.py	/^FACILITIES = {"console": "info", "file": "info", "syslog": "info"}$/;"	v
FAIL_OPEN_H	.\ofproto\fail-open.h	18;"	d
FAIL_OPEN_PRIORITY	.\ofproto\fail-open.h	32;"	d
FATAL_SIGNAL_H	.\lib\fatal-signal.h	18;"	d
FAT_RWLOCK_H	.\lib\fat-rwlock.h	18;"	d
FLAGS_MASK	.\lib\bfd.c	147;"	d	file:
FLAG_AUTH	.\lib\bfd.c	/^    FLAG_AUTH = 1 << 2,$/;"	e	enum:flags	file:
FLAG_CTL	.\lib\bfd.c	/^    FLAG_CTL = 1 << 3,$/;"	e	enum:flags	file:
FLAG_DEMAND	.\lib\bfd.c	/^    FLAG_DEMAND = 1 << 1,$/;"	e	enum:flags	file:
FLAG_FINAL	.\lib\bfd.c	/^    FLAG_FINAL = 1 << 4,$/;"	e	enum:flags	file:
FLAG_MULTIPOINT	.\lib\bfd.c	/^    FLAG_MULTIPOINT = 1 << 0,$/;"	e	enum:flags	file:
FLAG_POLL	.\lib\bfd.c	/^    FLAG_POLL = 1 << 5$/;"	e	enum:flags	file:
FLEX_ARRAY_BASE_BYTES_LEFT	.\datapath\linux\compat\include\linux\flex_array.h	43;"	d
FLEX_ARRAY_BASE_SIZE	.\datapath\linux\compat\include\linux\flex_array.h	14;"	d
FLEX_ARRAY_ELEMENTS_PER_PART	.\datapath\linux\compat\include\linux\flex_array.h	51;"	d
FLEX_ARRAY_FREE	.\datapath\linux\compat\include\linux\poison.h	8;"	d
FLEX_ARRAY_NR_BASE_PTRS	.\datapath\linux\compat\include\linux\flex_array.h	47;"	d
FLEX_ARRAY_PART_SIZE	.\datapath\linux\compat\include\linux\flex_array.h	13;"	d
FLOW_DL_TYPE_NONE	.\lib\flow.h	48;"	d
FLOW_H	.\datapath\flow.h	20;"	d
FLOW_H	.\lib\flow.h	17;"	d
FLOW_MAX_MPLS_LABELS	.\lib\flow.h	65;"	d
FLOW_MISS_MAX_BATCH	.\ofproto\ofproto-dpif-upcall.c	43;"	d	file:
FLOW_NETLINK_H	.\datapath\flow_netlink.h	21;"	d
FLOW_NW_FRAG_ANY	.\lib\flow.h	51;"	d
FLOW_NW_FRAG_LATER	.\lib\flow.h	52;"	d
FLOW_NW_FRAG_MASK	.\lib\flow.h	53;"	d
FLOW_N_REGS	.\lib\flow.h	43;"	d
FLOW_SAMPLE_UPCALL	.\ofproto\ofproto-dpif-upcall.c	/^    FLOW_SAMPLE_UPCALL,         \/* Per-flow sampling. *\/$/;"	e	enum:upcall_type	file:
FLOW_SEGMENT_1_ENDS_AT	.\lib\flow.h	/^    FLOW_SEGMENT_1_ENDS_AT = offsetof(struct flow, dl_dst),$/;"	e	enum:__anon47
FLOW_SEGMENT_2_ENDS_AT	.\lib\flow.h	/^    FLOW_SEGMENT_2_ENDS_AT = offsetof(struct flow, ipv6_src),$/;"	e	enum:__anon47
FLOW_SEGMENT_3_ENDS_AT	.\lib\flow.h	/^    FLOW_SEGMENT_3_ENDS_AT = offsetof(struct flow, tp_src),$/;"	e	enum:__anon47
FLOW_TABLE_H	.\datapath\flow_table.h	20;"	d
FLOW_TNL_F_CSUM	.\lib\flow.h	59;"	d
FLOW_TNL_F_DONT_FRAGMENT	.\lib\flow.h	58;"	d
FLOW_TNL_F_KEY	.\lib\flow.h	60;"	d
FLOW_U32OFS	.\lib\meta-flow.c	41;"	d	file:
FLOW_U32S	.\lib\flow.h	128;"	d
FLOW_WC_SEQ	.\lib\flow.h	41;"	d
FORCED_END	.\ofproto\ofproto-dpif-ipfix.c	/^    FORCED_END = 0x04,$/;"	e	enum:ipfix_flow_end_reason	file:
FOR_EACH_ENABLED_PORT	.\lib\stp.c	153;"	d	file:
FOR_EACH_MATCHING_TABLE	.\ofproto\ofproto.c	3312;"	d	file:
FOR_EACH_RULE_IN_LIST	.\lib\classifier.c	158;"	d	file:
FOR_EACH_RULE_IN_LIST_SAFE	.\lib\classifier.c	160;"	d	file:
FUNC	.\lib\sha1.c	80;"	d	file:
Factory	.\python\ovstest\tcp.py	/^from twisted.internet.protocol import Factory, ClientFactory, Protocol$/;"	i
Failure	.\tests\MockXenAPI.py	/^class Failure(Exception):$/;"	c
FileType	.\python\compat\argparse.py	/^class FileType(object):$/;"	c
GCC_UNALIGNED_ACCESSORS	.\lib\unaligned.h	42;"	d
GENL_HDRLEN	.\lib\netlink-protocol.h	97;"	d
GENL_ID_CTRL	.\lib\netlink-protocol.h	112;"	d
GENL_MAX_ID	.\lib\netlink-protocol.h	110;"	d
GENL_MIN_ID	.\lib\netlink-protocol.h	109;"	d
GREPROTO_CISCO	.\datapath\linux\compat\gre.c	49;"	d	file:
GREPROTO_MAX	.\datapath\linux\compat\gre.c	50;"	d	file:
GRE_HEADER_SECTION	.\datapath\linux\compat\include\net\gre.h	36;"	d
GROUP_ID	.\datapath\compat.h	29;"	d
GROUP_ID	.\datapath\compat.h	31;"	d
GUARDED_LIST_H	.\lib\guarded-list.h	18;"	d
GUARDED_LIST_INITIALIZER	.\lib\guarded-list.h	31;"	d
Get	.\xenserver\usr_lib_xsconsole_plugins-base_XSFeatureVSwitch.py	/^    def Get(action):$/;"	m	class:VSwitchConfig
HANDLE	.\include\linux\types.h	/^typedef __u32 HANDLE;$/;"	t
HASH_H	.\lib\hash.h	17;"	d
HEADER	.\tests\test-sflow.c	/^        uint32_t HEADER;$/;"	m	struct:sflow_xdr::__anon160	file:
HEAP_FOR_EACH	.\lib\heap.h	69;"	d
HEAP_H	.\lib\heap.h	18;"	d
HFSC_N_QUEUES	.\lib\netdev-linux.c	3298;"	d	file:
HINDEX_FOR_EACH	.\lib\hindex.h	151;"	d
HINDEX_FOR_EACH_SAFE	.\lib\hindex.h	158;"	d
HINDEX_FOR_EACH_WITH_HASH	.\lib\hindex.h	130;"	d
HINDEX_H	.\lib\hindex.h	18;"	d
HINDEX_INITIALIZER	.\lib\hindex.h	97;"	d
HMAPX_FOR_EACH	.\lib\hmapx.h	63;"	d
HMAPX_FOR_EACH_SAFE	.\lib\hmapx.h	68;"	d
HMAPX_H	.\lib\hmapx.h	18;"	d
HMAPX_INITIALIZER	.\lib\hmapx.h	32;"	d
HMAP_FOR_EACH	.\lib\hmap.h	150;"	d
HMAP_FOR_EACH_CONTINUE	.\lib\hmap.h	165;"	d
HMAP_FOR_EACH_IN_BUCKET	.\lib\hmap.h	133;"	d
HMAP_FOR_EACH_SAFE	.\lib\hmap.h	157;"	d
HMAP_FOR_EACH_WITH_HASH	.\lib\hmap.h	128;"	d
HMAP_H	.\lib\hmap.h	18;"	d
HMAP_INITIALIZER	.\lib\hmap.h	69;"	d
HMAP_NODE_NULL	.\lib\hmap.h	41;"	d
HMAP_NODE_NULL_INITIALIZER	.\lib\hmap.h	42;"	d
HOME	.\utilities\ovs-dev.py	/^HOME = ENV["HOME"]$/;"	v
HR_AVG_LEN	.\lib\coverage.h	45;"	d
HSTAMP_FILES	.\include\openflow\automake.mk	/^HSTAMP_FILES = \\$/;"	m
HTB_N_QUEUES	.\lib\netdev-linux.c	2816;"	d	file:
HandleKey	.\xenserver\usr_lib_xsconsole_plugins-base_XSFeatureVSwitch.py	/^    def HandleKey(self, inKey):$/;"	m	class:VSwitchControllerDialogue
HandleKeyGETCONTROLLER	.\xenserver\usr_lib_xsconsole_plugins-base_XSFeatureVSwitch.py	/^    def HandleKeyGETCONTROLLER(self, inKey):$/;"	m	class:VSwitchControllerDialogue
HandleKeyINITIAL	.\xenserver\usr_lib_xsconsole_plugins-base_XSFeatureVSwitch.py	/^    def HandleKeyINITIAL(self, inKey):$/;"	m	class:VSwitchControllerDialogue
HelpFormatter	.\python\compat\argparse.py	/^class HelpFormatter(object):$/;"	c
IBR_FROM_LOCAL_ARP	.\ofproto\in-band.c	/^    IBR_FROM_LOCAL_ARP,           \/* (c) From local port, ARP. *\/$/;"	e	enum:__anon134	file:
IBR_FROM_LOCAL_DHCP	.\ofproto\in-band.c	/^    IBR_FROM_LOCAL_DHCP = 180000, \/* (a) From local port, DHCP. *\/$/;"	e	enum:__anon134	file:
IBR_FROM_NEXT_HOP_ARP	.\ofproto\in-band.c	/^    IBR_FROM_NEXT_HOP_ARP,        \/* (e) From remote MAC, ARP. *\/$/;"	e	enum:__anon134	file:
IBR_FROM_REMOTE_ARP	.\ofproto\in-band.c	/^    IBR_FROM_REMOTE_ARP,          \/* (g) From remote IP, ARP. *\/$/;"	e	enum:__anon134	file:
IBR_FROM_REMOTE_TCP	.\ofproto\in-band.c	/^    IBR_FROM_REMOTE_TCP           \/* (i) From remote IP, TCP port. *\/$/;"	e	enum:__anon134	file:
IBR_TO_LOCAL_ARP	.\ofproto\in-band.c	/^    IBR_TO_LOCAL_ARP,             \/* (b) To local port, ARP. *\/$/;"	e	enum:__anon134	file:
IBR_TO_NEXT_HOP_ARP	.\ofproto\in-band.c	/^    IBR_TO_NEXT_HOP_ARP,          \/* (d) To remote MAC, ARP. *\/$/;"	e	enum:__anon134	file:
IBR_TO_REMOTE_ARP	.\ofproto\in-band.c	/^    IBR_TO_REMOTE_ARP,            \/* (f) To remote IP, ARP. *\/$/;"	e	enum:__anon134	file:
IBR_TO_REMOTE_TCP	.\ofproto\in-band.c	/^    IBR_TO_REMOTE_TCP,            \/* (h) To remote IP, TCP port. *\/$/;"	e	enum:__anon134	file:
ICMP6_DST_UNREACH	.\include\windows\netinet\icmp6.h	89;"	d
ICMP6_DST_UNREACH_ADDR	.\include\windows\netinet\icmp6.h	141;"	d
ICMP6_DST_UNREACH_ADMIN	.\include\windows\netinet\icmp6.h	138;"	d
ICMP6_DST_UNREACH_BEYONDSCOPE	.\include\windows\netinet\icmp6.h	140;"	d
ICMP6_DST_UNREACH_NOPORT	.\include\windows\netinet\icmp6.h	142;"	d
ICMP6_DST_UNREACH_NOROUTE	.\include\windows\netinet\icmp6.h	137;"	d
ICMP6_DST_UNREACH_NOTNEIGHBOR	.\include\windows\netinet\icmp6.h	139;"	d
ICMP6_DST_UNREACH_POLICY	.\include\windows\netinet\icmp6.h	143;"	d
ICMP6_DST_UNREACH_REJROUTE	.\include\windows\netinet\icmp6.h	144;"	d
ICMP6_DST_UNREACH_SOURCERT	.\include\windows\netinet\icmp6.h	145;"	d
ICMP6_ECHO_REPLY	.\include\windows\netinet\icmp6.h	95;"	d
ICMP6_ECHO_REQUEST	.\include\windows\netinet\icmp6.h	94;"	d
ICMP6_ERRSTAT_DST_UNREACH_ADDR	.\include\windows\netinet\icmp6.h	541;"	d
ICMP6_ERRSTAT_DST_UNREACH_ADMIN	.\include\windows\netinet\icmp6.h	539;"	d
ICMP6_ERRSTAT_DST_UNREACH_BEYONDSCOPE	.\include\windows\netinet\icmp6.h	540;"	d
ICMP6_ERRSTAT_DST_UNREACH_NOPORT	.\include\windows\netinet\icmp6.h	542;"	d
ICMP6_ERRSTAT_DST_UNREACH_NOROUTE	.\include\windows\netinet\icmp6.h	538;"	d
ICMP6_ERRSTAT_PACKET_TOO_BIG	.\include\windows\netinet\icmp6.h	543;"	d
ICMP6_ERRSTAT_PARAMPROB_HEADER	.\include\windows\netinet\icmp6.h	546;"	d
ICMP6_ERRSTAT_PARAMPROB_NEXTHEADER	.\include\windows\netinet\icmp6.h	547;"	d
ICMP6_ERRSTAT_PARAMPROB_OPTION	.\include\windows\netinet\icmp6.h	548;"	d
ICMP6_ERRSTAT_REDIRECT	.\include\windows\netinet\icmp6.h	549;"	d
ICMP6_ERRSTAT_TIME_EXCEED_REASSEMBLY	.\include\windows\netinet\icmp6.h	545;"	d
ICMP6_ERRSTAT_TIME_EXCEED_TRANSIT	.\include\windows\netinet\icmp6.h	544;"	d
ICMP6_ERRSTAT_UNKNOWN	.\include\windows\netinet\icmp6.h	550;"	d
ICMP6_FILTER_SETBLOCK	.\include\windows\netinet\icmp6.h	492;"	d
ICMP6_FILTER_SETBLOCKALL	.\include\windows\netinet\icmp6.h	488;"	d
ICMP6_FILTER_SETPASS	.\include\windows\netinet\icmp6.h	490;"	d
ICMP6_FILTER_SETPASSALL	.\include\windows\netinet\icmp6.h	486;"	d
ICMP6_FILTER_WILLBLOCK	.\include\windows\netinet\icmp6.h	496;"	d
ICMP6_FILTER_WILLPASS	.\include\windows\netinet\icmp6.h	494;"	d
ICMP6_FQDN_QUERY	.\include\windows\netinet\icmp6.h	121;"	d
ICMP6_FQDN_REPLY	.\include\windows\netinet\icmp6.h	122;"	d
ICMP6_HEADER_LEN	.\lib\packets.h	612;"	d
ICMP6_INFOMSG_MASK	.\include\windows\netinet\icmp6.h	154;"	d
ICMP6_MAXTYPE	.\include\windows\netinet\icmp6.h	135;"	d
ICMP6_MEMBERSHIP_QUERY	.\include\windows\netinet\icmp6.h	102;"	d
ICMP6_MEMBERSHIP_REDUCTION	.\include\windows\netinet\icmp6.h	104;"	d
ICMP6_MEMBERSHIP_REPORT	.\include\windows\netinet\icmp6.h	103;"	d
ICMP6_NI_QUERY	.\include\windows\netinet\icmp6.h	123;"	d
ICMP6_NI_REFUSED	.\include\windows\netinet\icmp6.h	161;"	d
ICMP6_NI_REPLY	.\include\windows\netinet\icmp6.h	124;"	d
ICMP6_NI_SUBJ_FQDN	.\include\windows\netinet\icmp6.h	157;"	d
ICMP6_NI_SUBJ_IPV4	.\include\windows\netinet\icmp6.h	158;"	d
ICMP6_NI_SUBJ_IPV6	.\include\windows\netinet\icmp6.h	156;"	d
ICMP6_NI_SUCCESS	.\include\windows\netinet\icmp6.h	160;"	d
ICMP6_NI_UNKNOWN	.\include\windows\netinet\icmp6.h	162;"	d
ICMP6_NSTATS	.\include\windows\netinet\icmp6.h	536;"	d
ICMP6_PACKET_TOO_BIG	.\include\windows\netinet\icmp6.h	90;"	d
ICMP6_PARAMPROB_HEADER	.\include\windows\netinet\icmp6.h	150;"	d
ICMP6_PARAMPROB_NEXTHEADER	.\include\windows\netinet\icmp6.h	151;"	d
ICMP6_PARAMPROB_OPTION	.\include\windows\netinet\icmp6.h	152;"	d
ICMP6_PARAM_PROB	.\include\windows\netinet\icmp6.h	92;"	d
ICMP6_ROUTER_RENUMBERING	.\include\windows\netinet\icmp6.h	117;"	d
ICMP6_ROUTER_RENUMBERING_COMMAND	.\include\windows\netinet\icmp6.h	164;"	d
ICMP6_ROUTER_RENUMBERING_RESULT	.\include\windows\netinet\icmp6.h	165;"	d
ICMP6_ROUTER_RENUMBERING_SEQNUM_RESET	.\include\windows\netinet\icmp6.h	166;"	d
ICMP6_RR_FLAGS_FORCEAPPLY	.\include\windows\netinet\icmp6.h	427;"	d
ICMP6_RR_FLAGS_PREVDONE	.\include\windows\netinet\icmp6.h	429;"	d
ICMP6_RR_FLAGS_REQRESULT	.\include\windows\netinet\icmp6.h	426;"	d
ICMP6_RR_FLAGS_SPECSITE	.\include\windows\netinet\icmp6.h	428;"	d
ICMP6_RR_FLAGS_TEST	.\include\windows\netinet\icmp6.h	425;"	d
ICMP6_RR_PCOUSE_FLAGS_DECRPLTIME	.\include\windows\netinet\icmp6.h	466;"	d
ICMP6_RR_PCOUSE_FLAGS_DECRVLTIME	.\include\windows\netinet\icmp6.h	465;"	d
ICMP6_RR_PCOUSE_RAFLAGS_AUTO	.\include\windows\netinet\icmp6.h	463;"	d
ICMP6_RR_PCOUSE_RAFLAGS_ONLINK	.\include\windows\netinet\icmp6.h	462;"	d
ICMP6_RR_RESULT_FLAGS_FORBIDDEN	.\include\windows\netinet\icmp6.h	476;"	d
ICMP6_RR_RESULT_FLAGS_OOB	.\include\windows\netinet\icmp6.h	475;"	d
ICMP6_STAT_BADCODE	.\include\windows\netinet\icmp6.h	513;"	d
ICMP6_STAT_BADLEN	.\include\windows\netinet\icmp6.h	516;"	d
ICMP6_STAT_BADNA	.\include\windows\netinet\icmp6.h	530;"	d
ICMP6_STAT_BADNS	.\include\windows\netinet\icmp6.h	529;"	d
ICMP6_STAT_BADRA	.\include\windows\netinet\icmp6.h	532;"	d
ICMP6_STAT_BADREDIRECT	.\include\windows\netinet\icmp6.h	533;"	d
ICMP6_STAT_BADRS	.\include\windows\netinet\icmp6.h	531;"	d
ICMP6_STAT_CANTERROR	.\include\windows\netinet\icmp6.h	509;"	d
ICMP6_STAT_CHECKSUM	.\include\windows\netinet\icmp6.h	515;"	d
ICMP6_STAT_DROPPED_RAROUTE	.\include\windows\netinet\icmp6.h	534;"	d
ICMP6_STAT_ERROR	.\include\windows\netinet\icmp6.h	508;"	d
ICMP6_STAT_INHIST	.\include\windows\netinet\icmp6.h	522;"	d
ICMP6_STAT_ND_BADOPT	.\include\windows\netinet\icmp6.h	528;"	d
ICMP6_STAT_ND_TOOMANYOPT	.\include\windows\netinet\icmp6.h	524;"	d
ICMP6_STAT_OUTERRHIST	.\include\windows\netinet\icmp6.h	525;"	d
ICMP6_STAT_OUTHIST	.\include\windows\netinet\icmp6.h	511;"	d
ICMP6_STAT_PMTUCHG	.\include\windows\netinet\icmp6.h	527;"	d
ICMP6_STAT_REFLECT	.\include\windows\netinet\icmp6.h	521;"	d
ICMP6_STAT_TOOFREQ	.\include\windows\netinet\icmp6.h	510;"	d
ICMP6_STAT_TOOSHORT	.\include\windows\netinet\icmp6.h	514;"	d
ICMP6_TIME_EXCEEDED	.\include\windows\netinet\icmp6.h	91;"	d
ICMP6_TIME_EXCEED_REASSEMBLY	.\include\windows\netinet\icmp6.h	148;"	d
ICMP6_TIME_EXCEED_TRANSIT	.\include\windows\netinet\icmp6.h	147;"	d
ICMP6_WRUREPLY	.\include\windows\netinet\icmp6.h	120;"	d
ICMP6_WRUREQUEST	.\include\windows\netinet\icmp6.h	119;"	d
ICMPV6CTL_ERRPPSLIMIT	.\include\windows\netinet\icmp6.h	568;"	d
ICMPV6CTL_MAXID	.\include\windows\netinet\icmp6.h	576;"	d
ICMPV6CTL_MTUDISC_HIWAT	.\include\windows\netinet\icmp6.h	570;"	d
ICMPV6CTL_MTUDISC_LOWAT	.\include\windows\netinet\icmp6.h	571;"	d
ICMPV6CTL_NAMES	.\include\windows\netinet\icmp6.h	578;"	d
ICMPV6CTL_ND6_DEBUG	.\include\windows\netinet\icmp6.h	572;"	d
ICMPV6CTL_ND6_DELAY	.\include\windows\netinet\icmp6.h	562;"	d
ICMPV6CTL_ND6_DRLIST	.\include\windows\netinet\icmp6.h	573;"	d
ICMPV6CTL_ND6_MAXNUDHINT	.\include\windows\netinet\icmp6.h	569;"	d
ICMPV6CTL_ND6_MAXQLEN	.\include\windows\netinet\icmp6.h	575;"	d
ICMPV6CTL_ND6_MMAXTRIES	.\include\windows\netinet\icmp6.h	564;"	d
ICMPV6CTL_ND6_PRLIST	.\include\windows\netinet\icmp6.h	574;"	d
ICMPV6CTL_ND6_PRUNE	.\include\windows\netinet\icmp6.h	561;"	d
ICMPV6CTL_ND6_UMAXTRIES	.\include\windows\netinet\icmp6.h	563;"	d
ICMPV6CTL_ND6_USELOOPBACK	.\include\windows\netinet\icmp6.h	565;"	d
ICMPV6CTL_NODEINFO	.\include\windows\netinet\icmp6.h	567;"	d
ICMPV6CTL_REDIRACCEPT	.\include\windows\netinet\icmp6.h	556;"	d
ICMPV6CTL_REDIRTIMEOUT	.\include\windows\netinet\icmp6.h	557;"	d
ICMPV6CTL_STATS	.\include\windows\netinet\icmp6.h	555;"	d
ICMPV6_PLD_MAXLEN	.\include\windows\netinet\icmp6.h	66;"	d
ICMP_HEADER_LEN	.\lib\packets.h	491;"	d
IDENTICAL_INTERPRETATION	.\lib\getopt_long.c	327;"	d	file:
IDENTICAL_INTERPRETATION	.\lib\getopt_long.c	459;"	d	file:
IDLE_TIMEOUT	.\ofproto\ofproto-dpif-ipfix.c	/^    IDLE_TIMEOUT = 0x01,$/;"	e	enum:ipfix_flow_end_reason	file:
IDLTEST_IDL_FILES	.\tests\automake.mk	/^IDLTEST_IDL_FILES = tests\/idltest.ovsschema tests\/idltest.ann$/;"	m
IDLTEST_IDL_HEADER	.\tests\idltest.h	4;"	d
IDLTEST_LINK1_COL_I	.\tests\idltest.h	/^    IDLTEST_LINK1_COL_I,$/;"	e	enum:__anon152
IDLTEST_LINK1_COL_K	.\tests\idltest.h	/^    IDLTEST_LINK1_COL_K,$/;"	e	enum:__anon152
IDLTEST_LINK1_COL_KA	.\tests\idltest.h	/^    IDLTEST_LINK1_COL_KA,$/;"	e	enum:__anon152
IDLTEST_LINK1_COL_L2	.\tests\idltest.h	/^    IDLTEST_LINK1_COL_L2,$/;"	e	enum:__anon152
IDLTEST_LINK1_FOR_EACH	.\tests\idltest.h	50;"	d
IDLTEST_LINK1_FOR_EACH_SAFE	.\tests\idltest.h	54;"	d
IDLTEST_LINK1_N_COLUMNS	.\tests\idltest.h	/^    IDLTEST_LINK1_N_COLUMNS$/;"	e	enum:__anon152
IDLTEST_LINK2_COL_I	.\tests\idltest.h	/^    IDLTEST_LINK2_COL_I,$/;"	e	enum:__anon153
IDLTEST_LINK2_COL_L1	.\tests\idltest.h	/^    IDLTEST_LINK2_COL_L1,$/;"	e	enum:__anon153
IDLTEST_LINK2_FOR_EACH	.\tests\idltest.h	107;"	d
IDLTEST_LINK2_FOR_EACH_SAFE	.\tests\idltest.h	111;"	d
IDLTEST_LINK2_N_COLUMNS	.\tests\idltest.h	/^    IDLTEST_LINK2_N_COLUMNS$/;"	e	enum:__anon153
IDLTEST_N_TABLES	.\tests\idltest.h	/^    IDLTEST_N_TABLES$/;"	e	enum:__anon155
IDLTEST_SIMPLE_COL_B	.\tests\idltest.h	/^    IDLTEST_SIMPLE_COL_B,$/;"	e	enum:__anon154
IDLTEST_SIMPLE_COL_BA	.\tests\idltest.h	/^    IDLTEST_SIMPLE_COL_BA,$/;"	e	enum:__anon154
IDLTEST_SIMPLE_COL_I	.\tests\idltest.h	/^    IDLTEST_SIMPLE_COL_I,$/;"	e	enum:__anon154
IDLTEST_SIMPLE_COL_IA	.\tests\idltest.h	/^    IDLTEST_SIMPLE_COL_IA,$/;"	e	enum:__anon154
IDLTEST_SIMPLE_COL_R	.\tests\idltest.h	/^    IDLTEST_SIMPLE_COL_R,$/;"	e	enum:__anon154
IDLTEST_SIMPLE_COL_RA	.\tests\idltest.h	/^    IDLTEST_SIMPLE_COL_RA,$/;"	e	enum:__anon154
IDLTEST_SIMPLE_COL_S	.\tests\idltest.h	/^    IDLTEST_SIMPLE_COL_S,$/;"	e	enum:__anon154
IDLTEST_SIMPLE_COL_SA	.\tests\idltest.h	/^    IDLTEST_SIMPLE_COL_SA,$/;"	e	enum:__anon154
IDLTEST_SIMPLE_COL_U	.\tests\idltest.h	/^    IDLTEST_SIMPLE_COL_U,$/;"	e	enum:__anon154
IDLTEST_SIMPLE_COL_UA	.\tests\idltest.h	/^    IDLTEST_SIMPLE_COL_UA,$/;"	e	enum:__anon154
IDLTEST_SIMPLE_FOR_EACH	.\tests\idltest.h	203;"	d
IDLTEST_SIMPLE_FOR_EACH_SAFE	.\tests\idltest.h	207;"	d
IDLTEST_SIMPLE_N_COLUMNS	.\tests\idltest.h	/^    IDLTEST_SIMPLE_N_COLUMNS$/;"	e	enum:__anon154
IDLTEST_TABLE_LINK1	.\tests\idltest.h	/^    IDLTEST_TABLE_LINK1,$/;"	e	enum:__anon155
IDLTEST_TABLE_LINK2	.\tests\idltest.h	/^    IDLTEST_TABLE_LINK2,$/;"	e	enum:__anon155
IDLTEST_TABLE_SIMPLE	.\tests\idltest.h	/^    IDLTEST_TABLE_SIMPLE,$/;"	e	enum:__anon155
IFACE_STAT	.\vswitchd\bridge.c	2008;"	d	file:
IFACE_STAT	.\vswitchd\bridge.c	2010;"	d	file:
IFACE_STAT	.\vswitchd\bridge.c	2027;"	d	file:
IFACE_STAT	.\vswitchd\bridge.c	2034;"	d	file:
IFACE_STATS	.\vswitchd\bridge.c	1994;"	d	file:
IFACE_STATS	.\vswitchd\bridge.c	2038;"	d	file:
IFCOUNTERS	.\tests\test-sflow.c	/^        uint32_t IFCOUNTERS;$/;"	m	struct:sflow_xdr::__anon160	file:
IFF_LIVE_ADDR_CHANGE	.\datapath\linux\compat\include\linux\if.h	15;"	d
IFF_OVS_DATAPATH	.\datapath\linux\compat\include\linux\if.h	11;"	d
IFF_TX_SKB_SHARING	.\datapath\linux\compat\include\linux\if.h	7;"	d
IFNAMSIZ	.\include\windows\net\if.h	22;"	d
IGNORE_FIRST	.\lib\getopt_long.c	46;"	d	file:
IN6ADDR_EXACT_INIT	.\lib\packets.h	639;"	d
INADDR_ANY	.\include\sparse\netinet\in.h	95;"	d
INADDR_BROADCAST	.\include\sparse\netinet\in.h	96;"	d
INADDR_LOOPBACK	.\include\sparse\netinet\in.h	97;"	d
INADDR_NONE	.\include\sparse\netinet\in.h	98;"	d
INCOMPLETE	.\python\ovs\db\idl.py	/^    INCOMPLETE = "incomplete"    # Commit in progress, please wait.$/;"	v	class:Transaction
INET6_ADDRSTRLEN	.\include\sparse\netinet\in.h	100;"	d
INIT1	.\lib\util.c	1001;"	d	file:
INIT16	.\lib\util.c	1013;"	d	file:
INIT2	.\lib\util.c	1010;"	d	file:
INIT32	.\lib\util.c	1014;"	d	file:
INIT4	.\lib\util.c	1011;"	d	file:
INIT64	.\lib\util.c	1015;"	d	file:
INIT8	.\lib\util.c	1012;"	d	file:
INORDER	.\lib\getopt_long.c	58;"	d	file:
INSTRUCTION_FOR_EACH	.\lib\ofp-actions.c	1673;"	d	file:
INT_STRLEN	.\lib\type-props.h	37;"	d
IN_BAND_H	.\ofproto\in-band.h	18;"	d
IN_ORDER	.\lib\getopt_long.c	52;"	d	file:
IN_OVS_ATOMIC_H	.\lib\ovs-atomic.h	247;"	d
IN_OVS_ATOMIC_H	.\lib\ovs-atomic.h	262;"	d
IP6F_MORE_FRAG	.\include\windows\netinet\ip6.h	222;"	d
IP6F_OFF_MASK	.\include\sparse\netinet\ip6.h	66;"	d
IP6F_OFF_MASK	.\include\windows\netinet\ip6.h	220;"	d
IP6F_RESERVED_MASK	.\include\windows\netinet\ip6.h	221;"	d
IP6OPT_JUMBO	.\include\windows\netinet\ip6.h	132;"	d
IP6OPT_JUMBO_LEN	.\include\windows\netinet\ip6.h	164;"	d
IP6OPT_MINLEN	.\include\windows\netinet\ip6.h	142;"	d
IP6OPT_MUTABLE	.\include\windows\netinet\ip6.h	150;"	d
IP6OPT_NSAP_ADDR	.\include\windows\netinet\ip6.h	133;"	d
IP6OPT_PAD1	.\include\windows\netinet\ip6.h	130;"	d
IP6OPT_PADN	.\include\windows\netinet\ip6.h	131;"	d
IP6OPT_ROUTER_ALERT	.\include\windows\netinet\ip6.h	136;"	d
IP6OPT_RTALERT	.\include\windows\netinet\ip6.h	135;"	d
IP6OPT_RTALERT_ACTNET	.\include\windows\netinet\ip6.h	141;"	d
IP6OPT_RTALERT_LEN	.\include\windows\netinet\ip6.h	138;"	d
IP6OPT_RTALERT_MLD	.\include\windows\netinet\ip6.h	139;"	d
IP6OPT_RTALERT_RSVP	.\include\windows\netinet\ip6.h	140;"	d
IP6OPT_TUNNEL_LIMIT	.\include\windows\netinet\ip6.h	134;"	d
IP6OPT_TYPE	.\include\windows\netinet\ip6.h	144;"	d
IP6OPT_TYPE_DISCARD	.\include\windows\netinet\ip6.h	146;"	d
IP6OPT_TYPE_FORCEICMP	.\include\windows\netinet\ip6.h	147;"	d
IP6OPT_TYPE_ICMP	.\include\windows\netinet\ip6.h	148;"	d
IP6OPT_TYPE_SKIP	.\include\windows\netinet\ip6.h	145;"	d
IP6TOS_CE	.\include\windows\netinet\ip6.h	100;"	d
IP6TOS_ECT	.\include\windows\netinet\ip6.h	101;"	d
IP6_ALERT_AN	.\include\windows\netinet\ip6.h	192;"	d
IP6_ALERT_MLD	.\include\windows\netinet\ip6.h	190;"	d
IP6_ALERT_RSVP	.\include\windows\netinet\ip6.h	191;"	d
IP6_FH_F_AUTH	.\datapath\linux\compat\include\net\ipv6.h	/^	IP6_FH_F_AUTH           = (1 << 1),$/;"	e	enum:__anon16
IP6_FH_F_FRAG	.\datapath\linux\compat\include\net\ipv6.h	/^	IP6_FH_F_FRAG           = (1 << 0),$/;"	e	enum:__anon16
IP6_FH_F_SKIP_RH	.\datapath\linux\compat\include\net\ipv6.h	/^	IP6_FH_F_SKIP_RH        = (1 << 2),$/;"	e	enum:__anon16
IPFIX_DEFAULT_COLLECTOR_PORT	.\ofproto\ofproto-dpif-ipfix.c	42;"	d	file:
IPFIX_ENTITY	.\ofproto\ofproto-dpif-ipfix.c	137;"	d	file:
IPFIX_ENTITY	.\ofproto\ofproto-dpif-ipfix.c	142;"	d	file:
IPFIX_PROTO_L2_ETH	.\ofproto\ofproto-dpif-ipfix.c	/^    IPFIX_PROTO_L2_ETH = 0,  \/* No VLAN. *\/$/;"	e	enum:ipfix_proto_l2	file:
IPFIX_PROTO_L2_VLAN	.\ofproto\ofproto-dpif-ipfix.c	/^    IPFIX_PROTO_L2_VLAN,$/;"	e	enum:ipfix_proto_l2	file:
IPFIX_PROTO_L3_IPV4	.\ofproto\ofproto-dpif-ipfix.c	/^    IPFIX_PROTO_L3_IPV4,$/;"	e	enum:ipfix_proto_l3	file:
IPFIX_PROTO_L3_IPV6	.\ofproto\ofproto-dpif-ipfix.c	/^    IPFIX_PROTO_L3_IPV6,$/;"	e	enum:ipfix_proto_l3	file:
IPFIX_PROTO_L3_UNKNOWN	.\ofproto\ofproto-dpif-ipfix.c	/^    IPFIX_PROTO_L3_UNKNOWN = 0,$/;"	e	enum:ipfix_proto_l3	file:
IPFIX_PROTO_L4_ICMP	.\ofproto\ofproto-dpif-ipfix.c	/^    IPFIX_PROTO_L4_ICMP,$/;"	e	enum:ipfix_proto_l4	file:
IPFIX_PROTO_L4_TCP_UDP_SCTP	.\ofproto\ofproto-dpif-ipfix.c	/^    IPFIX_PROTO_L4_TCP_UDP_SCTP,$/;"	e	enum:ipfix_proto_l4	file:
IPFIX_PROTO_L4_UNKNOWN	.\ofproto\ofproto-dpif-ipfix.c	/^    IPFIX_PROTO_L4_UNKNOWN = 0,$/;"	e	enum:ipfix_proto_l4	file:
IPFIX_SET_ID_OPTION_TEMPLATE	.\ofproto\ofproto-dpif-ipfix.c	95;"	d	file:
IPFIX_SET_ID_TEMPLATE	.\ofproto\ofproto-dpif-ipfix.c	94;"	d	file:
IPFIX_TEMPLATE_ID_MIN	.\ofproto\ofproto-dpif-ipfix.c	126;"	d	file:
IPFIX_TEMPLATE_INTERVAL	.\ofproto\ofproto-dpif-ipfix.c	81;"	d	file:
IPFIX_UPCALL	.\ofproto\ofproto-dpif-upcall.c	/^    IPFIX_UPCALL                \/* Per-bridge sampling. *\/$/;"	e	enum:upcall_type	file:
IPFIX_VERSION	.\ofproto\ofproto-dpif-ipfix.c	76;"	d	file:
IPPROTO_AH	.\include\sparse\netinet\in.h	68;"	d
IPPROTO_DSTOPTS	.\include\sparse\netinet\in.h	71;"	d
IPPROTO_FRAGMENT	.\include\sparse\netinet\in.h	67;"	d
IPPROTO_HOPOPTS	.\include\sparse\netinet\in.h	62;"	d
IPPROTO_ICMP	.\include\sparse\netinet\in.h	63;"	d
IPPROTO_ICMPV6	.\include\sparse\netinet\in.h	69;"	d
IPPROTO_IP	.\include\sparse\netinet\in.h	60;"	d
IPPROTO_IPV6	.\include\sparse\netinet\in.h	61;"	d
IPPROTO_NONE	.\include\sparse\netinet\in.h	70;"	d
IPPROTO_ROUTING	.\include\sparse\netinet\in.h	66;"	d
IPPROTO_SCTP	.\include\sparse\netinet\in.h	72;"	d
IPPROTO_SCTP	.\lib\packets.h	457;"	d
IPPROTO_TCP	.\include\sparse\netinet\in.h	64;"	d
IPPROTO_UDP	.\include\sparse\netinet\in.h	65;"	d
IPSEC_MARK	.\ofproto\tunnel.c	37;"	d	file:
IPTOS_LOWDELAY	.\include\windows\netinet\ip.h	22;"	d
IPTOS_PREC_INTERNETCONTROL	.\include\windows\netinet\ip.h	20;"	d
IPTOS_PREC_INTERNETCONTROL	.\python\ovs\stream.py	/^    IPTOS_PREC_INTERNETCONTROL = 0xc0$/;"	v	class:Stream
IPTOS_THROUGHPUT	.\include\windows\netinet\ip.h	23;"	d
IPV6_DEFHLIM	.\include\windows\netinet\ip6.h	228;"	d
IPV6_FLOWINFO_MASK	.\include\windows\netinet\ip6.h	96;"	d
IPV6_FLOWLABEL_MASK	.\include\windows\netinet\ip6.h	97;"	d
IPV6_FRAGTTL	.\include\windows\netinet\ip6.h	229;"	d
IPV6_HLIMDEC	.\include\windows\netinet\ip6.h	230;"	d
IPV6_LABEL_MASK	.\lib\packets.h	622;"	d
IPV6_MAXHLIM	.\include\windows\netinet\ip6.h	227;"	d
IPV6_MAXPACKET	.\include\windows\netinet\ip6.h	233;"	d
IPV6_MMTU	.\include\windows\netinet\ip6.h	232;"	d
IPV6_SCAN_FMT	.\lib\packets.h	635;"	d
IPV6_SCAN_LEN	.\lib\packets.h	636;"	d
IPV6_TCLASS	.\include\sparse\netinet\in.h	102;"	d
IPV6_VERSION	.\include\windows\netinet\ip6.h	93;"	d
IPV6_VERSION_MASK	.\include\windows\netinet\ip6.h	94;"	d
IP_ADD_MEMBERSHIP	.\include\sparse\netinet\in.h	75;"	d
IP_ARGS	.\lib\packets.h	413;"	d
IP_DONT_FRAGMENT	.\lib\packets.h	470;"	d
IP_DROP_MEMBERSHIP	.\include\sparse\netinet\in.h	76;"	d
IP_DSCP_MASK	.\lib\packets.h	466;"	d
IP_ECN_CE	.\lib\packets.h	464;"	d
IP_ECN_ECT_0	.\lib\packets.h	463;"	d
IP_ECN_ECT_1	.\lib\packets.h	462;"	d
IP_ECN_MASK	.\lib\packets.h	465;"	d
IP_ECN_NOT_ECT	.\lib\packets.h	461;"	d
IP_FMT	.\lib\packets.h	412;"	d
IP_FRAG_OFF_MASK	.\lib\packets.h	472;"	d
IP_HDRINCL	.\include\sparse\netinet\in.h	77;"	d
IP_HEADER_LEN	.\lib\packets.h	476;"	d
IP_IHL	.\lib\packets.h	453;"	d
IP_IHL_VER	.\lib\packets.h	454;"	d
IP_IS_FRAGMENT	.\lib\packets.h	473;"	d
IP_MORE_FRAGMENTS	.\lib\packets.h	471;"	d
IP_MTU	.\include\sparse\netinet\in.h	78;"	d
IP_MTU_DISCOVER	.\include\sparse\netinet\in.h	79;"	d
IP_MULTICAST_IF	.\include\sparse\netinet\in.h	80;"	d
IP_MULTICAST_LOOP	.\include\sparse\netinet\in.h	81;"	d
IP_MULTICAST_TTL	.\include\sparse\netinet\in.h	82;"	d
IP_NODEFRAG	.\include\sparse\netinet\in.h	83;"	d
IP_OPTIONS	.\include\sparse\netinet\in.h	84;"	d
IP_PKTINFO	.\include\sparse\netinet\in.h	85;"	d
IP_RECVERR	.\include\sparse\netinet\in.h	86;"	d
IP_RECVOPTS	.\include\sparse\netinet\in.h	87;"	d
IP_RECVTOS	.\include\sparse\netinet\in.h	88;"	d
IP_RECVTTL	.\include\sparse\netinet\in.h	89;"	d
IP_RETOPTS	.\include\sparse\netinet\in.h	90;"	d
IP_ROUTER_ALERT	.\include\sparse\netinet\in.h	91;"	d
IP_SCAN_ARGS	.\lib\packets.h	430;"	d
IP_SCAN_FMT	.\lib\packets.h	429;"	d
IP_SRC_ANY	.\ofproto\tunnel.c	/^    IP_SRC_ANY,             \/* Any ip_src is acceptable. *\/$/;"	e	enum:ip_src_type	file:
IP_SRC_CFG	.\ofproto\tunnel.c	/^    IP_SRC_CFG,             \/* ip_src must equal configured address. *\/$/;"	e	enum:ip_src_type	file:
IP_SRC_FLOW	.\ofproto\tunnel.c	/^    IP_SRC_FLOW             \/* ip_src is handled in flow table. *\/$/;"	e	enum:ip_src_type	file:
IP_TOS	.\include\sparse\netinet\in.h	92;"	d
IP_TTL	.\include\sparse\netinet\in.h	93;"	d
IP_VER	.\lib\packets.h	452;"	d
IP_VERSION	.\lib\packets.h	468;"	d
IS_BUILTIN	.\datapath\linux\compat\include\linux\kconfig.h	48;"	d
IS_ENABLED	.\datapath\linux\compat\include\linux\kconfig.h	40;"	d
IS_LOCKLESS_ATOMIC	.\lib\ovs-atomic-gcc4+.h	44;"	d
IS_MODULE	.\datapath\linux\compat\include\linux\kconfig.h	54;"	d
IS_OXM_HEADER	.\include\openflow\openflow-1.2.h	139;"	d
IS_POSIXLY_CORRECT	.\lib\getopt_long.c	49;"	d	file:
IS_POW2	.\lib\util.h	123;"	d
Idl	.\python\ovs\db\idl.py	/^class Idl:$/;"	c
IdlSchema	.\python\ovs\db\schema.py	/^class IdlSchema(DbSchema):$/;"	c
Idle	.\python\ovs\reconnect.py	/^    class Idle(object):$/;"	c	class:Reconnect
Inst	.\xenserver\usr_lib_xsconsole_plugins-base_XSFeatureVSwitch.py	/^    def Inst(cls, name, processname=None):$/;"	m	class:VSwitchService
IntegerType	.\python\ovs\db\types.py	/^IntegerType = AtomicType("integer", 0, (int, long))$/;"	v
JHASH_H	.\lib\jhash.h	18;"	d
JSONRPC_ERROR	.\lib\jsonrpc.h	/^    JSONRPC_ERROR              \/* Error reply. *\/$/;"	e	enum:jsonrpc_msg_type
JSONRPC_H	.\lib\jsonrpc.h	18;"	d
JSONRPC_NOTIFY	.\lib\jsonrpc.h	/^    JSONRPC_NOTIFY,            \/* Notification. *\/$/;"	e	enum:jsonrpc_msg_type
JSONRPC_REPLY	.\lib\jsonrpc.h	/^    JSONRPC_REPLY,             \/* Successful reply. *\/$/;"	e	enum:jsonrpc_msg_type
JSONRPC_REQUEST	.\lib\jsonrpc.h	/^    JSONRPC_REQUEST,           \/* Request. *\/$/;"	e	enum:jsonrpc_msg_type
JSON_ARRAY	.\lib\json.h	/^    JSON_ARRAY,                 \/* [1, 2, 3, ...] *\/$/;"	e	enum:json_type
JSON_FALSE	.\lib\json.h	/^    JSON_FALSE,                 \/* false *\/$/;"	e	enum:json_type
JSON_H	.\lib\json.h	18;"	d
JSON_INTEGER	.\lib\json.h	/^    JSON_INTEGER,               \/* 123. *\/$/;"	e	enum:json_type
JSON_LEX_ESCAPE	.\lib\json.c	/^    JSON_LEX_ESCAPE             \/* In a quoted string just after a "\\". *\/$/;"	e	enum:json_lex_state	file:
JSON_LEX_KEYWORD	.\lib\json.c	/^    JSON_LEX_KEYWORD,           \/* Reading a keyword. *\/$/;"	e	enum:json_lex_state	file:
JSON_LEX_NUMBER	.\lib\json.c	/^    JSON_LEX_NUMBER,            \/* Reading a number. *\/$/;"	e	enum:json_lex_state	file:
JSON_LEX_START	.\lib\json.c	/^    JSON_LEX_START,             \/* Not inside a token. *\/$/;"	e	enum:json_lex_state	file:
JSON_LEX_STRING	.\lib\json.c	/^    JSON_LEX_STRING,            \/* Reading a quoted string. *\/$/;"	e	enum:json_lex_state	file:
JSON_MAX_HEIGHT	.\lib\json.c	106;"	d	file:
JSON_NULL	.\lib\json.h	/^    JSON_NULL,                  \/* null *\/$/;"	e	enum:json_type
JSON_N_TYPES	.\lib\json.h	/^    JSON_N_TYPES$/;"	e	enum:json_type
JSON_OBJECT	.\lib\json.h	/^    JSON_OBJECT,                \/* {"a": b, "c": d, ...} *\/$/;"	e	enum:json_type
JSON_PARSE_ARRAY_INIT	.\lib\json.c	/^    JSON_PARSE_ARRAY_INIT,      \/* Expecting ']' or a value. *\/$/;"	e	enum:json_parse_state	file:
JSON_PARSE_ARRAY_NEXT	.\lib\json.c	/^    JSON_PARSE_ARRAY_NEXT       \/* Expecting ',' or ']'. *\/$/;"	e	enum:json_parse_state	file:
JSON_PARSE_ARRAY_VALUE	.\lib\json.c	/^    JSON_PARSE_ARRAY_VALUE,     \/* Expecting a value. *\/$/;"	e	enum:json_parse_state	file:
JSON_PARSE_END	.\lib\json.c	/^    JSON_PARSE_END,             \/* End of input. *\/$/;"	e	enum:json_parse_state	file:
JSON_PARSE_OBJECT_COLON	.\lib\json.c	/^    JSON_PARSE_OBJECT_COLON,    \/* Expecting ':'. *\/$/;"	e	enum:json_parse_state	file:
JSON_PARSE_OBJECT_INIT	.\lib\json.c	/^    JSON_PARSE_OBJECT_INIT,     \/* Expecting '}' or an object name. *\/$/;"	e	enum:json_parse_state	file:
JSON_PARSE_OBJECT_NAME	.\lib\json.c	/^    JSON_PARSE_OBJECT_NAME,     \/* Expecting an object name. *\/$/;"	e	enum:json_parse_state	file:
JSON_PARSE_OBJECT_NEXT	.\lib\json.c	/^    JSON_PARSE_OBJECT_NEXT,     \/* Expecting ',' or '}'. *\/$/;"	e	enum:json_parse_state	file:
JSON_PARSE_OBJECT_VALUE	.\lib\json.c	/^    JSON_PARSE_OBJECT_VALUE,    \/* Expecting an object value. *\/$/;"	e	enum:json_parse_state	file:
JSON_PARSE_START	.\lib\json.c	/^    JSON_PARSE_START,           \/* Beginning of input. *\/$/;"	e	enum:json_parse_state	file:
JSON_REAL	.\lib\json.h	/^    JSON_REAL,                  \/* 123.456. *\/$/;"	e	enum:json_type
JSON_STRING	.\lib\json.h	/^    JSON_STRING,                \/* "..." *\/$/;"	e	enum:json_type
JSON_TRUE	.\lib\json.h	/^    JSON_TRUE,                  \/* true *\/$/;"	e	enum:json_type
JSPF_TRAILER	.\lib\json.h	/^    JSPF_TRAILER = 1 << 0       \/* Check for garbage following input.  *\/$/;"	e	enum:__anon50
JSSF_PRETTY	.\lib\json.h	/^    JSSF_PRETTY = 1 << 0,       \/* Multiple lines with indentation, if true. *\/$/;"	e	enum:__anon51
JSSF_SORT	.\lib\json.h	/^    JSSF_SORT = 1 << 1          \/* Object members in sorted order, if true. *\/$/;"	e	enum:__anon51
L	.\lib\meta-flow.c	2501;"	d	file:
L	.\lib\meta-flow.c	2514;"	d	file:
L1_SIZE	.\lib\ovs-thread.c	566;"	d	file:
L2_SIZE	.\lib\ovs-thread.c	567;"	d	file:
LACK_OF_RESOURCES	.\ofproto\ofproto-dpif-ipfix.c	/^    LACK_OF_RESOURCES = 0x05$/;"	e	enum:ipfix_flow_end_reason	file:
LACP_CONFIGURED	.\lib\lacp.h	/^    LACP_CONFIGURED,                  \/* LACP is enabled but not negotiated. *\/$/;"	e	enum:lacp_status
LACP_CURRENT	.\lib\lacp.c	/^    LACP_CURRENT,   \/* Current State.  Partner up to date. *\/$/;"	e	enum:slave_status	file:
LACP_DEFAULTED	.\lib\lacp.c	/^    LACP_DEFAULTED, \/* Defaulted State.  No partner. *\/$/;"	e	enum:slave_status	file:
LACP_DISABLED	.\lib\lacp.h	/^    LACP_DISABLED                     \/* LACP is not enabled. *\/$/;"	e	enum:lacp_status
LACP_EXPIRED	.\lib\lacp.c	/^    LACP_EXPIRED,   \/* Expired State.  Partner out of date. *\/$/;"	e	enum:slave_status	file:
LACP_FAST_TIME_TX	.\lib\lacp.c	47;"	d	file:
LACP_H	.\lib\lacp.h	18;"	d
LACP_INFO_LEN	.\lib\lacp.c	51;"	d	file:
LACP_NEGOTIATED	.\lib\lacp.h	/^    LACP_NEGOTIATED,                  \/* Successful LACP negotations. *\/$/;"	e	enum:lacp_status
LACP_PDU_LEN	.\lib\lacp.c	63;"	d	file:
LACP_RX_MULTIPLIER	.\lib\lacp.c	49;"	d	file:
LACP_SLOW_TIME_TX	.\lib\lacp.c	48;"	d	file:
LACP_STATE_ACT	.\lib\lacp.c	38;"	d	file:
LACP_STATE_AGG	.\lib\lacp.c	40;"	d	file:
LACP_STATE_COL	.\lib\lacp.c	42;"	d	file:
LACP_STATE_DEF	.\lib\lacp.c	44;"	d	file:
LACP_STATE_DIST	.\lib\lacp.c	43;"	d	file:
LACP_STATE_EXP	.\lib\lacp.c	45;"	d	file:
LACP_STATE_SYNC	.\lib\lacp.c	41;"	d	file:
LACP_STATE_TIME	.\lib\lacp.c	39;"	d	file:
LATCH_H	.\lib\latch.h	18;"	d
LEARNING_SWITCH_H	.\lib\learning-switch.h	18;"	d
LEARN_H	.\lib\learn.h	18;"	d
LEVELS	.\python\ovs\vlog.py	/^LEVELS = {$/;"	v
LINUX	.\lib\socket-util.c	56;"	d	file:
LINUX	.\lib\socket-util.c	58;"	d	file:
LINUX	.\vswitchd\system-stats.c	54;"	d	file:
LINUX	.\vswitchd\system-stats.c	57;"	d	file:
LINUX_IF_ETHER_H	.\include\linux\if_ether.h	18;"	d
LINUX_TYPES_H	.\include\linux\types.h	18;"	d
LISP_DST_PORT	.\lib\netdev-vport.c	46;"	d	file:
LISP_HLEN	.\datapath\vport-lisp.c	95;"	d	file:
LIST_FOR_EACH	.\lib\list.h	60;"	d
LIST_FOR_EACH_CONTINUE	.\lib\list.h	64;"	d
LIST_FOR_EACH_REVERSE	.\lib\list.h	68;"	d
LIST_FOR_EACH_REVERSE_CONTINUE	.\lib\list.h	72;"	d
LIST_FOR_EACH_SAFE	.\lib\list.h	76;"	d
LIST_H	.\lib\list.h	17;"	d
LIST_INITIALIZER	.\lib\list.h	31;"	d
LLC_CNTL_SNAP	.\lib\packets.h	272;"	d
LLC_DSAP_SNAP	.\lib\packets.h	270;"	d
LLC_HEADER_LEN	.\lib\packets.h	274;"	d
LLC_SNAP_HEADER_LEN	.\lib\packets.h	293;"	d
LLC_SSAP_SNAP	.\lib\packets.h	271;"	d
LOCKFILE_H	.\lib\lockfile.h	17;"	d
LOCK_FUNCTION	.\lib\ovs-thread.c	49;"	d	file:
LOG2_N_TAG_BITS	.\lib\tag.c	20;"	d	file:
LOG_ALERT	.\include\windows\syslog.h	21;"	d
LOG_CRIT	.\include\windows\syslog.h	22;"	d
LOG_DAEMON	.\include\windows\syslog.h	29;"	d
LOG_DEBUG	.\include\windows\syslog.h	27;"	d
LOG_EMERG	.\include\windows\syslog.h	20;"	d
LOG_ERR	.\include\windows\syslog.h	23;"	d
LOG_INFO	.\include\windows\syslog.h	26;"	d
LOG_LOCAL0	.\include\windows\syslog.h	31;"	d
LOG_LOCAL1	.\include\windows\syslog.h	32;"	d
LOG_LOCAL2	.\include\windows\syslog.h	33;"	d
LOG_LOCAL3	.\include\windows\syslog.h	34;"	d
LOG_LOCAL4	.\include\windows\syslog.h	35;"	d
LOG_LOCAL5	.\include\windows\syslog.h	36;"	d
LOG_LOCAL6	.\include\windows\syslog.h	37;"	d
LOG_LOCAL7	.\include\windows\syslog.h	38;"	d
LOG_NDELAY	.\include\windows\syslog.h	28;"	d
LOG_NOTICE	.\include\windows\syslog.h	25;"	d
LOG_WARNING	.\include\windows\syslog.h	24;"	d
LSW_FLOOD	.\lib\learning-switch.h	/^    LSW_FLOOD,                  \/* Always use OFPP_FLOOD. *\/$/;"	e	enum:lswitch_mode
LSW_LEARN	.\lib\learning-switch.h	/^    LSW_LEARN                   \/* Learn MACs at controller. *\/$/;"	e	enum:lswitch_mode
LSW_NORMAL	.\lib\learning-switch.h	/^    LSW_NORMAL,                 \/* Always use OFPP_NORMAL. *\/$/;"	e	enum:lswitch_mode
Listening	.\python\ovs\reconnect.py	/^    class Listening(object):$/;"	c	class:Reconnect
LoopingCall	.\python\ovstest\udp.py	/^from twisted.internet.task import LoopingCall$/;"	i
MAC	.\lib\vtep-idl.h	/^	char *MAC;	\/* Always nonnull. *\/$/;"	m	struct:vteprec_mcast_macs_local
MAC	.\lib\vtep-idl.h	/^	char *MAC;	\/* Always nonnull. *\/$/;"	m	struct:vteprec_mcast_macs_remote
MAC	.\lib\vtep-idl.h	/^	char *MAC;	\/* Always nonnull. *\/$/;"	m	struct:vteprec_ucast_macs_local
MAC	.\lib\vtep-idl.h	/^	char *MAC;	\/* Always nonnull. *\/$/;"	m	struct:vteprec_ucast_macs_remote
MAC_DEFAULT_MAX	.\lib\mac-learning.h	31;"	d
MAC_ENTRY_DEFAULT_IDLE_TIME	.\lib\mac-learning.h	34;"	d
MAC_GRAT_ARP_LOCK_TIME	.\lib\mac-learning.h	38;"	d
MAC_LEARNING_H	.\lib\mac-learning.h	18;"	d
MALLOC_LIKE	.\lib\compiler.h	33;"	d
MALLOC_LIKE	.\lib\compiler.h	45;"	d
MASK_ARRAY_SIZE_MIN	.\datapath\flow_table.c	50;"	d	file:
MATCH_H	.\lib\match.h	18;"	d
MAX	.\lib\util.h	171;"	d
MAXTTL	.\include\windows\netinet\ip.h	21;"	d
MAX_ACTIONS_BUFSIZE	.\datapath\flow_netlink.c	1084;"	d	file:
MAX_CBS	.\lib\async-append-aio.c	/^enum { MAX_CBS = ROUND_DOWN_POW2(BUFFER_SIZE \/ sizeof(struct aiocb)) };$/;"	e	enum:__anon37	file:
MAX_DATA_RECORD_LEN	.\ofproto\ofproto-dpif-ipfix.c	259;"	d	file:
MAX_DATA_SET_LEN	.\ofproto\ofproto-dpif-ipfix.c	267;"	d	file:
MAX_ERRMSG_LEN	.\lib\sflow_agent.c	452;"	d	file:
MAX_FLOWS	.\lib\dpif-netdev.c	/^enum { MAX_FLOWS = 65536 };     \/* Maximum number of flows in flow table. *\/$/;"	e	enum:__anon41	file:
MAX_FLOW_KEY_LEN	.\ofproto\ofproto-dpif-ipfix.c	250;"	d	file:
MAX_GRE_PROTO_PRIORITY	.\datapath\linux\compat\include\net\gre.h	16;"	d
MAX_GROUP_NAME_LEN	.\lib\ofp-util.h	/^enum { MAX_GROUP_NAME_LEN = INT_STRLEN(uint32_t) };$/;"	e	enum:__anon75
MAX_HEIGHT	.\python\ovs\json.py	/^    MAX_HEIGHT = 1000$/;"	v	class:Parser
MAX_HOOKS	.\lib\fatal-signal.c	57;"	d	file:
MAX_INTERNAL_RESUBMITS	.\ofproto\ofproto-dpif-xlate.c	62;"	d	file:
MAX_IOVS	.\lib\netlink-socket.c	72;"	d	file:
MAX_KEYS	.\lib\ovs-thread.c	568;"	d	file:
MAX_LISTENERS	.\tests\test-controller.c	51;"	d	file:
MAX_LIVENESS_RECURSION	.\ofproto\ofproto-dpif-xlate.c	863;"	d	file:
MAX_MESSAGE_LEN	.\ofproto\ofproto-dpif-ipfix.c	273;"	d	file:
MAX_MIRRORS	.\ofproto\ofproto-dpif-mirror.h	22;"	d
MAX_MONITORS	.\lib\rconn.c	140;"	d	file:
MAX_OPS	.\lib\dpif-linux.c	1355;"	d	file:
MAX_PORTS	.\lib\dpif-linux.c	/^enum { MAX_PORTS = USHRT_MAX };$/;"	e	enum:__anon40	file:
MAX_QUEUE_LEN	.\lib\dpif-netdev.c	/^enum { MAX_QUEUE_LEN = 128 };   \/* Maximum number of packets per queue. *\/$/;"	e	enum:__anon42	file:
MAX_QUEUE_LENGTH	.\ofproto\ofproto-dpif-upcall.c	42;"	d	file:
MAX_RECIRC_DEPTH	.\lib\dpif-netdev.c	72;"	d	file:
MAX_RESUBMITS	.\ofproto\ofproto-dpif-xlate.c	67;"	d	file:
MAX_RESUBMIT_RECURSION	.\ofproto\ofproto-dpif-xlate.c	61;"	d	file:
MAX_RX_QUEUE_LEN	.\lib\netdev-dpdk.c	/^enum { MAX_RX_QUEUE_LEN = 64 };$/;"	e	enum:__anon54	file:
MAX_SLAVES	.\tests\test-bundle.c	31;"	d	file:
MAX_SOCKETS	.\utilities\ovs-benchmark.c	38;"	d	file:
MAX_STACK_COST	.\datapath\actions.c	670;"	d	file:
MAX_SWITCHES	.\tests\test-controller.c	50;"	d	file:
MAX_TX_QUEUE_LEN	.\lib\netdev-dpdk.c	/^enum { MAX_TX_QUEUE_LEN = 64 };$/;"	e	enum:__anon55	file:
MAX_UN_LEN	.\lib\socket-util.c	67;"	d	file:
MBUF_SIZE	.\lib\netdev-dpdk.c	63;"	d	file:
MC_HASH_ENTRIES	.\datapath\flow_table.c	54;"	d	file:
MC_HASH_SEGS	.\datapath\flow_table.c	55;"	d	file:
MC_HASH_SHIFT	.\datapath\flow_table.c	53;"	d	file:
MEMORY_CHECK_INTERVAL	.\lib\memory.c	33;"	d	file:
MEMORY_H	.\lib\memory.h	18;"	d
MEM_ALIGN	.\lib\util.c	179;"	d	file:
MESSAGE_AGE_INCREMENT	.\lib\stp.c	169;"	d	file:
META_FLOW_H	.\lib\meta-flow.h	18;"	d
ME_DOM	.\ovsdb\mutation.c	/^    ME_DOM,$/;"	e	enum:ovsdb_mutation_scalar_error	file:
ME_OK	.\ovsdb\mutation.c	/^    ME_OK,$/;"	e	enum:ovsdb_mutation_scalar_error	file:
ME_RANGE	.\ovsdb\mutation.c	/^    ME_RANGE$/;"	e	enum:ovsdb_mutation_scalar_error	file:
MFF_ARP_OP	.\lib\meta-flow.h	/^    MFF_ARP_OP,                 \/* be16 *\/$/;"	e	enum:mf_field_id
MFF_ARP_SHA	.\lib\meta-flow.h	/^    MFF_ARP_SHA,                \/* mac *\/$/;"	e	enum:mf_field_id
MFF_ARP_SPA	.\lib\meta-flow.h	/^    MFF_ARP_SPA,                \/* be32 *\/$/;"	e	enum:mf_field_id
MFF_ARP_THA	.\lib\meta-flow.h	/^    MFF_ARP_THA,                \/* mac *\/$/;"	e	enum:mf_field_id
MFF_ARP_TPA	.\lib\meta-flow.h	/^    MFF_ARP_TPA,                \/* be32 *\/$/;"	e	enum:mf_field_id
MFF_DL_VLAN	.\lib\meta-flow.h	/^    MFF_DL_VLAN,                \/* be16 (OpenFlow 1.0 compatibility) *\/$/;"	e	enum:mf_field_id
MFF_DL_VLAN_PCP	.\lib\meta-flow.h	/^    MFF_DL_VLAN_PCP,            \/* u8 (OpenFlow 1.0 compatibility) *\/$/;"	e	enum:mf_field_id
MFF_DP_HASH	.\lib\meta-flow.h	/^    MFF_DP_HASH,                \/* be32 *\/$/;"	e	enum:mf_field_id
MFF_ETH_DST	.\lib\meta-flow.h	/^    MFF_ETH_DST,                \/* mac *\/$/;"	e	enum:mf_field_id
MFF_ETH_SRC	.\lib\meta-flow.h	/^    MFF_ETH_SRC,                \/* mac *\/$/;"	e	enum:mf_field_id
MFF_ETH_TYPE	.\lib\meta-flow.h	/^    MFF_ETH_TYPE,               \/* be16 *\/$/;"	e	enum:mf_field_id
MFF_ICMPV4_CODE	.\lib\meta-flow.h	/^    MFF_ICMPV4_CODE,            \/* u8 *\/$/;"	e	enum:mf_field_id
MFF_ICMPV4_TYPE	.\lib\meta-flow.h	/^    MFF_ICMPV4_TYPE,            \/* u8 *\/$/;"	e	enum:mf_field_id
MFF_ICMPV6_CODE	.\lib\meta-flow.h	/^    MFF_ICMPV6_CODE,            \/* u8 *\/$/;"	e	enum:mf_field_id
MFF_ICMPV6_TYPE	.\lib\meta-flow.h	/^    MFF_ICMPV6_TYPE,            \/* u8 *\/$/;"	e	enum:mf_field_id
MFF_IN_PORT	.\lib\meta-flow.h	/^    MFF_IN_PORT,                \/* be16 *\/$/;"	e	enum:mf_field_id
MFF_IN_PORT_OXM	.\lib\meta-flow.h	/^    MFF_IN_PORT_OXM,            \/* be32 *\/$/;"	e	enum:mf_field_id
MFF_IPV4_DST	.\lib\meta-flow.h	/^    MFF_IPV4_DST,               \/* be32 *\/$/;"	e	enum:mf_field_id
MFF_IPV4_SRC	.\lib\meta-flow.h	/^    MFF_IPV4_SRC,               \/* be32 *\/$/;"	e	enum:mf_field_id
MFF_IPV6_DST	.\lib\meta-flow.h	/^    MFF_IPV6_DST,               \/* ipv6 *\/$/;"	e	enum:mf_field_id
MFF_IPV6_LABEL	.\lib\meta-flow.h	/^    MFF_IPV6_LABEL,             \/* be32 *\/$/;"	e	enum:mf_field_id
MFF_IPV6_SRC	.\lib\meta-flow.h	/^    MFF_IPV6_SRC,               \/* ipv6 *\/$/;"	e	enum:mf_field_id
MFF_IP_DSCP	.\lib\meta-flow.h	/^    MFF_IP_DSCP,                \/* u8 (used for IPv4 or IPv6) *\/$/;"	e	enum:mf_field_id
MFF_IP_DSCP_SHIFTED	.\lib\meta-flow.h	/^    MFF_IP_DSCP_SHIFTED,        \/* u8 (used for IPv4 or IPv6) (OF1.2 compat) *\/$/;"	e	enum:mf_field_id
MFF_IP_ECN	.\lib\meta-flow.h	/^    MFF_IP_ECN,                 \/* u8 (used for IPv4 or IPv6) *\/$/;"	e	enum:mf_field_id
MFF_IP_FRAG	.\lib\meta-flow.h	/^    MFF_IP_FRAG,                \/* u8 (used for IPv4 or IPv6) *\/$/;"	e	enum:mf_field_id
MFF_IP_PROTO	.\lib\meta-flow.h	/^    MFF_IP_PROTO,               \/* u8 (used for IPv4 or IPv6) *\/$/;"	e	enum:mf_field_id
MFF_IP_TTL	.\lib\meta-flow.h	/^    MFF_IP_TTL,                 \/* u8 (used for IPv4 or IPv6) *\/$/;"	e	enum:mf_field_id
MFF_METADATA	.\lib\meta-flow.h	/^    MFF_METADATA,               \/* be64 *\/$/;"	e	enum:mf_field_id
MFF_MPLS_BOS	.\lib\meta-flow.h	/^    MFF_MPLS_BOS,               \/* u8 *\/$/;"	e	enum:mf_field_id
MFF_MPLS_LABEL	.\lib\meta-flow.h	/^    MFF_MPLS_LABEL,             \/* be32 *\/$/;"	e	enum:mf_field_id
MFF_MPLS_TC	.\lib\meta-flow.h	/^    MFF_MPLS_TC,                \/* u8 *\/$/;"	e	enum:mf_field_id
MFF_ND_SLL	.\lib\meta-flow.h	/^    MFF_ND_SLL,                 \/* mac *\/$/;"	e	enum:mf_field_id
MFF_ND_TARGET	.\lib\meta-flow.h	/^    MFF_ND_TARGET,              \/* ipv6 *\/$/;"	e	enum:mf_field_id
MFF_ND_TLL	.\lib\meta-flow.h	/^    MFF_ND_TLL,                 \/* mac *\/$/;"	e	enum:mf_field_id
MFF_N_IDS	.\lib\meta-flow.h	/^    MFF_N_IDS$/;"	e	enum:mf_field_id
MFF_PKT_MARK	.\lib\meta-flow.h	/^    MFF_PKT_MARK,               \/* be32 *\/$/;"	e	enum:mf_field_id
MFF_RECIRC_ID	.\lib\meta-flow.h	/^    MFF_RECIRC_ID,              \/* be32 *\/$/;"	e	enum:mf_field_id
MFF_REG0	.\lib\meta-flow.h	/^    MFF_REG0,                   \/* be32 *\/$/;"	e	enum:mf_field_id
MFF_REG1	.\lib\meta-flow.h	/^    MFF_REG1,                   \/* be32 *\/$/;"	e	enum:mf_field_id
MFF_REG2	.\lib\meta-flow.h	/^    MFF_REG2,                   \/* be32 *\/$/;"	e	enum:mf_field_id
MFF_REG3	.\lib\meta-flow.h	/^    MFF_REG3,                   \/* be32 *\/$/;"	e	enum:mf_field_id
MFF_REG4	.\lib\meta-flow.h	/^    MFF_REG4,                   \/* be32 *\/$/;"	e	enum:mf_field_id
MFF_REG5	.\lib\meta-flow.h	/^    MFF_REG5,                   \/* be32 *\/$/;"	e	enum:mf_field_id
MFF_REG6	.\lib\meta-flow.h	/^    MFF_REG6,                   \/* be32 *\/$/;"	e	enum:mf_field_id
MFF_REG7	.\lib\meta-flow.h	/^    MFF_REG7,                   \/* be32 *\/$/;"	e	enum:mf_field_id
MFF_SCTP_DST	.\lib\meta-flow.h	/^    MFF_SCTP_DST,               \/* be16 (used for IPv4 or IPv6) *\/$/;"	e	enum:mf_field_id
MFF_SCTP_SRC	.\lib\meta-flow.h	/^    MFF_SCTP_SRC,               \/* be16 (used for IPv4 or IPv6) *\/$/;"	e	enum:mf_field_id
MFF_SKB_PRIORITY	.\lib\meta-flow.h	/^    MFF_SKB_PRIORITY,           \/* be32 *\/$/;"	e	enum:mf_field_id
MFF_TCP_DST	.\lib\meta-flow.h	/^    MFF_TCP_DST,                \/* be16 (used for IPv4 or IPv6) *\/$/;"	e	enum:mf_field_id
MFF_TCP_FLAGS	.\lib\meta-flow.h	/^    MFF_TCP_FLAGS,              \/* be16, 12 bits (4 MSB zeroed,$/;"	e	enum:mf_field_id
MFF_TCP_SRC	.\lib\meta-flow.h	/^    MFF_TCP_SRC,                \/* be16 (used for IPv4 or IPv6) *\/$/;"	e	enum:mf_field_id
MFF_TUN_DST	.\lib\meta-flow.h	/^    MFF_TUN_DST,                \/* be32 *\/$/;"	e	enum:mf_field_id
MFF_TUN_FLAGS	.\lib\meta-flow.h	/^    MFF_TUN_FLAGS,              \/* be16 *\/$/;"	e	enum:mf_field_id
MFF_TUN_ID	.\lib\meta-flow.h	/^    MFF_TUN_ID,                 \/* be64 *\/$/;"	e	enum:mf_field_id
MFF_TUN_SRC	.\lib\meta-flow.h	/^    MFF_TUN_SRC,                \/* be32 *\/$/;"	e	enum:mf_field_id
MFF_TUN_TOS	.\lib\meta-flow.h	/^    MFF_TUN_TOS,                \/* u8 *\/$/;"	e	enum:mf_field_id
MFF_TUN_TTL	.\lib\meta-flow.h	/^    MFF_TUN_TTL,                \/* u8 *\/$/;"	e	enum:mf_field_id
MFF_UDP_DST	.\lib\meta-flow.h	/^    MFF_UDP_DST,                \/* be16 (used for IPv4 or IPv6) *\/$/;"	e	enum:mf_field_id
MFF_UDP_SRC	.\lib\meta-flow.h	/^    MFF_UDP_SRC,                \/* be16 (used for IPv4 or IPv6) *\/$/;"	e	enum:mf_field_id
MFF_VLAN_PCP	.\lib\meta-flow.h	/^    MFF_VLAN_PCP,               \/* be16 (OpenFlow 1.2 compatibility) *\/$/;"	e	enum:mf_field_id
MFF_VLAN_TCI	.\lib\meta-flow.h	/^    MFF_VLAN_TCI,               \/* be16 *\/$/;"	e	enum:mf_field_id
MFF_VLAN_VID	.\lib\meta-flow.h	/^    MFF_VLAN_VID,               \/* be16 (OpenFlow 1.2 compatibility) *\/$/;"	e	enum:mf_field_id
MFM_FULLY	.\lib\meta-flow.h	/^    MFM_FULLY,                  \/* Every bit is individually maskable. *\/$/;"	e	enum:mf_maskable
MFM_NONE	.\lib\meta-flow.h	/^    MFM_NONE,                   \/* No sub-field masking. *\/$/;"	e	enum:mf_maskable
MFP_ARP	.\lib\meta-flow.h	/^    MFP_ARP,$/;"	e	enum:mf_prereqs
MFP_ICMPV4	.\lib\meta-flow.h	/^    MFP_ICMPV4,$/;"	e	enum:mf_prereqs
MFP_ICMPV6	.\lib\meta-flow.h	/^    MFP_ICMPV6,$/;"	e	enum:mf_prereqs
MFP_IPV4	.\lib\meta-flow.h	/^    MFP_IPV4,$/;"	e	enum:mf_prereqs
MFP_IPV6	.\lib\meta-flow.h	/^    MFP_IPV6,$/;"	e	enum:mf_prereqs
MFP_IP_ANY	.\lib\meta-flow.h	/^    MFP_IP_ANY,$/;"	e	enum:mf_prereqs
MFP_MPLS	.\lib\meta-flow.h	/^    MFP_MPLS,$/;"	e	enum:mf_prereqs
MFP_ND	.\lib\meta-flow.h	/^    MFP_ND,$/;"	e	enum:mf_prereqs
MFP_ND_ADVERT	.\lib\meta-flow.h	/^    MFP_ND_ADVERT$/;"	e	enum:mf_prereqs
MFP_ND_SOLICIT	.\lib\meta-flow.h	/^    MFP_ND_SOLICIT,$/;"	e	enum:mf_prereqs
MFP_NONE	.\lib\meta-flow.h	/^    MFP_NONE,$/;"	e	enum:mf_prereqs
MFP_SCTP	.\lib\meta-flow.h	/^    MFP_SCTP,                   \/* On IPv4 or IPv6. *\/$/;"	e	enum:mf_prereqs
MFP_TCP	.\lib\meta-flow.h	/^    MFP_TCP,                    \/* On IPv4 or IPv6. *\/$/;"	e	enum:mf_prereqs
MFP_UDP	.\lib\meta-flow.h	/^    MFP_UDP,                    \/* On IPv4 or IPv6. *\/$/;"	e	enum:mf_prereqs
MFP_VLAN_VID	.\lib\meta-flow.h	/^    MFP_VLAN_VID,$/;"	e	enum:mf_prereqs
MFS_DECIMAL	.\lib\meta-flow.h	/^    MFS_DECIMAL,$/;"	e	enum:mf_string
MFS_ETHERNET	.\lib\meta-flow.h	/^    MFS_ETHERNET,$/;"	e	enum:mf_string
MFS_FRAG	.\lib\meta-flow.h	/^    MFS_FRAG,                   \/* no, yes, first, later, not_later *\/$/;"	e	enum:mf_string
MFS_HEXADECIMAL	.\lib\meta-flow.h	/^    MFS_HEXADECIMAL,$/;"	e	enum:mf_string
MFS_IPV4	.\lib\meta-flow.h	/^    MFS_IPV4,$/;"	e	enum:mf_string
MFS_IPV6	.\lib\meta-flow.h	/^    MFS_IPV6,$/;"	e	enum:mf_string
MFS_OFP_PORT	.\lib\meta-flow.h	/^    MFS_OFP_PORT,               \/* An OpenFlow port number or name. *\/$/;"	e	enum:mf_string
MFS_OFP_PORT_OXM	.\lib\meta-flow.h	/^    MFS_OFP_PORT_OXM,           \/* An OpenFlow port number or name (32-bit). *\/$/;"	e	enum:mf_string
MFS_TCP_FLAGS	.\lib\meta-flow.h	/^    MFS_TCP_FLAGS,              \/* TCP_* flags *\/$/;"	e	enum:mf_string
MFS_TNL_FLAGS	.\lib\meta-flow.h	/^    MFS_TNL_FLAGS,              \/* FLOW_TNL_F_* flags *\/$/;"	e	enum:mf_string
MF_EXACT_MASK_INITIALIZER	.\lib\meta-flow.h	328;"	d
MF_FIELD_SIZES	.\lib\meta-flow.c	44;"	d	file:
MGMT	.\utilities\ovs-ofctl.c	/^enum open_target { MGMT, SNOOP };$/;"	e	enum:open_target	file:
MIN	.\lib\util.h	167;"	d
MINIFLOW_ASSERT	.\lib\flow.c	125;"	d	file:
MINIFLOW_ASSERT	.\lib\flow.c	127;"	d	file:
MINIFLOW_VALUES_SIZE	.\lib\flow.h	361;"	d
MINI_N_INLINE	.\lib\flow.h	325;"	d
MIN_AVG_LEN	.\lib\coverage.h	44;"	d
MIRROR_MASK_C	.\ofproto\ofproto-dpif-mirror.c	29;"	d	file:
MISS_UPCALL	.\ofproto\ofproto-dpif-upcall.c	/^    MISS_UPCALL,                \/* A flow miss.  *\/$/;"	e	enum:upcall_type	file:
MLD6_LISTENER_DONE	.\include\windows\netinet\icmp6.h	109;"	d
MLD6_LISTENER_QUERY	.\include\windows\netinet\icmp6.h	107;"	d
MLD6_LISTENER_REPORT	.\include\windows\netinet\icmp6.h	108;"	d
MLD6_MTRACE	.\include\windows\netinet\icmp6.h	133;"	d
MLD6_MTRACE_RESP	.\include\windows\netinet\icmp6.h	132;"	d
MLDV2_LISTENER_REPORT	.\include\windows\netinet\icmp6.h	125;"	d
MLD_LISTENER_DONE	.\include\windows\netinet\icmp6.h	98;"	d
MLD_LISTENER_QUERY	.\include\windows\netinet\icmp6.h	96;"	d
MLD_LISTENER_REDUCTION	.\include\windows\netinet\icmp6.h	99;"	d
MLD_LISTENER_REPORT	.\include\windows\netinet\icmp6.h	97;"	d
MLD_MINLEN	.\include\windows\netinet\icmp6.h	196;"	d
MLD_MTRACE	.\include\windows\netinet\icmp6.h	129;"	d
MLD_MTRACE_RESP	.\include\windows\netinet\icmp6.h	128;"	d
MONITOR_INTERVAL_MSEC	.\ofproto\ofproto-dpif-monitor.c	188;"	d	file:
MPLS_BOS_MASK	.\lib\packets.h	356;"	d
MPLS_BOS_SHIFT	.\lib\packets.h	357;"	d
MPLS_HLEN	.\lib\packets.h	365;"	d
MPLS_LABEL_MASK	.\lib\packets.h	362;"	d
MPLS_LABEL_SHIFT	.\lib\packets.h	363;"	d
MPLS_TC_MASK	.\lib\packets.h	359;"	d
MPLS_TC_SHIFT	.\lib\packets.h	360;"	d
MPLS_TTL_MASK	.\lib\packets.h	353;"	d
MPLS_TTL_SHIFT	.\lib\packets.h	354;"	d
MP_CACHE_SZ	.\lib\netdev-dpdk.c	68;"	d	file:
MSEC_TO_PRIO	.\ofproto\ofproto-dpif-monitor.c	41;"	d	file:
MSG_CTRUNC	.\include\sparse\sys\socket.h	/^    MSG_CTRUNC,$/;"	e	enum:__anon31
MSG_DONTROUTE	.\include\sparse\sys\socket.h	/^    MSG_DONTROUTE,$/;"	e	enum:__anon31
MSG_DONTWAIT	.\include\sparse\sys\socket.h	/^    MSG_DONTWAIT$/;"	e	enum:__anon31
MSG_EOR	.\include\sparse\sys\socket.h	/^    MSG_EOR,$/;"	e	enum:__anon31
MSG_NOSIGNAL	.\include\sparse\sys\socket.h	/^    MSG_NOSIGNAL,$/;"	e	enum:__anon31
MSG_OOB	.\include\sparse\sys\socket.h	/^    MSG_OOB,$/;"	e	enum:__anon31
MSG_PEEK	.\include\sparse\sys\socket.h	/^    MSG_PEEK,$/;"	e	enum:__anon31
MSG_TRUNC	.\include\sparse\sys\socket.h	/^    MSG_TRUNC,$/;"	e	enum:__anon31
MSG_WAITALL	.\include\sparse\sys\socket.h	/^    MSG_WAITALL,$/;"	e	enum:__anon31
MTU_TO_MAX_LEN	.\lib\netdev-dpdk.c	62;"	d	file:
MULTIPATH_H	.\lib\multipath.h	18;"	d
MUST_SUCCEED	.\tests\test-type-props.c	24;"	d	file:
MUTEX_INIT	.\lib\ovs-atomic-locked.c	33;"	d	file:
MUTEX_INIT16	.\lib\ovs-atomic-locked.c	35;"	d	file:
MUTEX_INIT4	.\lib\ovs-atomic-locked.c	34;"	d	file:
Message	.\python\ovs\jsonrpc.py	/^class Message(object):$/;"	c
Message	.\python\ovs\unixctl\server.py	/^Message = ovs.jsonrpc.Message$/;"	v
NAMESPACE_DNS	.\python\compat\uuid.py	/^NAMESPACE_DNS = UUID('6ba7b810-9dad-11d1-80b4-00c04fd430c8')$/;"	v
NAMESPACE_OID	.\python\compat\uuid.py	/^NAMESPACE_OID = UUID('6ba7b812-9dad-11d1-80b4-00c04fd430c8')$/;"	v
NAMESPACE_URL	.\python\compat\uuid.py	/^NAMESPACE_URL = UUID('6ba7b811-9dad-11d1-80b4-00c04fd430c8')$/;"	v
NAMESPACE_X500	.\python\compat\uuid.py	/^NAMESPACE_X500 = UUID('6ba7b814-9dad-11d1-80b4-00c04fd430c8')$/;"	v
NB_MBUF	.\lib\netdev-dpdk.c	67;"	d	file:
NDEBUG	.\tests\test-classifier.c	39;"	d	file:
NDEBUG	.\tests\test-csum.c	30;"	d	file:
NDEBUG	.\tests\test-flows.c	33;"	d	file:
NDEBUG	.\tests\test-hash.c	26;"	d	file:
NDEBUG	.\tests\test-heap.c	29;"	d	file:
NDEBUG	.\tests\test-hindex.c	28;"	d	file:
NDEBUG	.\tests\test-hmap.c	28;"	d	file:
NDEBUG	.\tests\test-list.c	25;"	d	file:
NDEBUG	.\tests\test-packets.c	24;"	d	file:
NDEBUG	.\tests\test-sha1.c	27;"	d	file:
NDEBUG	.\tests\test-util.c	32;"	d	file:
NDEBUG	.\tests\test-vconn.c	39;"	d	file:
ND_NA_FLAG_OVERRIDE	.\include\windows\netinet\icmp6.h	263;"	d
ND_NA_FLAG_ROUTER	.\include\windows\netinet\icmp6.h	261;"	d
ND_NA_FLAG_SOLICITED	.\include\windows\netinet\icmp6.h	262;"	d
ND_NEIGHBOR_ADVERT	.\include\windows\netinet\icmp6.h	114;"	d
ND_NEIGHBOR_SOLICIT	.\include\windows\netinet\icmp6.h	113;"	d
ND_OPT_ADVINTERVAL	.\include\windows\netinet\icmp6.h	288;"	d
ND_OPT_DNSSL	.\include\windows\netinet\icmp6.h	295;"	d
ND_OPT_HOMEAGENT_INFO	.\include\windows\netinet\icmp6.h	289;"	d
ND_OPT_MAP	.\include\windows\netinet\icmp6.h	292;"	d
ND_OPT_MTU	.\include\windows\netinet\icmp6.h	287;"	d
ND_OPT_PI_FLAG_AUTO	.\include\windows\netinet\icmp6.h	318;"	d
ND_OPT_PI_FLAG_ONLINK	.\include\windows\netinet\icmp6.h	317;"	d
ND_OPT_PREFIX_INFORMATION	.\include\windows\netinet\icmp6.h	285;"	d
ND_OPT_RDNSS	.\include\windows\netinet\icmp6.h	294;"	d
ND_OPT_REDIRECTED_HEADER	.\include\windows\netinet\icmp6.h	286;"	d
ND_OPT_ROUTE_INFO	.\include\windows\netinet\icmp6.h	293;"	d
ND_OPT_SOURCE_ADDRLIST	.\include\windows\netinet\icmp6.h	290;"	d
ND_OPT_SOURCE_LINKADDR	.\include\windows\netinet\icmp6.h	283;"	d
ND_OPT_TARGET_ADDRLIST	.\include\windows\netinet\icmp6.h	291;"	d
ND_OPT_TARGET_LINKADDR	.\include\windows\netinet\icmp6.h	284;"	d
ND_RA_FLAG_HOME_AGENT	.\include\windows\netinet\icmp6.h	226;"	d
ND_RA_FLAG_MANAGED	.\include\windows\netinet\icmp6.h	224;"	d
ND_RA_FLAG_OTHER	.\include\windows\netinet\icmp6.h	225;"	d
ND_RA_FLAG_RTPREF_HIGH	.\include\windows\netinet\icmp6.h	233;"	d
ND_RA_FLAG_RTPREF_LOW	.\include\windows\netinet\icmp6.h	235;"	d
ND_RA_FLAG_RTPREF_MASK	.\include\windows\netinet\icmp6.h	231;"	d
ND_RA_FLAG_RTPREF_MEDIUM	.\include\windows\netinet\icmp6.h	234;"	d
ND_RA_FLAG_RTPREF_RSV	.\include\windows\netinet\icmp6.h	236;"	d
ND_REDIRECT	.\include\windows\netinet\icmp6.h	115;"	d
ND_REDIRECT_ONLINK	.\include\windows\netinet\icmp6.h	169;"	d
ND_REDIRECT_ROUTER	.\include\windows\netinet\icmp6.h	170;"	d
ND_ROUTER_ADVERT	.\include\windows\netinet\icmp6.h	112;"	d
ND_ROUTER_SOLICIT	.\include\windows\netinet\icmp6.h	111;"	d
NEED_COUNT_1BITS_8	.\lib\util.h	426;"	d
NEED_DATABASE	.\ovsdb\ovsdb-client.c	/^    NEED_DATABASE         \/* JSON-RPC connection and database name needed. *\/$/;"	e	enum:args_needed	file:
NEED_NONE	.\ovsdb\ovsdb-client.c	/^    NEED_NONE,            \/* No JSON-RPC connection or database name needed. *\/$/;"	e	enum:args_needed	file:
NEED_RPC	.\ovsdb\ovsdb-client.c	/^    NEED_RPC,             \/* JSON-RPC connection needed. *\/$/;"	e	enum:args_needed	file:
NETDEV_BSD_CLASS	.\lib\netdev-bsd.c	1536;"	d	file:
NETDEV_DPDK_H	.\lib\netdev-dpdk.h	2;"	d
NETDEV_DUMMY_MAX_QUEUE	.\lib\netdev-dummy.c	108;"	d	file:
NETDEV_F_100GB_FD	.\lib\netdev.h	/^    NETDEV_F_100GB_FD =   1 << 8,  \/* 100 Gb full-duplex rate support. *\/$/;"	e	enum:netdev_features
NETDEV_F_100MB_FD	.\lib\netdev.h	/^    NETDEV_F_100MB_FD =   1 << 3,  \/* 100 Mb full-duplex rate support. *\/$/;"	e	enum:netdev_features
NETDEV_F_100MB_HD	.\lib\netdev.h	/^    NETDEV_F_100MB_HD =   1 << 2,  \/* 100 Mb half-duplex rate support. *\/$/;"	e	enum:netdev_features
NETDEV_F_10GB_FD	.\lib\netdev.h	/^    NETDEV_F_10GB_FD =    1 << 6,  \/* 10 Gb full-duplex rate support. *\/$/;"	e	enum:netdev_features
NETDEV_F_10MB_FD	.\lib\netdev.h	/^    NETDEV_F_10MB_FD =    1 << 1,  \/* 10 Mb full-duplex rate support. *\/$/;"	e	enum:netdev_features
NETDEV_F_10MB_HD	.\lib\netdev.h	/^    NETDEV_F_10MB_HD =    1 << 0,  \/* 10 Mb half-duplex rate support. *\/$/;"	e	enum:netdev_features
NETDEV_F_1GB_FD	.\lib\netdev.h	/^    NETDEV_F_1GB_FD =     1 << 5,  \/* 1 Gb full-duplex rate support. *\/$/;"	e	enum:netdev_features
NETDEV_F_1GB_HD	.\lib\netdev.h	/^    NETDEV_F_1GB_HD =     1 << 4,  \/* 1 Gb half-duplex rate support. *\/$/;"	e	enum:netdev_features
NETDEV_F_1TB_FD	.\lib\netdev.h	/^    NETDEV_F_1TB_FD =     1 << 9,  \/* 1 Tb full-duplex rate support. *\/$/;"	e	enum:netdev_features
NETDEV_F_40GB_FD	.\lib\netdev.h	/^    NETDEV_F_40GB_FD =    1 << 7,  \/* 40 Gb full-duplex rate support. *\/$/;"	e	enum:netdev_features
NETDEV_F_AUTONEG	.\lib\netdev.h	/^    NETDEV_F_AUTONEG =    1 << 13, \/* Auto-negotiation. *\/$/;"	e	enum:netdev_features
NETDEV_F_COPPER	.\lib\netdev.h	/^    NETDEV_F_COPPER =     1 << 11, \/* Copper medium. *\/$/;"	e	enum:netdev_features
NETDEV_F_FIBER	.\lib\netdev.h	/^    NETDEV_F_FIBER =      1 << 12, \/* Fiber medium. *\/$/;"	e	enum:netdev_features
NETDEV_F_OTHER	.\lib\netdev.h	/^    NETDEV_F_OTHER =      1 << 10, \/* Other rate, not in the list. *\/$/;"	e	enum:netdev_features
NETDEV_F_PAUSE	.\lib\netdev.h	/^    NETDEV_F_PAUSE =      1 << 14, \/* Pause. *\/$/;"	e	enum:netdev_features
NETDEV_F_PAUSE_ASYM	.\lib\netdev.h	/^    NETDEV_F_PAUSE_ASYM = 1 << 15, \/* Asymmetric pause. *\/$/;"	e	enum:netdev_features
NETDEV_H	.\lib\netdev.h	18;"	d
NETDEV_LINUX_CLASS	.\lib\netdev-linux.c	2720;"	d	file:
NETDEV_LINUX_H	.\lib\netdev-linux.h	18;"	d
NETDEV_LOOPBACK	.\lib\netdev.h	/^    NETDEV_LOOPBACK = 0x0004    \/* This is a loopback device. *\/$/;"	e	enum:netdev_flags
NETDEV_MAX_RX_BATCH	.\lib\netdev.h	/^enum { NETDEV_MAX_RX_BATCH = 256 };     \/* Maximum number packets in rx_recv() batch. *\/$/;"	e	enum:__anon61
NETDEV_PROMISC	.\lib\netdev.h	/^    NETDEV_PROMISC = 0x0002,    \/* Promiscuous mode? *\/$/;"	e	enum:netdev_flags
NETDEV_PROVIDER_H	.\lib\netdev-provider.h	18;"	d
NETDEV_QUEUE_FOR_EACH	.\lib\netdev.h	308;"	d
NETDEV_RULE_PRIORITY	.\lib\dpif-netdev.c	68;"	d	file:
NETDEV_UP	.\lib\netdev.h	/^    NETDEV_UP = 0x0001,         \/* Device enabled? *\/$/;"	e	enum:netdev_flags
NETDEV_VPORT_H	.\lib\netdev-vport.h	18;"	d
NETDEV_VPORT_NAME_BUFSIZE	.\lib\netdev-vport.h	/^enum { NETDEV_VPORT_NAME_BUFSIZE = 16 };$/;"	e	enum:__anon59
NETDEV_VPORT_NAME_BUFSIZE	.\lib\netdev-vport.h	/^enum { NETDEV_VPORT_NAME_BUFSIZE = 256 };$/;"	e	enum:__anon60
NETFLOW_H	.\lib\netflow.h	18;"	d
NETFLOW_V5_VERSION	.\lib\netflow.h	26;"	d
NETIF_F_FSO	.\datapath\linux\compat\include\linux\netdevice.h	60;"	d
NETIF_F_GSO_ENCAP_ALL	.\datapath\linux\compat\include\linux\netdev_features.h	13;"	d
NETIF_F_GSO_ENCAP_ALL	.\datapath\linux\compat\include\linux\netdev_features.h	45;"	d
NETIF_F_GSO_GRE	.\datapath\linux\compat\include\linux\netdev_features.h	18;"	d
NETIF_F_GSO_GRE_CSUM	.\datapath\linux\compat\include\linux\netdev_features.h	22;"	d
NETIF_F_GSO_IPIP	.\datapath\linux\compat\include\linux\netdev_features.h	26;"	d
NETIF_F_GSO_MPLS	.\datapath\linux\compat\include\linux\netdev_features.h	42;"	d
NETIF_F_GSO_SIT	.\datapath\linux\compat\include\linux\netdev_features.h	30;"	d
NETIF_F_GSO_UDP_TUNNEL	.\datapath\linux\compat\include\linux\netdev_features.h	34;"	d
NETIF_F_GSO_UDP_TUNNEL_CSUM	.\datapath\linux\compat\include\linux\netdev_features.h	38;"	d
NETIF_F_HW_VLAN_CTAG_TX	.\datapath\linux\compat\include\linux\netdev_features.h	9;"	d
NETLINK_ADD_MEMBERSHIP	.\lib\netlink-protocol.h	160;"	d
NETLINK_DROP_MEMBERSHIP	.\lib\netlink-protocol.h	161;"	d
NETLINK_GENERIC	.\lib\netlink-protocol.h	41;"	d
NETLINK_H	.\lib\netlink.h	18;"	d
NETLINK_NOTIFIER_H	.\lib\netlink-notifier.h	18;"	d
NETLINK_PROTOCOL_H	.\lib\netlink-protocol.h	18;"	d
NETLINK_SOCKET_H	.\lib\netlink-socket.h	18;"	d
NET_SKB_PAD	.\datapath\linux\compat\include\linux\skbuff.h	49;"	d
NEXTHDR_SCTP	.\datapath\linux\compat\include\net\ipv6.h	9;"	d
NF_ACTIVE_TIMEOUT_DEFAULT	.\ofproto\netflow.h	29;"	d
NF_OUT_DROP	.\ofproto\netflow.h	41;"	d
NF_OUT_FLOOD	.\ofproto\netflow.h	39;"	d
NF_OUT_MULTI	.\ofproto\netflow.h	40;"	d
NI_FQDN_FLAG_VALIDTTL	.\include\windows\netinet\icmp6.h	389;"	d
NI_NODEADDR_FLAG_ALL	.\include\windows\netinet\icmp6.h	395;"	d
NI_NODEADDR_FLAG_ALL	.\include\windows\netinet\icmp6.h	400;"	d
NI_NODEADDR_FLAG_ANYCAST	.\include\windows\netinet\icmp6.h	397;"	d
NI_NODEADDR_FLAG_ANYCAST	.\include\windows\netinet\icmp6.h	405;"	d
NI_NODEADDR_FLAG_COMPAT	.\include\windows\netinet\icmp6.h	401;"	d
NI_NODEADDR_FLAG_GLOBAL	.\include\windows\netinet\icmp6.h	394;"	d
NI_NODEADDR_FLAG_GLOBAL	.\include\windows\netinet\icmp6.h	404;"	d
NI_NODEADDR_FLAG_LINKLOCAL	.\include\windows\netinet\icmp6.h	392;"	d
NI_NODEADDR_FLAG_LINKLOCAL	.\include\windows\netinet\icmp6.h	402;"	d
NI_NODEADDR_FLAG_SITELOCAL	.\include\windows\netinet\icmp6.h	393;"	d
NI_NODEADDR_FLAG_SITELOCAL	.\include\windows\netinet\icmp6.h	403;"	d
NI_NODEADDR_FLAG_TRUNCATE	.\include\windows\netinet\icmp6.h	396;"	d
NI_NODEADDR_FLAG_TRUNCATE	.\include\windows\netinet\icmp6.h	399;"	d
NI_QTYPE_DNSNAME	.\include\windows\netinet\icmp6.h	384;"	d
NI_QTYPE_FQDN	.\include\windows\netinet\icmp6.h	383;"	d
NI_QTYPE_IPV4ADDR	.\include\windows\netinet\icmp6.h	386;"	d
NI_QTYPE_NODEADDR	.\include\windows\netinet\icmp6.h	385;"	d
NI_QTYPE_NOOP	.\include\windows\netinet\icmp6.h	381;"	d
NI_QTYPE_SUPTYPES	.\include\windows\netinet\icmp6.h	382;"	d
NI_SUPTYPE_FLAG_COMPRESS	.\include\windows\netinet\icmp6.h	388;"	d
NLA_ALIGN	.\lib\netlink-protocol.h	106;"	d
NLA_ALIGNTO	.\lib\netlink-protocol.h	105;"	d
NLA_F_NESTED	.\datapath\linux\compat\include\linux\netlink.h	8;"	d
NLA_F_NESTED	.\lib\netlink-protocol.h	152;"	d
NLA_F_NET_BYTEORDER	.\datapath\linux\compat\include\linux\netlink.h	9;"	d
NLA_F_NET_BYTEORDER	.\lib\netlink-protocol.h	153;"	d
NLA_HDRLEN	.\lib\netlink-protocol.h	107;"	d
NLA_TYPE_MASK	.\datapath\linux\compat\include\linux\netlink.h	10;"	d
NLA_TYPE_MASK	.\lib\netlink-protocol.h	154;"	d
NLMSG_ALIGN	.\lib\netlink-protocol.h	80;"	d
NLMSG_ALIGNTO	.\lib\netlink-protocol.h	79;"	d
NLMSG_DEFAULT_SIZE	.\datapath\linux\compat\include\linux\netlink.h	16;"	d
NLMSG_DONE	.\lib\netlink-protocol.h	65;"	d
NLMSG_ERROR	.\lib\netlink-protocol.h	64;"	d
NLMSG_HDRLEN	.\lib\netlink-protocol.h	81;"	d
NLMSG_MIN_TYPE	.\lib\netlink-protocol.h	68;"	d
NLMSG_NOOP	.\lib\netlink-protocol.h	63;"	d
NLMSG_OVERRUN	.\lib\netlink-protocol.h	66;"	d
NLM_F_ACK	.\lib\netlink-protocol.h	54;"	d
NLM_F_ATOMIC	.\lib\netlink-protocol.h	59;"	d
NLM_F_DUMP	.\lib\netlink-protocol.h	60;"	d
NLM_F_ECHO	.\lib\netlink-protocol.h	55;"	d
NLM_F_MATCH	.\lib\netlink-protocol.h	58;"	d
NLM_F_MULTI	.\lib\netlink-protocol.h	53;"	d
NLM_F_REQUEST	.\lib\netlink-protocol.h	52;"	d
NLM_F_ROOT	.\lib\netlink-protocol.h	57;"	d
NL_ATTR_FOR_EACH	.\lib\netlink.h	152;"	d
NL_ATTR_FOR_EACH_UNSAFE	.\lib\netlink.h	161;"	d
NL_ATTR_GET_AS	.\lib\netlink.c	537;"	d	file:
NL_ATTR_SIZE	.\lib\netlink.h	98;"	d
NL_A_BE16	.\lib\netlink.h	/^    NL_A_BE16 = NL_A_U16,$/;"	e	enum:nl_attr_type
NL_A_BE16_SIZE	.\lib\netlink.h	103;"	d
NL_A_BE32	.\lib\netlink.h	/^    NL_A_BE32 = NL_A_U32,$/;"	e	enum:nl_attr_type
NL_A_BE32_SIZE	.\lib\netlink.h	104;"	d
NL_A_BE64	.\lib\netlink.h	/^    NL_A_BE64 = NL_A_U64,$/;"	e	enum:nl_attr_type
NL_A_BE64_SIZE	.\lib\netlink.h	105;"	d
NL_A_FLAG	.\lib\netlink.h	/^    NL_A_FLAG,$/;"	e	enum:nl_attr_type
NL_A_FLAG_SIZE	.\lib\netlink.h	106;"	d
NL_A_NESTED	.\lib\netlink.h	/^    NL_A_NESTED,$/;"	e	enum:nl_attr_type
NL_A_NO_ATTR	.\lib\netlink.h	/^    NL_A_NO_ATTR = 0,$/;"	e	enum:nl_attr_type
NL_A_STRING	.\lib\netlink.h	/^    NL_A_STRING,$/;"	e	enum:nl_attr_type
NL_A_U16	.\lib\netlink.h	/^    NL_A_U16,$/;"	e	enum:nl_attr_type
NL_A_U16_SIZE	.\lib\netlink.h	100;"	d
NL_A_U32	.\lib\netlink.h	/^    NL_A_U32,$/;"	e	enum:nl_attr_type
NL_A_U32_SIZE	.\lib\netlink.h	101;"	d
NL_A_U64	.\lib\netlink.h	/^    NL_A_U64,$/;"	e	enum:nl_attr_type
NL_A_U64_SIZE	.\lib\netlink.h	102;"	d
NL_A_U8	.\lib\netlink.h	/^    NL_A_U8,$/;"	e	enum:nl_attr_type
NL_A_U8_SIZE	.\lib\netlink.h	99;"	d
NL_A_UNSPEC	.\lib\netlink.h	/^    NL_A_UNSPEC,$/;"	e	enum:nl_attr_type
NL_DUMP_BUFSIZE	.\lib\netlink-socket.h	110;"	d
NL_NESTED_FOR_EACH	.\lib\netlink.h	167;"	d
NL_NESTED_FOR_EACH_UNSAFE	.\lib\netlink.h	169;"	d
NL_POLICY_FOR	.\lib\netlink.h	200;"	d
NONE	.\lib\netdev-dummy.c	/^    NONE,       \/* No connection is configured. *\/$/;"	e	enum:dummy_packet_conn_type	file:
NON_PMD_THREAD_TX_QUEUE	.\lib\netdev-dpdk.c	71;"	d	file:
NOT_LOCKED	.\python\ovs\db\idl.py	/^    NOT_LOCKED = "not locked"    # Server hasn't given us the lock yet.$/;"	v	class:Transaction
NO_HANDLE	.\python\ovstest\tests.py	/^NO_HANDLE = -1$/;"	v
NO_RETURN	.\lib\compiler.h	28;"	d
NO_RETURN	.\lib\compiler.h	40;"	d
NO_STATUS_CHANGE	.\ofproto\ofproto-dpif.c	77;"	d	file:
NO_VLAN_WORKAROUND_DRIVERS	.\xenserver\opt_xensource_libexec_InterfaceReconfigureVswitch.py	/^NO_VLAN_WORKAROUND_DRIVERS = ($/;"	v
NR_QUEUE	.\lib\dpif-netdev.h	42;"	d
NR_THREADS	.\lib\dpif-netdev.c	70;"	d	file:
NUM_IPFIX_PROTO_L2	.\ofproto\ofproto-dpif-ipfix.c	/^    NUM_IPFIX_PROTO_L2$/;"	e	enum:ipfix_proto_l2	file:
NUM_IPFIX_PROTO_L3	.\ofproto\ofproto-dpif-ipfix.c	/^    NUM_IPFIX_PROTO_L3$/;"	e	enum:ipfix_proto_l3	file:
NUM_IPFIX_PROTO_L4	.\ofproto\ofproto-dpif-ipfix.c	/^    NUM_IPFIX_PROTO_L4$/;"	e	enum:ipfix_proto_l4	file:
NXAST_ACTION	.\lib\ofp-actions.c	1273;"	d	file:
NXAST_ACTION	.\lib\ofp-actions.c	315;"	d	file:
NXAST_ACTION	.\lib\ofp-actions.c	596;"	d	file:
NXAST_ACTION	.\lib\ofp-util.c	5852;"	d	file:
NXAST_ACTION	.\lib\ofp-util.c	5914;"	d	file:
NXAST_ACTION	.\lib\ofp-util.c	5941;"	d	file:
NXAST_ACTION	.\lib\ofp-util.h	943;"	d
NXAST_ACTION	.\lib\ofp-util.h	952;"	d
NXAST_ACTION	.\lib\ofp-util.h	987;"	d
NXAST_AUTOPATH__OBSOLETE	.\include\openflow\nicira-ext.h	/^    NXAST_AUTOPATH__OBSOLETE,   \/* No longer used. *\/$/;"	e	enum:nx_action_subtype
NXAST_BUNDLE	.\include\openflow\nicira-ext.h	/^    NXAST_BUNDLE,               \/* struct nx_action_bundle *\/$/;"	e	enum:nx_action_subtype
NXAST_BUNDLE_LOAD	.\include\openflow\nicira-ext.h	/^    NXAST_BUNDLE_LOAD,          \/* struct nx_action_bundle *\/$/;"	e	enum:nx_action_subtype
NXAST_CONTROLLER	.\include\openflow\nicira-ext.h	/^    NXAST_CONTROLLER,           \/* struct nx_action_controller *\/$/;"	e	enum:nx_action_subtype
NXAST_DEC_MPLS_TTL	.\include\openflow\nicira-ext.h	/^    NXAST_DEC_MPLS_TTL,         \/* struct nx_action_header *\/$/;"	e	enum:nx_action_subtype
NXAST_DEC_TTL	.\include\openflow\nicira-ext.h	/^    NXAST_DEC_TTL,              \/* struct nx_action_header *\/$/;"	e	enum:nx_action_subtype
NXAST_DEC_TTL_CNT_IDS	.\include\openflow\nicira-ext.h	/^    NXAST_DEC_TTL_CNT_IDS,      \/* struct nx_action_cnt_ids *\/$/;"	e	enum:nx_action_subtype
NXAST_DROP_SPOOFED_ARP__OBSOLETE	.\include\openflow\nicira-ext.h	/^    NXAST_DROP_SPOOFED_ARP__OBSOLETE,$/;"	e	enum:nx_action_subtype
NXAST_EXIT	.\include\openflow\nicira-ext.h	/^    NXAST_EXIT,                 \/* struct nx_action_header *\/$/;"	e	enum:nx_action_subtype
NXAST_FIN_TIMEOUT	.\include\openflow\nicira-ext.h	/^    NXAST_FIN_TIMEOUT,          \/* struct nx_action_fin_timeout *\/$/;"	e	enum:nx_action_subtype
NXAST_LEARN	.\include\openflow\nicira-ext.h	/^    NXAST_LEARN,                \/* struct nx_action_learn *\/$/;"	e	enum:nx_action_subtype
NXAST_MULTIPATH	.\include\openflow\nicira-ext.h	/^    NXAST_MULTIPATH,            \/* struct nx_action_multipath *\/$/;"	e	enum:nx_action_subtype
NXAST_NOTE	.\include\openflow\nicira-ext.h	/^    NXAST_NOTE,                 \/* struct nx_action_note *\/$/;"	e	enum:nx_action_subtype
NXAST_OUTPUT_REG	.\include\openflow\nicira-ext.h	/^    NXAST_OUTPUT_REG,           \/* struct nx_action_output_reg *\/$/;"	e	enum:nx_action_subtype
NXAST_POP_MPLS	.\include\openflow\nicira-ext.h	/^    NXAST_POP_MPLS,             \/* struct nx_action_pop_mpls *\/$/;"	e	enum:nx_action_subtype
NXAST_POP_QUEUE	.\include\openflow\nicira-ext.h	/^    NXAST_POP_QUEUE,            \/* struct nx_action_pop_queue *\/$/;"	e	enum:nx_action_subtype
NXAST_PUSH_MPLS	.\include\openflow\nicira-ext.h	/^    NXAST_PUSH_MPLS,            \/* struct nx_action_push_mpls *\/$/;"	e	enum:nx_action_subtype
NXAST_REG_LOAD	.\include\openflow\nicira-ext.h	/^    NXAST_REG_LOAD,             \/* struct nx_action_reg_load *\/$/;"	e	enum:nx_action_subtype
NXAST_REG_MOVE	.\include\openflow\nicira-ext.h	/^    NXAST_REG_MOVE,             \/* struct nx_action_reg_move *\/$/;"	e	enum:nx_action_subtype
NXAST_RESUBMIT	.\include\openflow\nicira-ext.h	/^    NXAST_RESUBMIT,             \/* struct nx_action_resubmit *\/$/;"	e	enum:nx_action_subtype
NXAST_RESUBMIT_TABLE	.\include\openflow\nicira-ext.h	/^    NXAST_RESUBMIT_TABLE,       \/* struct nx_action_resubmit *\/$/;"	e	enum:nx_action_subtype
NXAST_SAMPLE	.\include\openflow\nicira-ext.h	/^    NXAST_SAMPLE,               \/* struct nx_action_sample *\/$/;"	e	enum:nx_action_subtype
NXAST_SET_MPLS_LABEL	.\include\openflow\nicira-ext.h	/^    NXAST_SET_MPLS_LABEL,       \/* struct nx_action_ttl *\/$/;"	e	enum:nx_action_subtype
NXAST_SET_MPLS_TC	.\include\openflow\nicira-ext.h	/^    NXAST_SET_MPLS_TC,          \/* struct nx_action_ttl *\/$/;"	e	enum:nx_action_subtype
NXAST_SET_MPLS_TTL	.\include\openflow\nicira-ext.h	/^    NXAST_SET_MPLS_TTL,         \/* struct nx_action_ttl *\/$/;"	e	enum:nx_action_subtype
NXAST_SET_QUEUE	.\include\openflow\nicira-ext.h	/^    NXAST_SET_QUEUE,            \/* struct nx_action_set_queue *\/$/;"	e	enum:nx_action_subtype
NXAST_SET_TUNNEL	.\include\openflow\nicira-ext.h	/^    NXAST_SET_TUNNEL,           \/* struct nx_action_set_tunnel *\/$/;"	e	enum:nx_action_subtype
NXAST_SET_TUNNEL64	.\include\openflow\nicira-ext.h	/^    NXAST_SET_TUNNEL64,         \/* struct nx_action_set_tunnel64 *\/$/;"	e	enum:nx_action_subtype
NXAST_SNAT__OBSOLETE	.\include\openflow\nicira-ext.h	/^    NXAST_SNAT__OBSOLETE,       \/* No longer used. *\/$/;"	e	enum:nx_action_subtype
NXAST_STACK_POP	.\include\openflow\nicira-ext.h	/^    NXAST_STACK_POP,            \/* struct nx_action_stack *\/$/;"	e	enum:nx_action_subtype
NXAST_STACK_PUSH	.\include\openflow\nicira-ext.h	/^    NXAST_STACK_PUSH,           \/* struct nx_action_stack *\/$/;"	e	enum:nx_action_subtype
NXAST_WRITE_METADATA	.\include\openflow\nicira-ext.h	/^    NXAST_WRITE_METADATA,       \/* struct nx_action_write_metadata *\/$/;"	e	enum:nx_action_subtype
NXET_VENDOR	.\include\openflow\nicira-ext.h	54;"	d
NXFF_NXM	.\include\openflow\nicira-ext.h	/^    NXFF_NXM = 2                 \/* Nicira extended match. *\/$/;"	e	enum:nx_flow_format
NXFF_OPENFLOW10	.\include\openflow\nicira-ext.h	/^    NXFF_OPENFLOW10 = 0,         \/* Standard OpenFlow 1.0 compatible. *\/$/;"	e	enum:nx_flow_format
NXFME_ABBREV	.\include\openflow\nicira-ext.h	/^    NXFME_ABBREV = 3,           \/* Abbreviated reply. *\/$/;"	e	enum:nx_flow_update_event
NXFME_ADDED	.\include\openflow\nicira-ext.h	/^    NXFME_ADDED = 0,            \/* Flow was added. *\/$/;"	e	enum:nx_flow_update_event
NXFME_DELETED	.\include\openflow\nicira-ext.h	/^    NXFME_DELETED = 1,          \/* Flow was deleted. *\/$/;"	e	enum:nx_flow_update_event
NXFME_MODIFIED	.\include\openflow\nicira-ext.h	/^    NXFME_MODIFIED = 2,         \/* Flow (generally its actions) was changed. *\/$/;"	e	enum:nx_flow_update_event
NXFMF_ACTIONS	.\include\openflow\nicira-ext.h	/^    NXFMF_ACTIONS = 1 << 4,     \/* If set, actions are included. *\/$/;"	e	enum:nx_flow_monitor_flags
NXFMF_ADD	.\include\openflow\nicira-ext.h	/^    NXFMF_ADD = 1 << 1,         \/* New matching flows as they are added. *\/$/;"	e	enum:nx_flow_monitor_flags
NXFMF_DELETE	.\include\openflow\nicira-ext.h	/^    NXFMF_DELETE = 1 << 2,      \/* Old matching flows as they are removed. *\/$/;"	e	enum:nx_flow_monitor_flags
NXFMF_INITIAL	.\include\openflow\nicira-ext.h	/^    NXFMF_INITIAL = 1 << 0,     \/* Initially matching flows. *\/$/;"	e	enum:nx_flow_monitor_flags
NXFMF_MODIFY	.\include\openflow\nicira-ext.h	/^    NXFMF_MODIFY = 1 << 3,      \/* Matching flows as they are changed. *\/$/;"	e	enum:nx_flow_monitor_flags
NXFMF_OWN	.\include\openflow\nicira-ext.h	/^    NXFMF_OWN = 1 << 5,         \/* If set, include own changes in full. *\/$/;"	e	enum:nx_flow_monitor_flags
NXM_FIELD	.\include\openflow\nicira-ext.h	1341;"	d
NXM_HASMASK	.\include\openflow\nicira-ext.h	1343;"	d
NXM_HEADER	.\include\openflow\nicira-ext.h	1336;"	d
NXM_HEADER_W	.\include\openflow\nicira-ext.h	1338;"	d
NXM_HEADER__	.\include\openflow\nicira-ext.h	1334;"	d
NXM_IS_NX_REG	.\include\openflow\nicira-ext.h	1558;"	d
NXM_IS_NX_REG_W	.\include\openflow\nicira-ext.h	1559;"	d
NXM_LENGTH	.\include\openflow\nicira-ext.h	1344;"	d
NXM_MAKE_WILD_HEADER	.\include\openflow\nicira-ext.h	1346;"	d
NXM_NX_ARP_SHA	.\include\openflow\nicira-ext.h	1601;"	d
NXM_NX_ARP_THA	.\include\openflow\nicira-ext.h	1602;"	d
NXM_NX_COOKIE	.\include\openflow\nicira-ext.h	1762;"	d
NXM_NX_COOKIE_W	.\include\openflow\nicira-ext.h	1763;"	d
NXM_NX_DP_HASH	.\include\openflow\nicira-ext.h	1818;"	d
NXM_NX_DP_HASH_W	.\include\openflow\nicira-ext.h	1819;"	d
NXM_NX_ICMPV6_CODE	.\include\openflow\nicira-ext.h	1628;"	d
NXM_NX_ICMPV6_TYPE	.\include\openflow\nicira-ext.h	1627;"	d
NXM_NX_IPV6_DST	.\include\openflow\nicira-ext.h	1615;"	d
NXM_NX_IPV6_DST_W	.\include\openflow\nicira-ext.h	1616;"	d
NXM_NX_IPV6_LABEL	.\include\openflow\nicira-ext.h	1728;"	d
NXM_NX_IPV6_LABEL_W	.\include\openflow\nicira-ext.h	1729;"	d
NXM_NX_IPV6_SRC	.\include\openflow\nicira-ext.h	1613;"	d
NXM_NX_IPV6_SRC_W	.\include\openflow\nicira-ext.h	1614;"	d
NXM_NX_IP_ECN	.\include\openflow\nicira-ext.h	1738;"	d
NXM_NX_IP_FRAG	.\include\openflow\nicira-ext.h	1714;"	d
NXM_NX_IP_FRAG_W	.\include\openflow\nicira-ext.h	1715;"	d
NXM_NX_IP_TTL	.\include\openflow\nicira-ext.h	1747;"	d
NXM_NX_MAX_REGS	.\include\openflow\nicira-ext.h	1554;"	d
NXM_NX_ND_SLL	.\include\openflow\nicira-ext.h	1656;"	d
NXM_NX_ND_TARGET	.\include\openflow\nicira-ext.h	1642;"	d
NXM_NX_ND_TARGET_W	.\include\openflow\nicira-ext.h	1643;"	d
NXM_NX_ND_TLL	.\include\openflow\nicira-ext.h	1669;"	d
NXM_NX_PKT_MARK	.\include\openflow\nicira-ext.h	1791;"	d
NXM_NX_PKT_MARK_W	.\include\openflow\nicira-ext.h	1792;"	d
NXM_NX_RECIRC_ID	.\include\openflow\nicira-ext.h	1833;"	d
NXM_NX_REG	.\include\openflow\nicira-ext.h	1555;"	d
NXM_NX_REG0	.\include\openflow\nicira-ext.h	1560;"	d
NXM_NX_REG0_W	.\include\openflow\nicira-ext.h	1561;"	d
NXM_NX_REG1	.\include\openflow\nicira-ext.h	1562;"	d
NXM_NX_REG1_W	.\include\openflow\nicira-ext.h	1563;"	d
NXM_NX_REG2	.\include\openflow\nicira-ext.h	1564;"	d
NXM_NX_REG2_W	.\include\openflow\nicira-ext.h	1565;"	d
NXM_NX_REG3	.\include\openflow\nicira-ext.h	1566;"	d
NXM_NX_REG3_W	.\include\openflow\nicira-ext.h	1567;"	d
NXM_NX_REG4	.\include\openflow\nicira-ext.h	1568;"	d
NXM_NX_REG4_W	.\include\openflow\nicira-ext.h	1569;"	d
NXM_NX_REG5	.\include\openflow\nicira-ext.h	1570;"	d
NXM_NX_REG5_W	.\include\openflow\nicira-ext.h	1571;"	d
NXM_NX_REG6	.\include\openflow\nicira-ext.h	1572;"	d
NXM_NX_REG6_W	.\include\openflow\nicira-ext.h	1573;"	d
NXM_NX_REG7	.\include\openflow\nicira-ext.h	1574;"	d
NXM_NX_REG7_W	.\include\openflow\nicira-ext.h	1575;"	d
NXM_NX_REG_IDX	.\include\openflow\nicira-ext.h	1557;"	d
NXM_NX_REG_W	.\include\openflow\nicira-ext.h	1556;"	d
NXM_NX_TCP_FLAGS	.\include\openflow\nicira-ext.h	1803;"	d
NXM_NX_TCP_FLAGS_W	.\include\openflow\nicira-ext.h	1804;"	d
NXM_NX_TUN_ID	.\include\openflow\nicira-ext.h	1590;"	d
NXM_NX_TUN_ID_W	.\include\openflow\nicira-ext.h	1591;"	d
NXM_NX_TUN_IPV4_DST	.\include\openflow\nicira-ext.h	1777;"	d
NXM_NX_TUN_IPV4_DST_W	.\include\openflow\nicira-ext.h	1778;"	d
NXM_NX_TUN_IPV4_SRC	.\include\openflow\nicira-ext.h	1775;"	d
NXM_NX_TUN_IPV4_SRC_W	.\include\openflow\nicira-ext.h	1776;"	d
NXM_OF_ARP_OP	.\include\openflow\nicira-ext.h	1522;"	d
NXM_OF_ARP_SPA	.\include\openflow\nicira-ext.h	1534;"	d
NXM_OF_ARP_SPA_W	.\include\openflow\nicira-ext.h	1535;"	d
NXM_OF_ARP_TPA	.\include\openflow\nicira-ext.h	1536;"	d
NXM_OF_ARP_TPA_W	.\include\openflow\nicira-ext.h	1537;"	d
NXM_OF_ETH_DST	.\include\openflow\nicira-ext.h	1371;"	d
NXM_OF_ETH_DST_W	.\include\openflow\nicira-ext.h	1372;"	d
NXM_OF_ETH_SRC	.\include\openflow\nicira-ext.h	1373;"	d
NXM_OF_ETH_SRC_W	.\include\openflow\nicira-ext.h	1374;"	d
NXM_OF_ETH_TYPE	.\include\openflow\nicira-ext.h	1391;"	d
NXM_OF_ICMP_CODE	.\include\openflow\nicira-ext.h	1509;"	d
NXM_OF_ICMP_TYPE	.\include\openflow\nicira-ext.h	1508;"	d
NXM_OF_IN_PORT	.\include\openflow\nicira-ext.h	1360;"	d
NXM_OF_IP_DST	.\include\openflow\nicira-ext.h	1466;"	d
NXM_OF_IP_DST_W	.\include\openflow\nicira-ext.h	1467;"	d
NXM_OF_IP_PROTO	.\include\openflow\nicira-ext.h	1453;"	d
NXM_OF_IP_SRC	.\include\openflow\nicira-ext.h	1464;"	d
NXM_OF_IP_SRC_W	.\include\openflow\nicira-ext.h	1465;"	d
NXM_OF_IP_TOS	.\include\openflow\nicira-ext.h	1444;"	d
NXM_OF_TCP_DST	.\include\openflow\nicira-ext.h	1481;"	d
NXM_OF_TCP_DST_W	.\include\openflow\nicira-ext.h	1482;"	d
NXM_OF_TCP_SRC	.\include\openflow\nicira-ext.h	1479;"	d
NXM_OF_TCP_SRC_W	.\include\openflow\nicira-ext.h	1480;"	d
NXM_OF_UDP_DST	.\include\openflow\nicira-ext.h	1496;"	d
NXM_OF_UDP_DST_W	.\include\openflow\nicira-ext.h	1497;"	d
NXM_OF_UDP_SRC	.\include\openflow\nicira-ext.h	1494;"	d
NXM_OF_UDP_SRC_W	.\include\openflow\nicira-ext.h	1495;"	d
NXM_OF_VLAN_TCI	.\include\openflow\nicira-ext.h	1434;"	d
NXM_OF_VLAN_TCI_W	.\include\openflow\nicira-ext.h	1435;"	d
NXM_TYPE	.\include\openflow\nicira-ext.h	1342;"	d
NXM_TYPICAL_LEN	.\lib\nx-match.h	144;"	d
NXM_VENDOR	.\include\openflow\nicira-ext.h	1340;"	d
NXPIF_NXM	.\include\openflow\nicira-ext.h	/^    NXPIF_NXM = 1               \/* Nicira Extended. *\/$/;"	e	enum:nx_packet_in_format
NXPIF_OPENFLOW10	.\include\openflow\nicira-ext.h	/^    NXPIF_OPENFLOW10 = 0,       \/* Standard OpenFlow 1.0 compatible. *\/$/;"	e	enum:nx_packet_in_format
NXVC_VENDOR_ERROR	.\include\openflow\nicira-ext.h	/^    NXVC_VENDOR_ERROR           \/* 'data' contains struct nx_vendor_error. *\/$/;"	e	enum:nx_vendor_code
NX_BD_ALG_ACTIVE_BACKUP	.\include\openflow\nicira-ext.h	/^    NX_BD_ALG_ACTIVE_BACKUP,$/;"	e	enum:nx_bd_algorithm
NX_BD_ALG_HRW	.\include\openflow\nicira-ext.h	/^    NX_BD_ALG_HRW \/* Highest Random Weight. *\/$/;"	e	enum:nx_bd_algorithm
NX_HASH_FIELDS_ETH_SRC	.\include\openflow\nicira-ext.h	/^    NX_HASH_FIELDS_ETH_SRC,$/;"	e	enum:nx_hash_fields
NX_HASH_FIELDS_SYMMETRIC_L4	.\include\openflow\nicira-ext.h	/^    NX_HASH_FIELDS_SYMMETRIC_L4$/;"	e	enum:nx_hash_fields
NX_IP_FRAG_ANY	.\include\openflow\nicira-ext.h	1718;"	d
NX_IP_FRAG_LATER	.\include\openflow\nicira-ext.h	1719;"	d
NX_LEARN_DST_LOAD	.\include\openflow\nicira-ext.h	947;"	d
NX_LEARN_DST_MASK	.\include\openflow\nicira-ext.h	950;"	d
NX_LEARN_DST_MATCH	.\include\openflow\nicira-ext.h	946;"	d
NX_LEARN_DST_OUTPUT	.\include\openflow\nicira-ext.h	948;"	d
NX_LEARN_DST_RESERVED	.\include\openflow\nicira-ext.h	949;"	d
NX_LEARN_N_BITS_MASK	.\include\openflow\nicira-ext.h	940;"	d
NX_LEARN_SRC_FIELD	.\include\openflow\nicira-ext.h	942;"	d
NX_LEARN_SRC_IMMEDIATE	.\include\openflow\nicira-ext.h	943;"	d
NX_LEARN_SRC_MASK	.\include\openflow\nicira-ext.h	944;"	d
NX_MATCH_H	.\lib\nx-match.h	18;"	d
NX_MP_ALG_HASH_THRESHOLD	.\include\openflow\nicira-ext.h	/^    NX_MP_ALG_HASH_THRESHOLD,$/;"	e	enum:nx_mp_algorithm
NX_MP_ALG_HRW	.\include\openflow\nicira-ext.h	/^    NX_MP_ALG_HRW,              \/* Highest Random Weight. *\/$/;"	e	enum:nx_mp_algorithm
NX_MP_ALG_ITER_HASH	.\include\openflow\nicira-ext.h	/^    NX_MP_ALG_ITER_HASH         \/* Iterative Hash. *\/$/;"	e	enum:nx_mp_algorithm
NX_MP_ALG_MODULO_N	.\include\openflow\nicira-ext.h	/^    NX_MP_ALG_MODULO_N,$/;"	e	enum:nx_mp_algorithm
NX_ROLE_MASTER	.\include\openflow\nicira-ext.h	/^    NX_ROLE_MASTER,             \/* Full access, at most one. *\/$/;"	e	enum:nx_role
NX_ROLE_OTHER	.\include\openflow\nicira-ext.h	/^    NX_ROLE_OTHER,              \/* Default role, full access. *\/$/;"	e	enum:nx_role
NX_ROLE_SLAVE	.\include\openflow\nicira-ext.h	/^    NX_ROLE_SLAVE               \/* Read-only access. *\/$/;"	e	enum:nx_role
NX_VENDOR_ID	.\include\openflow\openflow-common.h	103;"	d
N_DL_DST_VALUES	.\tests\test-classifier.c	376;"	d	file:
N_DL_SRC_VALUES	.\tests\test-classifier.c	375;"	d	file:
N_DL_TYPE_VALUES	.\tests\test-classifier.c	372;"	d	file:
N_FLOWS	.\tests\test-bundle.c	30;"	d	file:
N_FLOW_VALUES	.\tests\test-classifier.c	380;"	d	file:
N_IN_PORT_VALUES	.\tests\test-classifier.c	370;"	d	file:
N_MATCH_TYPES	.\ofproto\tunnel.c	89;"	d	file:
N_METADATA_VALUES	.\tests\test-classifier.c	369;"	d	file:
N_NL_ATTR_TYPES	.\lib\netlink.h	/^    N_NL_ATTR_TYPES$/;"	e	enum:nl_attr_type
N_NW_DSCP_VALUES	.\tests\test-classifier.c	378;"	d	file:
N_NW_DST_VALUES	.\tests\test-classifier.c	367;"	d	file:
N_NW_PROTO_VALUES	.\tests\test-classifier.c	377;"	d	file:
N_NW_SRC_VALUES	.\tests\test-classifier.c	366;"	d	file:
N_OFPACTS	.\lib\ofp-actions.h	/^    N_OFPACTS =$/;"	e	enum:__anon73
N_OVS_INSTRUCTIONS	.\lib\ofp-actions.h	/^    N_OVS_INSTRUCTIONS = OVS_INSTRUCTIONS$/;"	e	enum:__anon74
N_PROTO_ABBREVS	.\lib\ofp-util.c	712;"	d	file:
N_SCHEDULERS	.\ofproto\connmgr.c	86;"	d	file:
N_SIGNALS	.\lib\signals.c	33;"	d	file:
N_SIGNALS	.\lib\signals.c	35;"	d	file:
N_SIGNALS	.\lib\signals.c	39;"	d	file:
N_TABLES	.\ofproto\ofproto-dpif.h	/^enum { N_TABLES = 255 };$/;"	e	enum:__anon144
N_TAG_BITS	.\lib\tag.h	67;"	d
N_TP_DST_VALUES	.\tests\test-classifier.c	374;"	d	file:
N_TP_SRC_VALUES	.\tests\test-classifier.c	373;"	d	file:
N_TUN_ID_VALUES	.\tests\test-classifier.c	368;"	d	file:
N_VLAN_TCI_VALUES	.\tests\test-classifier.c	371;"	d	file:
Namespace	.\python\compat\argparse.py	/^class Namespace(_AttributeHolder):$/;"	c
Network	.\tests\MockXenAPI.py	/^class Network(Table):$/;"	c
OAM_FLOW_REMOVED	.\ofproto\connmgr.h	/^    OAM_FLOW_REMOVED,           \/* OFPT_FLOW_REMOVED or NXT_FLOW_REMOVED. *\/$/;"	e	enum:ofconn_async_msg_type
OAM_N_TYPES	.\ofproto\connmgr.h	/^    OAM_N_TYPES$/;"	e	enum:ofconn_async_msg_type
OAM_PACKET_IN	.\ofproto\connmgr.h	/^    OAM_PACKET_IN,              \/* OFPT_PACKET_IN or NXT_PACKET_IN. *\/$/;"	e	enum:ofconn_async_msg_type
OAM_PORT_STATUS	.\ofproto\connmgr.h	/^    OAM_PORT_STATUS,            \/* OFPT_PORT_STATUS. *\/$/;"	e	enum:ofconn_async_msg_type
OBJECT_CONTAINING	.\lib\util.h	220;"	d
OBJECT_OFFSETOF	.\lib\util.h	202;"	d
OBJECT_OFFSETOF	.\lib\util.h	204;"	d
ODPP_LOCAL	.\lib\odp-util.h	69;"	d
ODPP_NONE	.\lib\odp-util.h	70;"	d
ODPUTIL_FLOW_KEY_BYTES	.\lib\odp-util.h	125;"	d
ODP_FIT_ERROR	.\lib\odp-util.h	/^    ODP_FIT_ERROR,              \/* The key was invalid. *\/$/;"	e	enum:odp_key_fitness
ODP_FIT_PERFECT	.\lib\odp-util.h	/^    ODP_FIT_PERFECT,            \/* The key had exactly the fields we expect. *\/$/;"	e	enum:odp_key_fitness
ODP_FIT_TOO_LITTLE	.\lib\odp-util.h	/^    ODP_FIT_TOO_LITTLE,         \/* The key lacked fields we expected to see. *\/$/;"	e	enum:odp_key_fitness
ODP_FIT_TOO_MUCH	.\lib\odp-util.h	/^    ODP_FIT_TOO_MUCH,           \/* The key had fields we don't understand. *\/$/;"	e	enum:odp_key_fitness
ODP_KEY_METADATA_SIZE	.\lib\odp-util.h	/^enum { ODP_KEY_METADATA_SIZE = 9 * 8 };$/;"	e	enum:__anon68
ODP_PORT_C	.\include\openvswitch\types.h	104;"	d
ODP_UTIL_H	.\lib\odp-util.h	18;"	d
OFCONN_PRIMARY	.\ofproto\connmgr.h	/^    OFCONN_PRIMARY,             \/* An ordinary OpenFlow controller. *\/$/;"	e	enum:ofconn_type
OFCONN_REPLY_MAX	.\ofproto\connmgr.c	95;"	d	file:
OFCONN_SERVICE	.\ofproto\connmgr.h	/^    OFCONN_SERVICE              \/* A service connection, e.g. "ovs-ofctl". *\/$/;"	e	enum:ofconn_type
OFOPERATION_ADD	.\ofproto\ofproto.c	/^    OFOPERATION_ADD,$/;"	e	enum:ofoperation_type	file:
OFOPERATION_DELETE	.\ofproto\ofproto.c	/^    OFOPERATION_DELETE,$/;"	e	enum:ofoperation_type	file:
OFOPERATION_MODIFY	.\ofproto\ofproto.c	/^    OFOPERATION_MODIFY,$/;"	e	enum:ofoperation_type	file:
OFOPERATION_REPLACE	.\ofproto\ofproto.c	/^    OFOPERATION_REPLACE$/;"	e	enum:ofoperation_type	file:
OFP10_VERSION	.\include\openflow\openflow-common.h	/^    OFP10_VERSION = 0x01,$/;"	e	enum:ofp_version
OFP10_VLAN_NONE	.\include\openflow\openflow-1.0.h	270;"	d
OFP11_INSTRUCTION_ALIGN	.\include\openflow\openflow-1.1.h	297;"	d
OFP11_PORT_C	.\include\openvswitch\types.h	105;"	d
OFP11_VERSION	.\include\openflow\openflow-common.h	/^    OFP11_VERSION = 0x02,$/;"	e	enum:ofp_version
OFP12_VERSION	.\include\openflow\openflow-common.h	/^    OFP12_VERSION = 0x03,$/;"	e	enum:ofp_version
OFP13_VERSION	.\include\openflow\openflow-common.h	/^    OFP13_VERSION = 0x04,$/;"	e	enum:ofp_version
OFP14_VERSION	.\include\openflow\openflow-common.h	/^    OFP14_VERSION = 0x05,$/;"	e	enum:ofp_version
OFP15_VERSION	.\include\openflow\openflow-common.h	/^    OFP15_VERSION = 0x06$/;"	e	enum:ofp_version
OFPACPT_FLOW_REMOVED_MASTER	.\include\openflow\openflow-1.4.h	/^    OFPACPT_FLOW_REMOVED_MASTER   = 5, \/* Flow removed mask for master. *\/$/;"	e	enum:ofp14_async_config_prop_type
OFPACPT_FLOW_REMOVED_SLAVE	.\include\openflow\openflow-1.4.h	/^    OFPACPT_FLOW_REMOVED_SLAVE    = 4, \/* Flow removed mask for slave. *\/$/;"	e	enum:ofp14_async_config_prop_type
OFPACPT_PACKET_IN_MASTER	.\include\openflow\openflow-1.4.h	/^    OFPACPT_PACKET_IN_MASTER      = 1, \/* Packet-in mask for master. *\/$/;"	e	enum:ofp14_async_config_prop_type
OFPACPT_PACKET_IN_SLAVE	.\include\openflow\openflow-1.4.h	/^    OFPACPT_PACKET_IN_SLAVE       = 0, \/* Packet-in mask for slave. *\/$/;"	e	enum:ofp14_async_config_prop_type
OFPACPT_PORT_STATUS_MASTER	.\include\openflow\openflow-1.4.h	/^    OFPACPT_PORT_STATUS_MASTER    = 3, \/* Port-status mask for master. *\/$/;"	e	enum:ofp14_async_config_prop_type
OFPACPT_PORT_STATUS_SLAVE	.\include\openflow\openflow-1.4.h	/^    OFPACPT_PORT_STATUS_SLAVE     = 2, \/* Port-status mask for slave. *\/$/;"	e	enum:ofp14_async_config_prop_type
OFPACPT_REQUESTFORWARD_MASTER	.\include\openflow\openflow-1.4.h	/^    OFPACPT_REQUESTFORWARD_MASTER = 11, \/* RequestForward mask for master. *\/$/;"	e	enum:ofp14_async_config_prop_type
OFPACPT_REQUESTFORWARD_SLAVE	.\include\openflow\openflow-1.4.h	/^    OFPACPT_REQUESTFORWARD_SLAVE  = 10, \/* RequestForward mask for slave. *\/$/;"	e	enum:ofp14_async_config_prop_type
OFPACPT_ROLE_STATUS_MASTER	.\include\openflow\openflow-1.4.h	/^    OFPACPT_ROLE_STATUS_MASTER    = 7, \/* Role status mask for master. *\/$/;"	e	enum:ofp14_async_config_prop_type
OFPACPT_ROLE_STATUS_SLAVE	.\include\openflow\openflow-1.4.h	/^    OFPACPT_ROLE_STATUS_SLAVE     = 6, \/* Role status mask for slave. *\/$/;"	e	enum:ofp14_async_config_prop_type
OFPACPT_TABLE_STATUS_MASTER	.\include\openflow\openflow-1.4.h	/^    OFPACPT_TABLE_STATUS_MASTER   = 9, \/* Table status mask for master. *\/$/;"	e	enum:ofp14_async_config_prop_type
OFPACPT_TABLE_STATUS_SLAVE	.\include\openflow\openflow-1.4.h	/^    OFPACPT_TABLE_STATUS_SLAVE    = 8, \/* Table status mask for slave. *\/$/;"	e	enum:ofp14_async_config_prop_type
OFPACTS	.\lib\ofp-actions.h	/^    OFPACTS$/;"	e	enum:ofpact_type
OFPACTS	.\lib\ofp-actions.h	52;"	d
OFPACT_ALIGN	.\lib\ofp-actions.h	171;"	d
OFPACT_ALIGNTO	.\lib\ofp-actions.h	170;"	d
OFPACT_FOR_EACH	.\lib\ofp-actions.h	187;"	d
OFPAT10_ACTION	.\lib\ofp-actions.c	1146;"	d	file:
OFPAT10_ACTION	.\lib\ofp-actions.c	353;"	d	file:
OFPAT10_ACTION	.\lib\ofp-actions.c	378;"	d	file:
OFPAT10_ACTION	.\lib\ofp-util.c	5849;"	d	file:
OFPAT10_ACTION	.\lib\ofp-util.c	5910;"	d	file:
OFPAT10_ACTION	.\lib\ofp-util.c	5921;"	d	file:
OFPAT10_ACTION	.\lib\ofp-util.h	940;"	d
OFPAT10_ACTION	.\lib\ofp-util.h	949;"	d
OFPAT10_ACTION	.\lib\ofp-util.h	978;"	d
OFPAT10_ENQUEUE	.\include\openflow\openflow-1.0.h	/^    OFPAT10_ENQUEUE,            \/* Output to queue. *\/$/;"	e	enum:ofp10_action_type
OFPAT10_OUTPUT	.\include\openflow\openflow-1.0.h	/^    OFPAT10_OUTPUT,             \/* Output to switch port. *\/$/;"	e	enum:ofp10_action_type
OFPAT10_SET_DL_DST	.\include\openflow\openflow-1.0.h	/^    OFPAT10_SET_DL_DST,         \/* Ethernet destination address. *\/$/;"	e	enum:ofp10_action_type
OFPAT10_SET_DL_SRC	.\include\openflow\openflow-1.0.h	/^    OFPAT10_SET_DL_SRC,         \/* Ethernet source address. *\/$/;"	e	enum:ofp10_action_type
OFPAT10_SET_NW_DST	.\include\openflow\openflow-1.0.h	/^    OFPAT10_SET_NW_DST,         \/* IP destination address. *\/$/;"	e	enum:ofp10_action_type
OFPAT10_SET_NW_SRC	.\include\openflow\openflow-1.0.h	/^    OFPAT10_SET_NW_SRC,         \/* IP source address. *\/$/;"	e	enum:ofp10_action_type
OFPAT10_SET_NW_TOS	.\include\openflow\openflow-1.0.h	/^    OFPAT10_SET_NW_TOS,         \/* IP ToS (DSCP field, 6 bits). *\/$/;"	e	enum:ofp10_action_type
OFPAT10_SET_TP_DST	.\include\openflow\openflow-1.0.h	/^    OFPAT10_SET_TP_DST,         \/* TCP\/UDP destination port. *\/$/;"	e	enum:ofp10_action_type
OFPAT10_SET_TP_SRC	.\include\openflow\openflow-1.0.h	/^    OFPAT10_SET_TP_SRC,         \/* TCP\/UDP source port. *\/$/;"	e	enum:ofp10_action_type
OFPAT10_SET_VLAN_PCP	.\include\openflow\openflow-1.0.h	/^    OFPAT10_SET_VLAN_PCP,       \/* Set the 802.1q priority. *\/$/;"	e	enum:ofp10_action_type
OFPAT10_SET_VLAN_VID	.\include\openflow\openflow-1.0.h	/^    OFPAT10_SET_VLAN_VID,       \/* Set the 802.1q VLAN id. *\/$/;"	e	enum:ofp10_action_type
OFPAT10_STRIP_VLAN	.\include\openflow\openflow-1.0.h	/^    OFPAT10_STRIP_VLAN,         \/* Strip the 802.1q header. *\/$/;"	e	enum:ofp10_action_type
OFPAT10_VENDOR	.\include\openflow\openflow-1.0.h	/^    OFPAT10_VENDOR = 0xffff$/;"	e	enum:ofp10_action_type
OFPAT11_ACTION	.\lib\ofp-actions.c	379;"	d	file:
OFPAT11_ACTION	.\lib\ofp-actions.c	526;"	d	file:
OFPAT11_ACTION	.\lib\ofp-actions.c	755;"	d	file:
OFPAT11_ACTION	.\lib\ofp-util.c	5850;"	d	file:
OFPAT11_ACTION	.\lib\ofp-util.c	5912;"	d	file:
OFPAT11_ACTION	.\lib\ofp-util.c	5937;"	d	file:
OFPAT11_ACTION	.\lib\ofp-util.h	941;"	d
OFPAT11_ACTION	.\lib\ofp-util.h	950;"	d
OFPAT11_ACTION	.\lib\ofp-util.h	981;"	d
OFPAT11_COPY_TTL_IN	.\include\openflow\openflow-1.1.h	/^    OFPAT11_COPY_TTL_IN,      \/* Copy TTL "inwards" -- from outermost to$/;"	e	enum:ofp11_action_type
OFPAT11_COPY_TTL_OUT	.\include\openflow\openflow-1.1.h	/^    OFPAT11_COPY_TTL_OUT,     \/* Copy TTL "outwards" -- from next-to-outermost$/;"	e	enum:ofp11_action_type
OFPAT11_DEC_MPLS_TTL	.\include\openflow\openflow-1.1.h	/^    OFPAT11_DEC_MPLS_TTL,     \/* Decrement MPLS TTL *\/$/;"	e	enum:ofp11_action_type
OFPAT11_DEC_NW_TTL	.\include\openflow\openflow-1.1.h	/^    OFPAT11_DEC_NW_TTL,       \/* Decrement IP TTL. *\/$/;"	e	enum:ofp11_action_type
OFPAT11_EXPERIMENTER	.\include\openflow\openflow-1.1.h	/^    OFPAT11_EXPERIMENTER = 0xffff$/;"	e	enum:ofp11_action_type
OFPAT11_GROUP	.\include\openflow\openflow-1.1.h	/^    OFPAT11_GROUP,            \/* Apply group. *\/$/;"	e	enum:ofp11_action_type
OFPAT11_OUTPUT	.\include\openflow\openflow-1.1.h	/^    OFPAT11_OUTPUT,           \/* Output to switch port. *\/$/;"	e	enum:ofp11_action_type
OFPAT11_POP_MPLS	.\include\openflow\openflow-1.1.h	/^    OFPAT11_POP_MPLS,         \/* Pop the outer MPLS Label Stack Entry *\/$/;"	e	enum:ofp11_action_type
OFPAT11_POP_VLAN	.\include\openflow\openflow-1.1.h	/^    OFPAT11_POP_VLAN,         \/* Pop the outer VLAN tag *\/$/;"	e	enum:ofp11_action_type
OFPAT11_PUSH_MPLS	.\include\openflow\openflow-1.1.h	/^    OFPAT11_PUSH_MPLS,        \/* Push a new MPLS Label Stack Entry *\/$/;"	e	enum:ofp11_action_type
OFPAT11_PUSH_VLAN	.\include\openflow\openflow-1.1.h	/^    OFPAT11_PUSH_VLAN,        \/* Push a new VLAN tag *\/$/;"	e	enum:ofp11_action_type
OFPAT11_SET_DL_DST	.\include\openflow\openflow-1.1.h	/^    OFPAT11_SET_DL_DST,       \/* Ethernet destination address. *\/$/;"	e	enum:ofp11_action_type
OFPAT11_SET_DL_SRC	.\include\openflow\openflow-1.1.h	/^    OFPAT11_SET_DL_SRC,       \/* Ethernet source address. *\/$/;"	e	enum:ofp11_action_type
OFPAT11_SET_MPLS_LABEL	.\include\openflow\openflow-1.1.h	/^    OFPAT11_SET_MPLS_LABEL,   \/* MPLS label *\/$/;"	e	enum:ofp11_action_type
OFPAT11_SET_MPLS_TC	.\include\openflow\openflow-1.1.h	/^    OFPAT11_SET_MPLS_TC,      \/* MPLS TC *\/$/;"	e	enum:ofp11_action_type
OFPAT11_SET_MPLS_TTL	.\include\openflow\openflow-1.1.h	/^    OFPAT11_SET_MPLS_TTL,     \/* MPLS TTL *\/$/;"	e	enum:ofp11_action_type
OFPAT11_SET_NW_DST	.\include\openflow\openflow-1.1.h	/^    OFPAT11_SET_NW_DST,       \/* IP destination address. *\/$/;"	e	enum:ofp11_action_type
OFPAT11_SET_NW_ECN	.\include\openflow\openflow-1.1.h	/^    OFPAT11_SET_NW_ECN,       \/* IP ECN (2 bits). *\/$/;"	e	enum:ofp11_action_type
OFPAT11_SET_NW_SRC	.\include\openflow\openflow-1.1.h	/^    OFPAT11_SET_NW_SRC,       \/* IP source address. *\/$/;"	e	enum:ofp11_action_type
OFPAT11_SET_NW_TOS	.\include\openflow\openflow-1.1.h	/^    OFPAT11_SET_NW_TOS,       \/* IP ToS (DSCP field, 6 bits). *\/$/;"	e	enum:ofp11_action_type
OFPAT11_SET_NW_TTL	.\include\openflow\openflow-1.1.h	/^    OFPAT11_SET_NW_TTL,       \/* IP TTL. *\/$/;"	e	enum:ofp11_action_type
OFPAT11_SET_QUEUE	.\include\openflow\openflow-1.1.h	/^    OFPAT11_SET_QUEUE,        \/* Set queue id when outputting to a port *\/$/;"	e	enum:ofp11_action_type
OFPAT11_SET_TP_DST	.\include\openflow\openflow-1.1.h	/^    OFPAT11_SET_TP_DST,       \/* TCP\/UDP\/SCTP destination port. *\/$/;"	e	enum:ofp11_action_type
OFPAT11_SET_TP_SRC	.\include\openflow\openflow-1.1.h	/^    OFPAT11_SET_TP_SRC,       \/* TCP\/UDP\/SCTP source port. *\/$/;"	e	enum:ofp11_action_type
OFPAT11_SET_VLAN_PCP	.\include\openflow\openflow-1.1.h	/^    OFPAT11_SET_VLAN_PCP,     \/* Set the 802.1q priority. *\/$/;"	e	enum:ofp11_action_type
OFPAT11_SET_VLAN_VID	.\include\openflow\openflow-1.1.h	/^    OFPAT11_SET_VLAN_VID,     \/* Set the 802.1q VLAN id. *\/$/;"	e	enum:ofp11_action_type
OFPAT12_SET_FIELD	.\include\openflow\openflow-1.2.h	/^    OFPAT12_SET_FIELD = 25,     \/* Set a header field using OXM TLV format. *\/$/;"	e	enum:ofp12_action_type
OFPAT13_ACTION	.\lib\ofp-actions.c	1147;"	d	file:
OFPAT13_ACTION	.\lib\ofp-actions.c	380;"	d	file:
OFPAT13_ACTION	.\lib\ofp-actions.c	527;"	d	file:
OFPAT13_ACTION	.\lib\ofp-print.c	2553;"	d	file:
OFPAT13_ACTION	.\lib\ofp-util.c	5851;"	d	file:
OFPAT13_ACTION	.\lib\ofp-util.c	5886;"	d	file:
OFPAT13_ACTION	.\lib\ofp-util.c	5906;"	d	file:
OFPAT13_ACTION	.\lib\ofp-util.c	5939;"	d	file:
OFPAT13_ACTION	.\lib\ofp-util.h	942;"	d
OFPAT13_ACTION	.\lib\ofp-util.h	951;"	d
OFPAT13_ACTION	.\lib\ofp-util.h	984;"	d
OFPAT13_COPY_TTL_IN	.\include\openflow\openflow-1.3.h	/^    OFPAT13_COPY_TTL_IN  = 12,  \/* Copy TTL "inwards" -- from outermost to$/;"	e	enum:ofp13_action_type
OFPAT13_COPY_TTL_OUT	.\include\openflow\openflow-1.3.h	/^    OFPAT13_COPY_TTL_OUT = 11,  \/* Copy TTL "outwards" -- from next-to-outermost$/;"	e	enum:ofp13_action_type
OFPAT13_DEC_MPLS_TTL	.\include\openflow\openflow-1.3.h	/^    OFPAT13_DEC_MPLS_TTL = 16,  \/* Decrement MPLS TTL *\/$/;"	e	enum:ofp13_action_type
OFPAT13_DEC_NW_TTL	.\include\openflow\openflow-1.3.h	/^    OFPAT13_DEC_NW_TTL   = 24,  \/* Decrement IP TTL. *\/$/;"	e	enum:ofp13_action_type
OFPAT13_GROUP	.\include\openflow\openflow-1.3.h	/^    OFPAT13_GROUP        = 22,  \/* Apply group. *\/$/;"	e	enum:ofp13_action_type
OFPAT13_OUTPUT	.\include\openflow\openflow-1.3.h	/^    OFPAT13_OUTPUT       = 0,   \/* Output to switch port. *\/$/;"	e	enum:ofp13_action_type
OFPAT13_POP_MPLS	.\include\openflow\openflow-1.3.h	/^    OFPAT13_POP_MPLS     = 20,  \/* Pop the outer MPLS Label Stack Entry *\/$/;"	e	enum:ofp13_action_type
OFPAT13_POP_PBB	.\include\openflow\openflow-1.3.h	/^    OFPAT13_POP_PBB      = 27,   \/* Pop the outer PBB service tag (I-TAG) *\/$/;"	e	enum:ofp13_action_type
OFPAT13_POP_VLAN	.\include\openflow\openflow-1.3.h	/^    OFPAT13_POP_VLAN     = 18,  \/* Pop the outer VLAN tag *\/$/;"	e	enum:ofp13_action_type
OFPAT13_PUSH_MPLS	.\include\openflow\openflow-1.3.h	/^    OFPAT13_PUSH_MPLS    = 19,  \/* Push a new MPLS Label Stack Entry *\/$/;"	e	enum:ofp13_action_type
OFPAT13_PUSH_PBB	.\include\openflow\openflow-1.3.h	/^    OFPAT13_PUSH_PBB     = 26,  \/* Push a new PBB service tag (I-TAG) *\/$/;"	e	enum:ofp13_action_type
OFPAT13_PUSH_VLAN	.\include\openflow\openflow-1.3.h	/^    OFPAT13_PUSH_VLAN    = 17,  \/* Push a new VLAN tag *\/$/;"	e	enum:ofp13_action_type
OFPAT13_SELF_LEARNING	.\include\openflow\openflow-1.3.h	/^    OFPAT13_SELF_LEARNING = 28    \/*self learning mac. *\/ $/;"	e	enum:ofp13_action_type
OFPAT13_SET_FIELD	.\include\openflow\openflow-1.3.h	/^    OFPAT13_SET_FIELD    = 25,  \/* Set a header field using OXM TLV format. *\/$/;"	e	enum:ofp13_action_type
OFPAT13_SET_MPLS_TTL	.\include\openflow\openflow-1.3.h	/^    OFPAT13_SET_MPLS_TTL = 15,  \/* MPLS TTL *\/$/;"	e	enum:ofp13_action_type
OFPAT13_SET_NW_TTL	.\include\openflow\openflow-1.3.h	/^    OFPAT13_SET_NW_TTL   = 23,  \/* IP TTL. *\/$/;"	e	enum:ofp13_action_type
OFPAT13_SET_QUEUE	.\include\openflow\openflow-1.3.h	/^    OFPAT13_SET_QUEUE    = 21,  \/* Set queue id when outputting to a port *\/$/;"	e	enum:ofp13_action_type
OFPBCT_CLOSE_REPLY	.\include\openflow\openflow-1.4.h	/^    OFPBCT_CLOSE_REPLY     = 3,$/;"	e	enum:ofp14_bundle_ctrl_type
OFPBCT_CLOSE_REQUEST	.\include\openflow\openflow-1.4.h	/^    OFPBCT_CLOSE_REQUEST   = 2,$/;"	e	enum:ofp14_bundle_ctrl_type
OFPBCT_COMMIT_REPLY	.\include\openflow\openflow-1.4.h	/^    OFPBCT_COMMIT_REPLY    = 5,$/;"	e	enum:ofp14_bundle_ctrl_type
OFPBCT_COMMIT_REQUEST	.\include\openflow\openflow-1.4.h	/^    OFPBCT_COMMIT_REQUEST  = 4,$/;"	e	enum:ofp14_bundle_ctrl_type
OFPBCT_DISCARD_REPLY	.\include\openflow\openflow-1.4.h	/^    OFPBCT_DISCARD_REPLY   = 7,$/;"	e	enum:ofp14_bundle_ctrl_type
OFPBCT_DISCARD_REQUEST	.\include\openflow\openflow-1.4.h	/^    OFPBCT_DISCARD_REQUEST = 6,$/;"	e	enum:ofp14_bundle_ctrl_type
OFPBCT_OPEN_REPLY	.\include\openflow\openflow-1.4.h	/^    OFPBCT_OPEN_REPLY      = 1,$/;"	e	enum:ofp14_bundle_ctrl_type
OFPBCT_OPEN_REQUEST	.\include\openflow\openflow-1.4.h	/^    OFPBCT_OPEN_REQUEST    = 0,$/;"	e	enum:ofp14_bundle_ctrl_type
OFPBF_ATOMIC	.\include\openflow\openflow-1.4.h	/^    OFPBF_ATOMIC  = 1 << 0,  \/* Execute atomically. *\/$/;"	e	enum:ofp14_bundle_flags
OFPBF_ORDERED	.\include\openflow\openflow-1.4.h	/^    OFPBF_ORDERED = 1 << 1,  \/* Execute in specified order. *\/$/;"	e	enum:ofp14_bundle_flags
OFPBUF_DPDK	.\lib\ofpbuf.h	/^    OFPBUF_DPDK,                \/* buffer data is from DPDK allocated memory.$/;"	e	enum:ofpbuf_source
OFPBUF_H	.\lib\ofpbuf.h	18;"	d
OFPBUF_MALLOC	.\lib\ofpbuf.h	/^    OFPBUF_MALLOC,              \/* Obtained via malloc(). *\/$/;"	e	enum:ofpbuf_source
OFPBUF_STACK	.\lib\ofpbuf.h	/^    OFPBUF_STACK,               \/* Un-movable stack space or static buffer. *\/$/;"	e	enum:ofpbuf_source
OFPBUF_STUB	.\lib\ofpbuf.h	/^    OFPBUF_STUB,                \/* Starts on stack, may expand into heap. *\/$/;"	e	enum:ofpbuf_source
OFPC10_RESERVED	.\include\openflow\openflow-1.0.h	/^    OFPC10_RESERVED       = 1 << 4,  \/* Reserved, must not be set. *\/$/;"	e	enum:ofp10_capabilities
OFPC10_STP	.\include\openflow\openflow-1.0.h	/^    OFPC10_STP            = 1 << 3,  \/* 802.1d spanning tree. *\/$/;"	e	enum:ofp10_capabilities
OFPC11_GROUP_STATS	.\include\openflow\openflow-1.1.h	/^    OFPC11_GROUP_STATS    = 1 << 3,  \/* Group statistics. *\/$/;"	e	enum:ofp11_capabilities
OFPC12_PORT_BLOCKED	.\include\openflow\openflow-1.2.h	/^    OFPC12_PORT_BLOCKED   = 1 << 8   \/* Switch will block looping ports. *\/$/;"	e	enum:ofp12_capabilities
OFPCML12_MAX	.\include\openflow\openflow-1.2.h	/^    OFPCML12_MAX       = 0xffe5, \/* maximum max_len value which can be used$/;"	e	enum:ofp12_controller_max_len
OFPCML12_NO_BUFFER	.\include\openflow\openflow-1.2.h	/^    OFPCML12_NO_BUFFER = 0xffff  \/* indicates that no buffering should be$/;"	e	enum:ofp12_controller_max_len
OFPCR12_ROLE_EQUAL	.\include\openflow\openflow-1.2.h	/^    OFPCR12_ROLE_EQUAL,       \/* Default role, full access. *\/$/;"	e	enum:ofp12_controller_role
OFPCR12_ROLE_MASTER	.\include\openflow\openflow-1.2.h	/^    OFPCR12_ROLE_MASTER,      \/* Full access, at most one master. *\/$/;"	e	enum:ofp12_controller_role
OFPCR12_ROLE_NOCHANGE	.\include\openflow\openflow-1.2.h	/^    OFPCR12_ROLE_NOCHANGE,    \/* Don't change current role. *\/$/;"	e	enum:ofp12_controller_role
OFPCR12_ROLE_SLAVE	.\include\openflow\openflow-1.2.h	/^    OFPCR12_ROLE_SLAVE,       \/* Read-only access. *\/$/;"	e	enum:ofp12_controller_role
OFPCRR_CONFIG	.\include\openflow\openflow-1.4.h	/^    OFPCRR_CONFIG         = 1,  \/* Configuration changed on the switch. *\/$/;"	e	enum:ofp14_controller_role_reason
OFPCRR_EXPERIMENTER	.\include\openflow\openflow-1.4.h	/^    OFPCRR_EXPERIMENTER   = 2,  \/* Experimenter data changed. *\/$/;"	e	enum:ofp14_controller_role_reason
OFPCRR_MASTER_REQUEST	.\include\openflow\openflow-1.4.h	/^    OFPCRR_MASTER_REQUEST = 0,  \/* Another controller asked to be master. *\/$/;"	e	enum:ofp14_controller_role_reason
OFPC_ARP_MATCH_IP	.\include\openflow\openflow-common.h	/^    OFPC_ARP_MATCH_IP   = 1 << 7   \/* Match IP addresses in ARP$/;"	e	enum:ofp_capabilities
OFPC_COMMON	.\lib\ofp-util.c	3998;"	d	file:
OFPC_FLOW_STATS	.\include\openflow\openflow-common.h	/^    OFPC_FLOW_STATS     = 1 << 0,  \/* Flow statistics. *\/$/;"	e	enum:ofp_capabilities
OFPC_FRAG_DROP	.\include\openflow\openflow-common.h	/^    OFPC_FRAG_DROP     = 1,  \/* Drop fragments. *\/$/;"	e	enum:ofp_config_flags
OFPC_FRAG_MASK	.\include\openflow\openflow-common.h	/^    OFPC_FRAG_MASK     = 3,$/;"	e	enum:ofp_config_flags
OFPC_FRAG_NORMAL	.\include\openflow\openflow-common.h	/^    OFPC_FRAG_NORMAL   = 0,  \/* No special handling for fragments. *\/$/;"	e	enum:ofp_config_flags
OFPC_FRAG_NX_MATCH	.\include\openflow\openflow-common.h	/^    OFPC_FRAG_NX_MATCH = 3,  \/* Make first fragments available for matching. *\/$/;"	e	enum:ofp_config_flags
OFPC_FRAG_REASM	.\include\openflow\openflow-common.h	/^    OFPC_FRAG_REASM    = 2,  \/* Reassemble (only if OFPC_IP_REASM set). *\/$/;"	e	enum:ofp_config_flags
OFPC_INVALID_TTL_TO_CONTROLLER	.\include\openflow\openflow-common.h	/^    OFPC_INVALID_TTL_TO_CONTROLLER = 1 << 2, \/* Send packets with invalid TTL$/;"	e	enum:ofp_config_flags
OFPC_IP_REASM	.\include\openflow\openflow-common.h	/^    OFPC_IP_REASM       = 1 << 5,  \/* Can reassemble IP fragments. *\/$/;"	e	enum:ofp_capabilities
OFPC_PORT_STATS	.\include\openflow\openflow-common.h	/^    OFPC_PORT_STATS     = 1 << 2,  \/* Port statistics. *\/$/;"	e	enum:ofp_capabilities
OFPC_QUEUE_STATS	.\include\openflow\openflow-common.h	/^    OFPC_QUEUE_STATS    = 1 << 6,  \/* Queue statistics. *\/$/;"	e	enum:ofp_capabilities
OFPC_TABLE_STATS	.\include\openflow\openflow-common.h	/^    OFPC_TABLE_STATS    = 1 << 1,  \/* Table statistics. *\/$/;"	e	enum:ofp_capabilities
OFPERR_NXBAC_MUST_BE_ZERO	.\lib\ofp-errors.h	/^    OFPERR_NXBAC_MUST_BE_ZERO,$/;"	e	enum:ofperr
OFPERR_NXBRC_BAD_REASON	.\lib\ofp-errors.h	/^    OFPERR_NXBRC_BAD_REASON,$/;"	e	enum:ofperr
OFPERR_NXBRC_FM_BAD_EVENT	.\lib\ofp-errors.h	/^    OFPERR_NXBRC_FM_BAD_EVENT,$/;"	e	enum:ofperr
OFPERR_NXBRC_FM_BAD_FLAGS	.\lib\ofp-errors.h	/^    OFPERR_NXBRC_FM_BAD_FLAGS,$/;"	e	enum:ofperr
OFPERR_NXBRC_FM_BAD_ID	.\lib\ofp-errors.h	/^    OFPERR_NXBRC_FM_BAD_ID,$/;"	e	enum:ofperr
OFPERR_NXBRC_FM_DUPLICATE_ID	.\lib\ofp-errors.h	/^    OFPERR_NXBRC_FM_DUPLICATE_ID,$/;"	e	enum:ofperr
OFPERR_NXBRC_MUST_BE_ZERO	.\lib\ofp-errors.h	/^    OFPERR_NXBRC_MUST_BE_ZERO,$/;"	e	enum:ofperr
OFPERR_NXBRC_NXM_BAD_TYPE	.\lib\ofp-errors.h	/^    OFPERR_NXBRC_NXM_BAD_TYPE,$/;"	e	enum:ofperr
OFPERR_NXBRC_NXM_INVALID	.\lib\ofp-errors.h	/^    OFPERR_NXBRC_NXM_INVALID,$/;"	e	enum:ofperr
OFPERR_NXBRC_UNENCODABLE_ERROR	.\lib\ofp-errors.h	/^    OFPERR_NXBRC_UNENCODABLE_ERROR,$/;"	e	enum:ofperr
OFPERR_NXFMFC_BAD_TABLE_ID	.\lib\ofp-errors.h	/^    OFPERR_NXFMFC_BAD_TABLE_ID,$/;"	e	enum:ofperr
OFPERR_NXFMFC_HARDWARE	.\lib\ofp-errors.h	/^    OFPERR_NXFMFC_HARDWARE,$/;"	e	enum:ofperr
OFPERR_OFPBAC_BAD_ARGUMENT	.\lib\ofp-errors.h	/^    OFPERR_OFPBAC_BAD_ARGUMENT,$/;"	e	enum:ofperr
OFPERR_OFPBAC_BAD_LEN	.\lib\ofp-errors.h	/^    OFPERR_OFPBAC_BAD_LEN,$/;"	e	enum:ofperr
OFPERR_OFPBAC_BAD_OUT_GROUP	.\lib\ofp-errors.h	/^    OFPERR_OFPBAC_BAD_OUT_GROUP,$/;"	e	enum:ofperr
OFPERR_OFPBAC_BAD_OUT_PORT	.\lib\ofp-errors.h	/^    OFPERR_OFPBAC_BAD_OUT_PORT,$/;"	e	enum:ofperr
OFPERR_OFPBAC_BAD_QUEUE	.\lib\ofp-errors.h	/^    OFPERR_OFPBAC_BAD_QUEUE,$/;"	e	enum:ofperr
OFPERR_OFPBAC_BAD_SET_ARGUMENT	.\lib\ofp-errors.h	/^    OFPERR_OFPBAC_BAD_SET_ARGUMENT,$/;"	e	enum:ofperr
OFPERR_OFPBAC_BAD_SET_LEN	.\lib\ofp-errors.h	/^    OFPERR_OFPBAC_BAD_SET_LEN,$/;"	e	enum:ofperr
OFPERR_OFPBAC_BAD_SET_TYPE	.\lib\ofp-errors.h	/^    OFPERR_OFPBAC_BAD_SET_TYPE,$/;"	e	enum:ofperr
OFPERR_OFPBAC_BAD_TAG	.\lib\ofp-errors.h	/^    OFPERR_OFPBAC_BAD_TAG,$/;"	e	enum:ofperr
OFPERR_OFPBAC_BAD_TYPE	.\lib\ofp-errors.h	/^    OFPERR_OFPBAC_BAD_TYPE,$/;"	e	enum:ofperr
OFPERR_OFPBAC_BAD_VENDOR	.\lib\ofp-errors.h	/^    OFPERR_OFPBAC_BAD_VENDOR,$/;"	e	enum:ofperr
OFPERR_OFPBAC_BAD_VENDOR_TYPE	.\lib\ofp-errors.h	/^    OFPERR_OFPBAC_BAD_VENDOR_TYPE,$/;"	e	enum:ofperr
OFPERR_OFPBAC_EPERM	.\lib\ofp-errors.h	/^    OFPERR_OFPBAC_EPERM,$/;"	e	enum:ofperr
OFPERR_OFPBAC_MATCH_INCONSISTENT	.\lib\ofp-errors.h	/^    OFPERR_OFPBAC_MATCH_INCONSISTENT,$/;"	e	enum:ofperr
OFPERR_OFPBAC_TOO_MANY	.\lib\ofp-errors.h	/^    OFPERR_OFPBAC_TOO_MANY,$/;"	e	enum:ofperr
OFPERR_OFPBAC_UNSUPPORTED_ORDER	.\lib\ofp-errors.h	/^    OFPERR_OFPBAC_UNSUPPORTED_ORDER,$/;"	e	enum:ofperr
OFPERR_OFPBFC_BAD_FLAGS	.\lib\ofp-errors.h	/^    OFPERR_OFPBFC_BAD_FLAGS,$/;"	e	enum:ofperr
OFPERR_OFPBFC_BAD_ID	.\lib\ofp-errors.h	/^    OFPERR_OFPBFC_BAD_ID,$/;"	e	enum:ofperr
OFPERR_OFPBFC_BAD_TYPE	.\lib\ofp-errors.h	/^    OFPERR_OFPBFC_BAD_TYPE,$/;"	e	enum:ofperr
OFPERR_OFPBFC_BUNDLE_CLOSED	.\lib\ofp-errors.h	/^    OFPERR_OFPBFC_BUNDLE_CLOSED,$/;"	e	enum:ofperr
OFPERR_OFPBFC_BUNDLE_EXIST	.\lib\ofp-errors.h	/^    OFPERR_OFPBFC_BUNDLE_EXIST,$/;"	e	enum:ofperr
OFPERR_OFPBFC_BUNDLE_IN_PROGRESS	.\lib\ofp-errors.h	/^    OFPERR_OFPBFC_BUNDLE_IN_PROGRESS,$/;"	e	enum:ofperr
OFPERR_OFPBFC_EPERM	.\lib\ofp-errors.h	/^    OFPERR_OFPBFC_EPERM,$/;"	e	enum:ofperr
OFPERR_OFPBFC_MSG_BAD_LEN	.\lib\ofp-errors.h	/^    OFPERR_OFPBFC_MSG_BAD_LEN,$/;"	e	enum:ofperr
OFPERR_OFPBFC_MSG_BAD_XID	.\lib\ofp-errors.h	/^    OFPERR_OFPBFC_MSG_BAD_XID,$/;"	e	enum:ofperr
OFPERR_OFPBFC_MSG_CONFLICT	.\lib\ofp-errors.h	/^    OFPERR_OFPBFC_MSG_CONFLICT,$/;"	e	enum:ofperr
OFPERR_OFPBFC_MSG_FAILED	.\lib\ofp-errors.h	/^    OFPERR_OFPBFC_MSG_FAILED,$/;"	e	enum:ofperr
OFPERR_OFPBFC_MSG_TOO_MANY	.\lib\ofp-errors.h	/^    OFPERR_OFPBFC_MSG_TOO_MANY,$/;"	e	enum:ofperr
OFPERR_OFPBFC_MSG_UNSUP	.\lib\ofp-errors.h	/^    OFPERR_OFPBFC_MSG_UNSUP,$/;"	e	enum:ofperr
OFPERR_OFPBFC_OUT_OF_BUNDLES	.\lib\ofp-errors.h	/^    OFPERR_OFPBFC_OUT_OF_BUNDLES,$/;"	e	enum:ofperr
OFPERR_OFPBFC_TIMEOUT	.\lib\ofp-errors.h	/^    OFPERR_OFPBFC_TIMEOUT,$/;"	e	enum:ofperr
OFPERR_OFPBFC_UNKNOWN	.\lib\ofp-errors.h	/^    OFPERR_OFPBFC_UNKNOWN,$/;"	e	enum:ofperr
OFPERR_OFPBIC_BAD_EXPERIMENTER	.\lib\ofp-errors.h	/^    OFPERR_OFPBIC_BAD_EXPERIMENTER,$/;"	e	enum:ofperr
OFPERR_OFPBIC_BAD_EXP_TYPE	.\lib\ofp-errors.h	/^    OFPERR_OFPBIC_BAD_EXP_TYPE,$/;"	e	enum:ofperr
OFPERR_OFPBIC_BAD_LEN	.\lib\ofp-errors.h	/^    OFPERR_OFPBIC_BAD_LEN,$/;"	e	enum:ofperr
OFPERR_OFPBIC_BAD_TABLE_ID	.\lib\ofp-errors.h	/^    OFPERR_OFPBIC_BAD_TABLE_ID,$/;"	e	enum:ofperr
OFPERR_OFPBIC_EPERM	.\lib\ofp-errors.h	/^    OFPERR_OFPBIC_EPERM,$/;"	e	enum:ofperr
OFPERR_OFPBIC_UNKNOWN_INST	.\lib\ofp-errors.h	/^    OFPERR_OFPBIC_UNKNOWN_INST,$/;"	e	enum:ofperr
OFPERR_OFPBIC_UNSUP_INST	.\lib\ofp-errors.h	/^    OFPERR_OFPBIC_UNSUP_INST,$/;"	e	enum:ofperr
OFPERR_OFPBIC_UNSUP_METADATA	.\lib\ofp-errors.h	/^    OFPERR_OFPBIC_UNSUP_METADATA,$/;"	e	enum:ofperr
OFPERR_OFPBIC_UNSUP_METADATA_MASK	.\lib\ofp-errors.h	/^    OFPERR_OFPBIC_UNSUP_METADATA_MASK,$/;"	e	enum:ofperr
OFPERR_OFPBMC_BAD_DL_ADDR_MASK	.\lib\ofp-errors.h	/^    OFPERR_OFPBMC_BAD_DL_ADDR_MASK,$/;"	e	enum:ofperr
OFPERR_OFPBMC_BAD_FIELD	.\lib\ofp-errors.h	/^    OFPERR_OFPBMC_BAD_FIELD,$/;"	e	enum:ofperr
OFPERR_OFPBMC_BAD_LEN	.\lib\ofp-errors.h	/^    OFPERR_OFPBMC_BAD_LEN,$/;"	e	enum:ofperr
OFPERR_OFPBMC_BAD_MASK	.\lib\ofp-errors.h	/^    OFPERR_OFPBMC_BAD_MASK,$/;"	e	enum:ofperr
OFPERR_OFPBMC_BAD_NW_ADDR_MASK	.\lib\ofp-errors.h	/^    OFPERR_OFPBMC_BAD_NW_ADDR_MASK,$/;"	e	enum:ofperr
OFPERR_OFPBMC_BAD_PREREQ	.\lib\ofp-errors.h	/^    OFPERR_OFPBMC_BAD_PREREQ,$/;"	e	enum:ofperr
OFPERR_OFPBMC_BAD_TAG	.\lib\ofp-errors.h	/^    OFPERR_OFPBMC_BAD_TAG,$/;"	e	enum:ofperr
OFPERR_OFPBMC_BAD_TYPE	.\lib\ofp-errors.h	/^    OFPERR_OFPBMC_BAD_TYPE,$/;"	e	enum:ofperr
OFPERR_OFPBMC_BAD_VALUE	.\lib\ofp-errors.h	/^    OFPERR_OFPBMC_BAD_VALUE,$/;"	e	enum:ofperr
OFPERR_OFPBMC_BAD_WILDCARDS	.\lib\ofp-errors.h	/^    OFPERR_OFPBMC_BAD_WILDCARDS,$/;"	e	enum:ofperr
OFPERR_OFPBMC_DUP_FIELD	.\lib\ofp-errors.h	/^    OFPERR_OFPBMC_DUP_FIELD,$/;"	e	enum:ofperr
OFPERR_OFPBMC_EPERM	.\lib\ofp-errors.h	/^    OFPERR_OFPBMC_EPERM,$/;"	e	enum:ofperr
OFPERR_OFPBPC_BAD_EXPERIMENTER	.\lib\ofp-errors.h	/^    OFPERR_OFPBPC_BAD_EXPERIMENTER,$/;"	e	enum:ofperr
OFPERR_OFPBPC_BAD_EXP_TYPE	.\lib\ofp-errors.h	/^    OFPERR_OFPBPC_BAD_EXP_TYPE,$/;"	e	enum:ofperr
OFPERR_OFPBPC_BAD_EXP_VALUE	.\lib\ofp-errors.h	/^    OFPERR_OFPBPC_BAD_EXP_VALUE,$/;"	e	enum:ofperr
OFPERR_OFPBPC_BAD_LEN	.\lib\ofp-errors.h	/^    OFPERR_OFPBPC_BAD_LEN,$/;"	e	enum:ofperr
OFPERR_OFPBPC_BAD_TYPE	.\lib\ofp-errors.h	/^    OFPERR_OFPBPC_BAD_TYPE,$/;"	e	enum:ofperr
OFPERR_OFPBPC_BAD_VALUE	.\lib\ofp-errors.h	/^    OFPERR_OFPBPC_BAD_VALUE,$/;"	e	enum:ofperr
OFPERR_OFPBPC_DUP_TYPE	.\lib\ofp-errors.h	/^    OFPERR_OFPBPC_DUP_TYPE,$/;"	e	enum:ofperr
OFPERR_OFPBPC_EPERM	.\lib\ofp-errors.h	/^    OFPERR_OFPBPC_EPERM,$/;"	e	enum:ofperr
OFPERR_OFPBPC_TOO_MANY	.\lib\ofp-errors.h	/^    OFPERR_OFPBPC_TOO_MANY,$/;"	e	enum:ofperr
OFPERR_OFPBRC_BAD_LEN	.\lib\ofp-errors.h	/^    OFPERR_OFPBRC_BAD_LEN,$/;"	e	enum:ofperr
OFPERR_OFPBRC_BAD_PACKET	.\lib\ofp-errors.h	/^    OFPERR_OFPBRC_BAD_PACKET,$/;"	e	enum:ofperr
OFPERR_OFPBRC_BAD_PORT	.\lib\ofp-errors.h	/^    OFPERR_OFPBRC_BAD_PORT,$/;"	e	enum:ofperr
OFPERR_OFPBRC_BAD_STAT	.\lib\ofp-errors.h	/^    OFPERR_OFPBRC_BAD_STAT,$/;"	e	enum:ofperr
OFPERR_OFPBRC_BAD_SUBTYPE	.\lib\ofp-errors.h	/^    OFPERR_OFPBRC_BAD_SUBTYPE,$/;"	e	enum:ofperr
OFPERR_OFPBRC_BAD_TABLE_ID	.\lib\ofp-errors.h	/^    OFPERR_OFPBRC_BAD_TABLE_ID,$/;"	e	enum:ofperr
OFPERR_OFPBRC_BAD_TYPE	.\lib\ofp-errors.h	/^    OFPERR_OFPBRC_BAD_TYPE,$/;"	e	enum:ofperr
OFPERR_OFPBRC_BAD_VENDOR	.\lib\ofp-errors.h	/^    OFPERR_OFPBRC_BAD_VENDOR,$/;"	e	enum:ofperr
OFPERR_OFPBRC_BAD_VERSION	.\lib\ofp-errors.h	/^    OFPERR_OFPBRC_BAD_VERSION,$/;"	e	enum:ofperr
OFPERR_OFPBRC_BUFFER_EMPTY	.\lib\ofp-errors.h	/^    OFPERR_OFPBRC_BUFFER_EMPTY,$/;"	e	enum:ofperr
OFPERR_OFPBRC_BUFFER_UNKNOWN	.\lib\ofp-errors.h	/^    OFPERR_OFPBRC_BUFFER_UNKNOWN,$/;"	e	enum:ofperr
OFPERR_OFPBRC_EPERM	.\lib\ofp-errors.h	/^    OFPERR_OFPBRC_EPERM,$/;"	e	enum:ofperr
OFPERR_OFPBRC_IS_SLAVE	.\lib\ofp-errors.h	/^    OFPERR_OFPBRC_IS_SLAVE,$/;"	e	enum:ofperr
OFPERR_OFPBRC_MULTIPART_BUFFER_OVERFLOW	.\lib\ofp-errors.h	/^    OFPERR_OFPBRC_MULTIPART_BUFFER_OVERFLOW,$/;"	e	enum:ofperr
OFPERR_OFPFMFC_BAD_COMMAND	.\lib\ofp-errors.h	/^    OFPERR_OFPFMFC_BAD_COMMAND,$/;"	e	enum:ofperr
OFPERR_OFPFMFC_BAD_EMERG_TIMEOUT	.\lib\ofp-errors.h	/^    OFPERR_OFPFMFC_BAD_EMERG_TIMEOUT,$/;"	e	enum:ofperr
OFPERR_OFPFMFC_BAD_FLAGS	.\lib\ofp-errors.h	/^    OFPERR_OFPFMFC_BAD_FLAGS,$/;"	e	enum:ofperr
OFPERR_OFPFMFC_BAD_TABLE_ID	.\lib\ofp-errors.h	/^    OFPERR_OFPFMFC_BAD_TABLE_ID,$/;"	e	enum:ofperr
OFPERR_OFPFMFC_BAD_TIMEOUT	.\lib\ofp-errors.h	/^    OFPERR_OFPFMFC_BAD_TIMEOUT,$/;"	e	enum:ofperr
OFPERR_OFPFMFC_EPERM	.\lib\ofp-errors.h	/^    OFPERR_OFPFMFC_EPERM,$/;"	e	enum:ofperr
OFPERR_OFPFMFC_OVERLAP	.\lib\ofp-errors.h	/^    OFPERR_OFPFMFC_OVERLAP,$/;"	e	enum:ofperr
OFPERR_OFPFMFC_TABLE_FULL	.\lib\ofp-errors.h	/^    OFPERR_OFPFMFC_TABLE_FULL,$/;"	e	enum:ofperr
OFPERR_OFPFMFC_UNKNOWN	.\lib\ofp-errors.h	/^    OFPERR_OFPFMFC_UNKNOWN,$/;"	e	enum:ofperr
OFPERR_OFPFMFC_UNSUPPORTED	.\lib\ofp-errors.h	/^    OFPERR_OFPFMFC_UNSUPPORTED,$/;"	e	enum:ofperr
OFPERR_OFPGMFC_BAD_BUCKET	.\lib\ofp-errors.h	/^    OFPERR_OFPGMFC_BAD_BUCKET,$/;"	e	enum:ofperr
OFPERR_OFPGMFC_BAD_COMMAND	.\lib\ofp-errors.h	/^    OFPERR_OFPGMFC_BAD_COMMAND,$/;"	e	enum:ofperr
OFPERR_OFPGMFC_BAD_TYPE	.\lib\ofp-errors.h	/^    OFPERR_OFPGMFC_BAD_TYPE,$/;"	e	enum:ofperr
OFPERR_OFPGMFC_BAD_WATCH	.\lib\ofp-errors.h	/^    OFPERR_OFPGMFC_BAD_WATCH,$/;"	e	enum:ofperr
OFPERR_OFPGMFC_CHAINED_GROUP	.\lib\ofp-errors.h	/^    OFPERR_OFPGMFC_CHAINED_GROUP,$/;"	e	enum:ofperr
OFPERR_OFPGMFC_CHAINING_UNSUPPORTED	.\lib\ofp-errors.h	/^    OFPERR_OFPGMFC_CHAINING_UNSUPPORTED,$/;"	e	enum:ofperr
OFPERR_OFPGMFC_EPERM	.\lib\ofp-errors.h	/^    OFPERR_OFPGMFC_EPERM,$/;"	e	enum:ofperr
OFPERR_OFPGMFC_GROUP_EXISTS	.\lib\ofp-errors.h	/^    OFPERR_OFPGMFC_GROUP_EXISTS,$/;"	e	enum:ofperr
OFPERR_OFPGMFC_INVALID_GROUP	.\lib\ofp-errors.h	/^    OFPERR_OFPGMFC_INVALID_GROUP,$/;"	e	enum:ofperr
OFPERR_OFPGMFC_LOOP	.\lib\ofp-errors.h	/^    OFPERR_OFPGMFC_LOOP,$/;"	e	enum:ofperr
OFPERR_OFPGMFC_OUT_OF_BUCKETS	.\lib\ofp-errors.h	/^    OFPERR_OFPGMFC_OUT_OF_BUCKETS,$/;"	e	enum:ofperr
OFPERR_OFPGMFC_OUT_OF_GROUPS	.\lib\ofp-errors.h	/^    OFPERR_OFPGMFC_OUT_OF_GROUPS,$/;"	e	enum:ofperr
OFPERR_OFPGMFC_UNKNOWN_GROUP	.\lib\ofp-errors.h	/^    OFPERR_OFPGMFC_UNKNOWN_GROUP,$/;"	e	enum:ofperr
OFPERR_OFPGMFC_WATCH_UNSUPPORTED	.\lib\ofp-errors.h	/^    OFPERR_OFPGMFC_WATCH_UNSUPPORTED,$/;"	e	enum:ofperr
OFPERR_OFPGMFC_WEIGHT_UNSUPPORTED	.\lib\ofp-errors.h	/^    OFPERR_OFPGMFC_WEIGHT_UNSUPPORTED,$/;"	e	enum:ofperr
OFPERR_OFPHFC_EPERM	.\lib\ofp-errors.h	/^    OFPERR_OFPHFC_EPERM,$/;"	e	enum:ofperr
OFPERR_OFPHFC_INCOMPATIBLE	.\lib\ofp-errors.h	/^    OFPERR_OFPHFC_INCOMPATIBLE = OFPERR_OFS,$/;"	e	enum:ofperr
OFPERR_OFPMMFC_BAD_BAND	.\lib\ofp-errors.h	/^    OFPERR_OFPMMFC_BAD_BAND,$/;"	e	enum:ofperr
OFPERR_OFPMMFC_BAD_BAND_VALUE	.\lib\ofp-errors.h	/^    OFPERR_OFPMMFC_BAD_BAND_VALUE,$/;"	e	enum:ofperr
OFPERR_OFPMMFC_BAD_BURST	.\lib\ofp-errors.h	/^    OFPERR_OFPMMFC_BAD_BURST,$/;"	e	enum:ofperr
OFPERR_OFPMMFC_BAD_COMMAND	.\lib\ofp-errors.h	/^    OFPERR_OFPMMFC_BAD_COMMAND,$/;"	e	enum:ofperr
OFPERR_OFPMMFC_BAD_FLAGS	.\lib\ofp-errors.h	/^    OFPERR_OFPMMFC_BAD_FLAGS,$/;"	e	enum:ofperr
OFPERR_OFPMMFC_BAD_RATE	.\lib\ofp-errors.h	/^    OFPERR_OFPMMFC_BAD_RATE,$/;"	e	enum:ofperr
OFPERR_OFPMMFC_INVALID_METER	.\lib\ofp-errors.h	/^    OFPERR_OFPMMFC_INVALID_METER,$/;"	e	enum:ofperr
OFPERR_OFPMMFC_METER_EXISTS	.\lib\ofp-errors.h	/^    OFPERR_OFPMMFC_METER_EXISTS,$/;"	e	enum:ofperr
OFPERR_OFPMMFC_OUT_OF_BANDS	.\lib\ofp-errors.h	/^    OFPERR_OFPMMFC_OUT_OF_BANDS,$/;"	e	enum:ofperr
OFPERR_OFPMMFC_OUT_OF_METERS	.\lib\ofp-errors.h	/^    OFPERR_OFPMMFC_OUT_OF_METERS,$/;"	e	enum:ofperr
OFPERR_OFPMMFC_UNKNOWN	.\lib\ofp-errors.h	/^    OFPERR_OFPMMFC_UNKNOWN,$/;"	e	enum:ofperr
OFPERR_OFPMMFC_UNKNOWN_METER	.\lib\ofp-errors.h	/^    OFPERR_OFPMMFC_UNKNOWN_METER,$/;"	e	enum:ofperr
OFPERR_OFPPMFC_BAD_ADVERTISE	.\lib\ofp-errors.h	/^    OFPERR_OFPPMFC_BAD_ADVERTISE,$/;"	e	enum:ofperr
OFPERR_OFPPMFC_BAD_CONFIG	.\lib\ofp-errors.h	/^    OFPERR_OFPPMFC_BAD_CONFIG,$/;"	e	enum:ofperr
OFPERR_OFPPMFC_BAD_HW_ADDR	.\lib\ofp-errors.h	/^    OFPERR_OFPPMFC_BAD_HW_ADDR,$/;"	e	enum:ofperr
OFPERR_OFPPMFC_BAD_PORT	.\lib\ofp-errors.h	/^    OFPERR_OFPPMFC_BAD_PORT,$/;"	e	enum:ofperr
OFPERR_OFPPMFC_EPERM	.\lib\ofp-errors.h	/^    OFPERR_OFPPMFC_EPERM,$/;"	e	enum:ofperr
OFPERR_OFPQOFC_BAD_PORT	.\lib\ofp-errors.h	/^    OFPERR_OFPQOFC_BAD_PORT,$/;"	e	enum:ofperr
OFPERR_OFPQOFC_BAD_QUEUE	.\lib\ofp-errors.h	/^    OFPERR_OFPQOFC_BAD_QUEUE,$/;"	e	enum:ofperr
OFPERR_OFPQOFC_EPERM	.\lib\ofp-errors.h	/^    OFPERR_OFPQOFC_EPERM,$/;"	e	enum:ofperr
OFPERR_OFPRRFC_BAD_ROLE	.\lib\ofp-errors.h	/^    OFPERR_OFPRRFC_BAD_ROLE,$/;"	e	enum:ofperr
OFPERR_OFPRRFC_STALE	.\lib\ofp-errors.h	/^    OFPERR_OFPRRFC_STALE,$/;"	e	enum:ofperr
OFPERR_OFPRRFC_UNSUP	.\lib\ofp-errors.h	/^    OFPERR_OFPRRFC_UNSUP,$/;"	e	enum:ofperr
OFPERR_OFPSCFC_BAD_FLAGS	.\lib\ofp-errors.h	/^    OFPERR_OFPSCFC_BAD_FLAGS,$/;"	e	enum:ofperr
OFPERR_OFPSCFC_BAD_LEN	.\lib\ofp-errors.h	/^    OFPERR_OFPSCFC_BAD_LEN,$/;"	e	enum:ofperr
OFPERR_OFPSCFC_EPERM	.\lib\ofp-errors.h	/^    OFPERR_OFPSCFC_EPERM,$/;"	e	enum:ofperr
OFPERR_OFPTFFC_BAD_METADATA	.\lib\ofp-errors.h	/^    OFPERR_OFPTFFC_BAD_METADATA,$/;"	e	enum:ofperr
OFPERR_OFPTFFC_BAD_TABLE	.\lib\ofp-errors.h	/^    OFPERR_OFPTFFC_BAD_TABLE,$/;"	e	enum:ofperr
OFPERR_OFPTFFC_EPERM	.\lib\ofp-errors.h	/^    OFPERR_OFPTFFC_EPERM,$/;"	e	enum:ofperr
OFPERR_OFPTMFC_BAD_CONFIG	.\lib\ofp-errors.h	/^    OFPERR_OFPTMFC_BAD_CONFIG,$/;"	e	enum:ofperr
OFPERR_OFPTMFC_BAD_TABLE	.\lib\ofp-errors.h	/^    OFPERR_OFPTMFC_BAD_TABLE,$/;"	e	enum:ofperr
OFPERR_OFPTMFC_EPERM	.\lib\ofp-errors.h	/^    OFPERR_OFPTMFC_EPERM,$/;"	e	enum:ofperr
OFPERR_OFS	.\lib\ofp-errors.h	46;"	d
OFPERR_ONFBIC_DUP_INSTRUCTION	.\lib\ofp-errors.h	/^    OFPERR_ONFBIC_DUP_INSTRUCTION,$/;"	e	enum:ofperr
OFPET12_EXPERIMENTER	.\include\openflow\openflow-1.2.h	59;"	d
OFPFC_ADD	.\include\openflow\openflow-common.h	/^    OFPFC_ADD,              \/* New flow. *\/$/;"	e	enum:ofp_flow_mod_command
OFPFC_DELETE	.\include\openflow\openflow-common.h	/^    OFPFC_DELETE,           \/* Delete all matching flows. *\/$/;"	e	enum:ofp_flow_mod_command
OFPFC_DELETE_STRICT	.\include\openflow\openflow-common.h	/^    OFPFC_DELETE_STRICT     \/* Strictly match wildcards and priority. *\/$/;"	e	enum:ofp_flow_mod_command
OFPFC_MODIFY	.\include\openflow\openflow-common.h	/^    OFPFC_MODIFY,           \/* Modify all matching flows. *\/$/;"	e	enum:ofp_flow_mod_command
OFPFC_MODIFY_STRICT	.\include\openflow\openflow-common.h	/^    OFPFC_MODIFY_STRICT,    \/* Modify entry strictly matching wildcards *\/$/;"	e	enum:ofp_flow_mod_command
OFPFF10_EMERG	.\include\openflow\openflow-1.0.h	/^    OFPFF10_EMERG       = 1 << 2 \/* Part of "emergency flow cache". *\/$/;"	e	enum:ofp10_flow_mod_flags
OFPFF12_RESET_COUNTS	.\include\openflow\openflow-1.2.h	/^    OFPFF12_RESET_COUNTS  = 1 << 2   \/* Reset flow packet and byte counts. *\/$/;"	e	enum:ofp12_flow_mod_flags
OFPFF13_NO_BYT_COUNTS	.\include\openflow\openflow-1.3.h	/^    OFPFF13_NO_BYT_COUNTS = 1 << 4  \/* Don't keep track of byte count. *\/$/;"	e	enum:ofp13_action_self_learning::ofp13_flow_mod_flags
OFPFF13_NO_PKT_COUNTS	.\include\openflow\openflow-1.3.h	/^    OFPFF13_NO_PKT_COUNTS = 1 << 3, \/* Don't keep track of packet count. *\/$/;"	e	enum:ofp13_action_self_learning::ofp13_flow_mod_flags
OFPFF_CHECK_OVERLAP	.\include\openflow\openflow-common.h	/^    OFPFF_CHECK_OVERLAP = 1 << 1,  \/* Check for overlapping entries first. *\/$/;"	e	enum:ofp_flow_mod_flags
OFPFF_SEND_FLOW_REM	.\include\openflow\openflow-common.h	/^    OFPFF_SEND_FLOW_REM = 1 << 0,  \/* Send flow removed message when flow$/;"	e	enum:ofp_flow_mod_flags
OFPFMF11_DL_DST	.\include\openflow\openflow-1.1.h	/^    OFPFMF11_DL_DST      = 1 << 12, \/* Ethernet destination address. *\/$/;"	e	enum:ofp11_flow_match_fields
OFPFMF11_DL_SRC	.\include\openflow\openflow-1.1.h	/^    OFPFMF11_DL_SRC      = 1 << 11, \/* Ethernet source address. *\/$/;"	e	enum:ofp11_flow_match_fields
OFPFMF11_DL_TYPE	.\include\openflow\openflow-1.1.h	/^    OFPFMF11_DL_TYPE     = 1 << 3,  \/* Ethernet frame type. *\/$/;"	e	enum:ofp11_flow_match_fields
OFPFMF11_DL_VLAN	.\include\openflow\openflow-1.1.h	/^    OFPFMF11_DL_VLAN     = 1 << 1,  \/* VLAN id. *\/$/;"	e	enum:ofp11_flow_match_fields
OFPFMF11_DL_VLAN_PCP	.\include\openflow\openflow-1.1.h	/^    OFPFMF11_DL_VLAN_PCP = 1 << 2,  \/* VLAN priority. *\/$/;"	e	enum:ofp11_flow_match_fields
OFPFMF11_IN_PORT	.\include\openflow\openflow-1.1.h	/^    OFPFMF11_IN_PORT     = 1 << 0,  \/* Switch input port. *\/$/;"	e	enum:ofp11_flow_match_fields
OFPFMF11_METADATA	.\include\openflow\openflow-1.1.h	/^    OFPFMF11_METADATA    = 1 << 15, \/* Metadata passed between tables. *\/$/;"	e	enum:ofp11_flow_match_fields
OFPFMF11_MPLS_LABEL	.\include\openflow\openflow-1.1.h	/^    OFPFMF11_MPLS_LABEL  = 1 << 8,  \/* MPLS label. *\/$/;"	e	enum:ofp11_flow_match_fields
OFPFMF11_MPLS_TC	.\include\openflow\openflow-1.1.h	/^    OFPFMF11_MPLS_TC     = 1 << 9,  \/* MPLS TC. *\/$/;"	e	enum:ofp11_flow_match_fields
OFPFMF11_NW_DST	.\include\openflow\openflow-1.1.h	/^    OFPFMF11_NW_DST      = 1 << 14, \/* IP destination address. *\/$/;"	e	enum:ofp11_flow_match_fields
OFPFMF11_NW_PROTO	.\include\openflow\openflow-1.1.h	/^    OFPFMF11_NW_PROTO    = 1 << 5,  \/* IP protocol. *\/$/;"	e	enum:ofp11_flow_match_fields
OFPFMF11_NW_SRC	.\include\openflow\openflow-1.1.h	/^    OFPFMF11_NW_SRC      = 1 << 13, \/* IP source address. *\/$/;"	e	enum:ofp11_flow_match_fields
OFPFMF11_NW_TOS	.\include\openflow\openflow-1.1.h	/^    OFPFMF11_NW_TOS      = 1 << 4,  \/* IP ToS (DSCP field, 6 bits). *\/$/;"	e	enum:ofp11_flow_match_fields
OFPFMF11_TP_DST	.\include\openflow\openflow-1.1.h	/^    OFPFMF11_TP_DST      = 1 << 7,  \/* TCP\/UDP\/SCTP destination port. *\/$/;"	e	enum:ofp11_flow_match_fields
OFPFMF11_TP_SRC	.\include\openflow\openflow-1.1.h	/^    OFPFMF11_TP_SRC      = 1 << 6,  \/* TCP\/UDP\/SCTP source port. *\/$/;"	e	enum:ofp11_flow_match_fields
OFPFMF11_TYPE	.\include\openflow\openflow-1.1.h	/^    OFPFMF11_TYPE        = 1 << 10, \/* Match type. *\/$/;"	e	enum:ofp11_flow_match_fields
OFPFW10_ALL	.\include\openflow\openflow-1.0.h	/^    OFPFW10_ALL = ((1 << 22) - 1)$/;"	e	enum:ofp10_flow_wildcards
OFPFW10_DL_DST	.\include\openflow\openflow-1.0.h	/^    OFPFW10_DL_DST     = 1 << 3,  \/* Ethernet destination address. *\/$/;"	e	enum:ofp10_flow_wildcards
OFPFW10_DL_SRC	.\include\openflow\openflow-1.0.h	/^    OFPFW10_DL_SRC     = 1 << 2,  \/* Ethernet source address. *\/$/;"	e	enum:ofp10_flow_wildcards
OFPFW10_DL_TYPE	.\include\openflow\openflow-1.0.h	/^    OFPFW10_DL_TYPE    = 1 << 4,  \/* Ethernet frame type. *\/$/;"	e	enum:ofp10_flow_wildcards
OFPFW10_DL_VLAN	.\include\openflow\openflow-1.0.h	/^    OFPFW10_DL_VLAN    = 1 << 1,  \/* VLAN vid. *\/$/;"	e	enum:ofp10_flow_wildcards
OFPFW10_DL_VLAN_PCP	.\include\openflow\openflow-1.0.h	/^    OFPFW10_DL_VLAN_PCP = 1 << 20, \/* VLAN priority. *\/$/;"	e	enum:ofp10_flow_wildcards
OFPFW10_ICMP_CODE	.\include\openflow\openflow-1.0.h	265;"	d
OFPFW10_ICMP_TYPE	.\include\openflow\openflow-1.0.h	264;"	d
OFPFW10_IN_PORT	.\include\openflow\openflow-1.0.h	/^    OFPFW10_IN_PORT    = 1 << 0,  \/* Switch input port. *\/$/;"	e	enum:ofp10_flow_wildcards
OFPFW10_NW_DST_ALL	.\include\openflow\openflow-1.0.h	/^    OFPFW10_NW_DST_ALL = 32 << OFPFW10_NW_DST_SHIFT,$/;"	e	enum:ofp10_flow_wildcards
OFPFW10_NW_DST_BITS	.\include\openflow\openflow-1.0.h	/^    OFPFW10_NW_DST_BITS = 6,$/;"	e	enum:ofp10_flow_wildcards
OFPFW10_NW_DST_MASK	.\include\openflow\openflow-1.0.h	/^    OFPFW10_NW_DST_MASK = (((1 << OFPFW10_NW_DST_BITS) - 1)$/;"	e	enum:ofp10_flow_wildcards
OFPFW10_NW_DST_SHIFT	.\include\openflow\openflow-1.0.h	/^    OFPFW10_NW_DST_SHIFT = 14,$/;"	e	enum:ofp10_flow_wildcards
OFPFW10_NW_PROTO	.\include\openflow\openflow-1.0.h	/^    OFPFW10_NW_PROTO   = 1 << 5,  \/* IP protocol. *\/$/;"	e	enum:ofp10_flow_wildcards
OFPFW10_NW_SRC_ALL	.\include\openflow\openflow-1.0.h	/^    OFPFW10_NW_SRC_ALL = 32 << OFPFW10_NW_SRC_SHIFT,$/;"	e	enum:ofp10_flow_wildcards
OFPFW10_NW_SRC_BITS	.\include\openflow\openflow-1.0.h	/^    OFPFW10_NW_SRC_BITS = 6,$/;"	e	enum:ofp10_flow_wildcards
OFPFW10_NW_SRC_MASK	.\include\openflow\openflow-1.0.h	/^    OFPFW10_NW_SRC_MASK = (((1 << OFPFW10_NW_SRC_BITS) - 1)$/;"	e	enum:ofp10_flow_wildcards
OFPFW10_NW_SRC_SHIFT	.\include\openflow\openflow-1.0.h	/^    OFPFW10_NW_SRC_SHIFT = 8,$/;"	e	enum:ofp10_flow_wildcards
OFPFW10_NW_TOS	.\include\openflow\openflow-1.0.h	/^    OFPFW10_NW_TOS = 1 << 21, \/* IP ToS (DSCP field, 6 bits). *\/$/;"	e	enum:ofp10_flow_wildcards
OFPFW10_TP_DST	.\include\openflow\openflow-1.0.h	/^    OFPFW10_TP_DST     = 1 << 7,  \/* TCP\/UDP destination port. *\/$/;"	e	enum:ofp10_flow_wildcards
OFPFW10_TP_SRC	.\include\openflow\openflow-1.0.h	/^    OFPFW10_TP_SRC     = 1 << 6,  \/* TCP\/UDP source port. *\/$/;"	e	enum:ofp10_flow_wildcards
OFPFW11_ALL	.\include\openflow\openflow-1.1.h	/^    OFPFW11_ALL           = ((1 << 10) - 1)$/;"	e	enum:ofp11_flow_wildcards
OFPFW11_DL_TYPE	.\include\openflow\openflow-1.1.h	/^    OFPFW11_DL_TYPE     = 1 << 3,  \/* Ethernet frame type. *\/$/;"	e	enum:ofp11_flow_wildcards
OFPFW11_DL_VLAN	.\include\openflow\openflow-1.1.h	/^    OFPFW11_DL_VLAN     = 1 << 1,  \/* VLAN id. *\/$/;"	e	enum:ofp11_flow_wildcards
OFPFW11_DL_VLAN_PCP	.\include\openflow\openflow-1.1.h	/^    OFPFW11_DL_VLAN_PCP = 1 << 2,  \/* VLAN priority. *\/$/;"	e	enum:ofp11_flow_wildcards
OFPFW11_IN_PORT	.\include\openflow\openflow-1.1.h	/^    OFPFW11_IN_PORT     = 1 << 0,  \/* Switch input port. *\/$/;"	e	enum:ofp11_flow_wildcards
OFPFW11_MPLS_LABEL	.\include\openflow\openflow-1.1.h	/^    OFPFW11_MPLS_LABEL  = 1 << 8,  \/* MPLS label. *\/$/;"	e	enum:ofp11_flow_wildcards
OFPFW11_MPLS_TC	.\include\openflow\openflow-1.1.h	/^    OFPFW11_MPLS_TC     = 1 << 9,  \/* MPLS TC. *\/$/;"	e	enum:ofp11_flow_wildcards
OFPFW11_NW_PROTO	.\include\openflow\openflow-1.1.h	/^    OFPFW11_NW_PROTO    = 1 << 5,  \/* IP protocol. *\/$/;"	e	enum:ofp11_flow_wildcards
OFPFW11_NW_TOS	.\include\openflow\openflow-1.1.h	/^    OFPFW11_NW_TOS      = 1 << 4,  \/* IP ToS (DSCP field, 6 bits). *\/$/;"	e	enum:ofp11_flow_wildcards
OFPFW11_TP_ALL	.\lib\ofp-util.c	442;"	d	file:
OFPFW11_TP_DST	.\include\openflow\openflow-1.1.h	/^    OFPFW11_TP_DST      = 1 << 7,  \/* TCP\/UDP\/SCTP destination port. *\/$/;"	e	enum:ofp11_flow_wildcards
OFPFW11_TP_SRC	.\include\openflow\openflow-1.1.h	/^    OFPFW11_TP_SRC      = 1 << 6,  \/* TCP\/UDP\/SCTP source port. *\/$/;"	e	enum:ofp11_flow_wildcards
OFPG11_ALL	.\include\openflow\openflow-1.1.h	/^    OFPG11_ALL        = 0xfffffffc,  \/* Represents all groups for group delete$/;"	e	enum:ofp11_group
OFPG11_ANY	.\include\openflow\openflow-1.1.h	/^    OFPG11_ANY        = 0xffffffff   \/* Wildcard group used only for flow stats$/;"	e	enum:ofp11_group
OFPG11_MAX	.\include\openflow\openflow-1.1.h	/^    OFPG11_MAX        = 0xffffff00,$/;"	e	enum:ofp11_group
OFPGC11_ADD	.\include\openflow\openflow-1.1.h	/^    OFPGC11_ADD,          \/* New group. *\/$/;"	e	enum:ofp11_group_mod_command
OFPGC11_DELETE	.\include\openflow\openflow-1.1.h	/^    OFPGC11_DELETE,       \/* Delete all matching groups. *\/$/;"	e	enum:ofp11_group_mod_command
OFPGC11_MODIFY	.\include\openflow\openflow-1.1.h	/^    OFPGC11_MODIFY,       \/* Modify all matching groups. *\/$/;"	e	enum:ofp11_group_mod_command
OFPGFC12_CHAINING	.\include\openflow\openflow-1.2.h	/^    OFPGFC12_CHAINING        = 1 << 2, \/* Support chaining groups *\/$/;"	e	enum:ofp12_group_capabilities
OFPGFC12_CHAINING_CHECKS	.\include\openflow\openflow-1.2.h	/^    OFPGFC12_CHAINING_CHECKS = 1 << 3, \/* Check chaining for loops and delete *\/$/;"	e	enum:ofp12_group_capabilities
OFPGFC12_SELECT_LIVENESS	.\include\openflow\openflow-1.2.h	/^    OFPGFC12_SELECT_LIVENESS = 1 << 1, \/* Support liveness for select groups *\/$/;"	e	enum:ofp12_group_capabilities
OFPGFC12_SELECT_WEIGHT	.\include\openflow\openflow-1.2.h	/^    OFPGFC12_SELECT_WEIGHT   = 1 << 0, \/* Support weight for select groups *\/$/;"	e	enum:ofp12_group_capabilities
OFPGFC_CHAINING	.\include\openflow\openflow-common.h	/^    OFPGFC_CHAINING        = 1 << 2, \/* Support chaining groups *\/$/;"	e	enum:ofp_group_capabilities
OFPGFC_CHAINING_CHECKS	.\include\openflow\openflow-common.h	/^    OFPGFC_CHAINING_CHECKS = 1 << 3, \/* Check chaining for loops and delete *\/$/;"	e	enum:ofp_group_capabilities
OFPGFC_SELECT_LIVENESS	.\include\openflow\openflow-common.h	/^    OFPGFC_SELECT_LIVENESS = 1 << 1, \/* Support liveness for select groups *\/$/;"	e	enum:ofp_group_capabilities
OFPGFC_SELECT_WEIGHT	.\include\openflow\openflow-common.h	/^    OFPGFC_SELECT_WEIGHT   = 1 << 0, \/* Support weight for select groups *\/$/;"	e	enum:ofp_group_capabilities
OFPGT11_ALL	.\include\openflow\openflow-1.1.h	/^    OFPGT11_ALL,      \/* All (multicast\/broadcast) group. *\/$/;"	e	enum:ofp11_group_type
OFPGT11_FF	.\include\openflow\openflow-1.1.h	/^    OFPGT11_FF        \/* Fast failover group. *\/$/;"	e	enum:ofp11_group_type
OFPGT11_INDIRECT	.\include\openflow\openflow-1.1.h	/^    OFPGT11_INDIRECT, \/* Indirect group. *\/$/;"	e	enum:ofp11_group_type
OFPGT11_SELECT	.\include\openflow\openflow-1.1.h	/^    OFPGT11_SELECT,   \/* Select group. *\/$/;"	e	enum:ofp11_group_type
OFPG_ALL	.\include\openflow\openflow-common.h	/^    OFPG_ALL        = 0xfffffffc,  \/* All groups, for group delete commands. *\/$/;"	e	enum:ofp_group
OFPG_ANY	.\include\openflow\openflow-common.h	/^    OFPG_ANY        = 0xffffffff   \/* Wildcard, for flow stats requests. *\/$/;"	e	enum:ofp_group
OFPG_MAX	.\include\openflow\openflow-common.h	/^    OFPG_MAX        = 0xffffff00,$/;"	e	enum:ofp_group
OFPHET_VERSIONBITMAP	.\include\openflow\openflow-common.h	/^    OFPHET_VERSIONBITMAP          = 1, \/* Bitmap of version supported. *\/$/;"	e	enum:ofp_hello_elem_type
OFPIEH12_AUTH	.\include\openflow\openflow-1.2.h	/^    OFPIEH12_AUTH   = 1 << 2,   \/* Authentication header present. *\/$/;"	e	enum:ofp12_ipv6exthdr_flags
OFPIEH12_DEST	.\include\openflow\openflow-1.2.h	/^    OFPIEH12_DEST   = 1 << 3,   \/* 1 or 2 dest headers present. *\/$/;"	e	enum:ofp12_ipv6exthdr_flags
OFPIEH12_ESP	.\include\openflow\openflow-1.2.h	/^    OFPIEH12_ESP    = 1 << 1,   \/* Encrypted Sec Payload header present. *\/$/;"	e	enum:ofp12_ipv6exthdr_flags
OFPIEH12_FRAG	.\include\openflow\openflow-1.2.h	/^    OFPIEH12_FRAG   = 1 << 4,   \/* Fragment header present. *\/$/;"	e	enum:ofp12_ipv6exthdr_flags
OFPIEH12_HOP	.\include\openflow\openflow-1.2.h	/^    OFPIEH12_HOP    = 1 << 6,   \/* Hop-by-hop header present. *\/$/;"	e	enum:ofp12_ipv6exthdr_flags
OFPIEH12_NONEXT	.\include\openflow\openflow-1.2.h	/^    OFPIEH12_NONEXT = 1 << 0,   \/* "No next header" encountered. *\/$/;"	e	enum:ofp12_ipv6exthdr_flags
OFPIEH12_ROUTER	.\include\openflow\openflow-1.2.h	/^    OFPIEH12_ROUTER = 1 << 5,   \/* Router header present. *\/$/;"	e	enum:ofp12_ipv6exthdr_flags
OFPIEH12_UNREP	.\include\openflow\openflow-1.2.h	/^    OFPIEH12_UNREP  = 1 << 7,   \/* Unexpected repeats encountered. *\/$/;"	e	enum:ofp12_ipv6exthdr_flags
OFPIEH12_UNSEQ	.\include\openflow\openflow-1.2.h	/^    OFPIEH12_UNSEQ  = 1 << 8    \/* Unexpected sequencing encountered. *\/$/;"	e	enum:ofp12_ipv6exthdr_flags
OFPIT11_ALL	.\include\openflow\openflow-1.1.h	293;"	d
OFPIT11_APPLY_ACTIONS	.\include\openflow\openflow-1.1.h	/^    OFPIT11_APPLY_ACTIONS = 4,     \/* Applies the action(s) immediately *\/$/;"	e	enum:ofp11_instruction_type
OFPIT11_CLEAR_ACTIONS	.\include\openflow\openflow-1.1.h	/^    OFPIT11_CLEAR_ACTIONS = 5,     \/* Clears all actions from the datapath$/;"	e	enum:ofp11_instruction_type
OFPIT11_EXPERIMENTER	.\include\openflow\openflow-1.1.h	/^    OFPIT11_EXPERIMENTER = 0xFFFF  \/* Experimenter instruction *\/$/;"	e	enum:ofp11_instruction_type
OFPIT11_GOTO_TABLE	.\include\openflow\openflow-1.1.h	/^    OFPIT11_GOTO_TABLE = 1,        \/* Setup the next table in the lookup$/;"	e	enum:ofp11_instruction_type
OFPIT11_WRITE_ACTIONS	.\include\openflow\openflow-1.1.h	/^    OFPIT11_WRITE_ACTIONS = 3,     \/* Write the action(s) onto the datapath$/;"	e	enum:ofp11_instruction_type
OFPIT11_WRITE_METADATA	.\include\openflow\openflow-1.1.h	/^    OFPIT11_WRITE_METADATA = 2,    \/* Setup the metadata field for use later$/;"	e	enum:ofp11_instruction_type
OFPIT13_ALL	.\include\openflow\openflow-1.3.h	94;"	d
OFPIT13_METER	.\include\openflow\openflow-1.3.h	/^    OFPIT13_METER = 6           \/* Apply meter (rate limiter) *\/$/;"	e	enum:ofp13_instruction_type
OFPM13_ALL	.\include\openflow\openflow-1.3.h	/^    OFPM13_ALL        = 0xffffffff, \/* Represents all meters for stat requests$/;"	e	enum:ofp13_action_self_learning::ofp13_meter
OFPM13_CONTROLLER	.\include\openflow\openflow-1.3.h	/^    OFPM13_CONTROLLER = 0xfffffffe, \/* Meter for controller connection. *\/$/;"	e	enum:ofp13_action_self_learning::ofp13_meter
OFPM13_MAX	.\include\openflow\openflow-1.3.h	/^    OFPM13_MAX        = 0xffff0000,$/;"	e	enum:ofp13_action_self_learning::ofp13_meter
OFPM13_SLOWPATH	.\include\openflow\openflow-1.3.h	/^    OFPM13_SLOWPATH   = 0xfffffffd, \/* Meter for slow datapath. *\/$/;"	e	enum:ofp13_action_self_learning::ofp13_meter
OFPMBT13_DROP	.\include\openflow\openflow-1.3.h	/^    OFPMBT13_DROP         = 1,     \/* Drop packet. *\/$/;"	e	enum:ofp13_action_self_learning::ofp13_meter_band_type
OFPMBT13_DSCP_REMARK	.\include\openflow\openflow-1.3.h	/^    OFPMBT13_DSCP_REMARK  = 2,     \/* Remark DSCP in the IP header. *\/$/;"	e	enum:ofp13_action_self_learning::ofp13_meter_band_type
OFPMBT13_EXPERIMENTER	.\include\openflow\openflow-1.3.h	/^    OFPMBT13_EXPERIMENTER = 0xFFFF \/* Experimenter meter band. *\/$/;"	e	enum:ofp13_action_self_learning::ofp13_meter_band_type
OFPMC13_ADD	.\include\openflow\openflow-1.3.h	/^    OFPMC13_ADD,           \/* New meter. *\/$/;"	e	enum:ofp13_action_self_learning::ofp13_meter_mod_command
OFPMC13_DELETE	.\include\openflow\openflow-1.3.h	/^    OFPMC13_DELETE         \/* Delete specified meter. *\/$/;"	e	enum:ofp13_action_self_learning::ofp13_meter_mod_command
OFPMC13_MODIFY	.\include\openflow\openflow-1.3.h	/^    OFPMC13_MODIFY,        \/* Modify specified meter. *\/$/;"	e	enum:ofp13_action_self_learning::ofp13_meter_mod_command
OFPMF13_BURST	.\include\openflow\openflow-1.3.h	/^    OFPMF13_BURST   = 1 << 2,   \/* Do burst size. *\/$/;"	e	enum:ofp13_action_self_learning::ofp13_meter_flags
OFPMF13_KBPS	.\include\openflow\openflow-1.3.h	/^    OFPMF13_KBPS    = 1 << 0,   \/* Rate value in kb\/s (kilo-bit per second). *\/$/;"	e	enum:ofp13_action_self_learning::ofp13_meter_flags
OFPMF13_PKTPS	.\include\openflow\openflow-1.3.h	/^    OFPMF13_PKTPS   = 1 << 1,   \/* Rate value in packet\/sec. *\/$/;"	e	enum:ofp13_action_self_learning::ofp13_meter_flags
OFPMF13_STATS	.\include\openflow\openflow-1.3.h	/^    OFPMF13_STATS   = 1 << 3    \/* Collect statistics. *\/$/;"	e	enum:ofp13_action_self_learning::ofp13_meter_flags
OFPMPF13_REQ_MORE	.\include\openflow\openflow-1.3.h	/^    OFPMPF13_REQ_MORE = 1 << 0 \/* More requests to follow. *\/$/;"	e	enum:ofp13_action_self_learning::ofp13_multipart_request_flags
OFPMT11_STANDARD_LENGTH	.\include\openflow\openflow-1.1.h	/^OFP_ASSERT(sizeof(struct ofp11_match) == OFPMT11_STANDARD_LENGTH);$/;"	v
OFPMT11_STANDARD_LENGTH	.\include\openflow\openflow-1.1.h	216;"	d
OFPMT_OXM	.\include\openflow\openflow-common.h	/^    OFPMT_OXM = 1,              \/* OpenFlow Extensible Match *\/$/;"	e	enum:ofp_match_type
OFPMT_STANDARD	.\include\openflow\openflow-common.h	/^    OFPMT_STANDARD = 0,         \/* The match fields defined in the ofp11_match$/;"	e	enum:ofp_match_type
OFPP11_MAX	.\include\openflow\openflow-1.1.h	70;"	d
OFPP11_OFFSET	.\include\openflow\openflow-1.1.h	71;"	d
OFPPC10_ALL	.\include\openflow\openflow-1.0.h	64;"	d
OFPPC10_NO_FLOOD	.\include\openflow\openflow-1.0.h	/^    OFPPC10_NO_FLOOD     = 1 << 4, \/* Do not include port when flooding. *\/$/;"	e	enum:ofp10_port_config
OFPPC10_NO_RECV_STP	.\include\openflow\openflow-1.0.h	/^    OFPPC10_NO_RECV_STP  = 1 << 3, \/* Drop received 802.1D STP packets. *\/$/;"	e	enum:ofp10_port_config
OFPPC10_NO_STP	.\include\openflow\openflow-1.0.h	/^    OFPPC10_NO_STP       = 1 << 1, \/* Disable 802.1D spanning tree on port. *\/$/;"	e	enum:ofp10_port_config
OFPPC11_ALL	.\include\openflow\openflow-1.1.h	82;"	d
OFPPC_NO_FWD	.\include\openflow\openflow-common.h	/^    OFPPC_NO_FWD       = 1 << 5,  \/* Drop packets forwarded to port. *\/$/;"	e	enum:ofp_port_config
OFPPC_NO_PACKET_IN	.\include\openflow\openflow-common.h	/^    OFPPC_NO_PACKET_IN = 1 << 6   \/* Do not send packet-in msgs for port. *\/$/;"	e	enum:ofp_port_config
OFPPC_NO_RECV	.\include\openflow\openflow-common.h	/^    OFPPC_NO_RECV      = 1 << 2,  \/* Drop all packets received by port. *\/$/;"	e	enum:ofp_port_config
OFPPC_PORT_DOWN	.\include\openflow\openflow-common.h	/^    OFPPC_PORT_DOWN    = 1 << 0,  \/* Port is administratively down. *\/$/;"	e	enum:ofp_port_config
OFPPDPT14_ETHERNET	.\include\openflow\openflow-1.4.h	/^    OFPPDPT14_ETHERNET          = 0,      \/* Ethernet property. *\/$/;"	e	enum:ofp_port_desc_prop_type
OFPPDPT14_EXPERIMENTER	.\include\openflow\openflow-1.4.h	/^    OFPPDPT14_EXPERIMENTER      = 0xFFFF, \/* Experimenter property. *\/$/;"	e	enum:ofp_port_desc_prop_type
OFPPDPT14_OPTICAL	.\include\openflow\openflow-1.4.h	/^    OFPPDPT14_OPTICAL           = 1,      \/* Optical property. *\/$/;"	e	enum:ofp_port_desc_prop_type
OFPPF10_AUTONEG	.\include\openflow\openflow-1.0.h	/^    OFPPF10_AUTONEG    = 1 << 9,  \/* Auto-negotiation. *\/$/;"	e	enum:ofp10_port_features
OFPPF10_COPPER	.\include\openflow\openflow-1.0.h	/^    OFPPF10_COPPER     = 1 << 7,  \/* Copper medium. *\/$/;"	e	enum:ofp10_port_features
OFPPF10_FIBER	.\include\openflow\openflow-1.0.h	/^    OFPPF10_FIBER      = 1 << 8,  \/* Fiber medium. *\/$/;"	e	enum:ofp10_port_features
OFPPF10_PAUSE	.\include\openflow\openflow-1.0.h	/^    OFPPF10_PAUSE      = 1 << 10, \/* Pause. *\/$/;"	e	enum:ofp10_port_features
OFPPF10_PAUSE_ASYM	.\include\openflow\openflow-1.0.h	/^    OFPPF10_PAUSE_ASYM = 1 << 11  \/* Asymmetric pause. *\/$/;"	e	enum:ofp10_port_features
OFPPF11_100GB_FD	.\include\openflow\openflow-1.1.h	/^    OFPPF11_100GB_FD   = 1 << 8,  \/* 100 Gb full-duplex rate support. *\/$/;"	e	enum:ofp11_port_features
OFPPF11_1TB_FD	.\include\openflow\openflow-1.1.h	/^    OFPPF11_1TB_FD     = 1 << 9,  \/* 1 Tb full-duplex rate support. *\/$/;"	e	enum:ofp11_port_features
OFPPF11_40GB_FD	.\include\openflow\openflow-1.1.h	/^    OFPPF11_40GB_FD    = 1 << 7,  \/* 40 Gb full-duplex rate support. *\/$/;"	e	enum:ofp11_port_features
OFPPF11_ALL	.\include\openflow\openflow-1.1.h	106;"	d
OFPPF11_AUTONEG	.\include\openflow\openflow-1.1.h	/^    OFPPF11_AUTONEG    = 1 << 13, \/* Auto-negotiation. *\/$/;"	e	enum:ofp11_port_features
OFPPF11_COPPER	.\include\openflow\openflow-1.1.h	/^    OFPPF11_COPPER     = 1 << 11, \/* Copper medium. *\/$/;"	e	enum:ofp11_port_features
OFPPF11_FIBER	.\include\openflow\openflow-1.1.h	/^    OFPPF11_FIBER      = 1 << 12, \/* Fiber medium. *\/$/;"	e	enum:ofp11_port_features
OFPPF11_OTHER	.\include\openflow\openflow-1.1.h	/^    OFPPF11_OTHER      = 1 << 10, \/* Other rate, not in the list. *\/$/;"	e	enum:ofp11_port_features
OFPPF11_PAUSE	.\include\openflow\openflow-1.1.h	/^    OFPPF11_PAUSE      = 1 << 14, \/* Pause. *\/$/;"	e	enum:ofp11_port_features
OFPPF11_PAUSE_ASYM	.\include\openflow\openflow-1.1.h	/^    OFPPF11_PAUSE_ASYM = 1 << 15  \/* Asymmetric pause. *\/$/;"	e	enum:ofp11_port_features
OFPPF_100MB_FD	.\include\openflow\openflow-common.h	/^    OFPPF_100MB_FD   = 1 << 3,  \/* 100 Mb full-duplex rate support. *\/$/;"	e	enum:ofp_port_features
OFPPF_100MB_HD	.\include\openflow\openflow-common.h	/^    OFPPF_100MB_HD   = 1 << 2,  \/* 100 Mb half-duplex rate support. *\/$/;"	e	enum:ofp_port_features
OFPPF_10GB_FD	.\include\openflow\openflow-common.h	/^    OFPPF_10GB_FD    = 1 << 6,  \/* 10 Gb full-duplex rate support. *\/$/;"	e	enum:ofp_port_features
OFPPF_10MB_FD	.\include\openflow\openflow-common.h	/^    OFPPF_10MB_FD    = 1 << 1,  \/* 10 Mb full-duplex rate support. *\/$/;"	e	enum:ofp_port_features
OFPPF_10MB_HD	.\include\openflow\openflow-common.h	/^    OFPPF_10MB_HD    = 1 << 0,  \/* 10 Mb half-duplex rate support. *\/$/;"	e	enum:ofp_port_features
OFPPF_1GB_FD	.\include\openflow\openflow-common.h	/^    OFPPF_1GB_FD     = 1 << 5,  \/* 1 Gb full-duplex rate support. *\/$/;"	e	enum:ofp_port_features
OFPPF_1GB_HD	.\include\openflow\openflow-common.h	/^    OFPPF_1GB_HD     = 1 << 4,  \/* 1 Gb half-duplex rate support. *\/$/;"	e	enum:ofp_port_features
OFPPMPT14_ETHERNET	.\include\openflow\openflow-1.4.h	/^    OFPPMPT14_ETHERNET          = 0,      \/* Ethernet property. *\/$/;"	e	enum:ofp14_port_mod_prop_type
OFPPMPT14_EXPERIMENTER	.\include\openflow\openflow-1.4.h	/^    OFPPMPT14_EXPERIMENTER      = 0xFFFF, \/* Experimenter property. *\/$/;"	e	enum:ofp14_port_mod_prop_type
OFPPMPT14_OPTICAL	.\include\openflow\openflow-1.4.h	/^    OFPPMPT14_OPTICAL           = 1,      \/* Optical property. *\/$/;"	e	enum:ofp14_port_mod_prop_type
OFPPR_ADD	.\include\openflow\openflow-common.h	/^    OFPPR_ADD,              \/* The port was added. *\/$/;"	e	enum:ofp_port_reason
OFPPR_DELETE	.\include\openflow\openflow-common.h	/^    OFPPR_DELETE,           \/* The port was removed. *\/$/;"	e	enum:ofp_port_reason
OFPPR_MODIFY	.\include\openflow\openflow-common.h	/^    OFPPR_MODIFY            \/* Some attribute of the port has changed. *\/$/;"	e	enum:ofp_port_reason
OFPPS10_ALL	.\include\openflow\openflow-1.0.h	83;"	d
OFPPS10_STP_BLOCK	.\include\openflow\openflow-1.0.h	/^    OFPPS10_STP_BLOCK   = 3 << 8, \/* Not part of spanning tree. *\/$/;"	e	enum:ofp10_port_state
OFPPS10_STP_FORWARD	.\include\openflow\openflow-1.0.h	/^    OFPPS10_STP_FORWARD = 2 << 8, \/* Learning and relaying frames. *\/$/;"	e	enum:ofp10_port_state
OFPPS10_STP_LEARN	.\include\openflow\openflow-1.0.h	/^    OFPPS10_STP_LEARN   = 1 << 8, \/* Learning but not relaying frames. *\/$/;"	e	enum:ofp10_port_state
OFPPS10_STP_LISTEN	.\include\openflow\openflow-1.0.h	/^    OFPPS10_STP_LISTEN  = 0 << 8, \/* Not learning or relaying frames. *\/$/;"	e	enum:ofp10_port_state
OFPPS10_STP_MASK	.\include\openflow\openflow-1.0.h	/^    OFPPS10_STP_MASK    = 3 << 8  \/* Bit mask for OFPPS10_STP_* values. *\/$/;"	e	enum:ofp10_port_state
OFPPS11_ALL	.\include\openflow\openflow-1.1.h	91;"	d
OFPPS11_BLOCKED	.\include\openflow\openflow-1.1.h	/^    OFPPS11_BLOCKED      = 1 << 1,  \/* Port is blocked *\/$/;"	e	enum:ofp11_port_state
OFPPS11_LIVE	.\include\openflow\openflow-1.1.h	/^    OFPPS11_LIVE         = 1 << 2,  \/* Live for Fast Failover Group. *\/$/;"	e	enum:ofp11_port_state
OFPPSPT14_ETHERNET	.\include\openflow\openflow-1.4.h	/^    OFPPSPT14_ETHERNET          = 0,      \/* Ethernet property. *\/$/;"	e	enum:ofp14_port_stats_prop_type
OFPPSPT14_EXPERIMENTER	.\include\openflow\openflow-1.4.h	/^    OFPPSPT14_EXPERIMENTER      = 0xFFFF, \/* Experimenter property. *\/$/;"	e	enum:ofp14_port_stats_prop_type
OFPPSPT14_OPTICAL	.\include\openflow\openflow-1.4.h	/^    OFPPSPT14_OPTICAL           = 1,      \/* Optical property. *\/$/;"	e	enum:ofp14_port_stats_prop_type
OFPPS_LINK_DOWN	.\include\openflow\openflow-common.h	/^    OFPPS_LINK_DOWN    = 1 << 0,  \/* No physical link present. *\/$/;"	e	enum:ofp_port_state
OFPP_ALL	.\include\openflow\openflow-1.0.h	43;"	d
OFPP_ANY	.\include\openflow\openflow-1.1.h	79;"	d
OFPP_CONTROLLER	.\include\openflow\openflow-1.0.h	44;"	d
OFPP_FIRST_RESV	.\include\openflow\openflow-1.0.h	34;"	d
OFPP_FLOOD	.\include\openflow\openflow-1.0.h	41;"	d
OFPP_IN_PORT	.\include\openflow\openflow-1.0.h	38;"	d
OFPP_LAST_RESV	.\include\openflow\openflow-1.0.h	35;"	d
OFPP_LOCAL	.\include\openflow\openflow-1.0.h	45;"	d
OFPP_MAX	.\include\openflow\openflow-1.0.h	33;"	d
OFPP_NONE	.\include\openflow\openflow-1.0.h	46;"	d
OFPP_NORMAL	.\include\openflow\openflow-1.0.h	40;"	d
OFPP_TABLE	.\include\openflow\openflow-1.0.h	39;"	d
OFPQT_EXPERIMENTER	.\include\openflow\openflow-common.h	/^    OFPQT_EXPERIMENTER = 0xffff, \/* Experimenter defined property. *\/$/;"	e	enum:ofp_queue_properties
OFPQT_MAX_RATE	.\include\openflow\openflow-common.h	/^    OFPQT_MAX_RATE = 2,          \/* Maximum guaranteed rate. *\/$/;"	e	enum:ofp_queue_properties
OFPQT_MIN_RATE	.\include\openflow\openflow-common.h	/^    OFPQT_MIN_RATE = 1,          \/* Minimum datarate guaranteed. *\/$/;"	e	enum:ofp_queue_properties
OFPQ_ALL	.\include\openflow\openflow-1.0.h	430;"	d
OFPRAW_NXST_AGGREGATE_REPLY	.\lib\ofp-msgs.h	/^    OFPRAW_NXST_AGGREGATE_REPLY,$/;"	e	enum:ofpraw
OFPRAW_NXST_AGGREGATE_REQUEST	.\lib\ofp-msgs.h	/^    OFPRAW_NXST_AGGREGATE_REQUEST,$/;"	e	enum:ofpraw
OFPRAW_NXST_FLOW_MONITOR_REPLY	.\lib\ofp-msgs.h	/^    OFPRAW_NXST_FLOW_MONITOR_REPLY,$/;"	e	enum:ofpraw
OFPRAW_NXST_FLOW_MONITOR_REQUEST	.\lib\ofp-msgs.h	/^    OFPRAW_NXST_FLOW_MONITOR_REQUEST,$/;"	e	enum:ofpraw
OFPRAW_NXST_FLOW_REPLY	.\lib\ofp-msgs.h	/^    OFPRAW_NXST_FLOW_REPLY,$/;"	e	enum:ofpraw
OFPRAW_NXST_FLOW_REQUEST	.\lib\ofp-msgs.h	/^    OFPRAW_NXST_FLOW_REQUEST,$/;"	e	enum:ofpraw
OFPRAW_NXT_FLOW_AGE	.\lib\ofp-msgs.h	/^    OFPRAW_NXT_FLOW_AGE,$/;"	e	enum:ofpraw
OFPRAW_NXT_FLOW_MOD	.\lib\ofp-msgs.h	/^    OFPRAW_NXT_FLOW_MOD,$/;"	e	enum:ofpraw
OFPRAW_NXT_FLOW_MOD_TABLE_ID	.\lib\ofp-msgs.h	/^    OFPRAW_NXT_FLOW_MOD_TABLE_ID,$/;"	e	enum:ofpraw
OFPRAW_NXT_FLOW_MONITOR_CANCEL	.\lib\ofp-msgs.h	/^    OFPRAW_NXT_FLOW_MONITOR_CANCEL,$/;"	e	enum:ofpraw
OFPRAW_NXT_FLOW_MONITOR_PAUSED	.\lib\ofp-msgs.h	/^    OFPRAW_NXT_FLOW_MONITOR_PAUSED,$/;"	e	enum:ofpraw
OFPRAW_NXT_FLOW_MONITOR_RESUMED	.\lib\ofp-msgs.h	/^    OFPRAW_NXT_FLOW_MONITOR_RESUMED,$/;"	e	enum:ofpraw
OFPRAW_NXT_FLOW_REMOVED	.\lib\ofp-msgs.h	/^    OFPRAW_NXT_FLOW_REMOVED,$/;"	e	enum:ofpraw
OFPRAW_NXT_PACKET_IN	.\lib\ofp-msgs.h	/^    OFPRAW_NXT_PACKET_IN,$/;"	e	enum:ofpraw
OFPRAW_NXT_ROLE_REPLY	.\lib\ofp-msgs.h	/^    OFPRAW_NXT_ROLE_REPLY,$/;"	e	enum:ofpraw
OFPRAW_NXT_ROLE_REQUEST	.\lib\ofp-msgs.h	/^    OFPRAW_NXT_ROLE_REQUEST,$/;"	e	enum:ofpraw
OFPRAW_NXT_SET_ASYNC_CONFIG	.\lib\ofp-msgs.h	/^    OFPRAW_NXT_SET_ASYNC_CONFIG,$/;"	e	enum:ofpraw
OFPRAW_NXT_SET_CONTROLLER_ID	.\lib\ofp-msgs.h	/^    OFPRAW_NXT_SET_CONTROLLER_ID,$/;"	e	enum:ofpraw
OFPRAW_NXT_SET_FLOW_FORMAT	.\lib\ofp-msgs.h	/^    OFPRAW_NXT_SET_FLOW_FORMAT,$/;"	e	enum:ofpraw
OFPRAW_NXT_SET_PACKET_IN_FORMAT	.\lib\ofp-msgs.h	/^    OFPRAW_NXT_SET_PACKET_IN_FORMAT,$/;"	e	enum:ofpraw
OFPRAW_OFPST10_AGGREGATE_REQUEST	.\lib\ofp-msgs.h	/^    OFPRAW_OFPST10_AGGREGATE_REQUEST,$/;"	e	enum:ofpraw
OFPRAW_OFPST10_FLOW_REPLY	.\lib\ofp-msgs.h	/^    OFPRAW_OFPST10_FLOW_REPLY,$/;"	e	enum:ofpraw
OFPRAW_OFPST10_FLOW_REQUEST	.\lib\ofp-msgs.h	/^    OFPRAW_OFPST10_FLOW_REQUEST,$/;"	e	enum:ofpraw
OFPRAW_OFPST10_PORT_DESC_REPLY	.\lib\ofp-msgs.h	/^    OFPRAW_OFPST10_PORT_DESC_REPLY,$/;"	e	enum:ofpraw
OFPRAW_OFPST10_PORT_DESC_REQUEST	.\lib\ofp-msgs.h	/^    OFPRAW_OFPST10_PORT_DESC_REQUEST,$/;"	e	enum:ofpraw
OFPRAW_OFPST10_PORT_REPLY	.\lib\ofp-msgs.h	/^    OFPRAW_OFPST10_PORT_REPLY,$/;"	e	enum:ofpraw
OFPRAW_OFPST10_PORT_REQUEST	.\lib\ofp-msgs.h	/^    OFPRAW_OFPST10_PORT_REQUEST,$/;"	e	enum:ofpraw
OFPRAW_OFPST10_QUEUE_REPLY	.\lib\ofp-msgs.h	/^    OFPRAW_OFPST10_QUEUE_REPLY,$/;"	e	enum:ofpraw
OFPRAW_OFPST10_QUEUE_REQUEST	.\lib\ofp-msgs.h	/^    OFPRAW_OFPST10_QUEUE_REQUEST,$/;"	e	enum:ofpraw
OFPRAW_OFPST10_TABLE_REPLY	.\lib\ofp-msgs.h	/^    OFPRAW_OFPST10_TABLE_REPLY,$/;"	e	enum:ofpraw
OFPRAW_OFPST11_AGGREGATE_REQUEST	.\lib\ofp-msgs.h	/^    OFPRAW_OFPST11_AGGREGATE_REQUEST,$/;"	e	enum:ofpraw
OFPRAW_OFPST11_FLOW_REPLY	.\lib\ofp-msgs.h	/^    OFPRAW_OFPST11_FLOW_REPLY,$/;"	e	enum:ofpraw
OFPRAW_OFPST11_FLOW_REQUEST	.\lib\ofp-msgs.h	/^    OFPRAW_OFPST11_FLOW_REQUEST,$/;"	e	enum:ofpraw
OFPRAW_OFPST11_GROUP_DESC_REPLY	.\lib\ofp-msgs.h	/^    OFPRAW_OFPST11_GROUP_DESC_REPLY,$/;"	e	enum:ofpraw
OFPRAW_OFPST11_GROUP_DESC_REQUEST	.\lib\ofp-msgs.h	/^    OFPRAW_OFPST11_GROUP_DESC_REQUEST,$/;"	e	enum:ofpraw
OFPRAW_OFPST11_GROUP_REPLY	.\lib\ofp-msgs.h	/^    OFPRAW_OFPST11_GROUP_REPLY,$/;"	e	enum:ofpraw
OFPRAW_OFPST11_GROUP_REQUEST	.\lib\ofp-msgs.h	/^    OFPRAW_OFPST11_GROUP_REQUEST,$/;"	e	enum:ofpraw
OFPRAW_OFPST11_PORT_DESC_REPLY	.\lib\ofp-msgs.h	/^    OFPRAW_OFPST11_PORT_DESC_REPLY,$/;"	e	enum:ofpraw
OFPRAW_OFPST11_PORT_REPLY	.\lib\ofp-msgs.h	/^    OFPRAW_OFPST11_PORT_REPLY,$/;"	e	enum:ofpraw
OFPRAW_OFPST11_PORT_REQUEST	.\lib\ofp-msgs.h	/^    OFPRAW_OFPST11_PORT_REQUEST,$/;"	e	enum:ofpraw
OFPRAW_OFPST11_QUEUE_REPLY	.\lib\ofp-msgs.h	/^    OFPRAW_OFPST11_QUEUE_REPLY,$/;"	e	enum:ofpraw
OFPRAW_OFPST11_QUEUE_REQUEST	.\lib\ofp-msgs.h	/^    OFPRAW_OFPST11_QUEUE_REQUEST,$/;"	e	enum:ofpraw
OFPRAW_OFPST11_TABLE_REPLY	.\lib\ofp-msgs.h	/^    OFPRAW_OFPST11_TABLE_REPLY,$/;"	e	enum:ofpraw
OFPRAW_OFPST12_GROUP_FEATURES_REPLY	.\lib\ofp-msgs.h	/^    OFPRAW_OFPST12_GROUP_FEATURES_REPLY,$/;"	e	enum:ofpraw
OFPRAW_OFPST12_GROUP_FEATURES_REQUEST	.\lib\ofp-msgs.h	/^    OFPRAW_OFPST12_GROUP_FEATURES_REQUEST,$/;"	e	enum:ofpraw
OFPRAW_OFPST12_TABLE_REPLY	.\lib\ofp-msgs.h	/^    OFPRAW_OFPST12_TABLE_REPLY,$/;"	e	enum:ofpraw
OFPRAW_OFPST13_FLOW_REPLY	.\lib\ofp-msgs.h	/^    OFPRAW_OFPST13_FLOW_REPLY,$/;"	e	enum:ofpraw
OFPRAW_OFPST13_GROUP_REPLY	.\lib\ofp-msgs.h	/^    OFPRAW_OFPST13_GROUP_REPLY,$/;"	e	enum:ofpraw
OFPRAW_OFPST13_METER_CONFIG_REPLY	.\lib\ofp-msgs.h	/^    OFPRAW_OFPST13_METER_CONFIG_REPLY,$/;"	e	enum:ofpraw
OFPRAW_OFPST13_METER_CONFIG_REQUEST	.\lib\ofp-msgs.h	/^    OFPRAW_OFPST13_METER_CONFIG_REQUEST,$/;"	e	enum:ofpraw
OFPRAW_OFPST13_METER_FEATURES_REPLY	.\lib\ofp-msgs.h	/^    OFPRAW_OFPST13_METER_FEATURES_REPLY,$/;"	e	enum:ofpraw
OFPRAW_OFPST13_METER_FEATURES_REQUEST	.\lib\ofp-msgs.h	/^    OFPRAW_OFPST13_METER_FEATURES_REQUEST,$/;"	e	enum:ofpraw
OFPRAW_OFPST13_METER_REPLY	.\lib\ofp-msgs.h	/^    OFPRAW_OFPST13_METER_REPLY,$/;"	e	enum:ofpraw
OFPRAW_OFPST13_METER_REQUEST	.\lib\ofp-msgs.h	/^    OFPRAW_OFPST13_METER_REQUEST,$/;"	e	enum:ofpraw
OFPRAW_OFPST13_PORT_REPLY	.\lib\ofp-msgs.h	/^    OFPRAW_OFPST13_PORT_REPLY,$/;"	e	enum:ofpraw
OFPRAW_OFPST13_QUEUE_REPLY	.\lib\ofp-msgs.h	/^    OFPRAW_OFPST13_QUEUE_REPLY,$/;"	e	enum:ofpraw
OFPRAW_OFPST13_TABLE_FEATURES_REPLY	.\lib\ofp-msgs.h	/^    OFPRAW_OFPST13_TABLE_FEATURES_REPLY,$/;"	e	enum:ofpraw
OFPRAW_OFPST13_TABLE_FEATURES_REQUEST	.\lib\ofp-msgs.h	/^    OFPRAW_OFPST13_TABLE_FEATURES_REQUEST,$/;"	e	enum:ofpraw
OFPRAW_OFPST13_TABLE_REPLY	.\lib\ofp-msgs.h	/^    OFPRAW_OFPST13_TABLE_REPLY,$/;"	e	enum:ofpraw
OFPRAW_OFPST14_PORT_DESC_REPLY	.\lib\ofp-msgs.h	/^    OFPRAW_OFPST14_PORT_DESC_REPLY,$/;"	e	enum:ofpraw
OFPRAW_OFPST14_PORT_REPLY	.\lib\ofp-msgs.h	/^    OFPRAW_OFPST14_PORT_REPLY,$/;"	e	enum:ofpraw
OFPRAW_OFPST14_QUEUE_REPLY	.\lib\ofp-msgs.h	/^    OFPRAW_OFPST14_QUEUE_REPLY,$/;"	e	enum:ofpraw
OFPRAW_OFPST15_GROUP_DESC_REQUEST	.\lib\ofp-msgs.h	/^    OFPRAW_OFPST15_GROUP_DESC_REQUEST,$/;"	e	enum:ofpraw
OFPRAW_OFPST15_PORT_DESC_REQUEST	.\lib\ofp-msgs.h	/^    OFPRAW_OFPST15_PORT_DESC_REQUEST,$/;"	e	enum:ofpraw
OFPRAW_OFPST_AGGREGATE_REPLY	.\lib\ofp-msgs.h	/^    OFPRAW_OFPST_AGGREGATE_REPLY,$/;"	e	enum:ofpraw
OFPRAW_OFPST_DESC_REPLY	.\lib\ofp-msgs.h	/^    OFPRAW_OFPST_DESC_REPLY,$/;"	e	enum:ofpraw
OFPRAW_OFPST_DESC_REQUEST	.\lib\ofp-msgs.h	/^    OFPRAW_OFPST_DESC_REQUEST,$/;"	e	enum:ofpraw
OFPRAW_OFPST_TABLE_REQUEST	.\lib\ofp-msgs.h	/^    OFPRAW_OFPST_TABLE_REQUEST,$/;"	e	enum:ofpraw
OFPRAW_OFPT10_BARRIER_REPLY	.\lib\ofp-msgs.h	/^    OFPRAW_OFPT10_BARRIER_REPLY,$/;"	e	enum:ofpraw
OFPRAW_OFPT10_BARRIER_REQUEST	.\lib\ofp-msgs.h	/^    OFPRAW_OFPT10_BARRIER_REQUEST,$/;"	e	enum:ofpraw
OFPRAW_OFPT10_FEATURES_REPLY	.\lib\ofp-msgs.h	/^    OFPRAW_OFPT10_FEATURES_REPLY,$/;"	e	enum:ofpraw
OFPRAW_OFPT10_FLOW_MOD	.\lib\ofp-msgs.h	/^    OFPRAW_OFPT10_FLOW_MOD,$/;"	e	enum:ofpraw
OFPRAW_OFPT10_FLOW_REMOVED	.\lib\ofp-msgs.h	/^    OFPRAW_OFPT10_FLOW_REMOVED,$/;"	e	enum:ofpraw
OFPRAW_OFPT10_PACKET_IN	.\lib\ofp-msgs.h	/^    OFPRAW_OFPT10_PACKET_IN,$/;"	e	enum:ofpraw
OFPRAW_OFPT10_PACKET_OUT	.\lib\ofp-msgs.h	/^    OFPRAW_OFPT10_PACKET_OUT,$/;"	e	enum:ofpraw
OFPRAW_OFPT10_PORT_MOD	.\lib\ofp-msgs.h	/^    OFPRAW_OFPT10_PORT_MOD,$/;"	e	enum:ofpraw
OFPRAW_OFPT10_PORT_STATUS	.\lib\ofp-msgs.h	/^    OFPRAW_OFPT10_PORT_STATUS,$/;"	e	enum:ofpraw
OFPRAW_OFPT10_QUEUE_GET_CONFIG_REPLY	.\lib\ofp-msgs.h	/^    OFPRAW_OFPT10_QUEUE_GET_CONFIG_REPLY,$/;"	e	enum:ofpraw
OFPRAW_OFPT10_QUEUE_GET_CONFIG_REQUEST	.\lib\ofp-msgs.h	/^    OFPRAW_OFPT10_QUEUE_GET_CONFIG_REQUEST,$/;"	e	enum:ofpraw
OFPRAW_OFPT11_BARRIER_REPLY	.\lib\ofp-msgs.h	/^    OFPRAW_OFPT11_BARRIER_REPLY,$/;"	e	enum:ofpraw
OFPRAW_OFPT11_BARRIER_REQUEST	.\lib\ofp-msgs.h	/^    OFPRAW_OFPT11_BARRIER_REQUEST,$/;"	e	enum:ofpraw
OFPRAW_OFPT11_FEATURES_REPLY	.\lib\ofp-msgs.h	/^    OFPRAW_OFPT11_FEATURES_REPLY,$/;"	e	enum:ofpraw
OFPRAW_OFPT11_FLOW_MOD	.\lib\ofp-msgs.h	/^    OFPRAW_OFPT11_FLOW_MOD,$/;"	e	enum:ofpraw
OFPRAW_OFPT11_FLOW_REMOVED	.\lib\ofp-msgs.h	/^    OFPRAW_OFPT11_FLOW_REMOVED,$/;"	e	enum:ofpraw
OFPRAW_OFPT11_GROUP_MOD	.\lib\ofp-msgs.h	/^    OFPRAW_OFPT11_GROUP_MOD,$/;"	e	enum:ofpraw
OFPRAW_OFPT11_PACKET_IN	.\lib\ofp-msgs.h	/^    OFPRAW_OFPT11_PACKET_IN,$/;"	e	enum:ofpraw
OFPRAW_OFPT11_PACKET_OUT	.\lib\ofp-msgs.h	/^    OFPRAW_OFPT11_PACKET_OUT,$/;"	e	enum:ofpraw
OFPRAW_OFPT11_PORT_MOD	.\lib\ofp-msgs.h	/^    OFPRAW_OFPT11_PORT_MOD,$/;"	e	enum:ofpraw
OFPRAW_OFPT11_PORT_STATUS	.\lib\ofp-msgs.h	/^    OFPRAW_OFPT11_PORT_STATUS,$/;"	e	enum:ofpraw
OFPRAW_OFPT11_QUEUE_GET_CONFIG_REPLY	.\lib\ofp-msgs.h	/^    OFPRAW_OFPT11_QUEUE_GET_CONFIG_REPLY,$/;"	e	enum:ofpraw
OFPRAW_OFPT11_QUEUE_GET_CONFIG_REQUEST	.\lib\ofp-msgs.h	/^    OFPRAW_OFPT11_QUEUE_GET_CONFIG_REQUEST,$/;"	e	enum:ofpraw
OFPRAW_OFPT11_TABLE_MOD	.\lib\ofp-msgs.h	/^    OFPRAW_OFPT11_TABLE_MOD,$/;"	e	enum:ofpraw
OFPRAW_OFPT12_PACKET_IN	.\lib\ofp-msgs.h	/^    OFPRAW_OFPT12_PACKET_IN,$/;"	e	enum:ofpraw
OFPRAW_OFPT12_ROLE_REPLY	.\lib\ofp-msgs.h	/^    OFPRAW_OFPT12_ROLE_REPLY,$/;"	e	enum:ofpraw
OFPRAW_OFPT12_ROLE_REQUEST	.\lib\ofp-msgs.h	/^    OFPRAW_OFPT12_ROLE_REQUEST,$/;"	e	enum:ofpraw
OFPRAW_OFPT13_FEATURES_REPLY	.\lib\ofp-msgs.h	/^    OFPRAW_OFPT13_FEATURES_REPLY,$/;"	e	enum:ofpraw
OFPRAW_OFPT13_GET_ASYNC_REPLY	.\lib\ofp-msgs.h	/^    OFPRAW_OFPT13_GET_ASYNC_REPLY,$/;"	e	enum:ofpraw
OFPRAW_OFPT13_GET_ASYNC_REQUEST	.\lib\ofp-msgs.h	/^    OFPRAW_OFPT13_GET_ASYNC_REQUEST,$/;"	e	enum:ofpraw
OFPRAW_OFPT13_METER_MOD	.\lib\ofp-msgs.h	/^    OFPRAW_OFPT13_METER_MOD,$/;"	e	enum:ofpraw
OFPRAW_OFPT13_PACKET_IN	.\lib\ofp-msgs.h	/^    OFPRAW_OFPT13_PACKET_IN,$/;"	e	enum:ofpraw
OFPRAW_OFPT13_SET_ASYNC	.\lib\ofp-msgs.h	/^    OFPRAW_OFPT13_SET_ASYNC,$/;"	e	enum:ofpraw
OFPRAW_OFPT14_BUNDLE_ADD_MESSAGE	.\lib\ofp-msgs.h	/^    OFPRAW_OFPT14_BUNDLE_ADD_MESSAGE,$/;"	e	enum:ofpraw
OFPRAW_OFPT14_BUNDLE_CONTROL	.\lib\ofp-msgs.h	/^    OFPRAW_OFPT14_BUNDLE_CONTROL,$/;"	e	enum:ofpraw
OFPRAW_OFPT14_PORT_MOD	.\lib\ofp-msgs.h	/^    OFPRAW_OFPT14_PORT_MOD,$/;"	e	enum:ofpraw
OFPRAW_OFPT14_PORT_STATUS	.\lib\ofp-msgs.h	/^    OFPRAW_OFPT14_PORT_STATUS,$/;"	e	enum:ofpraw
OFPRAW_OFPT14_ROLE_STATUS	.\lib\ofp-msgs.h	/^    OFPRAW_OFPT14_ROLE_STATUS,$/;"	e	enum:ofpraw
OFPRAW_OFPT14_TABLE_MOD	.\lib\ofp-msgs.h	/^    OFPRAW_OFPT14_TABLE_MOD,$/;"	e	enum:ofpraw
OFPRAW_OFPT_ECHO_REPLY	.\lib\ofp-msgs.h	/^    OFPRAW_OFPT_ECHO_REPLY,$/;"	e	enum:ofpraw
OFPRAW_OFPT_ECHO_REQUEST	.\lib\ofp-msgs.h	/^    OFPRAW_OFPT_ECHO_REQUEST,$/;"	e	enum:ofpraw
OFPRAW_OFPT_ERROR	.\lib\ofp-msgs.h	/^    OFPRAW_OFPT_ERROR,$/;"	e	enum:ofpraw
OFPRAW_OFPT_FEATURES_REQUEST	.\lib\ofp-msgs.h	/^    OFPRAW_OFPT_FEATURES_REQUEST,$/;"	e	enum:ofpraw
OFPRAW_OFPT_GET_CONFIG_REPLY	.\lib\ofp-msgs.h	/^    OFPRAW_OFPT_GET_CONFIG_REPLY,$/;"	e	enum:ofpraw
OFPRAW_OFPT_GET_CONFIG_REQUEST	.\lib\ofp-msgs.h	/^    OFPRAW_OFPT_GET_CONFIG_REQUEST,$/;"	e	enum:ofpraw
OFPRAW_OFPT_HELLO	.\lib\ofp-msgs.h	/^    OFPRAW_OFPT_HELLO,$/;"	e	enum:ofpraw
OFPRAW_OFPT_SET_CONFIG	.\lib\ofp-msgs.h	/^    OFPRAW_OFPT_SET_CONFIG,$/;"	e	enum:ofpraw
OFPROTO_DPIF_H	.\ofproto\ofproto-dpif.h	16;"	d
OFPROTO_DPIF_IPFIX_H	.\ofproto\ofproto-dpif-ipfix.h	18;"	d
OFPROTO_DPIF_MONITOR_H	.\ofproto\ofproto-dpif-monitor.h	16;"	d
OFPROTO_DPIF_RID_H	.\ofproto\ofproto-dpif-rid.h	18;"	d
OFPROTO_DPIF_SFLOW_H	.\ofproto\ofproto-dpif-sflow.h	19;"	d
OFPROTO_DPIF_UPCALL_H	.\ofproto\ofproto-dpif-upcall.h	16;"	d
OFPROTO_DPIF_XLATE_H	.\ofproto\ofproto-dpif-xlate.h	16;"	d
OFPROTO_FAIL_SECURE	.\ofproto\ofproto.h	/^    OFPROTO_FAIL_SECURE,        \/* Preserve flow table. *\/$/;"	e	enum:ofproto_fail_mode
OFPROTO_FAIL_STANDALONE	.\ofproto\ofproto.h	/^    OFPROTO_FAIL_STANDALONE     \/* Act as a standalone switch. *\/$/;"	e	enum:ofproto_fail_mode
OFPROTO_FLOW_LIMIT_DEFAULT	.\ofproto\ofproto.h	216;"	d
OFPROTO_FOR_EACH_TABLE	.\ofproto\ofproto-provider.h	268;"	d
OFPROTO_H	.\ofproto\ofproto.h	18;"	d
OFPROTO_IN_BAND	.\ofproto\ofproto.h	/^    OFPROTO_IN_BAND,            \/* In-band connection to controller. *\/$/;"	e	enum:ofproto_band
OFPROTO_MAX_IDLE_DEFAULT	.\ofproto\ofproto.h	217;"	d
OFPROTO_NETFLOW_H	.\ofproto\netflow.h	18;"	d
OFPROTO_OFPROTO_PROVIDER_H	.\ofproto\ofproto-provider.h	18;"	d
OFPROTO_OUT_OF_BAND	.\ofproto\ofproto.h	/^    OFPROTO_OUT_OF_BAND         \/* Out-of-band connection to controller. *\/$/;"	e	enum:ofproto_band
OFPROTO_PACKET_IN_MISS_FLOW	.\ofproto\connmgr.h	/^    OFPROTO_PACKET_IN_MISS_FLOW,$/;"	e	enum:ofproto_packet_in_miss_type
OFPROTO_PACKET_IN_MISS_WITHOUT_FLOW	.\ofproto\connmgr.h	/^    OFPROTO_PACKET_IN_MISS_WITHOUT_FLOW,$/;"	e	enum:ofproto_packet_in_miss_type
OFPROTO_PACKET_IN_NO_MISS	.\ofproto\connmgr.h	/^    OFPROTO_PACKET_IN_NO_MISS,$/;"	e	enum:ofproto_packet_in_miss_type
OFPROTO_PORT_FOR_EACH	.\ofproto\ofproto.h	209;"	d
OFPROTO_POSTPONE	.\ofproto\ofproto-provider.h	/^enum { OFPROTO_POSTPONE = 1 << 16 };$/;"	e	enum:__anon147
OFPROTO_TABLE_MISS_CONTINUE	.\ofproto\ofproto.h	/^    OFPROTO_TABLE_MISS_CONTINUE   = OFPTC11_TABLE_MISS_CONTINUE,$/;"	e	enum:ofproto_table_config
OFPROTO_TABLE_MISS_CONTROLLER	.\ofproto\ofproto.h	/^    OFPROTO_TABLE_MISS_CONTROLLER = OFPTC11_TABLE_MISS_CONTROLLER,$/;"	e	enum:ofproto_table_config
OFPROTO_TABLE_MISS_DEFAULT	.\ofproto\ofproto.h	/^    OFPROTO_TABLE_MISS_DEFAULT    = 3,$/;"	e	enum:ofproto_table_config
OFPROTO_TABLE_MISS_DROP	.\ofproto\ofproto.h	/^    OFPROTO_TABLE_MISS_DROP       = OFPTC11_TABLE_MISS_DROP,$/;"	e	enum:ofproto_table_config
OFPROT_DPIF_MIRROR_H	.\ofproto\ofproto-dpif-mirror.h	16;"	d
OFPRPT_EXPERIMENTER	.\include\openflow\openflow-1.4.h	/^    OFPRPT_EXPERIMENTER         = 0xFFFF, \/* Experimenter property. *\/$/;"	e	enum:ofp14_role_prop_type
OFPRR_DELETE	.\include\openflow\openflow-common.h	/^    OFPRR_DELETE,               \/* Evicted by a DELETE flow mod. *\/$/;"	e	enum:ofp_flow_removed_reason
OFPRR_EVICTION	.\include\openflow\openflow-common.h	/^    OFPRR_EVICTION,             \/* Switch eviction to free resources. *\/$/;"	e	enum:ofp_flow_removed_reason
OFPRR_GROUP_DELETE	.\include\openflow\openflow-common.h	/^    OFPRR_GROUP_DELETE,         \/* Group was removed. *\/$/;"	e	enum:ofp_flow_removed_reason
OFPRR_HARD_TIMEOUT	.\include\openflow\openflow-common.h	/^    OFPRR_HARD_TIMEOUT,         \/* Time exceeded hard_timeout. *\/$/;"	e	enum:ofp_flow_removed_reason
OFPRR_IDLE_TIMEOUT	.\include\openflow\openflow-common.h	/^    OFPRR_IDLE_TIMEOUT,         \/* Flow idle time exceeded idle_timeout. *\/$/;"	e	enum:ofp_flow_removed_reason
OFPRR_METER_DELETE	.\include\openflow\openflow-common.h	/^    OFPRR_METER_DELETE,         \/* Meter was removed. *\/$/;"	e	enum:ofp_flow_removed_reason
OFPR_ACTION	.\include\openflow\openflow-common.h	/^    OFPR_ACTION,            \/* Action explicitly output to controller. *\/$/;"	e	enum:ofp_packet_in_reason
OFPR_INVALID_TTL	.\include\openflow\openflow-common.h	/^    OFPR_INVALID_TTL        \/* Packet has invalid TTL. *\/,$/;"	e	enum:ofp_packet_in_reason
OFPR_NO_MATCH	.\include\openflow\openflow-common.h	/^    OFPR_NO_MATCH,          \/* No matching flow. *\/$/;"	e	enum:ofp_packet_in_reason
OFPR_N_REASONS	.\include\openflow\openflow-common.h	/^    OFPR_N_REASONS$/;"	e	enum:ofp_packet_in_reason
OFPSF_REPLY_MORE	.\include\openflow\openflow-common.h	/^    OFPSF_REPLY_MORE  = 1 << 0  \/* More replies to follow. *\/$/;"	e	enum:ofp_stats_reply_flags
OFPST_VENDOR	.\lib\ofp-msgs.c	36;"	d	file:
OFPT10_STATS_REPLY	.\lib\ofp-msgs.c	33;"	d	file:
OFPT10_STATS_REQUEST	.\lib\ofp-msgs.c	32;"	d	file:
OFPT11_STATS_REPLY	.\lib\ofp-msgs.c	35;"	d	file:
OFPT11_STATS_REQUEST	.\lib\ofp-msgs.c	34;"	d	file:
OFPTC11_TABLE_MISS_CONTINUE	.\include\openflow\openflow-common.h	/^    OFPTC11_TABLE_MISS_CONTINUE   = 1 << 0, \/* Go to next table, like OF1.0. *\/$/;"	e	enum:ofp_table_config
OFPTC11_TABLE_MISS_CONTROLLER	.\include\openflow\openflow-common.h	/^    OFPTC11_TABLE_MISS_CONTROLLER = 0 << 0, \/* Send to controller. *\/$/;"	e	enum:ofp_table_config
OFPTC11_TABLE_MISS_DROP	.\include\openflow\openflow-common.h	/^    OFPTC11_TABLE_MISS_DROP       = 2 << 0, \/* Drop the packet. *\/$/;"	e	enum:ofp_table_config
OFPTC11_TABLE_MISS_MASK	.\include\openflow\openflow-common.h	/^    OFPTC11_TABLE_MISS_MASK       = 3 << 0,$/;"	e	enum:ofp_table_config
OFPTC13_DEPRECATED_MASK	.\include\openflow\openflow-1.3.h	/^    OFPTC13_DEPRECATED_MASK = 3  \/* Deprecated bits *\/$/;"	e	enum:ofp13_action_self_learning::ofp13_table_config
OFPTC14_EVICTION	.\include\openflow\openflow-common.h	/^    OFPTC14_EVICTION              = 1 << 2, \/* Allow table to evict flows. *\/$/;"	e	enum:ofp_table_config
OFPTC14_VACANCY_EVENTS	.\include\openflow\openflow-common.h	/^    OFPTC14_VACANCY_EVENTS        = 1 << 3, \/* Enable vacancy events. *\/$/;"	e	enum:ofp_table_config
OFPTFPT13_APPLY_ACTIONS	.\include\openflow\openflow-1.3.h	/^    OFPTFPT13_APPLY_ACTIONS        = 6, \/* Apply Actions property. *\/$/;"	e	enum:ofp13_action_self_learning::ofp13_table_feature_prop_type
OFPTFPT13_APPLY_ACTIONS_MISS	.\include\openflow\openflow-1.3.h	/^    OFPTFPT13_APPLY_ACTIONS_MISS   = 7, \/* Apply Actions for table-miss. *\/$/;"	e	enum:ofp13_action_self_learning::ofp13_table_feature_prop_type
OFPTFPT13_APPLY_SETFIELD	.\include\openflow\openflow-1.3.h	/^    OFPTFPT13_APPLY_SETFIELD       = 14, \/* Apply Set-Field property. *\/$/;"	e	enum:ofp13_action_self_learning::ofp13_table_feature_prop_type
OFPTFPT13_APPLY_SETFIELD_MISS	.\include\openflow\openflow-1.3.h	/^    OFPTFPT13_APPLY_SETFIELD_MISS  = 15, \/* Apply Set-Field for table-miss. *\/$/;"	e	enum:ofp13_action_self_learning::ofp13_table_feature_prop_type
OFPTFPT13_EXPERIMENTER	.\include\openflow\openflow-1.3.h	/^    OFPTFPT13_EXPERIMENTER         = 0xFFFE, \/* Experimenter property. *\/$/;"	e	enum:ofp13_action_self_learning::ofp13_table_feature_prop_type
OFPTFPT13_EXPERIMENTER_MISS	.\include\openflow\openflow-1.3.h	/^    OFPTFPT13_EXPERIMENTER_MISS    = 0xFFFF, \/* Experimenter for table-miss. *\/$/;"	e	enum:ofp13_action_self_learning::ofp13_table_feature_prop_type
OFPTFPT13_INSTRUCTIONS	.\include\openflow\openflow-1.3.h	/^    OFPTFPT13_INSTRUCTIONS         = 0, \/* Instructions property. *\/$/;"	e	enum:ofp13_action_self_learning::ofp13_table_feature_prop_type
OFPTFPT13_INSTRUCTIONS_MISS	.\include\openflow\openflow-1.3.h	/^    OFPTFPT13_INSTRUCTIONS_MISS    = 1, \/* Instructions for table-miss. *\/$/;"	e	enum:ofp13_action_self_learning::ofp13_table_feature_prop_type
OFPTFPT13_MATCH	.\include\openflow\openflow-1.3.h	/^    OFPTFPT13_MATCH                = 8, \/* Match property. *\/$/;"	e	enum:ofp13_action_self_learning::ofp13_table_feature_prop_type
OFPTFPT13_NEXT_TABLES	.\include\openflow\openflow-1.3.h	/^    OFPTFPT13_NEXT_TABLES          = 2, \/* Next Table property. *\/$/;"	e	enum:ofp13_action_self_learning::ofp13_table_feature_prop_type
OFPTFPT13_NEXT_TABLES_MISS	.\include\openflow\openflow-1.3.h	/^    OFPTFPT13_NEXT_TABLES_MISS     = 3, \/* Next Table for table-miss. *\/$/;"	e	enum:ofp13_action_self_learning::ofp13_table_feature_prop_type
OFPTFPT13_WILDCARDS	.\include\openflow\openflow-1.3.h	/^    OFPTFPT13_WILDCARDS            = 10, \/* Wildcards property. *\/$/;"	e	enum:ofp13_action_self_learning::ofp13_table_feature_prop_type
OFPTFPT13_WRITE_ACTIONS	.\include\openflow\openflow-1.3.h	/^    OFPTFPT13_WRITE_ACTIONS        = 4, \/* Write Actions property. *\/$/;"	e	enum:ofp13_action_self_learning::ofp13_table_feature_prop_type
OFPTFPT13_WRITE_ACTIONS_MISS	.\include\openflow\openflow-1.3.h	/^    OFPTFPT13_WRITE_ACTIONS_MISS   = 5, \/* Write Actions for table-miss. *\/$/;"	e	enum:ofp13_action_self_learning::ofp13_table_feature_prop_type
OFPTFPT13_WRITE_SETFIELD	.\include\openflow\openflow-1.3.h	/^    OFPTFPT13_WRITE_SETFIELD       = 12, \/* Write Set-Field property. *\/$/;"	e	enum:ofp13_action_self_learning::ofp13_table_feature_prop_type
OFPTFPT13_WRITE_SETFIELD_MISS	.\include\openflow\openflow-1.3.h	/^    OFPTFPT13_WRITE_SETFIELD_MISS  = 13, \/* Write Set-Field for table-miss. *\/$/;"	e	enum:ofp13_action_self_learning::ofp13_table_feature_prop_type
OFPTFPT_EXPERIMENTER_MASTER	.\include\openflow\openflow-1.4.h	/^    OFPTFPT_EXPERIMENTER_MASTER   = 0xFFFF, \/* Experimenter for master. *\/$/;"	e	enum:ofp14_async_config_prop_type
OFPTFPT_EXPERIMENTER_SLAVE	.\include\openflow\openflow-1.4.h	/^    OFPTFPT_EXPERIMENTER_SLAVE    = 0xFFFE, \/* Experimenter for slave. *\/$/;"	e	enum:ofp14_async_config_prop_type
OFPTMPEF14_IMPORTANCE	.\include\openflow\openflow-1.4.h	/^    OFPTMPEF14_IMPORTANCE      = 1 << 1,     \/* Using flow entry importance. *\/$/;"	e	enum:ofp14_table_mod_prop_eviction_flag
OFPTMPEF14_LIFETIME	.\include\openflow\openflow-1.4.h	/^    OFPTMPEF14_LIFETIME        = 1 << 2,     \/* Using flow entry lifetime. *\/$/;"	e	enum:ofp14_table_mod_prop_eviction_flag
OFPTMPEF14_OTHER	.\include\openflow\openflow-1.4.h	/^    OFPTMPEF14_OTHER           = 1 << 0,     \/* Using other factors. *\/$/;"	e	enum:ofp14_table_mod_prop_eviction_flag
OFPTMPT14_EVICTION	.\include\openflow\openflow-1.4.h	/^    OFPTMPT14_EVICTION               = 0x2,    \/* Eviction property. *\/$/;"	e	enum:ofp14_table_mod_prop_type
OFPTMPT14_EXPERIMENTER	.\include\openflow\openflow-1.4.h	/^    OFPTMPT14_EXPERIMENTER           = 0xFFFF, \/* Experimenter property. *\/$/;"	e	enum:ofp14_table_mod_prop_type
OFPTMPT14_VACANCY	.\include\openflow\openflow-1.4.h	/^    OFPTMPT14_VACANCY                = 0x3,    \/* Vacancy property. *\/$/;"	e	enum:ofp14_table_mod_prop_type
OFPTT_ALL	.\include\openflow\openflow-common.h	/^    OFPTT_ALL = 0xff         \/* Wildcard table used for table config,$/;"	e	enum:ofp_table
OFPTT_MAX	.\include\openflow\openflow-common.h	/^    OFPTT_MAX = 0xfe,$/;"	e	enum:ofp_table
OFPTYPE_AGGREGATE_STATS_REPLY	.\lib\ofp-msgs.h	/^    OFPTYPE_AGGREGATE_STATS_REPLY,   \/* OFPRAW_OFPST_AGGREGATE_REPLY.$/;"	e	enum:ofptype
OFPTYPE_AGGREGATE_STATS_REQUEST	.\lib\ofp-msgs.h	/^    OFPTYPE_AGGREGATE_STATS_REQUEST, \/* OFPRAW_OFPST10_AGGREGATE_REQUEST.$/;"	e	enum:ofptype
OFPTYPE_BARRIER_REPLY	.\lib\ofp-msgs.h	/^    OFPTYPE_BARRIER_REPLY,       \/* OFPRAW_OFPT10_BARRIER_REPLY.$/;"	e	enum:ofptype
OFPTYPE_BARRIER_REQUEST	.\lib\ofp-msgs.h	/^    OFPTYPE_BARRIER_REQUEST,     \/* OFPRAW_OFPT10_BARRIER_REQUEST.$/;"	e	enum:ofptype
OFPTYPE_BUNDLE_ADD_MESSAGE	.\lib\ofp-msgs.h	/^    OFPTYPE_BUNDLE_ADD_MESSAGE,   \/* OFPRAW_OFPT14_BUNDLE_ADD_MESSAGE. *\/$/;"	e	enum:ofptype
OFPTYPE_BUNDLE_CONTROL	.\lib\ofp-msgs.h	/^    OFPTYPE_BUNDLE_CONTROL,       \/* OFPRAW_OFPT14_BUNDLE_CONTROL. *\/$/;"	e	enum:ofptype
OFPTYPE_DESC_STATS_REPLY	.\lib\ofp-msgs.h	/^    OFPTYPE_DESC_STATS_REPLY,        \/* OFPRAW_OFPST_DESC_REPLY. *\/$/;"	e	enum:ofptype
OFPTYPE_DESC_STATS_REQUEST	.\lib\ofp-msgs.h	/^    OFPTYPE_DESC_STATS_REQUEST,      \/* OFPRAW_OFPST_DESC_REQUEST. *\/$/;"	e	enum:ofptype
OFPTYPE_ECHO_REPLY	.\lib\ofp-msgs.h	/^    OFPTYPE_ECHO_REPLY,          \/* OFPRAW_OFPT_ECHO_REPLY. *\/$/;"	e	enum:ofptype
OFPTYPE_ECHO_REQUEST	.\lib\ofp-msgs.h	/^    OFPTYPE_ECHO_REQUEST,        \/* OFPRAW_OFPT_ECHO_REQUEST. *\/$/;"	e	enum:ofptype
OFPTYPE_ERROR	.\lib\ofp-msgs.h	/^    OFPTYPE_ERROR,               \/* OFPRAW_OFPT_ERROR. *\/$/;"	e	enum:ofptype
OFPTYPE_FEATURES_REPLY	.\lib\ofp-msgs.h	/^    OFPTYPE_FEATURES_REPLY,      \/* OFPRAW_OFPT10_FEATURES_REPLY.$/;"	e	enum:ofptype
OFPTYPE_FEATURES_REQUEST	.\lib\ofp-msgs.h	/^    OFPTYPE_FEATURES_REQUEST,    \/* OFPRAW_OFPT_FEATURES_REQUEST. *\/$/;"	e	enum:ofptype
OFPTYPE_FLOW_AGE	.\lib\ofp-msgs.h	/^    OFPTYPE_FLOW_AGE,             \/* OFPRAW_NXT_FLOW_AGE. *\/$/;"	e	enum:ofptype
OFPTYPE_FLOW_MOD	.\lib\ofp-msgs.h	/^    OFPTYPE_FLOW_MOD,            \/* OFPRAW_OFPT10_FLOW_MOD.$/;"	e	enum:ofptype
OFPTYPE_FLOW_MOD_TABLE_ID	.\lib\ofp-msgs.h	/^    OFPTYPE_FLOW_MOD_TABLE_ID,    \/* OFPRAW_NXT_FLOW_MOD_TABLE_ID. *\/$/;"	e	enum:ofptype
OFPTYPE_FLOW_MONITOR_CANCEL	.\lib\ofp-msgs.h	/^    OFPTYPE_FLOW_MONITOR_CANCEL,        \/* OFPRAW_NXT_FLOW_MONITOR_CANCEL. *\/$/;"	e	enum:ofptype
OFPTYPE_FLOW_MONITOR_PAUSED	.\lib\ofp-msgs.h	/^    OFPTYPE_FLOW_MONITOR_PAUSED,        \/* OFPRAW_NXT_FLOW_MONITOR_PAUSED. *\/$/;"	e	enum:ofptype
OFPTYPE_FLOW_MONITOR_RESUMED	.\lib\ofp-msgs.h	/^    OFPTYPE_FLOW_MONITOR_RESUMED,       \/* OFPRAW_NXT_FLOW_MONITOR_RESUMED. *\/$/;"	e	enum:ofptype
OFPTYPE_FLOW_MONITOR_STATS_REPLY	.\lib\ofp-msgs.h	/^    OFPTYPE_FLOW_MONITOR_STATS_REPLY,   \/* OFPRAW_NXST_FLOW_MONITOR_REPLY. *\/$/;"	e	enum:ofptype
OFPTYPE_FLOW_MONITOR_STATS_REQUEST	.\lib\ofp-msgs.h	/^    OFPTYPE_FLOW_MONITOR_STATS_REQUEST, \/* OFPRAW_NXST_FLOW_MONITOR_REQUEST. *\/$/;"	e	enum:ofptype
OFPTYPE_FLOW_REMOVED	.\lib\ofp-msgs.h	/^    OFPTYPE_FLOW_REMOVED,        \/* OFPRAW_OFPT10_FLOW_REMOVED.$/;"	e	enum:ofptype
OFPTYPE_FLOW_STATS_REPLY	.\lib\ofp-msgs.h	/^    OFPTYPE_FLOW_STATS_REPLY,        \/* OFPRAW_OFPST10_FLOW_REPLY.$/;"	e	enum:ofptype
OFPTYPE_FLOW_STATS_REQUEST	.\lib\ofp-msgs.h	/^    OFPTYPE_FLOW_STATS_REQUEST,      \/* OFPRAW_OFPST10_FLOW_REQUEST.$/;"	e	enum:ofptype
OFPTYPE_GET_ASYNC_REPLY	.\lib\ofp-msgs.h	/^    OFPTYPE_GET_ASYNC_REPLY,      \/* OFPRAW_OFPT13_GET_ASYNC_REPLY. *\/$/;"	e	enum:ofptype
OFPTYPE_GET_ASYNC_REQUEST	.\lib\ofp-msgs.h	/^    OFPTYPE_GET_ASYNC_REQUEST,    \/* OFPRAW_OFPT13_GET_ASYNC_REQUEST. *\/$/;"	e	enum:ofptype
OFPTYPE_GET_CONFIG_REPLY	.\lib\ofp-msgs.h	/^    OFPTYPE_GET_CONFIG_REPLY,    \/* OFPRAW_OFPT_GET_CONFIG_REPLY. *\/$/;"	e	enum:ofptype
OFPTYPE_GET_CONFIG_REQUEST	.\lib\ofp-msgs.h	/^    OFPTYPE_GET_CONFIG_REQUEST,  \/* OFPRAW_OFPT_GET_CONFIG_REQUEST. *\/$/;"	e	enum:ofptype
OFPTYPE_GROUP_DESC_STATS_REPLY	.\lib\ofp-msgs.h	/^    OFPTYPE_GROUP_DESC_STATS_REPLY,  \/* OFPRAW_OFPST11_GROUP_DESC_REPLY. *\/$/;"	e	enum:ofptype
OFPTYPE_GROUP_DESC_STATS_REQUEST	.\lib\ofp-msgs.h	/^    OFPTYPE_GROUP_DESC_STATS_REQUEST, \/* OFPRAW_OFPST11_GROUP_DESC_REQUEST.$/;"	e	enum:ofptype
OFPTYPE_GROUP_FEATURES_STATS_REPLY	.\lib\ofp-msgs.h	/^    OFPTYPE_GROUP_FEATURES_STATS_REPLY, \/* OFPRAW_OFPST12_GROUP_FEATURES_REPLY. *\/$/;"	e	enum:ofptype
OFPTYPE_GROUP_FEATURES_STATS_REQUEST	.\lib\ofp-msgs.h	/^    OFPTYPE_GROUP_FEATURES_STATS_REQUEST, \/* OFPRAW_OFPST12_GROUP_FEATURES_REQUEST. *\/$/;"	e	enum:ofptype
OFPTYPE_GROUP_MOD	.\lib\ofp-msgs.h	/^    OFPTYPE_GROUP_MOD,           \/* OFPRAW_OFPT11_GROUP_MOD. *\/$/;"	e	enum:ofptype
OFPTYPE_GROUP_STATS_REPLY	.\lib\ofp-msgs.h	/^    OFPTYPE_GROUP_STATS_REPLY,       \/* OFPRAW_OFPST11_GROUP_REPLY.$/;"	e	enum:ofptype
OFPTYPE_GROUP_STATS_REQUEST	.\lib\ofp-msgs.h	/^    OFPTYPE_GROUP_STATS_REQUEST,     \/* OFPRAW_OFPST11_GROUP_REQUEST. *\/$/;"	e	enum:ofptype
OFPTYPE_HELLO	.\lib\ofp-msgs.h	/^    OFPTYPE_HELLO,               \/* OFPRAW_OFPT_HELLO. *\/$/;"	e	enum:ofptype
OFPTYPE_METER_CONFIG_STATS_REPLY	.\lib\ofp-msgs.h	/^    OFPTYPE_METER_CONFIG_STATS_REPLY, \/* OFPRAW_OFPST13_METER_CONFIG_REPLY. *\/$/;"	e	enum:ofptype
OFPTYPE_METER_CONFIG_STATS_REQUEST	.\lib\ofp-msgs.h	/^    OFPTYPE_METER_CONFIG_STATS_REQUEST, \/* OFPRAW_OFPST13_METER_CONFIG_REQUEST. *\/$/;"	e	enum:ofptype
OFPTYPE_METER_FEATURES_STATS_REPLY	.\lib\ofp-msgs.h	/^    OFPTYPE_METER_FEATURES_STATS_REPLY, \/* OFPRAW_OFPST13_METER_FEATURES_REPLY. *\/$/;"	e	enum:ofptype
OFPTYPE_METER_FEATURES_STATS_REQUEST	.\lib\ofp-msgs.h	/^    OFPTYPE_METER_FEATURES_STATS_REQUEST, \/* OFPRAW_OFPST13_METER_FEATURES_REQUEST. *\/$/;"	e	enum:ofptype
OFPTYPE_METER_MOD	.\lib\ofp-msgs.h	/^    OFPTYPE_METER_MOD,            \/* OFPRAW_OFPT13_METER_MOD. *\/$/;"	e	enum:ofptype
OFPTYPE_METER_STATS_REPLY	.\lib\ofp-msgs.h	/^    OFPTYPE_METER_STATS_REPLY,       \/* OFPRAW_OFPST13_METER_REPLY. *\/$/;"	e	enum:ofptype
OFPTYPE_METER_STATS_REQUEST	.\lib\ofp-msgs.h	/^    OFPTYPE_METER_STATS_REQUEST,     \/* OFPRAW_OFPST13_METER_REQUEST. *\/$/;"	e	enum:ofptype
OFPTYPE_PACKET_IN	.\lib\ofp-msgs.h	/^    OFPTYPE_PACKET_IN,           \/* OFPRAW_OFPT10_PACKET_IN.$/;"	e	enum:ofptype
OFPTYPE_PACKET_OUT	.\lib\ofp-msgs.h	/^    OFPTYPE_PACKET_OUT,          \/* OFPRAW_OFPT10_PACKET_OUT.$/;"	e	enum:ofptype
OFPTYPE_PORT_DESC_STATS_REPLY	.\lib\ofp-msgs.h	/^    OFPTYPE_PORT_DESC_STATS_REPLY,   \/* OFPRAW_OFPST10_PORT_DESC_REPLY.$/;"	e	enum:ofptype
OFPTYPE_PORT_DESC_STATS_REQUEST	.\lib\ofp-msgs.h	/^    OFPTYPE_PORT_DESC_STATS_REQUEST, \/* OFPRAW_OFPST10_PORT_DESC_REQUEST.$/;"	e	enum:ofptype
OFPTYPE_PORT_MOD	.\lib\ofp-msgs.h	/^    OFPTYPE_PORT_MOD,            \/* OFPRAW_OFPT10_PORT_MOD.$/;"	e	enum:ofptype
OFPTYPE_PORT_STATS_REPLY	.\lib\ofp-msgs.h	/^    OFPTYPE_PORT_STATS_REPLY,        \/* OFPRAW_OFPST10_PORT_REPLY.$/;"	e	enum:ofptype
OFPTYPE_PORT_STATS_REQUEST	.\lib\ofp-msgs.h	/^    OFPTYPE_PORT_STATS_REQUEST,      \/* OFPRAW_OFPST10_PORT_REQUEST.$/;"	e	enum:ofptype
OFPTYPE_PORT_STATUS	.\lib\ofp-msgs.h	/^    OFPTYPE_PORT_STATUS,         \/* OFPRAW_OFPT10_PORT_STATUS.$/;"	e	enum:ofptype
OFPTYPE_QUEUE_GET_CONFIG_REPLY	.\lib\ofp-msgs.h	/^    OFPTYPE_QUEUE_GET_CONFIG_REPLY, \/* OFPRAW_OFPT10_QUEUE_GET_CONFIG_REPLY.$/;"	e	enum:ofptype
OFPTYPE_QUEUE_GET_CONFIG_REQUEST	.\lib\ofp-msgs.h	/^    OFPTYPE_QUEUE_GET_CONFIG_REQUEST, \/* OFPRAW_OFPT10_QUEUE_GET_CONFIG_REQUEST.$/;"	e	enum:ofptype
OFPTYPE_QUEUE_STATS_REPLY	.\lib\ofp-msgs.h	/^    OFPTYPE_QUEUE_STATS_REPLY,       \/* OFPRAW_OFPST10_QUEUE_REPLY.$/;"	e	enum:ofptype
OFPTYPE_QUEUE_STATS_REQUEST	.\lib\ofp-msgs.h	/^    OFPTYPE_QUEUE_STATS_REQUEST,     \/* OFPRAW_OFPST10_QUEUE_REQUEST.$/;"	e	enum:ofptype
OFPTYPE_ROLE_REPLY	.\lib\ofp-msgs.h	/^    OFPTYPE_ROLE_REPLY,           \/* OFPRAW_OFPT12_ROLE_REPLY.$/;"	e	enum:ofptype
OFPTYPE_ROLE_REQUEST	.\lib\ofp-msgs.h	/^    OFPTYPE_ROLE_REQUEST,         \/* OFPRAW_OFPT12_ROLE_REQUEST.$/;"	e	enum:ofptype
OFPTYPE_ROLE_STATUS	.\lib\ofp-msgs.h	/^    OFPTYPE_ROLE_STATUS,          \/* OFPRAW_OFPT14_ROLE_STATUS. *\/$/;"	e	enum:ofptype
OFPTYPE_SET_ASYNC_CONFIG	.\lib\ofp-msgs.h	/^    OFPTYPE_SET_ASYNC_CONFIG,     \/* OFPRAW_NXT_SET_ASYNC_CONFIG.$/;"	e	enum:ofptype
OFPTYPE_SET_CONFIG	.\lib\ofp-msgs.h	/^    OFPTYPE_SET_CONFIG,          \/* OFPRAW_OFPT_SET_CONFIG. *\/$/;"	e	enum:ofptype
OFPTYPE_SET_CONTROLLER_ID	.\lib\ofp-msgs.h	/^    OFPTYPE_SET_CONTROLLER_ID,    \/* OFPRAW_NXT_SET_CONTROLLER_ID. *\/$/;"	e	enum:ofptype
OFPTYPE_SET_FLOW_FORMAT	.\lib\ofp-msgs.h	/^    OFPTYPE_SET_FLOW_FORMAT,      \/* OFPRAW_NXT_SET_FLOW_FORMAT. *\/$/;"	e	enum:ofptype
OFPTYPE_SET_PACKET_IN_FORMAT	.\lib\ofp-msgs.h	/^    OFPTYPE_SET_PACKET_IN_FORMAT, \/* OFPRAW_NXT_SET_PACKET_IN_FORMAT. *\/$/;"	e	enum:ofptype
OFPTYPE_TABLE_FEATURES_STATS_REPLY	.\lib\ofp-msgs.h	/^    OFPTYPE_TABLE_FEATURES_STATS_REPLY, \/* OFPRAW_OFPST13_TABLE_FEATURES_REPLY. *\/$/;"	e	enum:ofptype
OFPTYPE_TABLE_FEATURES_STATS_REQUEST	.\lib\ofp-msgs.h	/^    OFPTYPE_TABLE_FEATURES_STATS_REQUEST, \/* OFPRAW_OFPST13_TABLE_FEATURES_REQUEST. *\/$/;"	e	enum:ofptype
OFPTYPE_TABLE_MOD	.\lib\ofp-msgs.h	/^    OFPTYPE_TABLE_MOD,           \/* OFPRAW_OFPT11_TABLE_MOD.$/;"	e	enum:ofptype
OFPTYPE_TABLE_STATS_REPLY	.\lib\ofp-msgs.h	/^    OFPTYPE_TABLE_STATS_REPLY,       \/* OFPRAW_OFPST10_TABLE_REPLY.$/;"	e	enum:ofptype
OFPTYPE_TABLE_STATS_REQUEST	.\lib\ofp-msgs.h	/^    OFPTYPE_TABLE_STATS_REQUEST,     \/* OFPRAW_OFPST_TABLE_REQUEST. *\/$/;"	e	enum:ofptype
OFPT_VENDOR	.\lib\ofp-msgs.c	31;"	d	file:
OFPUTIL_ACTION_INVALID	.\lib\ofp-util.h	/^    OFPUTIL_ACTION_INVALID,$/;"	e	enum:ofputil_action_code
OFPUTIL_A_COPY_TTL_IN	.\lib\ofp-util.h	/^    OFPUTIL_A_COPY_TTL_IN    = 1 << 14,$/;"	e	enum:ofputil_action_bitmap
OFPUTIL_A_COPY_TTL_OUT	.\lib\ofp-util.h	/^    OFPUTIL_A_COPY_TTL_OUT   = 1 << 13,$/;"	e	enum:ofputil_action_bitmap
OFPUTIL_A_DEC_MPLS_TTL	.\lib\ofp-util.h	/^    OFPUTIL_A_DEC_MPLS_TTL   = 1 << 18,$/;"	e	enum:ofputil_action_bitmap
OFPUTIL_A_DEC_NW_TTL	.\lib\ofp-util.h	/^    OFPUTIL_A_DEC_NW_TTL     = 1 << 26,$/;"	e	enum:ofputil_action_bitmap
OFPUTIL_A_ENQUEUE	.\lib\ofp-util.h	/^    OFPUTIL_A_ENQUEUE        = 1 << 12,$/;"	e	enum:ofputil_action_bitmap
OFPUTIL_A_GROUP	.\lib\ofp-util.h	/^    OFPUTIL_A_GROUP          = 1 << 24,$/;"	e	enum:ofputil_action_bitmap
OFPUTIL_A_OUTPUT	.\lib\ofp-util.h	/^    OFPUTIL_A_OUTPUT         = 1 << 0,$/;"	e	enum:ofputil_action_bitmap
OFPUTIL_A_POP_MPLS	.\lib\ofp-util.h	/^    OFPUTIL_A_POP_MPLS       = 1 << 22,$/;"	e	enum:ofputil_action_bitmap
OFPUTIL_A_POP_VLAN	.\lib\ofp-util.h	/^    OFPUTIL_A_POP_VLAN       = 1 << 20,$/;"	e	enum:ofputil_action_bitmap
OFPUTIL_A_PUSH_MPLS	.\lib\ofp-util.h	/^    OFPUTIL_A_PUSH_MPLS      = 1 << 21,$/;"	e	enum:ofputil_action_bitmap
OFPUTIL_A_PUSH_VLAN	.\lib\ofp-util.h	/^    OFPUTIL_A_PUSH_VLAN      = 1 << 19,$/;"	e	enum:ofputil_action_bitmap
OFPUTIL_A_SET_DL_DST	.\lib\ofp-util.h	/^    OFPUTIL_A_SET_DL_DST     = 1 << 5,$/;"	e	enum:ofputil_action_bitmap
OFPUTIL_A_SET_DL_SRC	.\lib\ofp-util.h	/^    OFPUTIL_A_SET_DL_SRC     = 1 << 4,$/;"	e	enum:ofputil_action_bitmap
OFPUTIL_A_SET_FIELD	.\lib\ofp-util.h	/^    OFPUTIL_A_SET_FIELD      = 1 << 27,$/;"	e	enum:ofputil_action_bitmap
OFPUTIL_A_SET_MPLS_LABEL	.\lib\ofp-util.h	/^    OFPUTIL_A_SET_MPLS_LABEL = 1 << 15,$/;"	e	enum:ofputil_action_bitmap
OFPUTIL_A_SET_MPLS_TC	.\lib\ofp-util.h	/^    OFPUTIL_A_SET_MPLS_TC    = 1 << 16,$/;"	e	enum:ofputil_action_bitmap
OFPUTIL_A_SET_MPLS_TTL	.\lib\ofp-util.h	/^    OFPUTIL_A_SET_MPLS_TTL   = 1 << 17,$/;"	e	enum:ofputil_action_bitmap
OFPUTIL_A_SET_NW_DST	.\lib\ofp-util.h	/^    OFPUTIL_A_SET_NW_DST     = 1 << 7,$/;"	e	enum:ofputil_action_bitmap
OFPUTIL_A_SET_NW_ECN	.\lib\ofp-util.h	/^    OFPUTIL_A_SET_NW_ECN     = 1 << 8,$/;"	e	enum:ofputil_action_bitmap
OFPUTIL_A_SET_NW_SRC	.\lib\ofp-util.h	/^    OFPUTIL_A_SET_NW_SRC     = 1 << 6,$/;"	e	enum:ofputil_action_bitmap
OFPUTIL_A_SET_NW_TOS	.\lib\ofp-util.h	/^    OFPUTIL_A_SET_NW_TOS     = 1 << 9,$/;"	e	enum:ofputil_action_bitmap
OFPUTIL_A_SET_NW_TTL	.\lib\ofp-util.h	/^    OFPUTIL_A_SET_NW_TTL     = 1 << 25,$/;"	e	enum:ofputil_action_bitmap
OFPUTIL_A_SET_QUEUE	.\lib\ofp-util.h	/^    OFPUTIL_A_SET_QUEUE      = 1 << 23,$/;"	e	enum:ofputil_action_bitmap
OFPUTIL_A_SET_TP_DST	.\lib\ofp-util.h	/^    OFPUTIL_A_SET_TP_DST     = 1 << 11,$/;"	e	enum:ofputil_action_bitmap
OFPUTIL_A_SET_TP_SRC	.\lib\ofp-util.h	/^    OFPUTIL_A_SET_TP_SRC     = 1 << 10,$/;"	e	enum:ofputil_action_bitmap
OFPUTIL_A_SET_VLAN_PCP	.\lib\ofp-util.h	/^    OFPUTIL_A_SET_VLAN_PCP   = 1 << 2,$/;"	e	enum:ofputil_action_bitmap
OFPUTIL_A_SET_VLAN_VID	.\lib\ofp-util.h	/^    OFPUTIL_A_SET_VLAN_VID   = 1 << 1,$/;"	e	enum:ofputil_action_bitmap
OFPUTIL_A_STRIP_VLAN	.\lib\ofp-util.h	/^    OFPUTIL_A_STRIP_VLAN     = 1 << 3,$/;"	e	enum:ofputil_action_bitmap
OFPUTIL_C_ARP_MATCH_IP	.\lib\ofp-util.h	/^    OFPUTIL_C_ARP_MATCH_IP   = 1 << 7,  \/* Match IP addresses in ARP pkts. *\/$/;"	e	enum:ofputil_capabilities
OFPUTIL_C_FLOW_STATS	.\lib\ofp-util.h	/^    OFPUTIL_C_FLOW_STATS     = 1 << 0,  \/* Flow statistics. *\/$/;"	e	enum:ofputil_capabilities
OFPUTIL_C_GROUP_STATS	.\lib\ofp-util.h	/^    OFPUTIL_C_GROUP_STATS    = 1 << 4,  \/* Group statistics. *\/$/;"	e	enum:ofputil_capabilities
OFPUTIL_C_IP_REASM	.\lib\ofp-util.h	/^    OFPUTIL_C_IP_REASM       = 1 << 5,  \/* Can reassemble IP fragments. *\/$/;"	e	enum:ofputil_capabilities
OFPUTIL_C_PORT_BLOCKED	.\lib\ofp-util.h	/^    OFPUTIL_C_PORT_BLOCKED   = 1 << 8,  \/* Switch will block looping ports *\/$/;"	e	enum:ofputil_capabilities
OFPUTIL_C_PORT_STATS	.\lib\ofp-util.h	/^    OFPUTIL_C_PORT_STATS     = 1 << 2,  \/* Port statistics. *\/$/;"	e	enum:ofputil_capabilities
OFPUTIL_C_QUEUE_STATS	.\lib\ofp-util.h	/^    OFPUTIL_C_QUEUE_STATS    = 1 << 6,  \/* Queue statistics. *\/$/;"	e	enum:ofputil_capabilities
OFPUTIL_C_STP	.\lib\ofp-util.h	/^    OFPUTIL_C_STP            = 1 << 3,  \/* 802.1d spanning tree. *\/$/;"	e	enum:ofputil_capabilities
OFPUTIL_C_TABLE_STATS	.\lib\ofp-util.h	/^    OFPUTIL_C_TABLE_STATS    = 1 << 1,  \/* Table statistics. *\/$/;"	e	enum:ofputil_capabilities
OFPUTIL_DEFAULT_VERSIONS	.\lib\ofp-util.h	186;"	d
OFPUTIL_FF_CHECK_OVERLAP	.\lib\ofp-util.h	/^    OFPUTIL_FF_CHECK_OVERLAP = 1 << 3, \/* All versions. *\/$/;"	e	enum:ofputil_flow_mod_flags
OFPUTIL_FF_EMERG	.\lib\ofp-util.h	/^    OFPUTIL_FF_EMERG         = 1 << 4, \/* OpenFlow 1.0 only. *\/$/;"	e	enum:ofputil_flow_mod_flags
OFPUTIL_FF_HIDDEN_FIELDS	.\lib\ofp-util.h	/^    OFPUTIL_FF_HIDDEN_FIELDS = 1 << 6, \/* Allow hidden match fields to be$/;"	e	enum:ofputil_flow_mod_flags
OFPUTIL_FF_NO_BYT_COUNTS	.\lib\ofp-util.h	/^    OFPUTIL_FF_NO_BYT_COUNTS = 1 << 2, \/* OpenFlow 1.3+. *\/$/;"	e	enum:ofputil_flow_mod_flags
OFPUTIL_FF_NO_PKT_COUNTS	.\lib\ofp-util.h	/^    OFPUTIL_FF_NO_PKT_COUNTS = 1 << 1, \/* OpenFlow 1.3+. *\/$/;"	e	enum:ofputil_flow_mod_flags
OFPUTIL_FF_NO_READONLY	.\lib\ofp-util.h	/^    OFPUTIL_FF_NO_READONLY   = 1 << 7, \/* Allow rules within read only tables$/;"	e	enum:ofputil_flow_mod_flags
OFPUTIL_FF_RESET_COUNTS	.\lib\ofp-util.h	/^    OFPUTIL_FF_RESET_COUNTS  = 1 << 5, \/* OpenFlow 1.2+. *\/$/;"	e	enum:ofputil_flow_mod_flags
OFPUTIL_FF_SEND_FLOW_REM	.\lib\ofp-util.h	/^    OFPUTIL_FF_SEND_FLOW_REM = 1 << 0, \/* All versions. *\/$/;"	e	enum:ofputil_flow_mod_flags
OFPUTIL_FF_STATE	.\lib\ofp-util.h	248;"	d
OFPUTIL_METER_CONFIG	.\lib\ofp-util.h	/^    OFPUTIL_METER_CONFIG,$/;"	e	enum:ofputil_meter_request_type
OFPUTIL_METER_FEATURES	.\lib\ofp-util.h	/^    OFPUTIL_METER_FEATURES,$/;"	e	enum:ofputil_meter_request_type
OFPUTIL_METER_STATS	.\lib\ofp-util.h	/^    OFPUTIL_METER_STATS$/;"	e	enum:ofputil_meter_request_type
OFPUTIL_NAMED_PORT	.\lib\ofp-util.c	5707;"	d	file:
OFPUTIL_NAMED_PORT	.\lib\ofp-util.c	5709;"	d	file:
OFPUTIL_NAMED_PORT	.\lib\ofp-util.c	5744;"	d	file:
OFPUTIL_NAMED_PORT	.\lib\ofp-util.c	5749;"	d	file:
OFPUTIL_NAMED_PORTS	.\lib\ofp-util.c	5638;"	d	file:
OFPUTIL_NAMED_PORTS_WITH_NONE	.\lib\ofp-util.c	5649;"	d	file:
OFPUTIL_N_ACTIONS	.\lib\ofp-util.h	/^    OFPUTIL_N_ACTIONS = 1$/;"	e	enum:__anon78
OFPUTIL_PACKET_IN_REASON_BUFSIZE	.\lib\ofp-util.h	/^enum { OFPUTIL_PACKET_IN_REASON_BUFSIZE = INT_STRLEN(int) + 1 };$/;"	e	enum:__anon76
OFPUTIL_PC_NO_FLOOD	.\lib\ofp-util.h	/^    OFPUTIL_PC_NO_FLOOD     = 1 << 4, \/* Do not include port when flooding. *\/$/;"	e	enum:ofputil_port_config
OFPUTIL_PC_NO_FWD	.\lib\ofp-util.h	/^    OFPUTIL_PC_NO_FWD       = 1 << 5, \/* Drop packets forwarded to port. *\/$/;"	e	enum:ofputil_port_config
OFPUTIL_PC_NO_PACKET_IN	.\lib\ofp-util.h	/^    OFPUTIL_PC_NO_PACKET_IN = 1 << 6, \/* No send packet-in msgs for port. *\/$/;"	e	enum:ofputil_port_config
OFPUTIL_PC_NO_RECV	.\lib\ofp-util.h	/^    OFPUTIL_PC_NO_RECV      = 1 << 2, \/* Drop all packets received by port. *\/$/;"	e	enum:ofputil_port_config
OFPUTIL_PC_NO_RECV_STP	.\lib\ofp-util.h	/^    OFPUTIL_PC_NO_RECV_STP  = 1 << 3, \/* Drop received 802.1D STP packets. *\/$/;"	e	enum:ofputil_port_config
OFPUTIL_PC_NO_STP	.\lib\ofp-util.h	/^    OFPUTIL_PC_NO_STP       = 1 << 1, \/* No 802.1D spanning tree for port. *\/$/;"	e	enum:ofputil_port_config
OFPUTIL_PC_PORT_DOWN	.\lib\ofp-util.h	/^    OFPUTIL_PC_PORT_DOWN    = 1 << 0, \/* Port is administratively down. *\/$/;"	e	enum:ofputil_port_config
OFPUTIL_PS_BLOCKED	.\lib\ofp-util.h	/^    OFPUTIL_PS_BLOCKED     = 1 << 1, \/* Port is blocked *\/$/;"	e	enum:ofputil_port_state
OFPUTIL_PS_LINK_DOWN	.\lib\ofp-util.h	/^    OFPUTIL_PS_LINK_DOWN   = 1 << 0, \/* No physical link present. *\/$/;"	e	enum:ofputil_port_state
OFPUTIL_PS_LIVE	.\lib\ofp-util.h	/^    OFPUTIL_PS_LIVE        = 1 << 2, \/* Live for Fast Failover Group. *\/$/;"	e	enum:ofputil_port_state
OFPUTIL_PS_STP_BLOCK	.\lib\ofp-util.h	/^    OFPUTIL_PS_STP_BLOCK   = 3 << 8, \/* Not part of spanning tree. *\/$/;"	e	enum:ofputil_port_state
OFPUTIL_PS_STP_FORWARD	.\lib\ofp-util.h	/^    OFPUTIL_PS_STP_FORWARD = 2 << 8, \/* Learning and relaying frames. *\/$/;"	e	enum:ofputil_port_state
OFPUTIL_PS_STP_LEARN	.\lib\ofp-util.h	/^    OFPUTIL_PS_STP_LEARN   = 1 << 8, \/* Learning but not relaying frames. *\/$/;"	e	enum:ofputil_port_state
OFPUTIL_PS_STP_LISTEN	.\lib\ofp-util.h	/^    OFPUTIL_PS_STP_LISTEN  = 0 << 8, \/* Not learning or relaying frames. *\/$/;"	e	enum:ofputil_port_state
OFPUTIL_PS_STP_MASK	.\lib\ofp-util.h	/^    OFPUTIL_PS_STP_MASK    = 3 << 8  \/* Bit mask for OFPPS10_STP_* values. *\/$/;"	e	enum:ofputil_port_state
OFPUTIL_P_ANY	.\lib\ofp-util.h	132;"	d
OFPUTIL_P_ANY_OXM	.\lib\ofp-util.h	114;"	d
OFPUTIL_P_NONE	.\lib\ofp-util.h	85;"	d
OFPUTIL_P_NXM_OF11_UP	.\lib\ofp-util.h	119;"	d
OFPUTIL_P_NXM_OXM_ANY	.\lib\ofp-util.h	122;"	d
OFPUTIL_P_OF10_ANY	.\lib\ofp-util.h	92;"	d
OFPUTIL_P_OF10_NXM	.\lib\ofp-util.h	/^    OFPUTIL_P_OF10_NXM     = 1 << 2,$/;"	e	enum:ofputil_protocol
OFPUTIL_P_OF10_NXM_ANY	.\lib\ofp-util.h	91;"	d
OFPUTIL_P_OF10_NXM_TID	.\lib\ofp-util.h	/^    OFPUTIL_P_OF10_NXM_TID = 1 << 3,$/;"	e	enum:ofputil_protocol
OFPUTIL_P_OF10_STD	.\lib\ofp-util.h	/^    OFPUTIL_P_OF10_STD     = 1 << 0,$/;"	e	enum:ofputil_protocol
OFPUTIL_P_OF10_STD_ANY	.\lib\ofp-util.h	90;"	d
OFPUTIL_P_OF10_STD_TID	.\lib\ofp-util.h	/^    OFPUTIL_P_OF10_STD_TID = 1 << 1,$/;"	e	enum:ofputil_protocol
OFPUTIL_P_OF11_STD	.\lib\ofp-util.h	/^    OFPUTIL_P_OF11_STD     = 1 << 4,$/;"	e	enum:ofputil_protocol
OFPUTIL_P_OF11_UP	.\lib\ofp-util.h	124;"	d
OFPUTIL_P_OF12_OXM	.\lib\ofp-util.h	/^    OFPUTIL_P_OF12_OXM      = 1 << 5,$/;"	e	enum:ofputil_protocol
OFPUTIL_P_OF12_UP	.\lib\ofp-util.h	126;"	d
OFPUTIL_P_OF13_OXM	.\lib\ofp-util.h	/^    OFPUTIL_P_OF13_OXM      = 1 << 6,$/;"	e	enum:ofputil_protocol
OFPUTIL_P_OF13_UP	.\lib\ofp-util.h	127;"	d
OFPUTIL_P_OF14_OXM	.\lib\ofp-util.h	/^    OFPUTIL_P_OF14_OXM      = 1 << 7,$/;"	e	enum:ofputil_protocol
OFPUTIL_P_OF14_UP	.\lib\ofp-util.h	128;"	d
OFPUTIL_P_OF15_OXM	.\lib\ofp-util.h	/^    OFPUTIL_P_OF15_OXM      = 1 << 8,$/;"	e	enum:ofputil_protocol
OFPUTIL_P_OF15_UP	.\lib\ofp-util.h	129;"	d
OFPUTIL_P_TID	.\lib\ofp-util.h	135;"	d
OFPUTIL_SUPPORTED_VERSIONS	.\lib\ofp-util.h	182;"	d
OFPVID11_ANY	.\include\openflow\openflow-1.1.h	/^    OFPVID11_ANY = 0xfffe,  \/* Indicate that a VLAN id is set but don't care$/;"	e	enum:ofp11_vlan_id
OFPVID11_NONE	.\include\openflow\openflow-1.1.h	/^    OFPVID11_NONE = 0xffff, \/* No VLAN id was set. *\/$/;"	e	enum:ofp11_vlan_id
OFPVID12_NONE	.\include\openflow\openflow-1.2.h	/^    OFPVID12_NONE    = 0x0000, \/* No VLAN id was set. *\/$/;"	e	enum:ofp12_vlan_id
OFPVID12_PRESENT	.\include\openflow\openflow-1.2.h	/^    OFPVID12_PRESENT = 0x1000, \/* Bit that indicate that a VLAN id is set *\/$/;"	e	enum:ofp12_vlan_id
OFPXMC12_EXPERIMENTER	.\include\openflow\openflow-1.2.h	/^    OFPXMC12_EXPERIMENTER   = 0xffff, \/* Experimenter class *\/$/;"	e	enum:ofp12_oxm_class
OFPXMC12_NXM_0	.\include\openflow\openflow-1.2.h	/^    OFPXMC12_NXM_0          = 0x0000, \/* Backward compatibility with NXM *\/$/;"	e	enum:ofp12_oxm_class
OFPXMC12_NXM_1	.\include\openflow\openflow-1.2.h	/^    OFPXMC12_NXM_1          = 0x0001, \/* Backward compatibility with NXM *\/$/;"	e	enum:ofp12_oxm_class
OFPXMC12_OPENFLOW_BASIC	.\include\openflow\openflow-1.2.h	/^    OFPXMC12_OPENFLOW_BASIC = 0x8000, \/* Basic class for OpenFlow *\/$/;"	e	enum:ofp12_oxm_class
OFPXMT12_MASK	.\include\openflow\openflow-1.2.h	112;"	d
OFPXMT12_OFB_ARP_OP	.\include\openflow\openflow-1.2.h	/^    OFPXMT12_OFB_ARP_OP,         \/* ARP opcode. *\/$/;"	e	enum:oxm12_ofb_match_fields
OFPXMT12_OFB_ARP_SHA	.\include\openflow\openflow-1.2.h	/^    OFPXMT12_OFB_ARP_SHA,        \/* ARP source hardware address. *\/$/;"	e	enum:oxm12_ofb_match_fields
OFPXMT12_OFB_ARP_SPA	.\include\openflow\openflow-1.2.h	/^    OFPXMT12_OFB_ARP_SPA,        \/* ARP source IPv4 address. *\/$/;"	e	enum:oxm12_ofb_match_fields
OFPXMT12_OFB_ARP_THA	.\include\openflow\openflow-1.2.h	/^    OFPXMT12_OFB_ARP_THA,        \/* ARP target hardware address. *\/$/;"	e	enum:oxm12_ofb_match_fields
OFPXMT12_OFB_ARP_TPA	.\include\openflow\openflow-1.2.h	/^    OFPXMT12_OFB_ARP_TPA,        \/* ARP target IPv4 address. *\/$/;"	e	enum:oxm12_ofb_match_fields
OFPXMT12_OFB_ETH_DST	.\include\openflow\openflow-1.2.h	/^    OFPXMT12_OFB_ETH_DST,        \/* Ethernet destination address. *\/$/;"	e	enum:oxm12_ofb_match_fields
OFPXMT12_OFB_ETH_SRC	.\include\openflow\openflow-1.2.h	/^    OFPXMT12_OFB_ETH_SRC,        \/* Ethernet source address. *\/$/;"	e	enum:oxm12_ofb_match_fields
OFPXMT12_OFB_ETH_TYPE	.\include\openflow\openflow-1.2.h	/^    OFPXMT12_OFB_ETH_TYPE,       \/* Ethernet frame type. *\/$/;"	e	enum:oxm12_ofb_match_fields
OFPXMT12_OFB_ICMPV4_CODE	.\include\openflow\openflow-1.2.h	/^    OFPXMT12_OFB_ICMPV4_CODE,    \/* ICMP code. *\/$/;"	e	enum:oxm12_ofb_match_fields
OFPXMT12_OFB_ICMPV4_TYPE	.\include\openflow\openflow-1.2.h	/^    OFPXMT12_OFB_ICMPV4_TYPE,    \/* ICMP type. *\/$/;"	e	enum:oxm12_ofb_match_fields
OFPXMT12_OFB_ICMPV6_CODE	.\include\openflow\openflow-1.2.h	/^    OFPXMT12_OFB_ICMPV6_CODE,    \/* ICMPv6 code. *\/$/;"	e	enum:oxm12_ofb_match_fields
OFPXMT12_OFB_ICMPV6_TYPE	.\include\openflow\openflow-1.2.h	/^    OFPXMT12_OFB_ICMPV6_TYPE,    \/* ICMPv6 type. *\/$/;"	e	enum:oxm12_ofb_match_fields
OFPXMT12_OFB_IN_PHY_PORT	.\include\openflow\openflow-1.2.h	/^    OFPXMT12_OFB_IN_PHY_PORT,    \/* Switch physical input port. *\/$/;"	e	enum:oxm12_ofb_match_fields
OFPXMT12_OFB_IN_PORT	.\include\openflow\openflow-1.2.h	/^    OFPXMT12_OFB_IN_PORT,        \/* Switch input port. *\/$/;"	e	enum:oxm12_ofb_match_fields
OFPXMT12_OFB_IPV4_DST	.\include\openflow\openflow-1.2.h	/^    OFPXMT12_OFB_IPV4_DST,       \/* IPv4 destination address. *\/$/;"	e	enum:oxm12_ofb_match_fields
OFPXMT12_OFB_IPV4_SRC	.\include\openflow\openflow-1.2.h	/^    OFPXMT12_OFB_IPV4_SRC,       \/* IPv4 source address. *\/$/;"	e	enum:oxm12_ofb_match_fields
OFPXMT12_OFB_IPV6_DST	.\include\openflow\openflow-1.2.h	/^    OFPXMT12_OFB_IPV6_DST,       \/* IPv6 destination address. *\/$/;"	e	enum:oxm12_ofb_match_fields
OFPXMT12_OFB_IPV6_FLABEL	.\include\openflow\openflow-1.2.h	/^    OFPXMT12_OFB_IPV6_FLABEL,    \/* IPv6 Flow Label *\/$/;"	e	enum:oxm12_ofb_match_fields
OFPXMT12_OFB_IPV6_ND_SLL	.\include\openflow\openflow-1.2.h	/^    OFPXMT12_OFB_IPV6_ND_SLL,    \/* Source link-layer for ND. *\/$/;"	e	enum:oxm12_ofb_match_fields
OFPXMT12_OFB_IPV6_ND_TARGET	.\include\openflow\openflow-1.2.h	/^    OFPXMT12_OFB_IPV6_ND_TARGET, \/* Target address for ND. *\/$/;"	e	enum:oxm12_ofb_match_fields
OFPXMT12_OFB_IPV6_ND_TLL	.\include\openflow\openflow-1.2.h	/^    OFPXMT12_OFB_IPV6_ND_TLL,    \/* Target link-layer for ND. *\/$/;"	e	enum:oxm12_ofb_match_fields
OFPXMT12_OFB_IPV6_SRC	.\include\openflow\openflow-1.2.h	/^    OFPXMT12_OFB_IPV6_SRC,       \/* IPv6 source address. *\/$/;"	e	enum:oxm12_ofb_match_fields
OFPXMT12_OFB_IP_DSCP	.\include\openflow\openflow-1.2.h	/^    OFPXMT12_OFB_IP_DSCP,        \/* IP DSCP (6 bits in ToS field). *\/$/;"	e	enum:oxm12_ofb_match_fields
OFPXMT12_OFB_IP_ECN	.\include\openflow\openflow-1.2.h	/^    OFPXMT12_OFB_IP_ECN,         \/* IP ECN (2 bits in ToS field). *\/$/;"	e	enum:oxm12_ofb_match_fields
OFPXMT12_OFB_IP_PROTO	.\include\openflow\openflow-1.2.h	/^    OFPXMT12_OFB_IP_PROTO,       \/* IP protocol. *\/$/;"	e	enum:oxm12_ofb_match_fields
OFPXMT12_OFB_METADATA	.\include\openflow\openflow-1.2.h	/^    OFPXMT12_OFB_METADATA,       \/* Metadata passed between tables. *\/$/;"	e	enum:oxm12_ofb_match_fields
OFPXMT12_OFB_MPLS_LABEL	.\include\openflow\openflow-1.2.h	/^    OFPXMT12_OFB_MPLS_LABEL,     \/* MPLS label. *\/$/;"	e	enum:oxm12_ofb_match_fields
OFPXMT12_OFB_MPLS_TC	.\include\openflow\openflow-1.2.h	/^    OFPXMT12_OFB_MPLS_TC,        \/* MPLS TC. *\/$/;"	e	enum:oxm12_ofb_match_fields
OFPXMT12_OFB_SCTP_DST	.\include\openflow\openflow-1.2.h	/^    OFPXMT12_OFB_SCTP_DST,       \/* SCTP destination port. *\/$/;"	e	enum:oxm12_ofb_match_fields
OFPXMT12_OFB_SCTP_SRC	.\include\openflow\openflow-1.2.h	/^    OFPXMT12_OFB_SCTP_SRC,       \/* SCTP source port. *\/$/;"	e	enum:oxm12_ofb_match_fields
OFPXMT12_OFB_TCP_DST	.\include\openflow\openflow-1.2.h	/^    OFPXMT12_OFB_TCP_DST,        \/* TCP destination port. *\/$/;"	e	enum:oxm12_ofb_match_fields
OFPXMT12_OFB_TCP_SRC	.\include\openflow\openflow-1.2.h	/^    OFPXMT12_OFB_TCP_SRC,        \/* TCP source port. *\/$/;"	e	enum:oxm12_ofb_match_fields
OFPXMT12_OFB_UDP_DST	.\include\openflow\openflow-1.2.h	/^    OFPXMT12_OFB_UDP_DST,        \/* UDP destination port. *\/$/;"	e	enum:oxm12_ofb_match_fields
OFPXMT12_OFB_UDP_SRC	.\include\openflow\openflow-1.2.h	/^    OFPXMT12_OFB_UDP_SRC,        \/* UDP source port. *\/$/;"	e	enum:oxm12_ofb_match_fields
OFPXMT12_OFB_VLAN_PCP	.\include\openflow\openflow-1.2.h	/^    OFPXMT12_OFB_VLAN_PCP,       \/* VLAN priority. *\/$/;"	e	enum:oxm12_ofb_match_fields
OFPXMT12_OFB_VLAN_VID	.\include\openflow\openflow-1.2.h	/^    OFPXMT12_OFB_VLAN_VID,       \/* VLAN id. *\/$/;"	e	enum:oxm12_ofb_match_fields
OFPXMT13_MASK	.\include\openflow\openflow-1.2.h	119;"	d
OFPXMT13_OFB_IPV6_EXTHDR	.\include\openflow\openflow-1.2.h	/^    OFPXMT13_OFB_IPV6_EXTHDR,    \/* IPv6 Extension Header pseudo-field *\/$/;"	e	enum:oxm12_ofb_match_fields
OFPXMT13_OFB_MPLS_BOS	.\include\openflow\openflow-1.2.h	/^    OFPXMT13_OFB_MPLS_BOS,       \/* MPLS BoS bit. *\/$/;"	e	enum:oxm12_ofb_match_fields
OFPXMT13_OFB_PBB_ISID	.\include\openflow\openflow-1.2.h	/^    OFPXMT13_OFB_PBB_ISID,       \/* PBB I-SID. *\/$/;"	e	enum:oxm12_ofb_match_fields
OFPXMT13_OFB_TUNNEL_ID	.\include\openflow\openflow-1.2.h	/^    OFPXMT13_OFB_TUNNEL_ID,      \/* Logical Port Metadata *\/$/;"	e	enum:oxm12_ofb_match_fields
OFPXMT14_MASK	.\include\openflow\openflow-1.2.h	123;"	d
OFPXMT14_OFB_PBB_UCA	.\include\openflow\openflow-1.2.h	/^    OFPXMT14_OFB_PBB_UCA = 41,  \/* PBB UCA header field. *\/$/;"	e	enum:oxm12_ofb_match_fields
OFPXMT15_MASK	.\include\openflow\openflow-1.2.h	127;"	d
OFPXMT15_OFB_TCP_FLAGS	.\include\openflow\openflow-1.2.h	/^    OFPXMT15_OFB_TCP_FLAGS = 42,  \/* TCP flags. *\/$/;"	e	enum:oxm12_ofb_match_fields
OFP_ACTIONS_H	.\lib\ofp-actions.h	18;"	d
OFP_ACTION_ALIGN	.\lib\ofp-util.h	992;"	d
OFP_ASSERT	.\include\openflow\openflow-common.h	56;"	d
OFP_ASSERT	.\include\openflow\openflow-common.h	59;"	d
OFP_ASSERT	.\include\openflow\openflow-common.h	64;"	d
OFP_DEFAULT_MISS_SEND_LEN	.\include\openflow\openflow-common.h	114;"	d
OFP_DEFAULT_PRIORITY	.\include\openflow\openflow-common.h	132;"	d
OFP_DL_TYPE_ETH2_CUTOFF	.\include\openflow\openflow-common.h	120;"	d
OFP_DL_TYPE_NOT_ETH_TYPE	.\include\openflow\openflow-common.h	125;"	d
OFP_ERRORS_H	.\lib\ofp-errors.h	18;"	d
OFP_ETH_ALEN	.\include\openflow\openflow-common.h	112;"	d
OFP_FLOW_PERMANENT	.\include\openflow\openflow-common.h	129;"	d
OFP_FLOW_REMOVED_REASON_BUFSIZE	.\lib\ofp-print.c	905;"	d	file:
OFP_MAX_PORT_NAME_LEN	.\include\openflow\openflow-common.h	107;"	d
OFP_MAX_TABLE_NAME_LEN	.\include\openflow\openflow-common.h	106;"	d
OFP_MSGS_H	.\lib\ofp-msgs.h	18;"	d
OFP_OLD_PORT	.\include\openflow\openflow-common.h	109;"	d
OFP_PARSE_H	.\lib\ofp-parse.h	20;"	d
OFP_PORT	.\include\openflow\openflow-common.h	110;"	d
OFP_PORT_ACTION_WINDOW	.\vswitchd\bridge.c	207;"	d	file:
OFP_PORT_C	.\include\openvswitch\types.h	103;"	d
OFP_PORT_REASON_BUFSIZE	.\lib\ofp-print.c	2082;"	d	file:
OFP_PRINT_H	.\lib\ofp-print.h	20;"	d
OFP_UTIL_H	.\lib\ofp-util.h	18;"	d
OFP_VERSION_H	.\lib\ofp-version-opt.h	2;"	d
OFP_VERSION_LONG_OPTIONS	.\lib\ofp-version-opt.h	8;"	d
OFP_VERSION_OPTION_HANDLERS	.\lib\ofp-version-opt.h	12;"	d
OFTABLE_HIDDEN	.\ofproto\ofproto-provider.h	/^    OFTABLE_HIDDEN = 1 << 0,   \/* Hide from most OpenFlow operations. *\/$/;"	e	enum:oftable_flags
OFTABLE_READONLY	.\ofproto\ofproto-provider.h	/^    OFTABLE_READONLY = 1 << 1  \/* Don't allow OpenFlow controller to change$/;"	e	enum:oftable_flags
OF_VENDOR_ID	.\include\openflow\openflow-common.h	102;"	d
OJMS_DELETE	.\ovsdb\jsonrpc-server.c	/^    OJMS_DELETE = 1 << 2,       \/* Deleted rows. *\/$/;"	e	enum:ovsdb_jsonrpc_monitor_selection	file:
OJMS_INITIAL	.\ovsdb\jsonrpc-server.c	/^    OJMS_INITIAL = 1 << 0,      \/* All rows when monitor is created. *\/$/;"	e	enum:ovsdb_jsonrpc_monitor_selection	file:
OJMS_INSERT	.\ovsdb\jsonrpc-server.c	/^    OJMS_INSERT = 1 << 1,       \/* New rows. *\/$/;"	e	enum:ovsdb_jsonrpc_monitor_selection	file:
OJMS_MODIFY	.\ovsdb\jsonrpc-server.c	/^    OJMS_MODIFY = 1 << 3        \/* Modified rows. *\/$/;"	e	enum:ovsdb_jsonrpc_monitor_selection	file:
OMIT_STANDARD_ATOMIC_TYPES	.\lib\ovs-atomic-c11.h	25;"	d
ONE_OR_MORE	.\python\compat\argparse.py	/^ONE_OR_MORE = '+'$/;"	v
ONF_VENDOR_ID	.\include\openflow\openflow-common.h	104;"	d
OPENFLOW_11_H	.\include\openflow\openflow-1.1.h	53;"	d
OPENFLOW_12_H	.\include\openflow\openflow-1.2.h	54;"	d
OPENFLOW_13_H	.\include\openflow\openflow-1.3.h	38;"	d
OPENFLOW_14_H	.\include\openflow\openflow-1.4.h	38;"	d
OPENFLOW_COMMON_H	.\include\openflow\openflow-common.h	51;"	d
OPENFLOW_NICIRA_EXT_H	.\include\openflow\nicira-ext.h	18;"	d
OPENFLOW_OPENFLOW10_H	.\include\openflow\openflow-1.0.h	20;"	d
OPENFLOW_OPENFLOW_H	.\include\openflow\openflow.h	18;"	d
OPENVSWITCH_TYPES_H	.\include\openvswitch\types.h	18;"	d
OPTIONAL	.\python\compat\argparse.py	/^OPTIONAL = '?'$/;"	v
OP_ANY	.\lib\ovsdb-parser.h	/^    OP_ANY = (OP_NULL | OP_FALSE | OP_TRUE | OP_OBJECT | OP_ARRAY$/;"	e	enum:ovsdb_parser_types
OP_ARRAY	.\lib\ovsdb-parser.h	/^    OP_ARRAY = 1 << JSON_ARRAY,           \/* [1, 2, 3, ...] *\/$/;"	e	enum:ovsdb_parser_types
OP_BOOLEAN	.\lib\ovsdb-parser.h	/^    OP_BOOLEAN = OP_FALSE | OP_TRUE,$/;"	e	enum:ovsdb_parser_types
OP_FALSE	.\lib\ovsdb-parser.h	/^    OP_FALSE = 1 << JSON_FALSE,           \/* false *\/$/;"	e	enum:ovsdb_parser_types
OP_ID	.\lib\ovsdb-parser.h	/^    OP_ID = 1 << JSON_N_TYPES,            \/* "[_a-zA-Z][_a-zA-Z0-9]*" *\/$/;"	e	enum:ovsdb_parser_types
OP_INTEGER	.\lib\ovsdb-parser.h	/^    OP_INTEGER = 1 << JSON_INTEGER,       \/* 123. *\/$/;"	e	enum:ovsdb_parser_types
OP_NONINTEGER	.\lib\ovsdb-parser.h	/^    OP_NONINTEGER = 1 << JSON_REAL,       \/* 123.456. *\/$/;"	e	enum:ovsdb_parser_types
OP_NULL	.\lib\ovsdb-parser.h	/^    OP_NULL = 1 << JSON_NULL,             \/* null *\/$/;"	e	enum:ovsdb_parser_types
OP_NUMBER	.\lib\ovsdb-parser.h	/^    OP_NUMBER = OP_INTEGER | OP_NONINTEGER,$/;"	e	enum:ovsdb_parser_types
OP_OBJECT	.\lib\ovsdb-parser.h	/^    OP_OBJECT = 1 << JSON_OBJECT,         \/* {"a": b, "c": d, ...} *\/$/;"	e	enum:ovsdb_parser_types
OP_OPTIONAL	.\lib\ovsdb-parser.h	/^    OP_OPTIONAL = 1 << (JSON_N_TYPES + 1) \/* no value at all *\/$/;"	e	enum:ovsdb_parser_types
OP_STRING	.\lib\ovsdb-parser.h	/^    OP_STRING = 1 << JSON_STRING,         \/* "..." *\/$/;"	e	enum:ovsdb_parser_types
OP_TRUE	.\lib\ovsdb-parser.h	/^    OP_TRUE = 1 << JSON_TRUE,             \/* true *\/$/;"	e	enum:ovsdb_parser_types
OUTER	.\build-aux\sodepends.pl	/^  OUTER:$/;"	l
OUTER	.\build-aux\soexpand.pl	/^OUTER: while (<STDIN>) {$/;"	l
OVERWRITE_MSECS	.\ofproto\pktbuf.c	48;"	d	file:
OVSDB_BASE_BOOLEAN_INIT	.\lib\ovsdb-types.h	90;"	d
OVSDB_BASE_INTEGER_INIT	.\lib\ovsdb-types.h	86;"	d
OVSDB_BASE_REAL_INIT	.\lib\ovsdb-types.h	88;"	d
OVSDB_BASE_STRING_INIT	.\lib\ovsdb-types.h	91;"	d
OVSDB_BASE_UUID_INIT	.\lib\ovsdb-types.h	93;"	d
OVSDB_BASE_VOID_INIT	.\lib\ovsdb-types.h	85;"	d
OVSDB_BUG	.\lib\ovsdb-error.h	47;"	d
OVSDB_COLUMN_H	.\ovsdb\column.h	17;"	d
OVSDB_COLUMN_SET_INITIALIZER	.\ovsdb\column.h	66;"	d
OVSDB_COL_UUID	.\ovsdb\column.h	/^    OVSDB_COL_UUID = 0,         \/* UUID for the row. *\/$/;"	e	enum:__anon149
OVSDB_COL_VERSION	.\ovsdb\column.h	/^    OVSDB_COL_VERSION = 1,      \/* Version number for the row. *\/$/;"	e	enum:__anon149
OVSDB_CONDITION_H	.\ovsdb\condition.h	17;"	d
OVSDB_CONDITION_INITIALIZER	.\ovsdb\condition.h	61;"	d
OVSDB_DATA_H	.\lib\ovsdb-data.h	17;"	d
OVSDB_DOC	.\ovsdb\automake.mk	/^OVSDB_DOC = $(run_python) $(srcdir)\/ovsdb\/ovsdb-doc$/;"	m
OVSDB_DOT	.\ovsdb\automake.mk	/^OVSDB_DOT = $(run_python) $(srcdir)\/ovsdb\/ovsdb-dot.in$/;"	m
OVSDB_ERROR_H	.\lib\ovsdb-error.h	17;"	d
OVSDB_FILE_H	.\ovsdb\file.h	17;"	d
OVSDB_FUNCTION	.\ovsdb\condition.c	31;"	d	file:
OVSDB_FUNCTION	.\ovsdb\condition.c	37;"	d	file:
OVSDB_FUNCTION	.\ovsdb\condition.c	47;"	d	file:
OVSDB_FUNCTION	.\ovsdb\condition.c	49;"	d	file:
OVSDB_FUNCTION	.\ovsdb\condition.h	40;"	d
OVSDB_FUNCTION	.\ovsdb\condition.h	42;"	d
OVSDB_FUNCTIONS	.\ovsdb\condition.h	/^    OVSDB_FUNCTIONS$/;"	e	enum:ovsdb_function
OVSDB_FUNCTIONS	.\ovsdb\condition.h	29;"	d
OVSDB_IDLC	.\ovsdb\automake.mk	/^OVSDB_IDLC = $(run_python) $(srcdir)\/ovsdb\/ovsdb-idlc.in$/;"	m
OVSDB_IDL_ALERT	.\lib\ovsdb-idl.h	94;"	d
OVSDB_IDL_H	.\lib\ovsdb-idl.h	17;"	d
OVSDB_IDL_MONITOR	.\lib\ovsdb-idl.h	93;"	d
OVSDB_IDL_PROVIDER_H	.\lib\ovsdb-idl-provider.h	17;"	d
OVSDB_JSONRPC_SERVER_H	.\ovsdb\jsonrpc-server.h	17;"	d
OVSDB_LOCK_STEAL	.\ovsdb\server.h	/^    OVSDB_LOCK_STEAL            \/* By stealing it from the owner. *\/$/;"	e	enum:ovsdb_lock_mode
OVSDB_LOCK_WAIT	.\ovsdb\server.h	/^    OVSDB_LOCK_WAIT,            \/* By waiting for it to become available. *\/$/;"	e	enum:ovsdb_lock_mode
OVSDB_LOG_CREATE	.\ovsdb\log.h	/^    OVSDB_LOG_CREATE            \/* Create new file, read\/write. *\/$/;"	e	enum:ovsdb_log_open_mode
OVSDB_LOG_H	.\ovsdb\log.h	17;"	d
OVSDB_LOG_READ	.\ovsdb\log.c	/^    OVSDB_LOG_READ,$/;"	e	enum:ovsdb_log_mode	file:
OVSDB_LOG_READ_ONLY	.\ovsdb\log.h	/^    OVSDB_LOG_READ_ONLY,        \/* Open existing file, read-only. *\/$/;"	e	enum:ovsdb_log_open_mode
OVSDB_LOG_READ_WRITE	.\ovsdb\log.h	/^    OVSDB_LOG_READ_WRITE,       \/* Open existing file, read\/write. *\/$/;"	e	enum:ovsdb_log_open_mode
OVSDB_LOG_WRITE	.\ovsdb\log.c	/^    OVSDB_LOG_WRITE$/;"	e	enum:ovsdb_log_mode	file:
OVSDB_MUTATION_H	.\ovsdb\mutation.h	17;"	d
OVSDB_MUTATION_SET_INITIALIZER	.\ovsdb\mutation.h	61;"	d
OVSDB_MUTATOR	.\ovsdb\mutation.c	32;"	d	file:
OVSDB_MUTATOR	.\ovsdb\mutation.c	38;"	d	file:
OVSDB_MUTATOR	.\ovsdb\mutation.c	48;"	d	file:
OVSDB_MUTATOR	.\ovsdb\mutation.c	50;"	d	file:
OVSDB_MUTATOR	.\ovsdb\mutation.h	39;"	d
OVSDB_MUTATOR	.\ovsdb\mutation.h	41;"	d
OVSDB_MUTATORS	.\ovsdb\mutation.h	/^    OVSDB_MUTATORS$/;"	e	enum:ovsdb_mutator
OVSDB_MUTATORS	.\ovsdb\mutation.h	29;"	d
OVSDB_N_STD_COLUMNS	.\ovsdb\column.h	/^    OVSDB_N_STD_COLUMNS$/;"	e	enum:__anon149
OVSDB_N_TYPES	.\lib\ovsdb-types.h	/^    OVSDB_N_TYPES$/;"	e	enum:ovsdb_atomic_type
OVSDB_OLD_PORT	.\lib\jsonrpc.h	41;"	d
OVSDB_OVSDB_H	.\ovsdb\ovsdb.h	17;"	d
OVSDB_PARSER_H	.\lib\ovsdb-parser.h	17;"	d
OVSDB_PORT	.\lib\jsonrpc.h	42;"	d
OVSDB_QUERY_H	.\ovsdb\query.h	17;"	d
OVSDB_REF_STRONG	.\lib\ovsdb-types.h	/^    OVSDB_REF_STRONG,           \/* Target must exist. *\/$/;"	e	enum:ovsdb_ref_type
OVSDB_REF_WEAK	.\lib\ovsdb-types.h	/^    OVSDB_REF_WEAK              \/* Delete reference if target disappears. *\/$/;"	e	enum:ovsdb_ref_type
OVSDB_ROW_H	.\ovsdb\row.h	17;"	d
OVSDB_ROW_HASH_INITIALIZER	.\ovsdb\row.h	153;"	d
OVSDB_ROW_SET_INITIALIZER	.\ovsdb\row.h	131;"	d
OVSDB_TABLE_H	.\ovsdb\table.h	17;"	d
OVSDB_TRANSACTION_H	.\ovsdb\transaction.h	17;"	d
OVSDB_TRIGGER_H	.\ovsdb\trigger.h	17;"	d
OVSDB_TYPES_H	.\lib\ovsdb-types.h	17;"	d
OVSDB_TYPE_BOOLEAN	.\lib\ovsdb-types.h	/^    OVSDB_TYPE_BOOLEAN,         \/* True or false. *\/$/;"	e	enum:ovsdb_atomic_type
OVSDB_TYPE_INTEGER	.\lib\ovsdb-types.h	/^    OVSDB_TYPE_INTEGER,         \/* Signed 64-bit integer. *\/$/;"	e	enum:ovsdb_atomic_type
OVSDB_TYPE_REAL	.\lib\ovsdb-types.h	/^    OVSDB_TYPE_REAL,            \/* IEEE 754 double-precision floating point. *\/$/;"	e	enum:ovsdb_atomic_type
OVSDB_TYPE_SCALAR_INITIALIZER	.\lib\ovsdb-types.h	140;"	d
OVSDB_TYPE_STRING	.\lib\ovsdb-types.h	/^    OVSDB_TYPE_STRING,          \/* UTF-8 string. *\/$/;"	e	enum:ovsdb_atomic_type
OVSDB_TYPE_UUID	.\lib\ovsdb-types.h	/^    OVSDB_TYPE_UUID,            \/* RFC 4122 UUID referencing a table row. *\/$/;"	e	enum:ovsdb_atomic_type
OVSDB_TYPE_VOID	.\lib\ovsdb-types.h	/^    OVSDB_TYPE_VOID,            \/* No value. *\/$/;"	e	enum:ovsdb_atomic_type
OVSDB_WRAP_BUG	.\lib\ovsdb-error.h	55;"	d
OVSP_LOCAL	.\include\linux\openvswitch.h	146;"	d
OVSRCU_TYPE	.\lib\ovs-rcu.h	131;"	d
OVSRCU_TYPE	.\lib\ovs-rcu.h	161;"	d
OVSREC_BRIDGE_COL_CONTROLLER	.\lib\vswitch-idl.h	/^    OVSREC_BRIDGE_COL_CONTROLLER,$/;"	e	enum:__anon99
OVSREC_BRIDGE_COL_DATAPATH_ID	.\lib\vswitch-idl.h	/^    OVSREC_BRIDGE_COL_DATAPATH_ID,$/;"	e	enum:__anon99
OVSREC_BRIDGE_COL_DATAPATH_TYPE	.\lib\vswitch-idl.h	/^    OVSREC_BRIDGE_COL_DATAPATH_TYPE,$/;"	e	enum:__anon99
OVSREC_BRIDGE_COL_EXTERNAL_IDS	.\lib\vswitch-idl.h	/^    OVSREC_BRIDGE_COL_EXTERNAL_IDS,$/;"	e	enum:__anon99
OVSREC_BRIDGE_COL_FAIL_MODE	.\lib\vswitch-idl.h	/^    OVSREC_BRIDGE_COL_FAIL_MODE,$/;"	e	enum:__anon99
OVSREC_BRIDGE_COL_FLOOD_VLANS	.\lib\vswitch-idl.h	/^    OVSREC_BRIDGE_COL_FLOOD_VLANS,$/;"	e	enum:__anon99
OVSREC_BRIDGE_COL_FLOW_TABLES	.\lib\vswitch-idl.h	/^    OVSREC_BRIDGE_COL_FLOW_TABLES,$/;"	e	enum:__anon99
OVSREC_BRIDGE_COL_IPFIX	.\lib\vswitch-idl.h	/^    OVSREC_BRIDGE_COL_IPFIX,$/;"	e	enum:__anon99
OVSREC_BRIDGE_COL_MIRRORS	.\lib\vswitch-idl.h	/^    OVSREC_BRIDGE_COL_MIRRORS,$/;"	e	enum:__anon99
OVSREC_BRIDGE_COL_NAME	.\lib\vswitch-idl.h	/^    OVSREC_BRIDGE_COL_NAME,$/;"	e	enum:__anon99
OVSREC_BRIDGE_COL_NETFLOW	.\lib\vswitch-idl.h	/^    OVSREC_BRIDGE_COL_NETFLOW,$/;"	e	enum:__anon99
OVSREC_BRIDGE_COL_OTHER_CONFIG	.\lib\vswitch-idl.h	/^    OVSREC_BRIDGE_COL_OTHER_CONFIG,$/;"	e	enum:__anon99
OVSREC_BRIDGE_COL_PORTS	.\lib\vswitch-idl.h	/^    OVSREC_BRIDGE_COL_PORTS,$/;"	e	enum:__anon99
OVSREC_BRIDGE_COL_PROTOCOLS	.\lib\vswitch-idl.h	/^    OVSREC_BRIDGE_COL_PROTOCOLS,$/;"	e	enum:__anon99
OVSREC_BRIDGE_COL_SFLOW	.\lib\vswitch-idl.h	/^    OVSREC_BRIDGE_COL_SFLOW,$/;"	e	enum:__anon99
OVSREC_BRIDGE_COL_STATUS	.\lib\vswitch-idl.h	/^    OVSREC_BRIDGE_COL_STATUS,$/;"	e	enum:__anon99
OVSREC_BRIDGE_COL_STP_ENABLE	.\lib\vswitch-idl.h	/^    OVSREC_BRIDGE_COL_STP_ENABLE,$/;"	e	enum:__anon99
OVSREC_BRIDGE_FOR_EACH	.\lib\vswitch-idl.h	121;"	d
OVSREC_BRIDGE_FOR_EACH_SAFE	.\lib\vswitch-idl.h	125;"	d
OVSREC_BRIDGE_N_COLUMNS	.\lib\vswitch-idl.h	/^    OVSREC_BRIDGE_N_COLUMNS$/;"	e	enum:__anon99
OVSREC_CONTROLLER_COL_CONNECTION_MODE	.\lib\vswitch-idl.h	/^    OVSREC_CONTROLLER_COL_CONNECTION_MODE,$/;"	e	enum:__anon100
OVSREC_CONTROLLER_COL_CONTROLLER_BURST_LIMIT	.\lib\vswitch-idl.h	/^    OVSREC_CONTROLLER_COL_CONTROLLER_BURST_LIMIT,$/;"	e	enum:__anon100
OVSREC_CONTROLLER_COL_CONTROLLER_RATE_LIMIT	.\lib\vswitch-idl.h	/^    OVSREC_CONTROLLER_COL_CONTROLLER_RATE_LIMIT,$/;"	e	enum:__anon100
OVSREC_CONTROLLER_COL_ENABLE_ASYNC_MESSAGES	.\lib\vswitch-idl.h	/^    OVSREC_CONTROLLER_COL_ENABLE_ASYNC_MESSAGES,$/;"	e	enum:__anon100
OVSREC_CONTROLLER_COL_EXTERNAL_IDS	.\lib\vswitch-idl.h	/^    OVSREC_CONTROLLER_COL_EXTERNAL_IDS,$/;"	e	enum:__anon100
OVSREC_CONTROLLER_COL_INACTIVITY_PROBE	.\lib\vswitch-idl.h	/^    OVSREC_CONTROLLER_COL_INACTIVITY_PROBE,$/;"	e	enum:__anon100
OVSREC_CONTROLLER_COL_IS_CONNECTED	.\lib\vswitch-idl.h	/^    OVSREC_CONTROLLER_COL_IS_CONNECTED,$/;"	e	enum:__anon100
OVSREC_CONTROLLER_COL_LOCAL_GATEWAY	.\lib\vswitch-idl.h	/^    OVSREC_CONTROLLER_COL_LOCAL_GATEWAY,$/;"	e	enum:__anon100
OVSREC_CONTROLLER_COL_LOCAL_IP	.\lib\vswitch-idl.h	/^    OVSREC_CONTROLLER_COL_LOCAL_IP,$/;"	e	enum:__anon100
OVSREC_CONTROLLER_COL_LOCAL_NETMASK	.\lib\vswitch-idl.h	/^    OVSREC_CONTROLLER_COL_LOCAL_NETMASK,$/;"	e	enum:__anon100
OVSREC_CONTROLLER_COL_MAX_BACKOFF	.\lib\vswitch-idl.h	/^    OVSREC_CONTROLLER_COL_MAX_BACKOFF,$/;"	e	enum:__anon100
OVSREC_CONTROLLER_COL_OTHER_CONFIG	.\lib\vswitch-idl.h	/^    OVSREC_CONTROLLER_COL_OTHER_CONFIG,$/;"	e	enum:__anon100
OVSREC_CONTROLLER_COL_ROLE	.\lib\vswitch-idl.h	/^    OVSREC_CONTROLLER_COL_ROLE,$/;"	e	enum:__anon100
OVSREC_CONTROLLER_COL_STATUS	.\lib\vswitch-idl.h	/^    OVSREC_CONTROLLER_COL_STATUS,$/;"	e	enum:__anon100
OVSREC_CONTROLLER_COL_TARGET	.\lib\vswitch-idl.h	/^    OVSREC_CONTROLLER_COL_TARGET,$/;"	e	enum:__anon100
OVSREC_CONTROLLER_FOR_EACH	.\lib\vswitch-idl.h	287;"	d
OVSREC_CONTROLLER_FOR_EACH_SAFE	.\lib\vswitch-idl.h	291;"	d
OVSREC_CONTROLLER_N_COLUMNS	.\lib\vswitch-idl.h	/^    OVSREC_CONTROLLER_N_COLUMNS$/;"	e	enum:__anon100
OVSREC_FLOW_SAMPLE_COLLECTOR_SET_COL_BRIDGE	.\lib\vswitch-idl.h	/^    OVSREC_FLOW_SAMPLE_COLLECTOR_SET_COL_BRIDGE,$/;"	e	enum:__anon101
OVSREC_FLOW_SAMPLE_COLLECTOR_SET_COL_EXTERNAL_IDS	.\lib\vswitch-idl.h	/^    OVSREC_FLOW_SAMPLE_COLLECTOR_SET_COL_EXTERNAL_IDS,$/;"	e	enum:__anon101
OVSREC_FLOW_SAMPLE_COLLECTOR_SET_COL_ID	.\lib\vswitch-idl.h	/^    OVSREC_FLOW_SAMPLE_COLLECTOR_SET_COL_ID,$/;"	e	enum:__anon101
OVSREC_FLOW_SAMPLE_COLLECTOR_SET_COL_IPFIX	.\lib\vswitch-idl.h	/^    OVSREC_FLOW_SAMPLE_COLLECTOR_SET_COL_IPFIX,$/;"	e	enum:__anon101
OVSREC_FLOW_SAMPLE_COLLECTOR_SET_FOR_EACH	.\lib\vswitch-idl.h	387;"	d
OVSREC_FLOW_SAMPLE_COLLECTOR_SET_FOR_EACH_SAFE	.\lib\vswitch-idl.h	391;"	d
OVSREC_FLOW_SAMPLE_COLLECTOR_SET_N_COLUMNS	.\lib\vswitch-idl.h	/^    OVSREC_FLOW_SAMPLE_COLLECTOR_SET_N_COLUMNS$/;"	e	enum:__anon101
OVSREC_FLOW_TABLE_COL_EXTERNAL_IDS	.\lib\vswitch-idl.h	/^    OVSREC_FLOW_TABLE_COL_EXTERNAL_IDS,$/;"	e	enum:__anon102
OVSREC_FLOW_TABLE_COL_FLOW_LIMIT	.\lib\vswitch-idl.h	/^    OVSREC_FLOW_TABLE_COL_FLOW_LIMIT,$/;"	e	enum:__anon102
OVSREC_FLOW_TABLE_COL_GROUPS	.\lib\vswitch-idl.h	/^    OVSREC_FLOW_TABLE_COL_GROUPS,$/;"	e	enum:__anon102
OVSREC_FLOW_TABLE_COL_NAME	.\lib\vswitch-idl.h	/^    OVSREC_FLOW_TABLE_COL_NAME,$/;"	e	enum:__anon102
OVSREC_FLOW_TABLE_COL_OVERFLOW_POLICY	.\lib\vswitch-idl.h	/^    OVSREC_FLOW_TABLE_COL_OVERFLOW_POLICY,$/;"	e	enum:__anon102
OVSREC_FLOW_TABLE_COL_PREFIXES	.\lib\vswitch-idl.h	/^    OVSREC_FLOW_TABLE_COL_PREFIXES,$/;"	e	enum:__anon102
OVSREC_FLOW_TABLE_FOR_EACH	.\lib\vswitch-idl.h	467;"	d
OVSREC_FLOW_TABLE_FOR_EACH_SAFE	.\lib\vswitch-idl.h	471;"	d
OVSREC_FLOW_TABLE_N_COLUMNS	.\lib\vswitch-idl.h	/^    OVSREC_FLOW_TABLE_N_COLUMNS$/;"	e	enum:__anon102
OVSREC_IDL_HEADER	.\lib\vswitch-idl.h	4;"	d
OVSREC_INTERFACE_COL_ADMIN_STATE	.\lib\vswitch-idl.h	/^    OVSREC_INTERFACE_COL_ADMIN_STATE,$/;"	e	enum:__anon104
OVSREC_INTERFACE_COL_BFD	.\lib\vswitch-idl.h	/^    OVSREC_INTERFACE_COL_BFD,$/;"	e	enum:__anon104
OVSREC_INTERFACE_COL_BFD_STATUS	.\lib\vswitch-idl.h	/^    OVSREC_INTERFACE_COL_BFD_STATUS,$/;"	e	enum:__anon104
OVSREC_INTERFACE_COL_CFM_FAULT	.\lib\vswitch-idl.h	/^    OVSREC_INTERFACE_COL_CFM_FAULT,$/;"	e	enum:__anon104
OVSREC_INTERFACE_COL_CFM_FAULT_STATUS	.\lib\vswitch-idl.h	/^    OVSREC_INTERFACE_COL_CFM_FAULT_STATUS,$/;"	e	enum:__anon104
OVSREC_INTERFACE_COL_CFM_FLAP_COUNT	.\lib\vswitch-idl.h	/^    OVSREC_INTERFACE_COL_CFM_FLAP_COUNT,$/;"	e	enum:__anon104
OVSREC_INTERFACE_COL_CFM_HEALTH	.\lib\vswitch-idl.h	/^    OVSREC_INTERFACE_COL_CFM_HEALTH,$/;"	e	enum:__anon104
OVSREC_INTERFACE_COL_CFM_MPID	.\lib\vswitch-idl.h	/^    OVSREC_INTERFACE_COL_CFM_MPID,$/;"	e	enum:__anon104
OVSREC_INTERFACE_COL_CFM_REMOTE_MPIDS	.\lib\vswitch-idl.h	/^    OVSREC_INTERFACE_COL_CFM_REMOTE_MPIDS,$/;"	e	enum:__anon104
OVSREC_INTERFACE_COL_CFM_REMOTE_OPSTATE	.\lib\vswitch-idl.h	/^    OVSREC_INTERFACE_COL_CFM_REMOTE_OPSTATE,$/;"	e	enum:__anon104
OVSREC_INTERFACE_COL_DUPLEX	.\lib\vswitch-idl.h	/^    OVSREC_INTERFACE_COL_DUPLEX,$/;"	e	enum:__anon104
OVSREC_INTERFACE_COL_EXTERNAL_IDS	.\lib\vswitch-idl.h	/^    OVSREC_INTERFACE_COL_EXTERNAL_IDS,$/;"	e	enum:__anon104
OVSREC_INTERFACE_COL_IFINDEX	.\lib\vswitch-idl.h	/^    OVSREC_INTERFACE_COL_IFINDEX,$/;"	e	enum:__anon104
OVSREC_INTERFACE_COL_INGRESS_POLICING_BURST	.\lib\vswitch-idl.h	/^    OVSREC_INTERFACE_COL_INGRESS_POLICING_BURST,$/;"	e	enum:__anon104
OVSREC_INTERFACE_COL_INGRESS_POLICING_RATE	.\lib\vswitch-idl.h	/^    OVSREC_INTERFACE_COL_INGRESS_POLICING_RATE,$/;"	e	enum:__anon104
OVSREC_INTERFACE_COL_LACP_CURRENT	.\lib\vswitch-idl.h	/^    OVSREC_INTERFACE_COL_LACP_CURRENT,$/;"	e	enum:__anon104
OVSREC_INTERFACE_COL_LINK_RESETS	.\lib\vswitch-idl.h	/^    OVSREC_INTERFACE_COL_LINK_RESETS,$/;"	e	enum:__anon104
OVSREC_INTERFACE_COL_LINK_SPEED	.\lib\vswitch-idl.h	/^    OVSREC_INTERFACE_COL_LINK_SPEED,$/;"	e	enum:__anon104
OVSREC_INTERFACE_COL_LINK_STATE	.\lib\vswitch-idl.h	/^    OVSREC_INTERFACE_COL_LINK_STATE,$/;"	e	enum:__anon104
OVSREC_INTERFACE_COL_MAC	.\lib\vswitch-idl.h	/^    OVSREC_INTERFACE_COL_MAC,$/;"	e	enum:__anon104
OVSREC_INTERFACE_COL_MAC_IN_USE	.\lib\vswitch-idl.h	/^    OVSREC_INTERFACE_COL_MAC_IN_USE,$/;"	e	enum:__anon104
OVSREC_INTERFACE_COL_MTU	.\lib\vswitch-idl.h	/^    OVSREC_INTERFACE_COL_MTU,$/;"	e	enum:__anon104
OVSREC_INTERFACE_COL_NAME	.\lib\vswitch-idl.h	/^    OVSREC_INTERFACE_COL_NAME,$/;"	e	enum:__anon104
OVSREC_INTERFACE_COL_OFPORT	.\lib\vswitch-idl.h	/^    OVSREC_INTERFACE_COL_OFPORT,$/;"	e	enum:__anon104
OVSREC_INTERFACE_COL_OFPORT_REQUEST	.\lib\vswitch-idl.h	/^    OVSREC_INTERFACE_COL_OFPORT_REQUEST,$/;"	e	enum:__anon104
OVSREC_INTERFACE_COL_OPTIONS	.\lib\vswitch-idl.h	/^    OVSREC_INTERFACE_COL_OPTIONS,$/;"	e	enum:__anon104
OVSREC_INTERFACE_COL_OTHER_CONFIG	.\lib\vswitch-idl.h	/^    OVSREC_INTERFACE_COL_OTHER_CONFIG,$/;"	e	enum:__anon104
OVSREC_INTERFACE_COL_STATISTICS	.\lib\vswitch-idl.h	/^    OVSREC_INTERFACE_COL_STATISTICS,$/;"	e	enum:__anon104
OVSREC_INTERFACE_COL_STATUS	.\lib\vswitch-idl.h	/^    OVSREC_INTERFACE_COL_STATUS,$/;"	e	enum:__anon104
OVSREC_INTERFACE_COL_TYPE	.\lib\vswitch-idl.h	/^    OVSREC_INTERFACE_COL_TYPE,$/;"	e	enum:__anon104
OVSREC_INTERFACE_FOR_EACH	.\lib\vswitch-idl.h	782;"	d
OVSREC_INTERFACE_FOR_EACH_SAFE	.\lib\vswitch-idl.h	786;"	d
OVSREC_INTERFACE_N_COLUMNS	.\lib\vswitch-idl.h	/^    OVSREC_INTERFACE_N_COLUMNS$/;"	e	enum:__anon104
OVSREC_IPFIX_COL_CACHE_ACTIVE_TIMEOUT	.\lib\vswitch-idl.h	/^    OVSREC_IPFIX_COL_CACHE_ACTIVE_TIMEOUT,$/;"	e	enum:__anon103
OVSREC_IPFIX_COL_CACHE_MAX_FLOWS	.\lib\vswitch-idl.h	/^    OVSREC_IPFIX_COL_CACHE_MAX_FLOWS,$/;"	e	enum:__anon103
OVSREC_IPFIX_COL_EXTERNAL_IDS	.\lib\vswitch-idl.h	/^    OVSREC_IPFIX_COL_EXTERNAL_IDS,$/;"	e	enum:__anon103
OVSREC_IPFIX_COL_OBS_DOMAIN_ID	.\lib\vswitch-idl.h	/^    OVSREC_IPFIX_COL_OBS_DOMAIN_ID,$/;"	e	enum:__anon103
OVSREC_IPFIX_COL_OBS_POINT_ID	.\lib\vswitch-idl.h	/^    OVSREC_IPFIX_COL_OBS_POINT_ID,$/;"	e	enum:__anon103
OVSREC_IPFIX_COL_SAMPLING	.\lib\vswitch-idl.h	/^    OVSREC_IPFIX_COL_SAMPLING,$/;"	e	enum:__anon103
OVSREC_IPFIX_COL_TARGETS	.\lib\vswitch-idl.h	/^    OVSREC_IPFIX_COL_TARGETS,$/;"	e	enum:__anon103
OVSREC_IPFIX_FOR_EACH	.\lib\vswitch-idl.h	561;"	d
OVSREC_IPFIX_FOR_EACH_SAFE	.\lib\vswitch-idl.h	565;"	d
OVSREC_IPFIX_N_COLUMNS	.\lib\vswitch-idl.h	/^    OVSREC_IPFIX_N_COLUMNS$/;"	e	enum:__anon103
OVSREC_MANAGER_COL_CONNECTION_MODE	.\lib\vswitch-idl.h	/^    OVSREC_MANAGER_COL_CONNECTION_MODE,$/;"	e	enum:__anon105
OVSREC_MANAGER_COL_EXTERNAL_IDS	.\lib\vswitch-idl.h	/^    OVSREC_MANAGER_COL_EXTERNAL_IDS,$/;"	e	enum:__anon105
OVSREC_MANAGER_COL_INACTIVITY_PROBE	.\lib\vswitch-idl.h	/^    OVSREC_MANAGER_COL_INACTIVITY_PROBE,$/;"	e	enum:__anon105
OVSREC_MANAGER_COL_IS_CONNECTED	.\lib\vswitch-idl.h	/^    OVSREC_MANAGER_COL_IS_CONNECTED,$/;"	e	enum:__anon105
OVSREC_MANAGER_COL_MAX_BACKOFF	.\lib\vswitch-idl.h	/^    OVSREC_MANAGER_COL_MAX_BACKOFF,$/;"	e	enum:__anon105
OVSREC_MANAGER_COL_OTHER_CONFIG	.\lib\vswitch-idl.h	/^    OVSREC_MANAGER_COL_OTHER_CONFIG,$/;"	e	enum:__anon105
OVSREC_MANAGER_COL_STATUS	.\lib\vswitch-idl.h	/^    OVSREC_MANAGER_COL_STATUS,$/;"	e	enum:__anon105
OVSREC_MANAGER_COL_TARGET	.\lib\vswitch-idl.h	/^    OVSREC_MANAGER_COL_TARGET,$/;"	e	enum:__anon105
OVSREC_MANAGER_FOR_EACH	.\lib\vswitch-idl.h	949;"	d
OVSREC_MANAGER_FOR_EACH_SAFE	.\lib\vswitch-idl.h	953;"	d
OVSREC_MANAGER_N_COLUMNS	.\lib\vswitch-idl.h	/^    OVSREC_MANAGER_N_COLUMNS$/;"	e	enum:__anon105
OVSREC_MIRROR_COL_EXTERNAL_IDS	.\lib\vswitch-idl.h	/^    OVSREC_MIRROR_COL_EXTERNAL_IDS,$/;"	e	enum:__anon106
OVSREC_MIRROR_COL_NAME	.\lib\vswitch-idl.h	/^    OVSREC_MIRROR_COL_NAME,$/;"	e	enum:__anon106
OVSREC_MIRROR_COL_OUTPUT_PORT	.\lib\vswitch-idl.h	/^    OVSREC_MIRROR_COL_OUTPUT_PORT,$/;"	e	enum:__anon106
OVSREC_MIRROR_COL_OUTPUT_VLAN	.\lib\vswitch-idl.h	/^    OVSREC_MIRROR_COL_OUTPUT_VLAN,$/;"	e	enum:__anon106
OVSREC_MIRROR_COL_SELECT_ALL	.\lib\vswitch-idl.h	/^    OVSREC_MIRROR_COL_SELECT_ALL,$/;"	e	enum:__anon106
OVSREC_MIRROR_COL_SELECT_DST_PORT	.\lib\vswitch-idl.h	/^    OVSREC_MIRROR_COL_SELECT_DST_PORT,$/;"	e	enum:__anon106
OVSREC_MIRROR_COL_SELECT_SRC_PORT	.\lib\vswitch-idl.h	/^    OVSREC_MIRROR_COL_SELECT_SRC_PORT,$/;"	e	enum:__anon106
OVSREC_MIRROR_COL_SELECT_VLAN	.\lib\vswitch-idl.h	/^    OVSREC_MIRROR_COL_SELECT_VLAN,$/;"	e	enum:__anon106
OVSREC_MIRROR_COL_STATISTICS	.\lib\vswitch-idl.h	/^    OVSREC_MIRROR_COL_STATISTICS,$/;"	e	enum:__anon106
OVSREC_MIRROR_FOR_EACH	.\lib\vswitch-idl.h	1059;"	d
OVSREC_MIRROR_FOR_EACH_SAFE	.\lib\vswitch-idl.h	1063;"	d
OVSREC_MIRROR_N_COLUMNS	.\lib\vswitch-idl.h	/^    OVSREC_MIRROR_N_COLUMNS$/;"	e	enum:__anon106
OVSREC_NETFLOW_COL_ACTIVE_TIMEOUT	.\lib\vswitch-idl.h	/^    OVSREC_NETFLOW_COL_ACTIVE_TIMEOUT,$/;"	e	enum:__anon107
OVSREC_NETFLOW_COL_ADD_ID_TO_INTERFACE	.\lib\vswitch-idl.h	/^    OVSREC_NETFLOW_COL_ADD_ID_TO_INTERFACE,$/;"	e	enum:__anon107
OVSREC_NETFLOW_COL_ENGINE_ID	.\lib\vswitch-idl.h	/^    OVSREC_NETFLOW_COL_ENGINE_ID,$/;"	e	enum:__anon107
OVSREC_NETFLOW_COL_ENGINE_TYPE	.\lib\vswitch-idl.h	/^    OVSREC_NETFLOW_COL_ENGINE_TYPE,$/;"	e	enum:__anon107
OVSREC_NETFLOW_COL_EXTERNAL_IDS	.\lib\vswitch-idl.h	/^    OVSREC_NETFLOW_COL_EXTERNAL_IDS,$/;"	e	enum:__anon107
OVSREC_NETFLOW_COL_TARGETS	.\lib\vswitch-idl.h	/^    OVSREC_NETFLOW_COL_TARGETS,$/;"	e	enum:__anon107
OVSREC_NETFLOW_FOR_EACH	.\lib\vswitch-idl.h	1154;"	d
OVSREC_NETFLOW_FOR_EACH_SAFE	.\lib\vswitch-idl.h	1158;"	d
OVSREC_NETFLOW_N_COLUMNS	.\lib\vswitch-idl.h	/^    OVSREC_NETFLOW_N_COLUMNS$/;"	e	enum:__anon107
OVSREC_N_TABLES	.\lib\vswitch-idl.h	/^    OVSREC_N_TABLES$/;"	e	enum:__anon114
OVSREC_OPEN_VSWITCH_COL_BRIDGES	.\lib\vswitch-idl.h	/^    OVSREC_OPEN_VSWITCH_COL_BRIDGES,$/;"	e	enum:__anon108
OVSREC_OPEN_VSWITCH_COL_CUR_CFG	.\lib\vswitch-idl.h	/^    OVSREC_OPEN_VSWITCH_COL_CUR_CFG,$/;"	e	enum:__anon108
OVSREC_OPEN_VSWITCH_COL_DB_VERSION	.\lib\vswitch-idl.h	/^    OVSREC_OPEN_VSWITCH_COL_DB_VERSION,$/;"	e	enum:__anon108
OVSREC_OPEN_VSWITCH_COL_EXTERNAL_IDS	.\lib\vswitch-idl.h	/^    OVSREC_OPEN_VSWITCH_COL_EXTERNAL_IDS,$/;"	e	enum:__anon108
OVSREC_OPEN_VSWITCH_COL_MANAGER_OPTIONS	.\lib\vswitch-idl.h	/^    OVSREC_OPEN_VSWITCH_COL_MANAGER_OPTIONS,$/;"	e	enum:__anon108
OVSREC_OPEN_VSWITCH_COL_NEXT_CFG	.\lib\vswitch-idl.h	/^    OVSREC_OPEN_VSWITCH_COL_NEXT_CFG,$/;"	e	enum:__anon108
OVSREC_OPEN_VSWITCH_COL_OTHER_CONFIG	.\lib\vswitch-idl.h	/^    OVSREC_OPEN_VSWITCH_COL_OTHER_CONFIG,$/;"	e	enum:__anon108
OVSREC_OPEN_VSWITCH_COL_OVS_VERSION	.\lib\vswitch-idl.h	/^    OVSREC_OPEN_VSWITCH_COL_OVS_VERSION,$/;"	e	enum:__anon108
OVSREC_OPEN_VSWITCH_COL_SSL	.\lib\vswitch-idl.h	/^    OVSREC_OPEN_VSWITCH_COL_SSL,$/;"	e	enum:__anon108
OVSREC_OPEN_VSWITCH_COL_STATISTICS	.\lib\vswitch-idl.h	/^    OVSREC_OPEN_VSWITCH_COL_STATISTICS,$/;"	e	enum:__anon108
OVSREC_OPEN_VSWITCH_COL_SYSTEM_TYPE	.\lib\vswitch-idl.h	/^    OVSREC_OPEN_VSWITCH_COL_SYSTEM_TYPE,$/;"	e	enum:__anon108
OVSREC_OPEN_VSWITCH_COL_SYSTEM_VERSION	.\lib\vswitch-idl.h	/^    OVSREC_OPEN_VSWITCH_COL_SYSTEM_VERSION,$/;"	e	enum:__anon108
OVSREC_OPEN_VSWITCH_FOR_EACH	.\lib\vswitch-idl.h	1269;"	d
OVSREC_OPEN_VSWITCH_FOR_EACH_SAFE	.\lib\vswitch-idl.h	1273;"	d
OVSREC_OPEN_VSWITCH_N_COLUMNS	.\lib\vswitch-idl.h	/^    OVSREC_OPEN_VSWITCH_N_COLUMNS$/;"	e	enum:__anon108
OVSREC_PORT_COL_BOND_ACTIVE_SLAVE	.\lib\vswitch-idl.h	/^    OVSREC_PORT_COL_BOND_ACTIVE_SLAVE,$/;"	e	enum:__anon109
OVSREC_PORT_COL_BOND_DOWNDELAY	.\lib\vswitch-idl.h	/^    OVSREC_PORT_COL_BOND_DOWNDELAY,$/;"	e	enum:__anon109
OVSREC_PORT_COL_BOND_FAKE_IFACE	.\lib\vswitch-idl.h	/^    OVSREC_PORT_COL_BOND_FAKE_IFACE,$/;"	e	enum:__anon109
OVSREC_PORT_COL_BOND_MODE	.\lib\vswitch-idl.h	/^    OVSREC_PORT_COL_BOND_MODE,$/;"	e	enum:__anon109
OVSREC_PORT_COL_BOND_UPDELAY	.\lib\vswitch-idl.h	/^    OVSREC_PORT_COL_BOND_UPDELAY,$/;"	e	enum:__anon109
OVSREC_PORT_COL_EXTERNAL_IDS	.\lib\vswitch-idl.h	/^    OVSREC_PORT_COL_EXTERNAL_IDS,$/;"	e	enum:__anon109
OVSREC_PORT_COL_FAKE_BRIDGE	.\lib\vswitch-idl.h	/^    OVSREC_PORT_COL_FAKE_BRIDGE,$/;"	e	enum:__anon109
OVSREC_PORT_COL_INTERFACES	.\lib\vswitch-idl.h	/^    OVSREC_PORT_COL_INTERFACES,$/;"	e	enum:__anon109
OVSREC_PORT_COL_LACP	.\lib\vswitch-idl.h	/^    OVSREC_PORT_COL_LACP,$/;"	e	enum:__anon109
OVSREC_PORT_COL_MAC	.\lib\vswitch-idl.h	/^    OVSREC_PORT_COL_MAC,$/;"	e	enum:__anon109
OVSREC_PORT_COL_NAME	.\lib\vswitch-idl.h	/^    OVSREC_PORT_COL_NAME,$/;"	e	enum:__anon109
OVSREC_PORT_COL_OTHER_CONFIG	.\lib\vswitch-idl.h	/^    OVSREC_PORT_COL_OTHER_CONFIG,$/;"	e	enum:__anon109
OVSREC_PORT_COL_QOS	.\lib\vswitch-idl.h	/^    OVSREC_PORT_COL_QOS,$/;"	e	enum:__anon109
OVSREC_PORT_COL_STATISTICS	.\lib\vswitch-idl.h	/^    OVSREC_PORT_COL_STATISTICS,$/;"	e	enum:__anon109
OVSREC_PORT_COL_STATUS	.\lib\vswitch-idl.h	/^    OVSREC_PORT_COL_STATUS,$/;"	e	enum:__anon109
OVSREC_PORT_COL_TAG	.\lib\vswitch-idl.h	/^    OVSREC_PORT_COL_TAG,$/;"	e	enum:__anon109
OVSREC_PORT_COL_TRUNKS	.\lib\vswitch-idl.h	/^    OVSREC_PORT_COL_TRUNKS,$/;"	e	enum:__anon109
OVSREC_PORT_COL_VLAN_MODE	.\lib\vswitch-idl.h	/^    OVSREC_PORT_COL_VLAN_MODE,$/;"	e	enum:__anon109
OVSREC_PORT_FOR_EACH	.\lib\vswitch-idl.h	1435;"	d
OVSREC_PORT_FOR_EACH_SAFE	.\lib\vswitch-idl.h	1439;"	d
OVSREC_PORT_N_COLUMNS	.\lib\vswitch-idl.h	/^    OVSREC_PORT_N_COLUMNS$/;"	e	enum:__anon109
OVSREC_QOS_COL_EXTERNAL_IDS	.\lib\vswitch-idl.h	/^    OVSREC_QOS_COL_EXTERNAL_IDS,$/;"	e	enum:__anon110
OVSREC_QOS_COL_OTHER_CONFIG	.\lib\vswitch-idl.h	/^    OVSREC_QOS_COL_OTHER_CONFIG,$/;"	e	enum:__anon110
OVSREC_QOS_COL_QUEUES	.\lib\vswitch-idl.h	/^    OVSREC_QOS_COL_QUEUES,$/;"	e	enum:__anon110
OVSREC_QOS_COL_TYPE	.\lib\vswitch-idl.h	/^    OVSREC_QOS_COL_TYPE,$/;"	e	enum:__anon110
OVSREC_QOS_FOR_EACH	.\lib\vswitch-idl.h	1546;"	d
OVSREC_QOS_FOR_EACH_SAFE	.\lib\vswitch-idl.h	1550;"	d
OVSREC_QOS_N_COLUMNS	.\lib\vswitch-idl.h	/^    OVSREC_QOS_N_COLUMNS$/;"	e	enum:__anon110
OVSREC_QUEUE_COL_DSCP	.\lib\vswitch-idl.h	/^    OVSREC_QUEUE_COL_DSCP,$/;"	e	enum:__anon111
OVSREC_QUEUE_COL_EXTERNAL_IDS	.\lib\vswitch-idl.h	/^    OVSREC_QUEUE_COL_EXTERNAL_IDS,$/;"	e	enum:__anon111
OVSREC_QUEUE_COL_OTHER_CONFIG	.\lib\vswitch-idl.h	/^    OVSREC_QUEUE_COL_OTHER_CONFIG,$/;"	e	enum:__anon111
OVSREC_QUEUE_FOR_EACH	.\lib\vswitch-idl.h	1609;"	d
OVSREC_QUEUE_FOR_EACH_SAFE	.\lib\vswitch-idl.h	1613;"	d
OVSREC_QUEUE_N_COLUMNS	.\lib\vswitch-idl.h	/^    OVSREC_QUEUE_N_COLUMNS$/;"	e	enum:__anon111
OVSREC_SFLOW_COL_AGENT	.\lib\vswitch-idl.h	/^    OVSREC_SFLOW_COL_AGENT,$/;"	e	enum:__anon113
OVSREC_SFLOW_COL_EXTERNAL_IDS	.\lib\vswitch-idl.h	/^    OVSREC_SFLOW_COL_EXTERNAL_IDS,$/;"	e	enum:__anon113
OVSREC_SFLOW_COL_HEADER	.\lib\vswitch-idl.h	/^    OVSREC_SFLOW_COL_HEADER,$/;"	e	enum:__anon113
OVSREC_SFLOW_COL_POLLING	.\lib\vswitch-idl.h	/^    OVSREC_SFLOW_COL_POLLING,$/;"	e	enum:__anon113
OVSREC_SFLOW_COL_SAMPLING	.\lib\vswitch-idl.h	/^    OVSREC_SFLOW_COL_SAMPLING,$/;"	e	enum:__anon113
OVSREC_SFLOW_COL_TARGETS	.\lib\vswitch-idl.h	/^    OVSREC_SFLOW_COL_TARGETS,$/;"	e	enum:__anon113
OVSREC_SFLOW_FOR_EACH	.\lib\vswitch-idl.h	1762;"	d
OVSREC_SFLOW_FOR_EACH_SAFE	.\lib\vswitch-idl.h	1766;"	d
OVSREC_SFLOW_N_COLUMNS	.\lib\vswitch-idl.h	/^    OVSREC_SFLOW_N_COLUMNS$/;"	e	enum:__anon113
OVSREC_SSL_COL_BOOTSTRAP_CA_CERT	.\lib\vswitch-idl.h	/^    OVSREC_SSL_COL_BOOTSTRAP_CA_CERT,$/;"	e	enum:__anon112
OVSREC_SSL_COL_CA_CERT	.\lib\vswitch-idl.h	/^    OVSREC_SSL_COL_CA_CERT,$/;"	e	enum:__anon112
OVSREC_SSL_COL_CERTIFICATE	.\lib\vswitch-idl.h	/^    OVSREC_SSL_COL_CERTIFICATE,$/;"	e	enum:__anon112
OVSREC_SSL_COL_EXTERNAL_IDS	.\lib\vswitch-idl.h	/^    OVSREC_SSL_COL_EXTERNAL_IDS,$/;"	e	enum:__anon112
OVSREC_SSL_COL_PRIVATE_KEY	.\lib\vswitch-idl.h	/^    OVSREC_SSL_COL_PRIVATE_KEY,$/;"	e	enum:__anon112
OVSREC_SSL_FOR_EACH	.\lib\vswitch-idl.h	1678;"	d
OVSREC_SSL_FOR_EACH_SAFE	.\lib\vswitch-idl.h	1682;"	d
OVSREC_SSL_N_COLUMNS	.\lib\vswitch-idl.h	/^    OVSREC_SSL_N_COLUMNS$/;"	e	enum:__anon112
OVSREC_TABLE_BRIDGE	.\lib\vswitch-idl.h	/^    OVSREC_TABLE_BRIDGE,$/;"	e	enum:__anon114
OVSREC_TABLE_CONTROLLER	.\lib\vswitch-idl.h	/^    OVSREC_TABLE_CONTROLLER,$/;"	e	enum:__anon114
OVSREC_TABLE_FLOW_SAMPLE_COLLECTOR_SET	.\lib\vswitch-idl.h	/^    OVSREC_TABLE_FLOW_SAMPLE_COLLECTOR_SET,$/;"	e	enum:__anon114
OVSREC_TABLE_FLOW_TABLE	.\lib\vswitch-idl.h	/^    OVSREC_TABLE_FLOW_TABLE,$/;"	e	enum:__anon114
OVSREC_TABLE_INTERFACE	.\lib\vswitch-idl.h	/^    OVSREC_TABLE_INTERFACE,$/;"	e	enum:__anon114
OVSREC_TABLE_IPFIX	.\lib\vswitch-idl.h	/^    OVSREC_TABLE_IPFIX,$/;"	e	enum:__anon114
OVSREC_TABLE_MANAGER	.\lib\vswitch-idl.h	/^    OVSREC_TABLE_MANAGER,$/;"	e	enum:__anon114
OVSREC_TABLE_MIRROR	.\lib\vswitch-idl.h	/^    OVSREC_TABLE_MIRROR,$/;"	e	enum:__anon114
OVSREC_TABLE_NETFLOW	.\lib\vswitch-idl.h	/^    OVSREC_TABLE_NETFLOW,$/;"	e	enum:__anon114
OVSREC_TABLE_OPEN_VSWITCH	.\lib\vswitch-idl.h	/^    OVSREC_TABLE_OPEN_VSWITCH,$/;"	e	enum:__anon114
OVSREC_TABLE_PORT	.\lib\vswitch-idl.h	/^    OVSREC_TABLE_PORT,$/;"	e	enum:__anon114
OVSREC_TABLE_QOS	.\lib\vswitch-idl.h	/^    OVSREC_TABLE_QOS,$/;"	e	enum:__anon114
OVSREC_TABLE_QUEUE	.\lib\vswitch-idl.h	/^    OVSREC_TABLE_QUEUE,$/;"	e	enum:__anon114
OVSREC_TABLE_SFLOW	.\lib\vswitch-idl.h	/^    OVSREC_TABLE_SFLOW,$/;"	e	enum:__anon114
OVSREC_TABLE_SSL	.\lib\vswitch-idl.h	/^    OVSREC_TABLE_SSL,$/;"	e	enum:__anon114
OVSTEST_H	.\tests\ovstest.h	18;"	d
OVSTEST_REGISTER	.\tests\ovstest.h	74;"	d
OVSTEST_USAGE	.\tests\ovstest.c	47;"	d	file:
OVSTHREAD_ONCE_INITIALIZER	.\lib\ovs-thread.h	536;"	d
OVSTHREAD_STATS_FOR_EACH_BUCKET	.\lib\ovs-thread.h	614;"	d
OVS_ACQUIRES	.\lib\compiler.h	122;"	d
OVS_ACQUIRES	.\lib\compiler.h	145;"	d
OVS_ACQUIRES	.\lib\lacp.c	/^lacp_lock(void) OVS_ACQUIRES(mutex)$/;"	f
OVS_ACQ_AFTER	.\lib\compiler.h	135;"	d
OVS_ACQ_AFTER	.\lib\compiler.h	154;"	d
OVS_ACQ_BEFORE	.\lib\compiler.h	134;"	d
OVS_ACQ_BEFORE	.\lib\compiler.h	153;"	d
OVS_ACQ_RDLOCK	.\lib\compiler.h	115;"	d
OVS_ACQ_RDLOCK	.\lib\compiler.h	141;"	d
OVS_ACQ_RDLOCK	.\lib\fat-rwlock.c	/^    OVS_ACQ_RDLOCK(rwlock_)$/;"	f
OVS_ACQ_WRLOCK	.\lib\compiler.h	118;"	d
OVS_ACQ_WRLOCK	.\lib\compiler.h	143;"	d
OVS_ACQ_WRLOCK	.\lib\fat-rwlock.c	/^    OVS_ACQ_WRLOCK(rwlock_)$/;"	f
OVS_ACTION_ATTR_HASH	.\include\linux\openvswitch.h	/^	OVS_ACTION_ATTR_HASH,	      \/* struct ovs_action_hash. *\/$/;"	e	enum:ovs_action_attr
OVS_ACTION_ATTR_MAX	.\include\linux\openvswitch.h	613;"	d
OVS_ACTION_ATTR_OUTPUT	.\include\linux\openvswitch.h	/^	OVS_ACTION_ATTR_OUTPUT,	      \/* u32 port number. *\/$/;"	e	enum:ovs_action_attr
OVS_ACTION_ATTR_POP_MPLS	.\include\linux\openvswitch.h	/^	OVS_ACTION_ATTR_POP_MPLS,     \/* __be16 ethertype. *\/$/;"	e	enum:ovs_action_attr
OVS_ACTION_ATTR_POP_VLAN	.\include\linux\openvswitch.h	/^	OVS_ACTION_ATTR_POP_VLAN,     \/* No argument. *\/$/;"	e	enum:ovs_action_attr
OVS_ACTION_ATTR_PUSH_MPLS	.\include\linux\openvswitch.h	/^	OVS_ACTION_ATTR_PUSH_MPLS,    \/* struct ovs_action_push_mpls. *\/$/;"	e	enum:ovs_action_attr
OVS_ACTION_ATTR_PUSH_VLAN	.\include\linux\openvswitch.h	/^	OVS_ACTION_ATTR_PUSH_VLAN,    \/* struct ovs_action_push_vlan. *\/$/;"	e	enum:ovs_action_attr
OVS_ACTION_ATTR_RECIRC	.\include\linux\openvswitch.h	/^	OVS_ACTION_ATTR_RECIRC,	      \/* u32 recirc_id. *\/$/;"	e	enum:ovs_action_attr
OVS_ACTION_ATTR_SAMPLE	.\include\linux\openvswitch.h	/^	OVS_ACTION_ATTR_SAMPLE,       \/* Nested OVS_SAMPLE_ATTR_*. *\/$/;"	e	enum:ovs_action_attr
OVS_ACTION_ATTR_SET	.\include\linux\openvswitch.h	/^	OVS_ACTION_ATTR_SET,          \/* One nested OVS_KEY_ATTR_*. *\/$/;"	e	enum:ovs_action_attr
OVS_ACTION_ATTR_UNSPEC	.\include\linux\openvswitch.h	/^	OVS_ACTION_ATTR_UNSPEC,$/;"	e	enum:ovs_action_attr
OVS_ACTION_ATTR_USERSPACE	.\include\linux\openvswitch.h	/^	OVS_ACTION_ATTR_USERSPACE,    \/* Nested OVS_USERSPACE_ATTR_*. *\/$/;"	e	enum:ovs_action_attr
OVS_ADAPTIVE_MUTEX_INITIALIZER	.\lib\ovs-thread.h	50;"	d
OVS_ADAPTIVE_MUTEX_INITIALIZER	.\lib\ovs-thread.h	53;"	d
OVS_ALIGNED_STRUCT	.\lib\compiler.h	191;"	d
OVS_ALIGNED_STRUCT	.\lib\compiler.h	193;"	d
OVS_ATOMIC_CLANG_IMPL	.\lib\ovs-atomic-clang.h	22;"	d
OVS_ATOMIC_GCC4P_IMPL	.\lib\ovs-atomic-gcc4+.h	23;"	d
OVS_ATOMIC_H	.\lib\ovs-atomic.h	18;"	d
OVS_ATOMIC_LOCKED_IMPL	.\lib\ovs-atomic-locked.h	6;"	d
OVS_ATOMIC_PTHREADS_IMPL	.\lib\ovs-atomic-pthreads.h	24;"	d
OVS_BE16_MAX	.\include\openvswitch\types.h	42;"	d
OVS_BE32_MAX	.\include\openvswitch\types.h	43;"	d
OVS_BE64_MAX	.\include\openvswitch\types.h	44;"	d
OVS_BITWISE	.\include\openvswitch\types.h	25;"	d
OVS_BITWISE	.\include\openvswitch\types.h	28;"	d
OVS_CACHE_LINE_SIZE	.\lib\netdev-dpdk.c	54;"	d	file:
OVS_CB	.\datapath\datapath.h	111;"	d
OVS_CONSTRUCTOR	.\lib\compiler.h	199;"	d
OVS_CONSTRUCTOR	.\lib\compiler.h	204;"	d
OVS_DATAPATH_FAMILY	.\include\linux\openvswitch.h	61;"	d
OVS_DATAPATH_MCGROUP	.\include\linux\openvswitch.h	62;"	d
OVS_DATAPATH_VERSION	.\include\linux\openvswitch.h	68;"	d
OVS_DP_ATTR_MAX	.\include\linux\openvswitch.h	110;"	d
OVS_DP_ATTR_MEGAFLOW_STATS	.\include\linux\openvswitch.h	/^	OVS_DP_ATTR_MEGAFLOW_STATS,	\/* struct ovs_dp_megaflow_stats *\/$/;"	e	enum:ovs_datapath_attr
OVS_DP_ATTR_NAME	.\include\linux\openvswitch.h	/^	OVS_DP_ATTR_NAME,		\/* name of dp_ifindex netdev *\/$/;"	e	enum:ovs_datapath_attr
OVS_DP_ATTR_STATS	.\include\linux\openvswitch.h	/^	OVS_DP_ATTR_STATS,		\/* struct ovs_dp_stats *\/$/;"	e	enum:ovs_datapath_attr
OVS_DP_ATTR_UNSPEC	.\include\linux\openvswitch.h	/^	OVS_DP_ATTR_UNSPEC,$/;"	e	enum:ovs_datapath_attr
OVS_DP_ATTR_UPCALL_PID	.\include\linux\openvswitch.h	/^	OVS_DP_ATTR_UPCALL_PID,		\/* Netlink PID to receive upcalls *\/$/;"	e	enum:ovs_datapath_attr
OVS_DP_ATTR_USER_FEATURES	.\include\linux\openvswitch.h	/^	OVS_DP_ATTR_USER_FEATURES,	\/* OVS_DP_F_*  *\/$/;"	e	enum:ovs_datapath_attr
OVS_DP_CMD_DEL	.\include\linux\openvswitch.h	/^	OVS_DP_CMD_DEL,$/;"	e	enum:ovs_datapath_cmd
OVS_DP_CMD_GET	.\include\linux\openvswitch.h	/^	OVS_DP_CMD_GET,$/;"	e	enum:ovs_datapath_cmd
OVS_DP_CMD_NEW	.\include\linux\openvswitch.h	/^	OVS_DP_CMD_NEW,$/;"	e	enum:ovs_datapath_cmd
OVS_DP_CMD_SET	.\include\linux\openvswitch.h	/^	OVS_DP_CMD_SET$/;"	e	enum:ovs_datapath_cmd
OVS_DP_CMD_UNSPEC	.\include\linux\openvswitch.h	/^	OVS_DP_CMD_UNSPEC,$/;"	e	enum:ovs_datapath_cmd
OVS_DP_F_UNALIGNED	.\include\linux\openvswitch.h	140;"	d
OVS_DP_F_VPORT_PIDS	.\include\linux\openvswitch.h	143;"	d
OVS_DP_VER_FEATURES	.\include\linux\openvswitch.h	71;"	d
OVS_EXCLUDED	.\lib\bfd.c	/^                   const struct ofpbuf *p) OVS_EXCLUDED(mutex)$/;"	f
OVS_EXCLUDED	.\lib\bfd.c	/^                 void *aux OVS_UNUSED) OVS_EXCLUDED(mutex)$/;"	f
OVS_EXCLUDED	.\lib\bfd.c	/^               uint8_t eth_src[ETH_ADDR_LEN]) OVS_EXCLUDED(mutex)$/;"	f
OVS_EXCLUDED	.\lib\bfd.c	/^              struct netdev *netdev) OVS_EXCLUDED(mutex)$/;"	f
OVS_EXCLUDED	.\lib\bfd.c	/^    OVS_EXCLUDED(mutex)$/;"	f
OVS_EXCLUDED	.\lib\bfd.c	/^bfd_check_status_change(struct bfd *bfd) OVS_EXCLUDED(mutex)$/;"	f
OVS_EXCLUDED	.\lib\bfd.c	/^bfd_forwarding(struct bfd *bfd) OVS_EXCLUDED(mutex)$/;"	f
OVS_EXCLUDED	.\lib\bfd.c	/^bfd_run(struct bfd *bfd) OVS_EXCLUDED(mutex)$/;"	f
OVS_EXCLUDED	.\lib\bfd.c	/^bfd_should_send_packet(const struct bfd *bfd) OVS_EXCLUDED(mutex)$/;"	f
OVS_EXCLUDED	.\lib\bfd.c	/^bfd_unref(struct bfd *bfd) OVS_EXCLUDED(mutex)$/;"	f
OVS_EXCLUDED	.\lib\bfd.c	/^bfd_wait(const struct bfd *bfd) OVS_EXCLUDED(mutex)$/;"	f
OVS_EXCLUDED	.\lib\bfd.c	/^bfd_wake_time(const struct bfd *bfd) OVS_EXCLUDED(mutex)$/;"	f
OVS_EXCLUDED	.\lib\cfm.c	/^                      void *aux OVS_UNUSED) OVS_EXCLUDED(mutex)$/;"	f
OVS_EXCLUDED	.\lib\cfm.c	/^                 void *aux OVS_UNUSED) OVS_EXCLUDED(mutex)$/;"	f
OVS_EXCLUDED	.\lib\cfm.c	/^                uint8_t eth_src[ETH_ADDR_LEN]) OVS_EXCLUDED(mutex)$/;"	f
OVS_EXCLUDED	.\lib\cfm.c	/^    OVS_EXCLUDED(mutex)$/;"	f
OVS_EXCLUDED	.\lib\cfm.c	/^cfm_check_status_change(struct cfm *cfm) OVS_EXCLUDED(mutex)$/;"	f
OVS_EXCLUDED	.\lib\cfm.c	/^cfm_create(const struct netdev *netdev) OVS_EXCLUDED(mutex)$/;"	f
OVS_EXCLUDED	.\lib\cfm.c	/^cfm_get_fault(const struct cfm *cfm) OVS_EXCLUDED(mutex)$/;"	f
OVS_EXCLUDED	.\lib\cfm.c	/^cfm_get_flap_count(const struct cfm *cfm) OVS_EXCLUDED(mutex)$/;"	f
OVS_EXCLUDED	.\lib\cfm.c	/^cfm_get_health(const struct cfm *cfm) OVS_EXCLUDED(mutex)$/;"	f
OVS_EXCLUDED	.\lib\cfm.c	/^cfm_get_opup(const struct cfm *cfm_) OVS_EXCLUDED(mutex)$/;"	f
OVS_EXCLUDED	.\lib\cfm.c	/^cfm_run(struct cfm *cfm) OVS_EXCLUDED(mutex)$/;"	f
OVS_EXCLUDED	.\lib\cfm.c	/^cfm_should_send_ccm(struct cfm *cfm) OVS_EXCLUDED(mutex)$/;"	f
OVS_EXCLUDED	.\lib\cfm.c	/^cfm_unref(struct cfm *cfm) OVS_EXCLUDED(mutex)$/;"	f
OVS_EXCLUDED	.\lib\cfm.c	/^cfm_wait(struct cfm *cfm) OVS_EXCLUDED(mutex)$/;"	f
OVS_EXCLUDED	.\lib\cfm.c	/^cfm_wake_time(struct cfm *cfm) OVS_EXCLUDED(mutex)$/;"	f
OVS_EXCLUDED	.\lib\compiler.h	133;"	d
OVS_EXCLUDED	.\lib\compiler.h	151;"	d
OVS_EXCLUDED	.\lib\lacp.c	/^                  void *aux OVS_UNUSED) OVS_EXCLUDED(mutex)$/;"	f
OVS_EXCLUDED	.\lib\lacp.c	/^    OVS_EXCLUDED(mutex)$/;"	f
OVS_EXCLUDED	.\lib\lacp.c	/^lacp_create(void) OVS_EXCLUDED(mutex)$/;"	f
OVS_EXCLUDED	.\lib\lacp.c	/^lacp_is_active(const struct lacp *lacp) OVS_EXCLUDED(mutex)$/;"	f
OVS_EXCLUDED	.\lib\lacp.c	/^lacp_run(struct lacp *lacp, lacp_send_pdu *send_pdu) OVS_EXCLUDED(mutex)$/;"	f
OVS_EXCLUDED	.\lib\lacp.c	/^lacp_status(const struct lacp *lacp) OVS_EXCLUDED(mutex)$/;"	f
OVS_EXCLUDED	.\lib\lacp.c	/^lacp_unref(struct lacp *lacp) OVS_EXCLUDED(mutex)$/;"	f
OVS_EXCLUDED	.\lib\lacp.c	/^lacp_wait(struct lacp *lacp) OVS_EXCLUDED(mutex)$/;"	f
OVS_EXCLUDED	.\lib\netdev.c	/^    OVS_EXCLUDED(netdev_class_mutex, netdev_mutex)$/;"	f
OVS_EXCLUDED	.\lib\netdev.c	/^    OVS_EXCLUDED(netdev_mutex)$/;"	f
OVS_EXCLUDED	.\lib\route-table.c	/^    OVS_EXCLUDED(route_table_mutex)$/;"	f
OVS_EXCLUDED	.\lib\seq.c	/^     OVS_EXCLUDED(seq_mutex)$/;"	f
OVS_EXCLUDED	.\lib\seq.c	/^    OVS_EXCLUDED(seq_mutex)$/;"	f
OVS_EXCLUDED	.\lib\seq.c	/^struct seq * OVS_EXCLUDED(seq_mutex)$/;"	f
OVS_EXCLUDED	.\ofproto\connmgr.c	/^    OVS_EXCLUDED(ofproto_mutex)$/;"	f
OVS_EXCLUDED	.\ofproto\connmgr.c	/^connmgr_wants_packet_in_on_miss(struct connmgr *mgr) OVS_EXCLUDED(ofproto_mutex)$/;"	f
OVS_EXCLUDED	.\ofproto\fail-open.c	/^    OVS_EXCLUDED(ofproto_mutex)$/;"	f
OVS_EXCLUDED	.\ofproto\netflow.c	/^    OVS_EXCLUDED(mutex)$/;"	f
OVS_EXCLUDED	.\ofproto\netflow.c	/^netflow_flow_clear(struct netflow *nf, struct flow *flow) OVS_EXCLUDED(mutex)$/;"	f
OVS_EXCLUDED	.\ofproto\netflow.c	/^netflow_wait(struct netflow *nf) OVS_EXCLUDED(mutex)$/;"	f
OVS_EXCLUDED	.\ofproto\ofproto-dpif-ipfix.c	/^                         const struct flow *flow) OVS_EXCLUDED(mutex)$/;"	f
OVS_EXCLUDED	.\ofproto\ofproto-dpif-ipfix.c	/^                       uint32_t obs_point_id) OVS_EXCLUDED(mutex)$/;"	f
OVS_EXCLUDED	.\ofproto\ofproto-dpif-ipfix.c	/^    OVS_EXCLUDED(mutex)$/;"	f
OVS_EXCLUDED	.\ofproto\ofproto-dpif-ipfix.c	/^    size_t n_flow_exporters_options) OVS_EXCLUDED(mutex)$/;"	f
OVS_EXCLUDED	.\ofproto\ofproto-dpif-ipfix.c	/^dpif_ipfix_run(struct dpif_ipfix *di) OVS_EXCLUDED(mutex)$/;"	f
OVS_EXCLUDED	.\ofproto\ofproto-dpif-ipfix.c	/^dpif_ipfix_unref(struct dpif_ipfix *di) OVS_EXCLUDED(mutex)$/;"	f
OVS_EXCLUDED	.\ofproto\ofproto-dpif-ipfix.c	/^dpif_ipfix_wait(struct dpif_ipfix *di) OVS_EXCLUDED(mutex)$/;"	f
OVS_EXCLUDED	.\ofproto\ofproto-dpif-sflow.c	/^                               odp_port_t odp_port) OVS_EXCLUDED(mutex)$/;"	f
OVS_EXCLUDED	.\ofproto\ofproto-dpif-sflow.c	/^                    odp_port_t odp_port) OVS_EXCLUDED(mutex)$/;"	f
OVS_EXCLUDED	.\ofproto\ofproto-dpif-sflow.c	/^    OVS_EXCLUDED(mutex)$/;"	f
OVS_EXCLUDED	.\ofproto\ofproto-dpif-sflow.c	/^dpif_sflow_clear(struct dpif_sflow *ds) OVS_EXCLUDED(mutex)$/;"	f
OVS_EXCLUDED	.\ofproto\ofproto-dpif-sflow.c	/^dpif_sflow_get_probability(const struct dpif_sflow *ds) OVS_EXCLUDED(mutex)$/;"	f
OVS_EXCLUDED	.\ofproto\ofproto-dpif-sflow.c	/^dpif_sflow_is_enabled(const struct dpif_sflow *ds) OVS_EXCLUDED(mutex)$/;"	f
OVS_EXCLUDED	.\ofproto\ofproto-dpif-sflow.c	/^dpif_sflow_run(struct dpif_sflow *ds) OVS_EXCLUDED(mutex)$/;"	f
OVS_EXCLUDED	.\ofproto\ofproto-dpif-sflow.c	/^dpif_sflow_unref(struct dpif_sflow *ds) OVS_EXCLUDED(mutex)$/;"	f
OVS_EXCLUDED	.\ofproto\ofproto-dpif-sflow.c	/^dpif_sflow_wait(struct dpif_sflow *ds) OVS_EXCLUDED(mutex)$/;"	f
OVS_EXCLUDED	.\ofproto\ofproto-dpif-xlate.c	/^    OVS_EXCLUDED(xlate_rwlock)$/;"	f
OVS_EXCLUDED	.\ofproto\ofproto.c	/^    OVS_EXCLUDED(ofproto_mutex)$/;"	f
OVS_EXCLUDED	.\ofproto\tunnel.c	/^              struct flow_wildcards *wc) OVS_EXCLUDED(rwlock)$/;"	f
OVS_EXCLUDED	.\ofproto\tunnel.c	/^             odp_port_t odp_port) OVS_EXCLUDED(rwlock)$/;"	f
OVS_EXCLUDED	.\ofproto\tunnel.c	/^    OVS_EXCLUDED(rwlock)$/;"	f
OVS_EXCLUDED	.\ofproto\tunnel.c	/^tnl_port_del(const struct ofport_dpif *ofport) OVS_EXCLUDED(rwlock)$/;"	f
OVS_EXCLUDED	.\ofproto\tunnel.c	/^tnl_port_receive(const struct flow *flow) OVS_EXCLUDED(rwlock)$/;"	f
OVS_FLOW_ATTR_ACTIONS	.\include\linux\openvswitch.h	/^	OVS_FLOW_ATTR_ACTIONS,   \/* Nested OVS_ACTION_ATTR_* attributes. *\/$/;"	e	enum:ovs_flow_attr
OVS_FLOW_ATTR_CLEAR	.\include\linux\openvswitch.h	/^	OVS_FLOW_ATTR_CLEAR,     \/* Flag to clear stats, tcp_flags, used. *\/$/;"	e	enum:ovs_flow_attr
OVS_FLOW_ATTR_KEY	.\include\linux\openvswitch.h	/^	OVS_FLOW_ATTR_KEY,       \/* Sequence of OVS_KEY_ATTR_* attributes. *\/$/;"	e	enum:ovs_flow_attr
OVS_FLOW_ATTR_MASK	.\include\linux\openvswitch.h	/^	OVS_FLOW_ATTR_MASK,      \/* Sequence of OVS_KEY_ATTR_* attributes. *\/$/;"	e	enum:ovs_flow_attr
OVS_FLOW_ATTR_MAX	.\include\linux\openvswitch.h	479;"	d
OVS_FLOW_ATTR_STATS	.\include\linux\openvswitch.h	/^	OVS_FLOW_ATTR_STATS,     \/* struct ovs_flow_stats. *\/$/;"	e	enum:ovs_flow_attr
OVS_FLOW_ATTR_TCP_FLAGS	.\include\linux\openvswitch.h	/^	OVS_FLOW_ATTR_TCP_FLAGS, \/* 8-bit OR'd TCP flags. *\/$/;"	e	enum:ovs_flow_attr
OVS_FLOW_ATTR_UNSPEC	.\include\linux\openvswitch.h	/^	OVS_FLOW_ATTR_UNSPEC,$/;"	e	enum:ovs_flow_attr
OVS_FLOW_ATTR_USED	.\include\linux\openvswitch.h	/^	OVS_FLOW_ATTR_USED,      \/* u64 msecs last used in monotonic time. *\/$/;"	e	enum:ovs_flow_attr
OVS_FLOW_CMD_DEL	.\include\linux\openvswitch.h	/^	OVS_FLOW_CMD_DEL,$/;"	e	enum:ovs_flow_cmd
OVS_FLOW_CMD_GET	.\include\linux\openvswitch.h	/^	OVS_FLOW_CMD_GET,$/;"	e	enum:ovs_flow_cmd
OVS_FLOW_CMD_NEW	.\include\linux\openvswitch.h	/^	OVS_FLOW_CMD_NEW,$/;"	e	enum:ovs_flow_cmd
OVS_FLOW_CMD_SET	.\include\linux\openvswitch.h	/^	OVS_FLOW_CMD_SET$/;"	e	enum:ovs_flow_cmd
OVS_FLOW_CMD_UNSPEC	.\include\linux\openvswitch.h	/^	OVS_FLOW_CMD_UNSPEC,$/;"	e	enum:ovs_flow_cmd
OVS_FLOW_FAMILY	.\include\linux\openvswitch.h	281;"	d
OVS_FLOW_MCGROUP	.\include\linux\openvswitch.h	282;"	d
OVS_FLOW_VERSION	.\include\linux\openvswitch.h	283;"	d
OVS_FORCE	.\include\openvswitch\types.h	26;"	d
OVS_FORCE	.\include\openvswitch\types.h	29;"	d
OVS_FRAG_TYPE_FIRST	.\include\linux\openvswitch.h	/^	OVS_FRAG_TYPE_FIRST,$/;"	e	enum:ovs_frag_type
OVS_FRAG_TYPE_LATER	.\include\linux\openvswitch.h	/^	OVS_FRAG_TYPE_LATER,$/;"	e	enum:ovs_frag_type
OVS_FRAG_TYPE_MAX	.\include\linux\openvswitch.h	364;"	d
OVS_FRAG_TYPE_NONE	.\include\linux\openvswitch.h	/^	OVS_FRAG_TYPE_NONE,$/;"	e	enum:ovs_frag_type
OVS_GSO_CB	.\datapath\linux\compat\gso.h	18;"	d
OVS_GUARDED	.\lib\compiler.h	130;"	d
OVS_GUARDED	.\lib\compiler.h	149;"	d
OVS_GUARDED	.\lib\dpif-netdev.c	/^    long long int byte_count OVS_GUARDED;   \/* Number of bytes matched. *\/$/;"	m	struct:dp_netdev_flow_stats	file:
OVS_GUARDED	.\lib\dpif-netdev.c	/^    long long int packet_count OVS_GUARDED; \/* Number of packets matched. *\/$/;"	m	struct:dp_netdev_flow_stats	file:
OVS_GUARDED	.\lib\dpif-netdev.c	/^    long long int used OVS_GUARDED; \/* Last used time, in monotonic msecs. *\/$/;"	m	struct:dp_netdev_flow_stats	file:
OVS_GUARDED	.\lib\dpif-netdev.c	/^    struct dp_netdev_upcall upcalls[MAX_QUEUE_LEN] OVS_GUARDED;$/;"	m	struct:dp_netdev_queue	typeref:struct:dp_netdev_queue::upcalls	file:
OVS_GUARDED	.\lib\dpif-netdev.c	/^    struct hmap flow_table OVS_GUARDED; \/* Flow table. *\/$/;"	m	struct:dp_netdev	typeref:struct:dp_netdev::flow_table	file:
OVS_GUARDED	.\lib\dpif-netdev.c	/^    struct hmap ports OVS_GUARDED;$/;"	m	struct:dp_netdev	typeref:struct:dp_netdev::ports	file:
OVS_GUARDED	.\lib\dpif-netdev.c	/^    uint16_t tcp_flags OVS_GUARDED; \/* Bitwise-OR of seen tcp_flags values. *\/$/;"	m	struct:dp_netdev_flow_stats	file:
OVS_GUARDED	.\lib\dpif-netdev.c	/^    unsigned int head OVS_GUARDED;$/;"	m	struct:dp_netdev_queue	file:
OVS_GUARDED	.\lib\dpif-netdev.c	/^    unsigned int tail OVS_GUARDED;$/;"	m	struct:dp_netdev_queue	file:
OVS_GUARDED	.\lib\dpif-netdev.c	/^    unsigned long long int n[DP_N_STATS] OVS_GUARDED;$/;"	m	struct:dp_netdev_stats	file:
OVS_GUARDED	.\lib\fat-rwlock.h	/^    struct list threads OVS_GUARDED;$/;"	m	struct:fat_rwlock	typeref:struct:fat_rwlock::threads
OVS_GUARDED	.\lib\mac-learning.h	/^    struct list lru_node OVS_GUARDED; \/* Element in 'lrus' list. *\/$/;"	m	struct:mac_entry	typeref:struct:mac_entry::lru_node
OVS_GUARDED	.\lib\mac-learning.h	/^    struct list lrus OVS_GUARDED; \/* In-use entries, least recently used at the$/;"	m	struct:mac_learning	typeref:struct:mac_learning::lrus
OVS_GUARDED	.\lib\mac-learning.h	/^    } port OVS_GUARDED;$/;"	m	struct:mac_entry	typeref:union:mac_entry::__anon52
OVS_GUARDED	.\lib\netdev-dummy.c	/^    FILE *tx_pcap, *rxq_pcap OVS_GUARDED;$/;"	m	struct:netdev_dummy	file:
OVS_GUARDED	.\lib\netdev-dummy.c	/^    enum netdev_flags flags OVS_GUARDED;$/;"	m	struct:netdev_dummy	typeref:enum:netdev_dummy::flags	file:
OVS_GUARDED	.\lib\netdev-dummy.c	/^    int ifindex OVS_GUARDED;$/;"	m	struct:netdev_dummy	file:
OVS_GUARDED	.\lib\netdev-dummy.c	/^    int mtu OVS_GUARDED;$/;"	m	struct:netdev_dummy	file:
OVS_GUARDED	.\lib\netdev-dummy.c	/^    struct dummy_packet_conn conn OVS_GUARDED;$/;"	m	struct:netdev_dummy	typeref:struct:netdev_dummy::conn	file:
OVS_GUARDED	.\lib\netdev-dummy.c	/^    struct list rxes OVS_GUARDED; \/* List of child "netdev_rxq_dummy"s. *\/$/;"	m	struct:netdev_dummy	typeref:struct:netdev_dummy::rxes	file:
OVS_GUARDED	.\lib\netdev-dummy.c	/^    struct netdev_stats stats OVS_GUARDED;$/;"	m	struct:netdev_dummy	typeref:struct:netdev_dummy::stats	file:
OVS_GUARDED	.\lib\netdev-dummy.c	/^    uint8_t hwaddr[ETH_ADDR_LEN] OVS_GUARDED;$/;"	m	struct:netdev_dummy	file:
OVS_GUARDED	.\lib\rconn.h	/^    int ref_cnt OVS_GUARDED;            \/* Number of owners. *\/$/;"	m	struct:rconn_packet_counter
OVS_GUARDED	.\lib\rconn.h	/^    unsigned int n_bytes OVS_GUARDED;   \/* Number of bytes queued. *\/$/;"	m	struct:rconn_packet_counter
OVS_GUARDED	.\lib\rconn.h	/^    unsigned int n_packets OVS_GUARDED; \/* Number of packets queued. *\/$/;"	m	struct:rconn_packet_counter
OVS_GUARDED	.\lib\seq.c	/^    bool waiting OVS_GUARDED;        \/* True if latch_wait() already called. *\/$/;"	m	struct:seq_thread	file:
OVS_GUARDED	.\lib\seq.c	/^    struct hmap waiters OVS_GUARDED; \/* Contains 'struct seq_waiter's. *\/$/;"	m	struct:seq	typeref:struct:seq::waiters	file:
OVS_GUARDED	.\lib\seq.c	/^    struct hmap_node hmap_node OVS_GUARDED; \/* In 'seq->waiters'. *\/$/;"	m	struct:seq_waiter	typeref:struct:seq_waiter::hmap_node	file:
OVS_GUARDED	.\lib\seq.c	/^    struct latch latch OVS_GUARDED;  \/* Wakeup latch for this thread. *\/$/;"	m	struct:seq_thread	typeref:struct:seq_thread::latch	file:
OVS_GUARDED	.\lib\seq.c	/^    struct list list_node OVS_GUARDED;     \/* In 'thread->waiters'. *\/$/;"	m	struct:seq_waiter	typeref:struct:seq_waiter::list_node	file:
OVS_GUARDED	.\lib\seq.c	/^    struct list waiters OVS_GUARDED; \/* Contains 'struct seq_waiter's. *\/$/;"	m	struct:seq_thread	typeref:struct:seq_thread::waiters	file:
OVS_GUARDED	.\lib\seq.c	/^    struct seq *seq OVS_GUARDED;            \/* Seq being waited for. *\/$/;"	m	struct:seq_waiter	typeref:struct:seq_waiter::seq	file:
OVS_GUARDED	.\lib\seq.c	/^    struct seq_thread *thread OVS_GUARDED; \/* Thread preparing to wait. *\/$/;"	m	struct:seq_waiter	typeref:struct:seq_waiter::thread	file:
OVS_GUARDED	.\lib\seq.c	/^    uint64_t value OVS_GUARDED; \/* seq->value we're waiting to change. *\/$/;"	m	struct:seq_waiter	file:
OVS_GUARDED	.\lib\seq.c	/^    uint64_t value OVS_GUARDED;$/;"	m	struct:seq	file:
OVS_GUARDED	.\lib\seq.c	/^    unsigned int ovsthread_id OVS_GUARDED;  \/* Key in 'waiters' hmap. *\/$/;"	m	struct:seq_waiter	file:
OVS_GUARDED	.\lib\timeval.c	/^    bool stopped OVS_GUARDED;          \/* Disable real-time updates if true. *\/$/;"	m	struct:clock	file:
OVS_GUARDED	.\lib\timeval.c	/^    struct timespec cache OVS_GUARDED; \/* Last time read from kernel. *\/$/;"	m	struct:clock	typeref:struct:clock::cache	file:
OVS_GUARDED	.\lib\timeval.c	/^    struct timespec warp OVS_GUARDED;  \/* Offset added for unit tests. *\/$/;"	m	struct:clock	typeref:struct:clock::warp	file:
OVS_GUARDED	.\ofproto\bond.c	/^    struct list enabled_slaves OVS_GUARDED; \/* Contains struct bond_slaves. *\/$/;"	m	struct:bond	typeref:struct:bond::enabled_slaves	file:
OVS_GUARDED	.\ofproto\ofproto-dpif-upcall.c	/^        struct hmap hmap OVS_GUARDED;  \/* Datapath flow keys. *\/$/;"	m	struct:udpif::__anon135	typeref:struct:udpif::__anon135::hmap	file:
OVS_GUARDED	.\ofproto\ofproto-dpif-upcall.c	/^    bool flow_exists OVS_GUARDED;             \/* Ensures flows are only deleted$/;"	m	struct:udpif_key	file:
OVS_GUARDED	.\ofproto\ofproto-dpif-upcall.c	/^    bool mark OVS_GUARDED;                    \/* For mark and sweep garbage$/;"	m	struct:udpif_key	file:
OVS_GUARDED	.\ofproto\ofproto-dpif-upcall.c	/^    long long int created OVS_GUARDED;        \/* Estimate of creation time. *\/$/;"	m	struct:udpif_key	file:
OVS_GUARDED	.\ofproto\ofproto-dpif-upcall.c	/^    struct dpif_flow_stats stats OVS_GUARDED; \/* Last known stats.*\/$/;"	m	struct:udpif_key	typeref:struct:udpif_key::stats	file:
OVS_GUARDED	.\ofproto\ofproto-dpif-upcall.c	/^    struct xlate_cache *xcache OVS_GUARDED;   \/* Cache for xlate entries that$/;"	m	struct:udpif_key	typeref:struct:udpif_key::xcache	file:
OVS_GUARDED	.\ofproto\ofproto-dpif.c	/^    struct bucket_counter *bucket_stats OVS_GUARDED;  \/* Bucket statistics. *\/$/;"	m	struct:group_dpif	typeref:struct:group_dpif::bucket_stats	file:
OVS_GUARDED	.\ofproto\ofproto-dpif.c	/^    struct dpif_flow_stats stats OVS_GUARDED;$/;"	m	struct:rule_dpif	typeref:struct:rule_dpif::stats	file:
OVS_GUARDED	.\ofproto\ofproto-dpif.c	/^    struct hmap odp_to_ofport_map OVS_GUARDED; \/* Contains "struct ofport"s. *\/$/;"	m	struct:dpif_backer	typeref:struct:dpif_backer::odp_to_ofport_map	file:
OVS_GUARDED	.\ofproto\ofproto-dpif.c	/^    struct hmap realdev_vid_map OVS_GUARDED; \/* (realdev,vid) -> vlandev. *\/$/;"	m	struct:ofproto_dpif	typeref:struct:ofproto_dpif::realdev_vid_map	file:
OVS_GUARDED	.\ofproto\ofproto-dpif.c	/^    struct hmap vlandev_map OVS_GUARDED;     \/* vlandev -> (realdev,vid). *\/$/;"	m	struct:ofproto_dpif	typeref:struct:ofproto_dpif::vlandev_map	file:
OVS_GUARDED	.\ofproto\ofproto-dpif.c	/^    struct netdev_stats stats OVS_GUARDED; \/* To account packets generated and$/;"	m	struct:ofproto_dpif	typeref:struct:ofproto_dpif::stats	file:
OVS_GUARDED	.\ofproto\ofproto-dpif.c	/^    uint64_t byte_count OVS_GUARDED;    \/* Number of bytes received. *\/$/;"	m	struct:group_dpif	file:
OVS_GUARDED	.\ofproto\ofproto-dpif.c	/^    uint64_t packet_count OVS_GUARDED;  \/* Number of packets received. *\/$/;"	m	struct:group_dpif	file:
OVS_GUARDED	.\ofproto\ofproto-provider.h	/^    enum ofputil_flow_mod_flags flags OVS_GUARDED;$/;"	m	struct:rule	typeref:enum:rule::flags
OVS_GUARDED	.\ofproto\ofproto-provider.h	/^    long long int created OVS_GUARDED; \/* Creation time. *\/$/;"	m	struct:rule
OVS_GUARDED	.\ofproto\ofproto-provider.h	/^    long long int modified OVS_GUARDED; \/* Time of last modification. *\/$/;"	m	struct:rule
OVS_GUARDED	.\ofproto\ofproto-provider.h	/^    ovs_be64 flow_cookie OVS_GUARDED;$/;"	m	struct:rule
OVS_GUARDED	.\ofproto\ofproto-provider.h	/^    struct hmap groups OVS_GUARDED;   \/* Contains "struct ofgroup"s. *\/$/;"	m	struct:ofproto	typeref:struct:ofproto::groups
OVS_GUARDED	.\ofproto\ofproto-provider.h	/^    uint16_t hard_timeout OVS_GUARDED; \/* In seconds from ->modified. *\/$/;"	m	struct:rule
OVS_GUARDED	.\ofproto\ofproto-provider.h	/^    uint16_t idle_timeout OVS_GUARDED; \/* In seconds from ->used. *\/$/;"	m	struct:rule
OVS_GUARDED	.\ofproto\ofproto-provider.h	/^    uint32_t n_groups[4] OVS_GUARDED; \/* # of existing groups of each type. *\/$/;"	m	struct:ofproto
OVS_GUARDED_BY	.\lib\compiler.h	131;"	d
OVS_GUARDED_BY	.\lib\compiler.h	150;"	d
OVS_HASH_ALG_L4	.\include\linux\openvswitch.h	/^	OVS_HASH_ALG_L4,$/;"	e	enum:ovs_hash_alg
OVS_INSTRUCTIONS	.\lib\ofp-actions.h	/^    OVS_INSTRUCTIONS$/;"	e	enum:ovs_instruction_type
OVS_INSTRUCTIONS	.\lib\ofp-actions.h	712;"	d
OVS_KEY_ATTR_ARP	.\include\linux\openvswitch.h	/^	OVS_KEY_ATTR_ARP,       \/* struct ovs_key_arp *\/$/;"	e	enum:ovs_key_attr
OVS_KEY_ATTR_BUFSIZE	.\lib\odp-util.c	/^enum { OVS_KEY_ATTR_BUFSIZE = 3 + INT_STRLEN(unsigned int) + 1 };$/;"	e	enum:__anon66	file:
OVS_KEY_ATTR_DP_HASH	.\include\linux\openvswitch.h	/^	OVS_KEY_ATTR_DP_HASH,	\/* u32 hash value. Value 0 indicates the hash$/;"	e	enum:ovs_key_attr
OVS_KEY_ATTR_ENCAP	.\include\linux\openvswitch.h	/^	OVS_KEY_ATTR_ENCAP,	\/* Nested set of encapsulated attributes. *\/$/;"	e	enum:ovs_key_attr
OVS_KEY_ATTR_ETHERNET	.\include\linux\openvswitch.h	/^	OVS_KEY_ATTR_ETHERNET,  \/* struct ovs_key_ethernet *\/$/;"	e	enum:ovs_key_attr
OVS_KEY_ATTR_ETHERTYPE	.\include\linux\openvswitch.h	/^	OVS_KEY_ATTR_ETHERTYPE,	\/* be16 Ethernet type *\/$/;"	e	enum:ovs_key_attr
OVS_KEY_ATTR_ICMP	.\include\linux\openvswitch.h	/^	OVS_KEY_ATTR_ICMP,      \/* struct ovs_key_icmp *\/$/;"	e	enum:ovs_key_attr
OVS_KEY_ATTR_ICMPV6	.\include\linux\openvswitch.h	/^	OVS_KEY_ATTR_ICMPV6,    \/* struct ovs_key_icmpv6 *\/$/;"	e	enum:ovs_key_attr
OVS_KEY_ATTR_IN_PORT	.\include\linux\openvswitch.h	/^	OVS_KEY_ATTR_IN_PORT,   \/* u32 OVS dp port number *\/$/;"	e	enum:ovs_key_attr
OVS_KEY_ATTR_IPV4	.\include\linux\openvswitch.h	/^	OVS_KEY_ATTR_IPV4,      \/* struct ovs_key_ipv4 *\/$/;"	e	enum:ovs_key_attr
OVS_KEY_ATTR_IPV4_TUNNEL	.\include\linux\openvswitch.h	/^	OVS_KEY_ATTR_IPV4_TUNNEL,  \/* struct ovs_key_ipv4_tunnel *\/$/;"	e	enum:ovs_key_attr
OVS_KEY_ATTR_IPV6	.\include\linux\openvswitch.h	/^	OVS_KEY_ATTR_IPV6,      \/* struct ovs_key_ipv6 *\/$/;"	e	enum:ovs_key_attr
OVS_KEY_ATTR_MAX	.\include\linux\openvswitch.h	333;"	d
OVS_KEY_ATTR_MPLS	.\include\linux\openvswitch.h	/^	OVS_KEY_ATTR_MPLS = 62, \/* array of struct ovs_key_mpls.$/;"	e	enum:ovs_key_attr
OVS_KEY_ATTR_ND	.\include\linux\openvswitch.h	/^	OVS_KEY_ATTR_ND,        \/* struct ovs_key_nd *\/$/;"	e	enum:ovs_key_attr
OVS_KEY_ATTR_PRIORITY	.\include\linux\openvswitch.h	/^	OVS_KEY_ATTR_PRIORITY,  \/* u32 skb->priority *\/$/;"	e	enum:ovs_key_attr
OVS_KEY_ATTR_RECIRC_ID	.\include\linux\openvswitch.h	/^	OVS_KEY_ATTR_RECIRC_ID, \/* u32 recirc id *\/$/;"	e	enum:ovs_key_attr
OVS_KEY_ATTR_SCTP	.\include\linux\openvswitch.h	/^	OVS_KEY_ATTR_SCTP,      \/* struct ovs_key_sctp *\/$/;"	e	enum:ovs_key_attr
OVS_KEY_ATTR_SKB_MARK	.\include\linux\openvswitch.h	/^	OVS_KEY_ATTR_SKB_MARK,  \/* u32 skb mark *\/$/;"	e	enum:ovs_key_attr
OVS_KEY_ATTR_TCP	.\include\linux\openvswitch.h	/^	OVS_KEY_ATTR_TCP,       \/* struct ovs_key_tcp *\/$/;"	e	enum:ovs_key_attr
OVS_KEY_ATTR_TCP_FLAGS	.\include\linux\openvswitch.h	/^	OVS_KEY_ATTR_TCP_FLAGS,	\/* be16 TCP flags. *\/$/;"	e	enum:ovs_key_attr
OVS_KEY_ATTR_TUNNEL	.\include\linux\openvswitch.h	/^	OVS_KEY_ATTR_TUNNEL,	\/* Nested set of ovs_tunnel attributes *\/$/;"	e	enum:ovs_key_attr
OVS_KEY_ATTR_UDP	.\include\linux\openvswitch.h	/^	OVS_KEY_ATTR_UDP,       \/* struct ovs_key_udp *\/$/;"	e	enum:ovs_key_attr
OVS_KEY_ATTR_UNSPEC	.\include\linux\openvswitch.h	/^	OVS_KEY_ATTR_UNSPEC,$/;"	e	enum:ovs_key_attr
OVS_KEY_ATTR_VLAN	.\include\linux\openvswitch.h	/^	OVS_KEY_ATTR_VLAN,	\/* be16 VLAN TCI *\/$/;"	e	enum:ovs_key_attr
OVS_LIKELY	.\lib\compiler.h	37;"	d
OVS_LIKELY	.\lib\compiler.h	49;"	d
OVS_LOCKABLE	.\lib\compiler.h	113;"	d
OVS_LOCKABLE	.\lib\compiler.h	139;"	d
OVS_MUTEX_INITIALIZER	.\lib\ovs-thread.h	43;"	d
OVS_MUTEX_INITIALIZER	.\lib\ovs-thread.h	46;"	d
OVS_NLERR	.\datapath\datapath.h	206;"	d
OVS_NOT_REACHED	.\lib\util.h	174;"	d
OVS_NO_THREAD_SAFETY_ANALYSIS	.\lib\compiler.h	136;"	d
OVS_NO_THREAD_SAFETY_ANALYSIS	.\lib\compiler.h	155;"	d
OVS_PACKED	.\lib\compiler.h	177;"	d
OVS_PACKED	.\lib\compiler.h	179;"	d
OVS_PACKED_ENUM	.\lib\compiler.h	171;"	d
OVS_PACKED_ENUM	.\lib\compiler.h	173;"	d
OVS_PACKET_ATTR_ACTIONS	.\include\linux\openvswitch.h	/^	OVS_PACKET_ATTR_ACTIONS,     \/* Nested OVS_ACTION_ATTR_* attributes. *\/$/;"	e	enum:ovs_packet_attr
OVS_PACKET_ATTR_KEY	.\include\linux\openvswitch.h	/^	OVS_PACKET_ATTR_KEY,         \/* Nested OVS_KEY_ATTR_* attributes. *\/$/;"	e	enum:ovs_packet_attr
OVS_PACKET_ATTR_MAX	.\include\linux\openvswitch.h	196;"	d
OVS_PACKET_ATTR_PACKET	.\include\linux\openvswitch.h	/^	OVS_PACKET_ATTR_PACKET,      \/* Packet data. *\/$/;"	e	enum:ovs_packet_attr
OVS_PACKET_ATTR_UNSPEC	.\include\linux\openvswitch.h	/^	OVS_PACKET_ATTR_UNSPEC,$/;"	e	enum:ovs_packet_attr
OVS_PACKET_ATTR_USERDATA	.\include\linux\openvswitch.h	/^	OVS_PACKET_ATTR_USERDATA,    \/* OVS_ACTION_ATTR_USERSPACE arg. *\/$/;"	e	enum:ovs_packet_attr
OVS_PACKET_CMD_ACTION	.\include\linux\openvswitch.h	/^	OVS_PACKET_CMD_ACTION,  \/* OVS_ACTION_ATTR_USERSPACE action. *\/$/;"	e	enum:ovs_packet_cmd
OVS_PACKET_CMD_EXECUTE	.\include\linux\openvswitch.h	/^	OVS_PACKET_CMD_EXECUTE  \/* Apply actions to a packet. *\/$/;"	e	enum:ovs_packet_cmd
OVS_PACKET_CMD_MISS	.\include\linux\openvswitch.h	/^	OVS_PACKET_CMD_MISS,    \/* Flow table miss. *\/$/;"	e	enum:ovs_packet_cmd
OVS_PACKET_CMD_UNSPEC	.\include\linux\openvswitch.h	/^	OVS_PACKET_CMD_UNSPEC,$/;"	e	enum:ovs_packet_cmd
OVS_PACKET_FAMILY	.\include\linux\openvswitch.h	150;"	d
OVS_PACKET_VERSION	.\include\linux\openvswitch.h	151;"	d
OVS_PKI	.\tests\automake.mk	/^OVS_PKI = $(SHELL) $(srcdir)\/utilities\/ovs-pki.in --dir=tests\/pki --log=tests\/ovs-pki.log$/;"	m
OVS_PREFETCH	.\lib\compiler.h	216;"	d
OVS_PREFETCH	.\lib\compiler.h	219;"	d
OVS_PREFETCH_WRITE	.\lib\compiler.h	217;"	d
OVS_PREFETCH_WRITE	.\lib\compiler.h	220;"	d
OVS_RCU_H	.\lib\ovs-rcu.h	18;"	d
OVS_RELEASES	.\lib\compiler.h	132;"	d
OVS_RELEASES	.\lib\compiler.h	152;"	d
OVS_RELEASES	.\lib\fat-rwlock.c	/^    OVS_RELEASES(rwlock_)$/;"	f
OVS_RELEASES	.\lib\lacp.c	/^lacp_unlock(void) OVS_RELEASES(mutex)$/;"	f
OVS_RELEASES	.\lib\netdev.c	/^    OVS_RELEASES(netdev_mutex)$/;"	f
OVS_REQUIRES	.\lib\bfd.c	/^        const struct bfd *bfd) OVS_REQUIRES(mutex)$/;"	f
OVS_REQUIRES	.\lib\bfd.c	/^    OVS_REQUIRES(mutex)$/;"	f
OVS_REQUIRES	.\lib\bfd.c	/^bfd_decay_update(struct bfd * bfd) OVS_REQUIRES(mutex)$/;"	f
OVS_REQUIRES	.\lib\bfd.c	/^bfd_find_by_name(const char *name) OVS_REQUIRES(mutex)$/;"	f
OVS_REQUIRES	.\lib\bfd.c	/^bfd_forwarding__(struct bfd *bfd) OVS_REQUIRES(mutex)$/;"	f
OVS_REQUIRES	.\lib\bfd.c	/^bfd_forwarding_if_rx_update(struct bfd *bfd) OVS_REQUIRES(mutex)$/;"	f
OVS_REQUIRES	.\lib\bfd.c	/^bfd_in_poll(const struct bfd *bfd) OVS_REQUIRES(mutex)$/;"	f
OVS_REQUIRES	.\lib\bfd.c	/^bfd_min_tx(const struct bfd *bfd) OVS_REQUIRES(mutex)$/;"	f
OVS_REQUIRES	.\lib\bfd.c	/^bfd_poll(struct bfd *bfd) OVS_REQUIRES(mutex)$/;"	f
OVS_REQUIRES	.\lib\bfd.c	/^bfd_put_details(struct ds *ds, const struct bfd *bfd) OVS_REQUIRES(mutex)$/;"	f
OVS_REQUIRES	.\lib\bfd.c	/^bfd_rx_interval(const struct bfd *bfd) OVS_REQUIRES(mutex)$/;"	f
OVS_REQUIRES	.\lib\bfd.c	/^bfd_rx_packets(const struct bfd *bfd) OVS_REQUIRES(mutex)$/;"	f
OVS_REQUIRES	.\lib\bfd.c	/^bfd_set_next_tx(struct bfd *bfd) OVS_REQUIRES(mutex)$/;"	f
OVS_REQUIRES	.\lib\bfd.c	/^bfd_status_changed(struct bfd *bfd) OVS_REQUIRES(mutex)$/;"	f
OVS_REQUIRES	.\lib\bfd.c	/^bfd_try_decay(struct bfd *bfd) OVS_REQUIRES(mutex)$/;"	f
OVS_REQUIRES	.\lib\bfd.c	/^bfd_tx_interval(const struct bfd *bfd) OVS_REQUIRES(mutex)$/;"	f
OVS_REQUIRES	.\lib\cfm.c	/^cfm_fault_interval(struct cfm *cfm) OVS_REQUIRES(mutex)$/;"	f
OVS_REQUIRES	.\lib\cfm.c	/^cfm_find(const char *name) OVS_REQUIRES(mutex)$/;"	f
OVS_REQUIRES	.\lib\cfm.c	/^cfm_generate_maid(struct cfm *cfm) OVS_REQUIRES(mutex)$/;"	f
OVS_REQUIRES	.\lib\cfm.c	/^cfm_get_fault__(const struct cfm *cfm) OVS_REQUIRES(mutex)$/;"	f
OVS_REQUIRES	.\lib\cfm.c	/^cfm_print_details(struct ds *ds, struct cfm *cfm) OVS_REQUIRES(mutex)$/;"	f
OVS_REQUIRES	.\lib\cfm.c	/^cfm_rx_packets(const struct cfm *cfm) OVS_REQUIRES(mutex)$/;"	f
OVS_REQUIRES	.\lib\cfm.c	/^cfm_status_changed(struct cfm *cfm) OVS_REQUIRES(mutex)$/;"	f
OVS_REQUIRES	.\lib\cfm.c	/^lookup_remote_mp(const struct cfm *cfm, uint64_t mpid) OVS_REQUIRES(mutex)$/;"	f
OVS_REQUIRES	.\lib\compiler.h	120;"	d
OVS_REQUIRES	.\lib\compiler.h	144;"	d
OVS_REQUIRES	.\lib\dpif-netdev.c	/^    OVS_REQUIRES(dp_netdev_mutex)$/;"	f
OVS_REQUIRES	.\lib\lacp.c	/^    OVS_REQUIRES(mutex)$/;"	f
OVS_REQUIRES	.\lib\lacp.c	/^lacp_find(const char *name) OVS_REQUIRES(mutex)$/;"	f
OVS_REQUIRES	.\lib\lacp.c	/^lacp_print_details(struct ds *ds, struct lacp *lacp) OVS_REQUIRES(mutex)$/;"	f
OVS_REQUIRES	.\lib\lacp.c	/^lacp_update_attached(struct lacp *lacp) OVS_REQUIRES(mutex)$/;"	f
OVS_REQUIRES	.\lib\lacp.c	/^slave_destroy(struct slave *slave) OVS_REQUIRES(mutex)$/;"	f
OVS_REQUIRES	.\lib\lacp.c	/^slave_lookup(const struct lacp *lacp, const void *slave_) OVS_REQUIRES(mutex)$/;"	f
OVS_REQUIRES	.\lib\lacp.c	/^slave_may_enable__(struct slave *slave) OVS_REQUIRES(mutex)$/;"	f
OVS_REQUIRES	.\lib\lacp.c	/^slave_may_tx(const struct slave *slave) OVS_REQUIRES(mutex)$/;"	f
OVS_REQUIRES	.\lib\lacp.c	/^slave_set_defaulted(struct slave *slave) OVS_REQUIRES(mutex)$/;"	f
OVS_REQUIRES	.\lib\lacp.c	/^slave_set_expired(struct slave *slave) OVS_REQUIRES(mutex)$/;"	f
OVS_REQUIRES	.\lib\netdev-dpdk.c	/^dpdk_eth_dev_init(struct netdev_dpdk *dev) OVS_REQUIRES(dpdk_mutex)$/;"	f
OVS_REQUIRES	.\lib\netdev-dpdk.c	/^dpdk_mp_get(int socket_id, int mtu) OVS_REQUIRES(dpdk_mutex)$/;"	f
OVS_REQUIRES	.\lib\route-table.c	/^    OVS_REQUIRES(route_table_mutex)$/;"	f
OVS_REQUIRES	.\lib\seq.c	/^    OVS_REQUIRES(seq_mutex)$/;"	f
OVS_REQUIRES	.\lib\stp.c	/^     OVS_REQUIRES(mutex)$/;"	f
OVS_REQUIRES	.\lib\stp.c	/^    OVS_REQUIRES(mutex)$/;"	f
OVS_REQUIRES	.\lib\stp.c	/^stp_acknowledge_topology_change(struct stp_port *p) OVS_REQUIRES(mutex)$/;"	f
OVS_REQUIRES	.\lib\stp.c	/^stp_become_designated_port(struct stp_port *p) OVS_REQUIRES(mutex)$/;"	f
OVS_REQUIRES	.\lib\stp.c	/^stp_become_root_bridge(struct stp *stp) OVS_REQUIRES(mutex)$/;"	f
OVS_REQUIRES	.\lib\stp.c	/^stp_config_bpdu_generation(struct stp *stp) OVS_REQUIRES(mutex)$/;"	f
OVS_REQUIRES	.\lib\stp.c	/^stp_configuration_update(struct stp *stp) OVS_REQUIRES(mutex)$/;"	f
OVS_REQUIRES	.\lib\stp.c	/^stp_designated_port_selection(struct stp *stp) OVS_REQUIRES(mutex)$/;"	f
OVS_REQUIRES	.\lib\stp.c	/^stp_find(const char *name) OVS_REQUIRES(mutex)$/;"	f
OVS_REQUIRES	.\lib\stp.c	/^stp_forward_delay_timer_expiry(struct stp_port *p) OVS_REQUIRES(mutex)$/;"	f
OVS_REQUIRES	.\lib\stp.c	/^stp_hello_timer_expiry(struct stp *stp) OVS_REQUIRES(mutex)$/;"	f
OVS_REQUIRES	.\lib\stp.c	/^stp_hold_timer_expiry(struct stp_port *p) OVS_REQUIRES(mutex)$/;"	f
OVS_REQUIRES	.\lib\stp.c	/^stp_is_designated_for_some_port(const struct stp *stp) OVS_REQUIRES(mutex)$/;"	f
OVS_REQUIRES	.\lib\stp.c	/^stp_is_designated_port(const struct stp_port *p) OVS_REQUIRES(mutex)$/;"	f
OVS_REQUIRES	.\lib\stp.c	/^stp_make_blocking(struct stp_port *p) OVS_REQUIRES(mutex)$/;"	f
OVS_REQUIRES	.\lib\stp.c	/^stp_make_forwarding(struct stp_port *p) OVS_REQUIRES(mutex)$/;"	f
OVS_REQUIRES	.\lib\stp.c	/^stp_message_age_timer_expiry(struct stp_port *p) OVS_REQUIRES(mutex)$/;"	f
OVS_REQUIRES	.\lib\stp.c	/^stp_port_state_selection(struct stp *stp) OVS_REQUIRES(mutex)$/;"	f
OVS_REQUIRES	.\lib\stp.c	/^stp_root_selection(struct stp *stp) OVS_REQUIRES(mutex)$/;"	f
OVS_REQUIRES	.\lib\stp.c	/^stp_start_timer(struct stp_timer *timer, int value) OVS_REQUIRES(mutex)$/;"	f
OVS_REQUIRES	.\lib\stp.c	/^stp_stop_timer(struct stp_timer *timer) OVS_REQUIRES(mutex)$/;"	f
OVS_REQUIRES	.\lib\stp.c	/^stp_tcn_timer_expiry(struct stp *stp) OVS_REQUIRES(mutex)$/;"	f
OVS_REQUIRES	.\lib\stp.c	/^stp_topology_change_acknowledged(struct stp *stp) OVS_REQUIRES(mutex)$/;"	f
OVS_REQUIRES	.\lib\stp.c	/^stp_topology_change_detection(struct stp *stp) OVS_REQUIRES(mutex)$/;"	f
OVS_REQUIRES	.\lib\stp.c	/^stp_topology_change_timer_expiry(struct stp *stp) OVS_REQUIRES(mutex)$/;"	f
OVS_REQUIRES	.\lib\stp.c	/^stp_transmit_config(struct stp_port *p) OVS_REQUIRES(mutex)$/;"	f
OVS_REQUIRES	.\lib\stp.c	/^stp_transmit_tcn(struct stp *stp) OVS_REQUIRES(mutex)$/;"	f
OVS_REQUIRES	.\lib\stp.c	/^stp_update_bridge_timers(struct stp *stp) OVS_REQUIRES(mutex)$/;"	f
OVS_REQUIRES	.\ofproto\connmgr.c	/^    OVS_REQUIRES(ofproto_mutex)$/;"	f
OVS_REQUIRES	.\ofproto\netflow.c	/^    OVS_REQUIRES(mutex)$/;"	f
OVS_REQUIRES	.\ofproto\netflow.c	/^netflow_run__(struct netflow *nf) OVS_REQUIRES(mutex)$/;"	f
OVS_REQUIRES	.\ofproto\ofproto-dpif-ipfix.c	/^    OVS_REQUIRES(mutex)$/;"	f
OVS_REQUIRES	.\ofproto\ofproto-dpif-ipfix.c	/^dpif_ipfix_clear(struct dpif_ipfix *di) OVS_REQUIRES(mutex)$/;"	f
OVS_REQUIRES	.\ofproto\ofproto-dpif-monitor.c	/^             uint8_t hw_addr[ETH_ADDR_LEN]) OVS_REQUIRES(monitor_mutex)$/;"	f
OVS_REQUIRES	.\ofproto\ofproto-dpif-monitor.c	/^    OVS_REQUIRES(monitor_mutex)$/;"	f
OVS_REQUIRES	.\ofproto\ofproto-dpif-monitor.c	/^mport_find(const struct ofport_dpif *ofport) OVS_REQUIRES(monitor_mutex)$/;"	f
OVS_REQUIRES	.\ofproto\ofproto-dpif-sflow.c	/^    OVS_REQUIRES(mutex)$/;"	f
OVS_REQUIRES	.\ofproto\ofproto-dpif-sflow.c	/^dpif_sflow_clear__(struct dpif_sflow *ds) OVS_REQUIRES(mutex)$/;"	f
OVS_REQUIRES	.\ofproto\ofproto-dpif.c	/^    OVS_REQUIRES(ofproto_mutex)$/;"	f
OVS_REQUIRES	.\ofproto\ofproto.c	/^    OVS_REQUIRES(ofproto_mutex)$/;"	f
OVS_REQUIRES	.\vswitchd\system-stats.c	/^discard_stats(void) OVS_REQUIRES(mutex)$/;"	f
OVS_REQ_RDLOCK	.\lib\compiler.h	114;"	d
OVS_REQ_RDLOCK	.\lib\compiler.h	140;"	d
OVS_REQ_RDLOCK	.\lib\netdev.c	/^    OVS_REQ_RDLOCK(netdev_class_mutex)$/;"	f
OVS_REQ_RDLOCK	.\lib\vlog.c	/^    OVS_REQ_RDLOCK(pattern_rwlock)$/;"	f
OVS_REQ_RDLOCK	.\ofproto\bond.c	/^    OVS_REQ_RDLOCK(rwlock)$/;"	f
OVS_REQ_RDLOCK	.\ofproto\bond.c	/^bond_find(const char *name) OVS_REQ_RDLOCK(rwlock)$/;"	f
OVS_REQ_RDLOCK	.\ofproto\bond.c	/^bond_is_balanced(const struct bond *bond) OVS_REQ_RDLOCK(rwlock)$/;"	f
OVS_REQ_RDLOCK	.\ofproto\bond.c	/^bond_slave_from_bal_node(struct list *bal) OVS_REQ_RDLOCK(rwlock)$/;"	f
OVS_REQ_RDLOCK	.\ofproto\ofproto-dpif-xlate.c	/^    OVS_REQ_RDLOCK(xlate_rwlock)$/;"	f
OVS_REQ_RDLOCK	.\ofproto\tunnel.c	/^    OVS_REQ_RDLOCK(rwlock)$/;"	f
OVS_REQ_RDLOCK	.\ofproto\tunnel.c	/^tnl_find(const struct flow *flow) OVS_REQ_RDLOCK(rwlock)$/;"	f
OVS_REQ_RDLOCK	.\ofproto\tunnel.c	/^tnl_find_ofport(const struct ofport_dpif *ofport) OVS_REQ_RDLOCK(rwlock)$/;"	f
OVS_REQ_RDLOCK	.\ofproto\tunnel.c	/^tnl_port_fmt(const struct tnl_port *tnl_port) OVS_REQ_RDLOCK(rwlock)$/;"	f
OVS_REQ_RDLOCK	.\ofproto\tunnel.c	/^tnl_port_get_name(const struct tnl_port *tnl_port) OVS_REQ_RDLOCK(rwlock)$/;"	f
OVS_REQ_WRLOCK	.\lib\compiler.h	116;"	d
OVS_REQ_WRLOCK	.\lib\compiler.h	142;"	d
OVS_REQ_WRLOCK	.\ofproto\bond.c	/^    OVS_REQ_WRLOCK(rwlock)$/;"	f
OVS_REQ_WRLOCK	.\ofproto\tunnel.c	/^    OVS_REQ_WRLOCK(rwlock)$/;"	f
OVS_REQ_WRLOCK	.\ofproto\tunnel.c	/^tnl_port_del__(const struct ofport_dpif *ofport) OVS_REQ_WRLOCK(rwlock)$/;"	f
OVS_RWLOCK_INITIALIZER	.\lib\ovs-thread.h	108;"	d
OVS_RWLOCK_INITIALIZER	.\lib\ovs-thread.h	111;"	d
OVS_SAMPLE_ATTR_ACTIONS	.\include\linux\openvswitch.h	/^	OVS_SAMPLE_ATTR_ACTIONS,     \/* Nested OVS_ACTION_ATTR_* attributes. *\/$/;"	e	enum:ovs_sample_attr
OVS_SAMPLE_ATTR_MAX	.\include\linux\openvswitch.h	500;"	d
OVS_SAMPLE_ATTR_PROBABILITY	.\include\linux\openvswitch.h	/^	OVS_SAMPLE_ATTR_PROBABILITY, \/* u32 number *\/$/;"	e	enum:ovs_sample_attr
OVS_SAMPLE_ATTR_UNSPEC	.\include\linux\openvswitch.h	/^	OVS_SAMPLE_ATTR_UNSPEC,$/;"	e	enum:ovs_sample_attr
OVS_SRC	.\utilities\ovs-dev.py	/^OVS_SRC = HOME + "\/ovs"$/;"	v
OVS_SW_FLOW_KEY_METADATA_SIZE	.\datapath\flow.h	70;"	d
OVS_THREAD_H	.\lib\ovs-thread.h	18;"	d
OVS_TRY_LOCK	.\lib\compiler.h	128;"	d
OVS_TRY_LOCK	.\lib\compiler.h	148;"	d
OVS_TRY_RDLOCK	.\lib\compiler.h	126;"	d
OVS_TRY_RDLOCK	.\lib\compiler.h	147;"	d
OVS_TRY_RDLOCK	.\ofproto\ofproto-dpif.c	/^    OVS_TRY_RDLOCK(true, (*group)->up.rwlock)$/;"	f
OVS_TRY_RDLOCK	.\ofproto\ofproto.c	/^    OVS_TRY_RDLOCK(true, (*group)->rwlock)$/;"	f
OVS_TRY_WRLOCK	.\lib\compiler.h	124;"	d
OVS_TRY_WRLOCK	.\lib\compiler.h	146;"	d
OVS_TRY_WRLOCK	.\ofproto\ofproto.c	/^    OVS_TRY_WRLOCK(true, (*group)->rwlock)$/;"	f
OVS_TUNNEL_ATTR_DST_PORT	.\include\linux\openvswitch.h	/^	OVS_TUNNEL_ATTR_DST_PORT, \/* 16-bit UDP port, used by L4 tunnels. *\/$/;"	e	enum:__anon20
OVS_TUNNEL_ATTR_MAX	.\include\linux\openvswitch.h	277;"	d
OVS_TUNNEL_ATTR_UNSPEC	.\include\linux\openvswitch.h	/^	OVS_TUNNEL_ATTR_UNSPEC,$/;"	e	enum:__anon20
OVS_TUNNEL_KEY_ATTR_CSUM	.\include\linux\openvswitch.h	/^	OVS_TUNNEL_KEY_ATTR_CSUM,		\/* No argument. CSUM packet. *\/$/;"	e	enum:ovs_tunnel_key_attr
OVS_TUNNEL_KEY_ATTR_DONT_FRAGMENT	.\include\linux\openvswitch.h	/^	OVS_TUNNEL_KEY_ATTR_DONT_FRAGMENT,	\/* No argument, set DF. *\/$/;"	e	enum:ovs_tunnel_key_attr
OVS_TUNNEL_KEY_ATTR_ID	.\include\linux\openvswitch.h	/^	OVS_TUNNEL_KEY_ATTR_ID,			\/* be64 Tunnel ID *\/$/;"	e	enum:ovs_tunnel_key_attr
OVS_TUNNEL_KEY_ATTR_IPV4_DST	.\include\linux\openvswitch.h	/^	OVS_TUNNEL_KEY_ATTR_IPV4_DST,		\/* be32 dst IP address. *\/$/;"	e	enum:ovs_tunnel_key_attr
OVS_TUNNEL_KEY_ATTR_IPV4_SRC	.\include\linux\openvswitch.h	/^	OVS_TUNNEL_KEY_ATTR_IPV4_SRC,		\/* be32 src IP address. *\/$/;"	e	enum:ovs_tunnel_key_attr
OVS_TUNNEL_KEY_ATTR_MAX	.\include\linux\openvswitch.h	346;"	d
OVS_TUNNEL_KEY_ATTR_TOS	.\include\linux\openvswitch.h	/^	OVS_TUNNEL_KEY_ATTR_TOS,		\/* u8 Tunnel IP ToS. *\/$/;"	e	enum:ovs_tunnel_key_attr
OVS_TUNNEL_KEY_ATTR_TTL	.\include\linux\openvswitch.h	/^	OVS_TUNNEL_KEY_ATTR_TTL,		\/* u8 Tunnel IP TTL. *\/$/;"	e	enum:ovs_tunnel_key_attr
OVS_TUNNEL_KEY_SIZE	.\datapath\flow.h	41;"	d
OVS_TYPEOF	.\lib\util.h	187;"	d
OVS_TYPEOF	.\lib\util.h	189;"	d
OVS_UNLIKELY	.\lib\compiler.h	38;"	d
OVS_UNLIKELY	.\lib\compiler.h	50;"	d
OVS_UNUSED	.\lib\compiler.h	29;"	d
OVS_UNUSED	.\lib\compiler.h	41;"	d
OVS_UNUSED	.\lib\packets.h	/^static const uint8_t eth_addr_bfd[ETH_ADDR_LEN] OVS_UNUSED$/;"	v
OVS_UNUSED	.\lib\packets.h	/^static const uint8_t eth_addr_broadcast[ETH_ADDR_LEN] OVS_UNUSED$/;"	v
OVS_UNUSED	.\lib\packets.h	/^static const uint8_t eth_addr_lacp[ETH_ADDR_LEN] OVS_UNUSED$/;"	v
OVS_UNUSED	.\lib\packets.h	/^static const uint8_t eth_addr_stp[ETH_ADDR_LEN] OVS_UNUSED$/;"	v
OVS_USERSPACE_ATTR_MAX	.\include\linux\openvswitch.h	516;"	d
OVS_USERSPACE_ATTR_PID	.\include\linux\openvswitch.h	/^	OVS_USERSPACE_ATTR_PID,	      \/* u32 Netlink PID to receive upcalls. *\/$/;"	e	enum:ovs_userspace_attr
OVS_USERSPACE_ATTR_UNSPEC	.\include\linux\openvswitch.h	/^	OVS_USERSPACE_ATTR_UNSPEC,$/;"	e	enum:ovs_userspace_attr
OVS_USERSPACE_ATTR_USERDATA	.\include\linux\openvswitch.h	/^	OVS_USERSPACE_ATTR_USERDATA,  \/* Optional user-specified cookie. *\/$/;"	e	enum:ovs_userspace_attr
OVS_VPORT_ATTR_MAX	.\include\linux\openvswitch.h	267;"	d
OVS_VPORT_ATTR_NAME	.\include\linux\openvswitch.h	/^	OVS_VPORT_ATTR_NAME,	\/* string name, up to IFNAMSIZ bytes long *\/$/;"	e	enum:ovs_vport_attr
OVS_VPORT_ATTR_OPTIONS	.\include\linux\openvswitch.h	/^	OVS_VPORT_ATTR_OPTIONS, \/* nested attributes, varies by vport type *\/$/;"	e	enum:ovs_vport_attr
OVS_VPORT_ATTR_PORT_NO	.\include\linux\openvswitch.h	/^	OVS_VPORT_ATTR_PORT_NO,	\/* u32 port number within datapath *\/$/;"	e	enum:ovs_vport_attr
OVS_VPORT_ATTR_STATS	.\include\linux\openvswitch.h	/^	OVS_VPORT_ATTR_STATS,	\/* struct ovs_vport_stats *\/$/;"	e	enum:ovs_vport_attr
OVS_VPORT_ATTR_TYPE	.\include\linux\openvswitch.h	/^	OVS_VPORT_ATTR_TYPE,	\/* u32 OVS_VPORT_TYPE_* constant. *\/$/;"	e	enum:ovs_vport_attr
OVS_VPORT_ATTR_UNSPEC	.\include\linux\openvswitch.h	/^	OVS_VPORT_ATTR_UNSPEC,$/;"	e	enum:ovs_vport_attr
OVS_VPORT_ATTR_UPCALL_PID	.\include\linux\openvswitch.h	/^	OVS_VPORT_ATTR_UPCALL_PID, \/* array of u32 Netlink socket PIDs for *\/$/;"	e	enum:ovs_vport_attr
OVS_VPORT_CMD_DEL	.\include\linux\openvswitch.h	/^	OVS_VPORT_CMD_DEL,$/;"	e	enum:ovs_vport_cmd
OVS_VPORT_CMD_GET	.\include\linux\openvswitch.h	/^	OVS_VPORT_CMD_GET,$/;"	e	enum:ovs_vport_cmd
OVS_VPORT_CMD_NEW	.\include\linux\openvswitch.h	/^	OVS_VPORT_CMD_NEW,$/;"	e	enum:ovs_vport_cmd
OVS_VPORT_CMD_SET	.\include\linux\openvswitch.h	/^	OVS_VPORT_CMD_SET$/;"	e	enum:ovs_vport_cmd
OVS_VPORT_CMD_UNSPEC	.\include\linux\openvswitch.h	/^	OVS_VPORT_CMD_UNSPEC,$/;"	e	enum:ovs_vport_cmd
OVS_VPORT_DPDK	.\lib\netdev-dpdk.c	55;"	d	file:
OVS_VPORT_FAMILY	.\include\linux\openvswitch.h	200;"	d
OVS_VPORT_MCGROUP	.\include\linux\openvswitch.h	201;"	d
OVS_VPORT_TYPE_GRE	.\include\linux\openvswitch.h	/^	OVS_VPORT_TYPE_GRE,	 \/* GRE tunnel. *\/$/;"	e	enum:ovs_vport_type
OVS_VPORT_TYPE_GRE64	.\include\linux\openvswitch.h	/^	OVS_VPORT_TYPE_GRE64 = 104, \/* GRE tunnel with 64-bit keys *\/$/;"	e	enum:ovs_vport_type
OVS_VPORT_TYPE_INTERNAL	.\include\linux\openvswitch.h	/^	OVS_VPORT_TYPE_INTERNAL, \/* network device implemented by datapath *\/$/;"	e	enum:ovs_vport_type
OVS_VPORT_TYPE_LISP	.\include\linux\openvswitch.h	/^	OVS_VPORT_TYPE_LISP = 105,  \/* LISP tunnel *\/$/;"	e	enum:ovs_vport_type
OVS_VPORT_TYPE_MAX	.\include\linux\openvswitch.h	223;"	d
OVS_VPORT_TYPE_NETDEV	.\include\linux\openvswitch.h	/^	OVS_VPORT_TYPE_NETDEV,   \/* network device *\/$/;"	e	enum:ovs_vport_type
OVS_VPORT_TYPE_UNSPEC	.\include\linux\openvswitch.h	/^	OVS_VPORT_TYPE_UNSPEC,$/;"	e	enum:ovs_vport_type
OVS_VPORT_TYPE_VXLAN	.\include\linux\openvswitch.h	/^	OVS_VPORT_TYPE_VXLAN,    \/* VXLAN tunnel *\/$/;"	e	enum:ovs_vport_type
OVS_VPORT_VERSION	.\include\linux\openvswitch.h	202;"	d
OXM_HEADER	.\include\openflow\openflow-1.2.h	134;"	d
OXM_HEADER_W	.\include\openflow\openflow-1.2.h	136;"	d
OXM_OF_ARP_OP	.\include\openflow\openflow-1.2.h	167;"	d
OXM_OF_ARP_SHA	.\include\openflow\openflow-1.2.h	172;"	d
OXM_OF_ARP_SHA_W	.\include\openflow\openflow-1.2.h	173;"	d
OXM_OF_ARP_SPA	.\include\openflow\openflow-1.2.h	168;"	d
OXM_OF_ARP_SPA_W	.\include\openflow\openflow-1.2.h	169;"	d
OXM_OF_ARP_THA	.\include\openflow\openflow-1.2.h	174;"	d
OXM_OF_ARP_THA_W	.\include\openflow\openflow-1.2.h	175;"	d
OXM_OF_ARP_TPA	.\include\openflow\openflow-1.2.h	170;"	d
OXM_OF_ARP_TPA_W	.\include\openflow\openflow-1.2.h	171;"	d
OXM_OF_ETH_DST	.\include\openflow\openflow-1.2.h	144;"	d
OXM_OF_ETH_DST_W	.\include\openflow\openflow-1.2.h	145;"	d
OXM_OF_ETH_SRC	.\include\openflow\openflow-1.2.h	146;"	d
OXM_OF_ETH_SRC_W	.\include\openflow\openflow-1.2.h	147;"	d
OXM_OF_ETH_TYPE	.\include\openflow\openflow-1.2.h	148;"	d
OXM_OF_ICMPV4_CODE	.\include\openflow\openflow-1.2.h	166;"	d
OXM_OF_ICMPV4_TYPE	.\include\openflow\openflow-1.2.h	165;"	d
OXM_OF_ICMPV6_CODE	.\include\openflow\openflow-1.2.h	183;"	d
OXM_OF_ICMPV6_TYPE	.\include\openflow\openflow-1.2.h	182;"	d
OXM_OF_IN_PHY_PORT	.\include\openflow\openflow-1.2.h	142;"	d
OXM_OF_IN_PORT	.\include\openflow\openflow-1.2.h	141;"	d
OXM_OF_IPV4_DST	.\include\openflow\openflow-1.2.h	157;"	d
OXM_OF_IPV4_DST_W	.\include\openflow\openflow-1.2.h	158;"	d
OXM_OF_IPV4_SRC	.\include\openflow\openflow-1.2.h	155;"	d
OXM_OF_IPV4_SRC_W	.\include\openflow\openflow-1.2.h	156;"	d
OXM_OF_IPV6_DST	.\include\openflow\openflow-1.2.h	178;"	d
OXM_OF_IPV6_DST_W	.\include\openflow\openflow-1.2.h	179;"	d
OXM_OF_IPV6_EXTHDR	.\include\openflow\openflow-1.2.h	194;"	d
OXM_OF_IPV6_EXTHDR_W	.\include\openflow\openflow-1.2.h	195;"	d
OXM_OF_IPV6_FLABEL	.\include\openflow\openflow-1.2.h	180;"	d
OXM_OF_IPV6_FLABEL_W	.\include\openflow\openflow-1.2.h	181;"	d
OXM_OF_IPV6_ND_SLL	.\include\openflow\openflow-1.2.h	185;"	d
OXM_OF_IPV6_ND_TARGET	.\include\openflow\openflow-1.2.h	184;"	d
OXM_OF_IPV6_ND_TLL	.\include\openflow\openflow-1.2.h	186;"	d
OXM_OF_IPV6_SRC	.\include\openflow\openflow-1.2.h	176;"	d
OXM_OF_IPV6_SRC_W	.\include\openflow\openflow-1.2.h	177;"	d
OXM_OF_IP_DSCP	.\include\openflow\openflow-1.2.h	152;"	d
OXM_OF_IP_ECN	.\include\openflow\openflow-1.2.h	153;"	d
OXM_OF_IP_PROTO	.\include\openflow\openflow-1.2.h	154;"	d
OXM_OF_METADATA	.\include\openflow\openflow-1.2.h	143;"	d
OXM_OF_MPLS_BOS	.\include\openflow\openflow-1.2.h	189;"	d
OXM_OF_MPLS_LABEL	.\include\openflow\openflow-1.2.h	187;"	d
OXM_OF_MPLS_TC	.\include\openflow\openflow-1.2.h	188;"	d
OXM_OF_PBB_ISID	.\include\openflow\openflow-1.2.h	190;"	d
OXM_OF_PBB_ISID_W	.\include\openflow\openflow-1.2.h	191;"	d
OXM_OF_PBB_UCA	.\include\openflow\openflow-1.2.h	196;"	d
OXM_OF_SCTP_DST	.\include\openflow\openflow-1.2.h	164;"	d
OXM_OF_SCTP_SRC	.\include\openflow\openflow-1.2.h	163;"	d
OXM_OF_TCP_DST	.\include\openflow\openflow-1.2.h	160;"	d
OXM_OF_TCP_FLAGS	.\include\openflow\openflow-1.2.h	197;"	d
OXM_OF_TCP_FLAGS_W	.\include\openflow\openflow-1.2.h	198;"	d
OXM_OF_TCP_SRC	.\include\openflow\openflow-1.2.h	159;"	d
OXM_OF_TUNNEL_ID	.\include\openflow\openflow-1.2.h	192;"	d
OXM_OF_TUNNEL_ID_W	.\include\openflow\openflow-1.2.h	193;"	d
OXM_OF_UDP_DST	.\include\openflow\openflow-1.2.h	162;"	d
OXM_OF_UDP_SRC	.\include\openflow\openflow-1.2.h	161;"	d
OXM_OF_VLAN_PCP	.\include\openflow\openflow-1.2.h	151;"	d
OXM_OF_VLAN_VID	.\include\openflow\openflow-1.2.h	149;"	d
OXM_OF_VLAN_VID_W	.\include\openflow\openflow-1.2.h	150;"	d
O_DIRECTORY	.\lib\socket-util.c	62;"	d	file:
PACKETS_H	.\lib\packets.h	18;"	d
PACKET_AUXDATA	.\lib\netdev-linux.c	120;"	d	file:
PACKET_RCVD	.\datapath\linux\compat\include\net\ip_tunnels.h	58;"	d
PACKET_REJECT	.\datapath\linux\compat\include\net\ip_tunnels.h	59;"	d
PAD_SIZE	.\lib\util.h	117;"	d
PAIR	.\lib\stream.c	782;"	d	file:
PARENT	.\tests\test-lockfile.c	/^static enum { PARENT, CHILD }$/;"	e	enum:__anon157	file:
PARSER	.\python\compat\argparse.py	/^PARSER = 'A...'$/;"	v
PASSIVE	.\lib\netdev-dummy.c	/^    PASSIVE,    \/* Listener. *\/$/;"	e	enum:dummy_packet_conn_type	file:
PATH	.\utilities\ovs-dev.py	/^PATH = "%(ovs)s\/utilities:%(ovs)s\/ovsdb:%(ovs)s\/vswitchd" % {"ovs": BUILD_GCC}$/;"	v
PATTERNS	.\python\ovs\vlog.py	/^PATTERNS = {$/;"	v
PCAP_FILE_H	.\lib\pcap-file.h	18;"	d
PCAP_SNAPLEN	.\lib\netdev-bsd.c	116;"	d	file:
PERMUTE	.\lib\getopt_long.c	50;"	d	file:
PF_INET	.\include\sparse\sys\socket.h	/^    PF_INET = AF_INET,$/;"	e	enum:__anon32
PF_INET6	.\include\sparse\sys\socket.h	/^    PF_INET6 = AF_INET6,$/;"	e	enum:__anon32
PF_NETLINK	.\include\sparse\sys\socket.h	/^    PF_NETLINK = AF_NETLINK,$/;"	e	enum:__anon32
PF_PACKET	.\include\sparse\sys\socket.h	/^    PF_PACKET = AF_PACKET$/;"	e	enum:__anon32
PF_UNIX	.\include\sparse\sys\socket.h	/^    PF_UNIX = AF_UNIX,$/;"	e	enum:__anon32
PF_UNSPEC	.\include\sparse\sys\socket.h	/^    PF_UNSPEC = AF_UNSPEC,$/;"	e	enum:__anon32
PIF_OTHERCONFIG_DEFAULTS	.\xenserver\opt_xensource_libexec_InterfaceReconfigure.py	/^PIF_OTHERCONFIG_DEFAULTS = {'gro': 'off', 'lro': 'off'}$/;"	v
PINSCHED_H_H	.\ofproto\pinsched.h	18;"	d
PKTBUF_BITS	.\ofproto\pktbuf.c	41;"	d	file:
PKTBUF_CNT	.\ofproto\pktbuf.c	43;"	d	file:
PKTBUF_H	.\ofproto\pktbuf.h	18;"	d
PKTBUF_MASK	.\ofproto\pktbuf.c	42;"	d	file:
PKT_METADATA_INITIALIZER	.\lib\packets.h	65;"	d
POLLERR	.\python\ovs\poller.py	/^POLLERR = 0x008$/;"	v
POLLHUP	.\python\ovs\poller.py	/^POLLHUP = 0x010$/;"	v
POLLIN	.\python\ovs\poller.py	/^POLLIN = 0x001$/;"	v
POLLNVAL	.\python\ovs\poller.py	/^POLLNVAL = 0x020$/;"	v
POLLOUT	.\python\ovs\poller.py	/^POLLOUT = 0x004$/;"	v
POLL_LOOP_H	.\lib\poll-loop.h	34;"	d
PORT_VLAN_ACCESS	.\ofproto\ofproto.h	/^    PORT_VLAN_ACCESS,$/;"	e	enum:port_vlan_mode
PORT_VLAN_NATIVE_TAGGED	.\ofproto\ofproto.h	/^    PORT_VLAN_NATIVE_TAGGED,$/;"	e	enum:port_vlan_mode
PORT_VLAN_NATIVE_UNTAGGED	.\ofproto\ofproto.h	/^    PORT_VLAN_NATIVE_UNTAGGED$/;"	e	enum:port_vlan_mode
PORT_VLAN_TRUNK	.\ofproto\ofproto.h	/^    PORT_VLAN_TRUNK,$/;"	e	enum:port_vlan_mode
PRINTF_FORMAT	.\lib\compiler.h	30;"	d
PRINTF_FORMAT	.\lib\compiler.h	42;"	d
PRINT_ERROR	.\lib\getopt_long.c	47;"	d	file:
PRIO_TO_MSEC	.\ofproto\ofproto-dpif-monitor.c	43;"	d	file:
PRIXSIZE	.\lib\util.h	243;"	d
PRIXSIZE	.\lib\util.h	250;"	d
PRIdSIZE	.\lib\util.h	238;"	d
PRIdSIZE	.\lib\util.h	245;"	d
PRIiSIZE	.\lib\util.h	239;"	d
PRIiSIZE	.\lib\util.h	246;"	d
PRIoSIZE	.\lib\util.h	240;"	d
PRIoSIZE	.\lib\util.h	247;"	d
PRIuSIZE	.\lib\util.h	241;"	d
PRIuSIZE	.\lib\util.h	248;"	d
PRIxSIZE	.\lib\util.h	242;"	d
PRIxSIZE	.\lib\util.h	249;"	d
PROBE	.\python\ovs\reconnect.py	/^PROBE = 'probe'$/;"	v
PROCESS_H	.\lib\process.h	18;"	d
PROGRAM_NAME	.\python\ovs\util.py	/^PROGRAM_NAME = os.path.basename(sys.argv[0])$/;"	v
PSTREAM_INIT	.\lib\vconn-stream.c	377;"	d	file:
PTHREAD_ERRORCHECK_MUTEX_INITIALIZER_NP	.\include\sparse\pthread.h	33;"	d
PTHREAD_ERRORCHECK_MUTEX_INITIALIZER_NP	.\include\sparse\pthread.h	34;"	d
PTHREAD_MUTEX_INITIALIZER	.\include\sparse\pthread.h	27;"	d
PTHREAD_MUTEX_INITIALIZER	.\include\sparse\pthread.h	28;"	d
PTHREAD_RWLOCK_INITIALIZER	.\include\sparse\pthread.h	30;"	d
PTHREAD_RWLOCK_INITIALIZER	.\include\sparse\pthread.h	31;"	d
PYFILES	.\python\automake.mk	/^PYFILES = $(ovs_pyfiles) python\/ovs\/dirs.py $(ovstest_pyfiles)$/;"	m
PYTHONDONTWRITEBYTECODE	.\tests\automake.mk	/^	PYTHONDONTWRITEBYTECODE=yes COVERAGE_FILE=$(COVERAGE_FILE) PYTHON='$(COVERAGE) run -p' $(SHELL) '$(TESTSUITE)' -C tests AUTOTEST_PATH=$(AUTOTEST_PATH) $(TESTSUITEFLAGS)$/;"	m
Parser	.\python\ovs\db\parser.py	/^class Parser(object):$/;"	c
Parser	.\python\ovs\json.py	/^class Parser(object):$/;"	c
PassiveStream	.\python\ovs\stream.py	/^class PassiveStream(object):$/;"	c
Poller	.\python\ovs\poller.py	/^class Poller(object):$/;"	c
Pool	.\tests\MockXenAPI.py	/^class Pool(Table):$/;"	c
Producer	.\python\ovstest\tcp.py	/^class Producer(object):$/;"	c
Protocol	.\python\ovstest\tcp.py	/^from twisted.internet.protocol import Factory, ClientFactory, Protocol$/;"	i
QUEUE_MASK	.\lib\dpif-netdev.c	/^enum { QUEUE_MASK = MAX_QUEUE_LEN - 1 };$/;"	e	enum:__anon43	file:
RANDOM_H	.\lib\random.h	18;"	d
RCONN_H	.\lib\rconn.h	18;"	d
RCU_INITIALIZER	.\datapath\linux\compat\include\linux\rcupdate.h	26;"	d
RCU_INIT_POINTER	.\datapath\linux\compat\include\linux\rcupdate.h	30;"	d
RDP2_1	.\lib\util.h	144;"	d
RDP2_2	.\lib\util.h	145;"	d
RDP2_3	.\lib\util.h	146;"	d
RDP2_4	.\lib\util.h	147;"	d
RDP2_5	.\lib\util.h	148;"	d
RDP2__	.\lib\util.h	143;"	d
RECEIVER_INDEX	.\ofproto\ofproto-dpif-sflow.c	68;"	d	file:
RECIRC_ID_BASE	.\ofproto\ofproto-dpif-rid.c	45;"	d	file:
RECIRC_ID_N_IDS	.\ofproto\ofproto-dpif-rid.c	46;"	d	file:
RECIRC_RULE_PRIORITY	.\ofproto\bond.c	59;"	d	file:
RECIRC_STACK_COST	.\datapath\actions.c	667;"	d	file:
RECONNECT_CONNECT	.\lib\reconnect.h	/^    RECONNECT_CONNECT = 1,$/;"	e	enum:reconnect_action
RECONNECT_DEFAULT_MAX_BACKOFF	.\lib\reconnect.h	45;"	d
RECONNECT_DEFAULT_MIN_BACKOFF	.\lib\reconnect.h	44;"	d
RECONNECT_DEFAULT_PROBE_INTERVAL	.\lib\reconnect.h	46;"	d
RECONNECT_DISCONNECT	.\lib\reconnect.h	/^    RECONNECT_DISCONNECT,$/;"	e	enum:reconnect_action
RECONNECT_H	.\lib\reconnect.h	18;"	d
RECONNECT_PROBE	.\lib\reconnect.h	/^    RECONNECT_PROBE,$/;"	e	enum:reconnect_action
REGISTER	.\lib\meta-flow.c	213;"	d	file:
REGNAME_LEN	.\lib\match.c	1020;"	d	file:
REHASH_INTERVAL	.\datapath\flow_table.c	51;"	d	file:
RELOP	.\utilities\ovs-vsctl.c	3791;"	d	file:
RELOP	.\utilities\ovs-vsctl.c	3793;"	d	file:
RELOP	.\utilities\ovs-vsctl.c	3844;"	d	file:
RELOP	.\utilities\ovs-vsctl.c	3846;"	d	file:
RELOP	.\vtep\vtep-ctl.c	3401;"	d	file:
RELOP	.\vtep\vtep-ctl.c	3403;"	d	file:
RELOP	.\vtep\vtep-ctl.c	3454;"	d	file:
RELOP	.\vtep\vtep-ctl.c	3456;"	d	file:
RELOPS	.\utilities\ovs-vsctl.c	/^    RELOPS$/;"	e	enum:relop	file:
RELOPS	.\utilities\ovs-vsctl.c	3776;"	d	file:
RELOPS	.\vtep\vtep-ctl.c	/^    RELOPS$/;"	e	enum:relop	file:
RELOPS	.\vtep\vtep-ctl.c	3386;"	d	file:
REMAINDER	.\python\compat\argparse.py	/^REMAINDER = '...'$/;"	v
RESTART_EXIT_CODE	.\python\ovs\daemon.py	/^RESTART_EXIT_CODE = 5$/;"	v
REVALIDATE_MAX_BATCH	.\ofproto\ofproto-dpif-upcall.c	44;"	d	file:
REV_BOND	.\ofproto\ofproto-dpif.c	/^    REV_BOND,                  \/* Bonding changed. *\/$/;"	e	enum:revalidate_reason	file:
REV_FLOW_TABLE	.\ofproto\ofproto-dpif.c	/^    REV_FLOW_TABLE,            \/* Flow table changed. *\/$/;"	e	enum:revalidate_reason	file:
REV_MAC_LEARNING	.\ofproto\ofproto-dpif.c	/^    REV_MAC_LEARNING,          \/* Mac learning changed. *\/$/;"	e	enum:revalidate_reason	file:
REV_PORT_TOGGLED	.\ofproto\ofproto-dpif.c	/^    REV_PORT_TOGGLED,          \/* Port enabled or disabled by CFM, LACP, ...*\/$/;"	e	enum:revalidate_reason	file:
REV_RECONFIGURE	.\ofproto\ofproto-dpif.c	/^    REV_RECONFIGURE = 1,       \/* Switch configuration changed. *\/$/;"	e	enum:revalidate_reason	file:
REV_STP	.\ofproto\ofproto-dpif.c	/^    REV_STP,                   \/* Spanning tree protocol port status change. *\/$/;"	e	enum:revalidate_reason	file:
RO	.\utilities\ovs-vsctl.c	/^    enum { RO, RW } mode;       \/* Does this command modify the database? *\/$/;"	e	enum:vsctl_command_syntax::__anon161	file:
RO	.\vtep\vtep-ctl.c	/^    enum { RO, RW } mode;       \/* Does this command modify the database? *\/$/;"	e	enum:vtep_ctl_command_syntax::__anon162	file:
ROOT	.\utilities\ovs-dev.py	/^ROOT = HOME + "\/root"$/;"	v
ROUND_DOWN	.\lib\util.h	120;"	d
ROUND_DOWN_POW2	.\lib\util.h	142;"	d
ROUND_UP	.\lib\util.h	114;"	d
ROUND_UP_POW2	.\lib\util.h	132;"	d
ROUTE_TABLE_H	.\lib\route-table.h	18;"	d
RPM_PCO_ADD	.\include\windows\netinet\icmp6.h	447;"	d
RPM_PCO_CHANGE	.\include\windows\netinet\icmp6.h	448;"	d
RPM_PCO_MAX	.\include\windows\netinet\icmp6.h	450;"	d
RPM_PCO_SETGLOBAL	.\include\windows\netinet\icmp6.h	449;"	d
RTBSD_H	.\lib\rtbsd.h	18;"	d
RTNETLINK_LINK_H	.\lib\rtnetlink-link.h	18;"	d
RULE_CAST	.\ofproto\ofproto-dpif.h	234;"	d
RULE_CAST	.\ofproto\ofproto-dpif.h	266;"	d
RULE_DPIF_LOOKUP_VERDICT_CONTROLLER	.\ofproto\ofproto-dpif.h	/^    RULE_DPIF_LOOKUP_VERDICT_CONTROLLER,    \/* A miss occurred and the packet$/;"	e	enum:rule_dpif_lookup_verdict
RULE_DPIF_LOOKUP_VERDICT_DEFAULT	.\ofproto\ofproto-dpif.h	/^    RULE_DPIF_LOOKUP_VERDICT_DEFAULT,       \/* A miss occurred and the packet$/;"	e	enum:rule_dpif_lookup_verdict
RULE_DPIF_LOOKUP_VERDICT_DROP	.\ofproto\ofproto-dpif.h	/^    RULE_DPIF_LOOKUP_VERDICT_DROP,          \/* A miss occurred and the packet$/;"	e	enum:rule_dpif_lookup_verdict
RULE_DPIF_LOOKUP_VERDICT_MATCH	.\ofproto\ofproto-dpif.h	/^    RULE_DPIF_LOOKUP_VERDICT_MATCH,         \/* A match occurred. *\/$/;"	e	enum:rule_dpif_lookup_verdict
RUNNING_ON_VALGRIND	.\lib\valgrind.h	23;"	d
RUP2_1	.\lib\util.h	134;"	d
RUP2_2	.\lib\util.h	135;"	d
RUP2_3	.\lib\util.h	136;"	d
RUP2_4	.\lib\util.h	137;"	d
RUP2_5	.\lib\util.h	138;"	d
RUP2_6	.\lib\util.h	139;"	d
RUP2__	.\lib\util.h	133;"	d
RUSAGE_CHILDREN	.\include\windows\sys\resource.h	44;"	d
RUSAGE_SELF	.\include\windows\sys\resource.h	40;"	d
RUSAGE_THREAD	.\include\windows\sys\resource.h	48;"	d
RW	.\utilities\ovs-vsctl.c	/^    enum { RO, RW } mode;       \/* Does this command modify the database? *\/$/;"	e	enum:vsctl_command_syntax::__anon161	file:
RW	.\vtep\vtep-ctl.c	/^    enum { RO, RW } mode;       \/* Does this command modify the database? *\/$/;"	e	enum:vtep_ctl_command_syntax::__anon162	file:
RXQ_SIZE	.\tests\test-stp.c	47;"	d	file:
RX_HTHRESH	.\lib\netdev-dpdk.c	75;"	d	file:
RX_PTHRESH	.\lib\netdev-dpdk.c	74;"	d	file:
RX_WTHRESH	.\lib\netdev-dpdk.c	76;"	d	file:
RawDescriptionHelpFormatter	.\python\compat\argparse.py	/^class RawDescriptionHelpFormatter(HelpFormatter):$/;"	c
RawTextHelpFormatter	.\python\compat\argparse.py	/^class RawTextHelpFormatter(RawDescriptionHelpFormatter):$/;"	c
RealType	.\python\ovs\db\types.py	/^RealType = AtomicType("real", 0.0, (int, long, float))$/;"	v
Reconnect	.\python\ovs\reconnect.py	/^    class Reconnect(object):$/;"	c	class:Reconnect
Reconnect	.\python\ovs\reconnect.py	/^class Reconnect(object):$/;"	c
RecordRef	.\tests\MockXenAPI.py	/^class RecordRef(object):$/;"	c
Register	.\xenserver\usr_lib_xsconsole_plugins-base_XSFeatureVSwitch.py	/^    def Register(self):$/;"	m	class:XSFeatureVSwitch
Row	.\python\ovs\db\idl.py	/^class Row(object):$/;"	c
SAMPLE_ACTION_DEPTH	.\datapath\datapath.h	38;"	d
SAT_MATH_H	.\lib\sat-math.h	18;"	d
SAT_MUL	.\lib\sat-math.h	37;"	d
SCANF_FORMAT	.\lib\compiler.h	31;"	d
SCANF_FORMAT	.\lib\compiler.h	43;"	d
SCAN_CHAR	.\lib\util.c	/^        SCAN_CHAR,$/;"	e	enum:scan_spec::__anon96	file:
SCAN_DISCARD	.\lib\util.c	/^        SCAN_DISCARD,$/;"	e	enum:scan_spec::__anon96	file:
SCAN_INT	.\lib\util.c	/^        SCAN_INT,$/;"	e	enum:scan_spec::__anon96	file:
SCAN_INTMAX_T	.\lib\util.c	/^        SCAN_INTMAX_T,$/;"	e	enum:scan_spec::__anon96	file:
SCAN_LLONG	.\lib\util.c	/^        SCAN_LLONG,$/;"	e	enum:scan_spec::__anon96	file:
SCAN_LONG	.\lib\util.c	/^        SCAN_LONG,$/;"	e	enum:scan_spec::__anon96	file:
SCAN_PTRDIFF_T	.\lib\util.c	/^        SCAN_PTRDIFF_T,$/;"	e	enum:scan_spec::__anon96	file:
SCAN_SHORT	.\lib\util.c	/^        SCAN_SHORT,$/;"	e	enum:scan_spec::__anon96	file:
SCAN_SIZE_T	.\lib\util.c	/^        SCAN_SIZE_T$/;"	e	enum:scan_spec::__anon96	file:
SCM_RIGHTS	.\include\sparse\sys\socket.h	/^    SCM_RIGHTS = 1$/;"	e	enum:__anon27
SCS_CONNECTED	.\lib\stream.c	/^    SCS_CONNECTED,              \/* Connection established. *\/$/;"	e	enum:stream_state	file:
SCS_CONNECTING	.\lib\stream.c	/^    SCS_CONNECTING,             \/* Underlying stream is not connected. *\/$/;"	e	enum:stream_state	file:
SCS_DISCONNECTED	.\lib\stream.c	/^    SCS_DISCONNECTED            \/* Connection failed or connection closed. *\/$/;"	e	enum:stream_state	file:
SCTP_HEADER_LEN	.\lib\packets.h	511;"	d
SENTINEL	.\lib\compiler.h	36;"	d
SENTINEL	.\lib\compiler.h	48;"	d
SEQ_H	.\lib\seq.h	18;"	d
SERIAL_NUM_LEN	.\include\openflow\openflow-common.h	396;"	d
SERVER	.\lib\stream-ssl.c	/^    SERVER$/;"	e	enum:session_type	file:
SERVER_H	.\ovsdb\server.h	17;"	d
SFLADDRESSTYPE_IP_V4	.\lib\sflow.h	/^    SFLADDRESSTYPE_IP_V4 = 1,$/;"	e	enum:SFLAddress_type
SFLADDRESSTYPE_IP_V6	.\lib\sflow.h	/^    SFLADDRESSTYPE_IP_V6 = 2$/;"	e	enum:SFLAddress_type
SFLADD_ELEMENT	.\lib\sflow.h	533;"	d
SFLAddress	.\lib\sflow.h	/^} SFLAddress;$/;"	t	typeref:struct:_SFLAddress
SFLAddress_type	.\lib\sflow.h	/^enum SFLAddress_type {$/;"	g
SFLAddress_value	.\lib\sflow.h	/^} SFLAddress_value;$/;"	t	typeref:union:_SFLAddress_value
SFLAgent	.\lib\sflow_api.h	/^} SFLAgent;$/;"	t	typeref:struct:_SFLAgent
SFLCOUNTERS_ETHERNET	.\lib\sflow.h	/^    SFLCOUNTERS_ETHERNET     = 2,$/;"	e	enum:SFLCounters_type_tag
SFLCOUNTERS_GENERIC	.\lib\sflow.h	/^    SFLCOUNTERS_GENERIC      = 1,$/;"	e	enum:SFLCounters_type_tag
SFLCOUNTERS_SAMPLE	.\lib\sflow.h	/^    SFLCOUNTERS_SAMPLE = 2,          \/* enterprise = 0 : format = 2 *\/$/;"	e	enum:SFL_sample_tag
SFLCOUNTERS_SAMPLE_EXPANDED	.\lib\sflow.h	/^    SFLCOUNTERS_SAMPLE_EXPANDED = 4  \/* enterprise = 0 : format = 4 *\/$/;"	e	enum:SFL_sample_tag
SFLCOUNTERS_TOKENRING	.\lib\sflow.h	/^    SFLCOUNTERS_TOKENRING    = 3,$/;"	e	enum:SFLCounters_type_tag
SFLCOUNTERS_VG	.\lib\sflow.h	/^    SFLCOUNTERS_VG           = 4,$/;"	e	enum:SFLCounters_type_tag
SFLCOUNTERS_VLAN	.\lib\sflow.h	/^    SFLCOUNTERS_VLAN         = 5$/;"	e	enum:SFLCounters_type_tag
SFLCounters_sample	.\lib\sflow.h	/^} SFLCounters_sample;$/;"	t	typeref:struct:_SFLCounters_sample
SFLCounters_sample_element	.\lib\sflow.h	/^} SFLCounters_sample_element;$/;"	t	typeref:struct:_SFLCounters_sample_element
SFLCounters_sample_expanded	.\lib\sflow.h	/^} SFLCounters_sample_expanded;$/;"	t	typeref:struct:_SFLCounters_sample_expanded
SFLCounters_type	.\lib\sflow.h	/^} SFLCounters_type;$/;"	t	typeref:union:_SFLCounters_type
SFLCounters_type_tag	.\lib\sflow.h	/^enum SFLCounters_type_tag {$/;"	g
SFLDATAGRAM_VERSION2	.\lib\sflow.h	/^    SFLDATAGRAM_VERSION2 = 2,$/;"	e	enum:SFLDatagram_version
SFLDATAGRAM_VERSION4	.\lib\sflow.h	/^    SFLDATAGRAM_VERSION4 = 4,$/;"	e	enum:SFLDatagram_version
SFLDATAGRAM_VERSION5	.\lib\sflow.h	/^    SFLDATAGRAM_VERSION5 = 5$/;"	e	enum:SFLDatagram_version
SFLDataSource_instance	.\lib\sflow_api.h	/^} SFLDataSource_instance;$/;"	t	typeref:struct:_SFLDataSource_instance
SFLDatagram_version	.\lib\sflow.h	/^enum SFLDatagram_version {$/;"	g
SFLEXTENDED_AS_SEQUENCE	.\lib\sflow.h	/^    SFLEXTENDED_AS_SEQUENCE = 2  \/* Ordered sequence of ASs *\/$/;"	e	enum:SFLExtended_as_path_segment_type
SFLEXTENDED_AS_SET	.\lib\sflow.h	/^    SFLEXTENDED_AS_SET = 1,      \/* Unordered set of ASs *\/$/;"	e	enum:SFLExtended_as_path_segment_type
SFLEXTENDED_URL_DST	.\lib\sflow.h	/^    SFLEXTENDED_URL_DST = 2  \/* URL is associated with destination address *\/$/;"	e	enum:SFLExtended_url_direction
SFLEXTENDED_URL_SRC	.\lib\sflow.h	/^    SFLEXTENDED_URL_SRC = 1, \/* URL is associated with source address *\/$/;"	e	enum:SFLExtended_url_direction
SFLEthernet_counters	.\lib\sflow.h	/^} SFLEthernet_counters;$/;"	t	typeref:struct:_SFLEthernet_counters
SFLExtended_as_path_segment	.\lib\sflow.h	/^} SFLExtended_as_path_segment;$/;"	t	typeref:struct:_SFLExtended_as_path_segment
SFLExtended_as_path_segment_type	.\lib\sflow.h	/^enum SFLExtended_as_path_segment_type {$/;"	g
SFLExtended_gateway	.\lib\sflow.h	/^} SFLExtended_gateway;$/;"	t	typeref:struct:_SFLExtended_gateway
SFLExtended_mpls	.\lib\sflow.h	/^} SFLExtended_mpls;$/;"	t	typeref:struct:_SFLExtended_mpls
SFLExtended_mpls_FTN	.\lib\sflow.h	/^} SFLExtended_mpls_FTN;$/;"	t	typeref:struct:_SFLExtended_mpls_FTN
SFLExtended_mpls_LDP_FEC	.\lib\sflow.h	/^} SFLExtended_mpls_LDP_FEC;$/;"	t	typeref:struct:_SFLExtended_mpls_LDP_FEC
SFLExtended_mpls_tunnel	.\lib\sflow.h	/^} SFLExtended_mpls_tunnel;$/;"	t	typeref:struct:_SFLExtended_mpls_tunnel
SFLExtended_mpls_vc	.\lib\sflow.h	/^} SFLExtended_mpls_vc;$/;"	t	typeref:struct:_SFLExtended_mpls_vc
SFLExtended_nat	.\lib\sflow.h	/^} SFLExtended_nat;$/;"	t	typeref:struct:_SFLExtended_nat
SFLExtended_router	.\lib\sflow.h	/^} SFLExtended_router;$/;"	t	typeref:struct:_SFLExtended_router
SFLExtended_switch	.\lib\sflow.h	/^} SFLExtended_switch;$/;"	t	typeref:struct:_SFLExtended_switch
SFLExtended_url	.\lib\sflow.h	/^} SFLExtended_url;$/;"	t	typeref:struct:_SFLExtended_url
SFLExtended_url_direction	.\lib\sflow.h	/^enum SFLExtended_url_direction {$/;"	g
SFLExtended_user	.\lib\sflow.h	/^} SFLExtended_user;$/;"	t	typeref:struct:_SFLExtended_user
SFLExtended_vlan_tunnel	.\lib\sflow.h	/^} SFLExtended_vlan_tunnel;$/;"	t	typeref:struct:_SFLExtended_vlan_tunnel
SFLFLOW_ETHERNET	.\lib\sflow.h	/^    SFLFLOW_ETHERNET  = 2,      \/* MAC layer information *\/$/;"	e	enum:SFLFlow_type_tag
SFLFLOW_EX_GATEWAY	.\lib\sflow.h	/^    SFLFLOW_EX_GATEWAY   = 1003,      \/* Extended gateway router information *\/$/;"	e	enum:SFLFlow_type_tag
SFLFLOW_EX_MPLS	.\lib\sflow.h	/^    SFLFLOW_EX_MPLS      = 1006,      \/* Extended MPLS information *\/$/;"	e	enum:SFLFlow_type_tag
SFLFLOW_EX_MPLS_FTN	.\lib\sflow.h	/^    SFLFLOW_EX_MPLS_FTN     = 1010,$/;"	e	enum:SFLFlow_type_tag
SFLFLOW_EX_MPLS_LDP_FEC	.\lib\sflow.h	/^    SFLFLOW_EX_MPLS_LDP_FEC = 1011,$/;"	e	enum:SFLFlow_type_tag
SFLFLOW_EX_MPLS_TUNNEL	.\lib\sflow.h	/^    SFLFLOW_EX_MPLS_TUNNEL  = 1008,   \/* additional MPLS information *\/$/;"	e	enum:SFLFlow_type_tag
SFLFLOW_EX_MPLS_VC	.\lib\sflow.h	/^    SFLFLOW_EX_MPLS_VC      = 1009,$/;"	e	enum:SFLFlow_type_tag
SFLFLOW_EX_NAT	.\lib\sflow.h	/^    SFLFLOW_EX_NAT       = 1007,      \/* Extended NAT information *\/$/;"	e	enum:SFLFlow_type_tag
SFLFLOW_EX_ROUTER	.\lib\sflow.h	/^    SFLFLOW_EX_ROUTER    = 1002,      \/* Extended router information *\/$/;"	e	enum:SFLFlow_type_tag
SFLFLOW_EX_SWITCH	.\lib\sflow.h	/^    SFLFLOW_EX_SWITCH    = 1001,      \/* Extended switch information *\/$/;"	e	enum:SFLFlow_type_tag
SFLFLOW_EX_URL	.\lib\sflow.h	/^    SFLFLOW_EX_URL       = 1005,      \/* Extended URL information *\/$/;"	e	enum:SFLFlow_type_tag
SFLFLOW_EX_USER	.\lib\sflow.h	/^    SFLFLOW_EX_USER      = 1004,      \/* Extended TACAS\/RADIUS user information *\/$/;"	e	enum:SFLFlow_type_tag
SFLFLOW_EX_VLAN_TUNNEL	.\lib\sflow.h	/^    SFLFLOW_EX_VLAN_TUNNEL  = 1012,   \/* VLAN stack *\/$/;"	e	enum:SFLFlow_type_tag
SFLFLOW_HEADER	.\lib\sflow.h	/^    SFLFLOW_HEADER    = 1,      \/* Packet headers are sampled *\/$/;"	e	enum:SFLFlow_type_tag
SFLFLOW_IPV4	.\lib\sflow.h	/^    SFLFLOW_IPV4      = 3,      \/* IP version 4 data *\/$/;"	e	enum:SFLFlow_type_tag
SFLFLOW_IPV6	.\lib\sflow.h	/^    SFLFLOW_IPV6      = 4,      \/* IP version 6 data *\/$/;"	e	enum:SFLFlow_type_tag
SFLFLOW_SAMPLE	.\lib\sflow.h	/^    SFLFLOW_SAMPLE = 1,              \/* enterprise = 0 : format = 1 *\/$/;"	e	enum:SFL_sample_tag
SFLFLOW_SAMPLE_EXPANDED	.\lib\sflow.h	/^    SFLFLOW_SAMPLE_EXPANDED = 3,     \/* enterprise = 0 : format = 3 *\/$/;"	e	enum:SFL_sample_tag
SFLFlow_sample	.\lib\sflow.h	/^} SFLFlow_sample;$/;"	t	typeref:struct:_SFLFlow_sample
SFLFlow_sample_element	.\lib\sflow.h	/^} SFLFlow_sample_element;$/;"	t	typeref:struct:_SFLFlow_sample_element
SFLFlow_sample_expanded	.\lib\sflow.h	/^} SFLFlow_sample_expanded;$/;"	t	typeref:struct:_SFLFlow_sample_expanded
SFLFlow_type	.\lib\sflow.h	/^} SFLFlow_type;$/;"	t	typeref:union:_SFLFlow_type
SFLFlow_type_tag	.\lib\sflow.h	/^enum SFLFlow_type_tag {$/;"	g
SFLHEADER_AAL5	.\lib\sflow.h	/^    SFLHEADER_AAL5                 = 9,$/;"	e	enum:SFLHeader_protocol
SFLHEADER_AAL5_IP	.\lib\sflow.h	/^    SFLHEADER_AAL5_IP              = 10, \/* e.g. Cisco AAL5 mux *\/$/;"	e	enum:SFLHeader_protocol
SFLHEADER_ETHERNET_ISO8023	.\lib\sflow.h	/^    SFLHEADER_ETHERNET_ISO8023     = 1,$/;"	e	enum:SFLHeader_protocol
SFLHEADER_FDDI	.\lib\sflow.h	/^    SFLHEADER_FDDI                 = 4,$/;"	e	enum:SFLHeader_protocol
SFLHEADER_FRAME_RELAY	.\lib\sflow.h	/^    SFLHEADER_FRAME_RELAY          = 5,$/;"	e	enum:SFLHeader_protocol
SFLHEADER_IPv4	.\lib\sflow.h	/^    SFLHEADER_IPv4                 = 11,$/;"	e	enum:SFLHeader_protocol
SFLHEADER_IPv6	.\lib\sflow.h	/^    SFLHEADER_IPv6                 = 12,$/;"	e	enum:SFLHeader_protocol
SFLHEADER_ISO88024_TOKENBUS	.\lib\sflow.h	/^    SFLHEADER_ISO88024_TOKENBUS    = 2,$/;"	e	enum:SFLHeader_protocol
SFLHEADER_ISO88025_TOKENRING	.\lib\sflow.h	/^    SFLHEADER_ISO88025_TOKENRING   = 3,$/;"	e	enum:SFLHeader_protocol
SFLHEADER_MPLS	.\lib\sflow.h	/^    SFLHEADER_MPLS                 = 13$/;"	e	enum:SFLHeader_protocol
SFLHEADER_PPP	.\lib\sflow.h	/^    SFLHEADER_PPP                  = 7,$/;"	e	enum:SFLHeader_protocol
SFLHEADER_SMDS	.\lib\sflow.h	/^    SFLHEADER_SMDS                 = 8,$/;"	e	enum:SFLHeader_protocol
SFLHEADER_X25	.\lib\sflow.h	/^    SFLHEADER_X25                  = 6,$/;"	e	enum:SFLHeader_protocol
SFLHeader_protocol	.\lib\sflow.h	/^enum SFLHeader_protocol {$/;"	g
SFLIPv4	.\lib\sflow.h	/^} SFLIPv4;$/;"	t	typeref:struct:__anon92
SFLIPv6	.\lib\sflow.h	/^} SFLIPv6;$/;"	t	typeref:struct:__anon93
SFLIf_counters	.\lib\sflow.h	/^} SFLIf_counters;$/;"	t	typeref:struct:_SFLIf_counters
SFLLabelStack	.\lib\sflow.h	/^} SFLLabelStack;$/;"	t	typeref:struct:_SFLLabelStack
SFLOWXDR_assert	.\tests\test-sflow.c	118;"	d	file:
SFLOWXDR_throw	.\tests\test-sflow.c	117;"	d	file:
SFLOWXDR_try	.\tests\test-sflow.c	116;"	d	file:
SFLOW_ADDRTYPE_IP4	.\tests\test-sflow.c	/^        SFLOW_ADDRTYPE_IP4,$/;"	e	enum:sflow_addr::__anon158	file:
SFLOW_ADDRTYPE_IP6	.\tests\test-sflow.c	/^        SFLOW_ADDRTYPE_IP6$/;"	e	enum:sflow_addr::__anon158	file:
SFLOW_ADDRTYPE_undefined	.\tests\test-sflow.c	/^        SFLOW_ADDRTYPE_undefined = 0,$/;"	e	enum:sflow_addr::__anon158	file:
SFLOW_API_H	.\lib\sflow_api.h	9;"	d
SFLOW_COUNTERS_SAMPLE	.\tests\test-sflow.c	52;"	d	file:
SFLOW_COUNTERS_SAMPLE_EXPANDED	.\tests\test-sflow.c	54;"	d	file:
SFLOW_FLOW_SAMPLE	.\tests\test-sflow.c	51;"	d	file:
SFLOW_FLOW_SAMPLE_EXPANDED	.\tests\test-sflow.c	53;"	d	file:
SFLOW_H	.\lib\sflow.h	9;"	d
SFLOW_HEX_SCRATCH	.\tests\test-sflow.c	255;"	d	file:
SFLOW_MIN_LEN	.\tests\test-sflow.c	48;"	d	file:
SFLOW_TAG_CTR_IFCOUNTERS	.\tests\test-sflow.c	57;"	d	file:
SFLOW_TAG_PKT_HEADER	.\tests\test-sflow.c	58;"	d	file:
SFLOW_TAG_PKT_SWITCH	.\tests\test-sflow.c	59;"	d	file:
SFLOW_UPCALL	.\ofproto\ofproto-dpif-upcall.c	/^    SFLOW_UPCALL,               \/* sFlow sample. *\/$/;"	e	enum:upcall_type	file:
SFLOW_VERSION_5	.\tests\test-sflow.c	47;"	d	file:
SFLPoller	.\lib\sflow_api.h	/^} SFLPoller;$/;"	t	typeref:struct:_SFLPoller
SFLReceiver	.\lib\sflow_api.h	/^} SFLReceiver;$/;"	t	typeref:struct:_SFLReceiver
SFLSampleCollector	.\lib\sflow_api.h	/^} SFLSampleCollector;$/;"	t	typeref:struct:_SFLSampleCollector
SFLSample_datagram_hdr	.\lib\sflow.h	/^} SFLSample_datagram_hdr;$/;"	t	typeref:struct:_SFLSample_datagram_hdr
SFLSampled_ethernet	.\lib\sflow.h	/^} SFLSampled_ethernet;$/;"	t	typeref:struct:_SFLSampled_ethernet
SFLSampled_header	.\lib\sflow.h	/^} SFLSampled_header;$/;"	t	typeref:struct:_SFLSampled_header
SFLSampled_ipv4	.\lib\sflow.h	/^} SFLSampled_ipv4;$/;"	t	typeref:struct:_SFLSampled_ipv4
SFLSampled_ipv6	.\lib\sflow.h	/^} SFLSampled_ipv6;$/;"	t	typeref:struct:_SFLSampled_ipv6
SFLSampler	.\lib\sflow_api.h	/^} SFLSampler;$/;"	t	typeref:struct:_SFLSampler
SFLString	.\lib\sflow.h	/^} SFLString;$/;"	t	typeref:struct:_SFLString
SFLTokenring_counters	.\lib\sflow.h	/^} SFLTokenring_counters;$/;"	t	typeref:struct:_SFLTokenring_counters
SFLVg_counters	.\lib\sflow.h	/^} SFLVg_counters;$/;"	t	typeref:struct:_SFLVg_counters
SFLVlanStack	.\lib\sflow.h	/^typedef SFLLabelStack SFLVlanStack;$/;"	t
SFLVlan_counters	.\lib\sflow.h	/^} SFLVlan_counters;$/;"	t	typeref:struct:_SFLVlan_counters
SFL_ALLOC	.\lib\sflow_api.h	339;"	d
SFL_COUNTERS_SAMPLE_TYPE	.\lib\sflow_api.h	67;"	d
SFL_COUNTERS_SAMPLE_TYPE	.\lib\sflow_api.h	70;"	d
SFL_DATA_PAD	.\lib\sflow.h	561;"	d
SFL_DEFAULT_COLLECTOR_PORT	.\lib\sflow.h	48;"	d
SFL_DEFAULT_DATAGRAM_SIZE	.\lib\sflow.h	559;"	d
SFL_DEFAULT_HEADER_SIZE	.\lib\sflow.h	47;"	d
SFL_DEFAULT_POLLING_INTERVAL	.\lib\sflow.h	50;"	d
SFL_DEFAULT_SAMPLING_RATE	.\lib\sflow.h	49;"	d
SFL_DSCLASS	.\lib\sflow.h	/^} SFL_DSCLASS;$/;"	t	typeref:enum:__anon91
SFL_DSCLASS_IFINDEX	.\lib\sflow.h	/^    SFL_DSCLASS_IFINDEX = 0,$/;"	e	enum:__anon91
SFL_DSCLASS_LOGICAL_ENTITY	.\lib\sflow.h	/^    SFL_DSCLASS_LOGICAL_ENTITY = 3$/;"	e	enum:__anon91
SFL_DSCLASS_PHYSICAL_ENTITY	.\lib\sflow.h	/^    SFL_DSCLASS_PHYSICAL_ENTITY = 2,$/;"	e	enum:__anon91
SFL_DSCLASS_VLAN	.\lib\sflow.h	/^    SFL_DSCLASS_VLAN = 1,$/;"	e	enum:__anon91
SFL_DS_CLASS	.\lib\sflow_api.h	77;"	d
SFL_DS_DATASOURCE	.\lib\sflow_api.h	73;"	d
SFL_DS_INDEX	.\lib\sflow_api.h	78;"	d
SFL_DS_INSTANCE	.\lib\sflow_api.h	76;"	d
SFL_DS_SET	.\lib\sflow_api.h	79;"	d
SFL_FLOW_SAMPLE_TYPE	.\lib\sflow_api.h	66;"	d
SFL_FLOW_SAMPLE_TYPE	.\lib\sflow_api.h	69;"	d
SFL_FREE	.\lib\sflow_api.h	340;"	d
SFL_HASHTABLE_SIZ	.\lib\sflow_api.h	183;"	d
SFL_MAX_DATAGRAM_SIZE	.\lib\sflow.h	557;"	d
SFL_MIN_DATAGRAM_SIZE	.\lib\sflow.h	558;"	d
SFL_sample_tag	.\lib\sflow.h	/^enum SFL_sample_tag {$/;"	g
SHA1_ARGS	.\lib\sha1.h	55;"	d
SHA1_DIGEST_SIZE	.\lib\sha1.h	36;"	d
SHA1_FMT	.\lib\sha1.h	52;"	d
SHA1_H	.\lib\sha1.h	30;"	d
SHA1_HEX_DIGEST_LEN	.\lib\sha1.h	37;"	d
SHASH_FOR_EACH	.\lib\shash.h	38;"	d
SHASH_FOR_EACH_SAFE	.\lib\shash.h	41;"	d
SHASH_H	.\lib\shash.h	18;"	d
SHASH_INITIALIZER	.\lib\shash.h	36;"	d
SHA_BLOCK_SIZE	.\lib\sha1.c	90;"	d	file:
SHRT_MAX	.\datapath\linux\compat\include\linux\kernel.h	51;"	d
SHRT_MIN	.\datapath\linux\compat\include\linux\kernel.h	52;"	d
SHUT_RD	.\include\sparse\sys\socket.h	/^    SHUT_RD,$/;"	e	enum:__anon33
SHUT_RDWR	.\include\sparse\sys\socket.h	/^    SHUT_RDWR,$/;"	e	enum:__anon33
SHUT_RDWR	.\lib\stream-ssl.c	62;"	d	file:
SHUT_WR	.\include\sparse\sys\socket.h	/^    SHUT_WR$/;"	e	enum:__anon33
SIGNALS_H	.\lib\signals.h	18;"	d
SIGNAL_NAME_BUFSIZE	.\lib\signals.h	/^enum { SIGNAL_NAME_BUFSIZE = 7 + INT_STRLEN(int) + 1 };$/;"	e	enum:__anon95
SIG_ATOMIC_MAX	.\lib\fatal-signal.c	38;"	d	file:
SIMAP_FOR_EACH	.\lib\simap.h	39;"	d
SIMAP_FOR_EACH_SAFE	.\lib\simap.h	42;"	d
SIMAP_H	.\lib\simap.h	18;"	d
SIMAP_INITIALIZER	.\lib\simap.h	37;"	d
SLOW_PATH_REASONS	.\lib\odp-util.h	/^    SLOW_PATH_REASONS$/;"	e	enum:__anon67
SLOW_PATH_REASONS	.\lib\odp-util.h	/^    SLOW_PATH_REASONS$/;"	e	enum:slow_path_reason
SLOW_PATH_REASONS	.\lib\odp-util.h	39;"	d
SMAP_FOR_EACH	.\lib\smap.h	35;"	d
SMAP_FOR_EACH_SAFE	.\lib\smap.h	38;"	d
SMAP_H	.\lib\smap.h	16;"	d
SMAP_INITIALIZER	.\lib\smap.h	33;"	d
SNAP_HEADER_LEN	.\lib\packets.h	285;"	d
SNAP_ORG_ETHERNET	.\lib\packets.h	283;"	d
SNOOP	.\utilities\ovs-ofctl.c	/^enum open_target { MGMT, SNOOP };$/;"	e	enum:open_target	file:
SOCKET0	.\lib\netdev-dpdk.c	69;"	d	file:
SOCKET_UTIL_H	.\lib\socket-util.h	18;"	d
SOCK_DGRAM	.\include\sparse\sys\socket.h	/^    SOCK_DGRAM,$/;"	e	enum:__anon28
SOCK_RAW	.\include\sparse\sys\socket.h	/^    SOCK_RAW,$/;"	e	enum:__anon28
SOCK_SEQPACKET	.\include\sparse\sys\socket.h	/^    SOCK_SEQPACKET,$/;"	e	enum:__anon28
SOCK_STREAM	.\include\sparse\sys\socket.h	/^    SOCK_STREAM$/;"	e	enum:__anon28
SOL_NETLINK	.\lib\netlink-socket.c	48;"	d	file:
SOL_PACKET	.\include\sparse\sys\socket.h	/^    SOL_PACKET,$/;"	e	enum:__anon29
SOL_SOCKET	.\include\sparse\sys\socket.h	/^    SOL_SOCKET$/;"	e	enum:__anon29
SORT_ASC	.\utilities\ovs-ofctl.c	/^enum sort_order { SORT_ASC, SORT_DESC };$/;"	e	enum:sort_order	file:
SORT_DESC	.\utilities\ovs-ofctl.c	/^enum sort_order { SORT_ASC, SORT_DESC };$/;"	e	enum:sort_order	file:
SORT_H	.\lib\sort.h	17;"	d
SOURCE_LOCATOR	.\lib\util.h	180;"	d
SO_ACCEPTCONN	.\include\sparse\sys\socket.h	/^    SO_ACCEPTCONN,$/;"	e	enum:__anon30
SO_ATTACH_FILTER	.\include\sparse\sys\socket.h	/^    SO_ATTACH_FILTER$/;"	e	enum:__anon30
SO_BROADCAST	.\include\sparse\sys\socket.h	/^    SO_BROADCAST,$/;"	e	enum:__anon30
SO_DEBUG	.\include\sparse\sys\socket.h	/^    SO_DEBUG,$/;"	e	enum:__anon30
SO_DONTROUTE	.\include\sparse\sys\socket.h	/^    SO_DONTROUTE,$/;"	e	enum:__anon30
SO_ERROR	.\include\sparse\sys\socket.h	/^    SO_ERROR,$/;"	e	enum:__anon30
SO_KEEPALIVE	.\include\sparse\sys\socket.h	/^    SO_KEEPALIVE,$/;"	e	enum:__anon30
SO_LINGER	.\include\sparse\sys\socket.h	/^    SO_LINGER,$/;"	e	enum:__anon30
SO_OOBINLINE	.\include\sparse\sys\socket.h	/^    SO_OOBINLINE,$/;"	e	enum:__anon30
SO_PROTOCOL	.\lib\socket-util.c	1136;"	d	file:
SO_RCVBUF	.\include\sparse\sys\socket.h	/^    SO_RCVBUF,$/;"	e	enum:__anon30
SO_RCVBUFFORCE	.\include\sparse\sys\socket.h	/^    SO_RCVBUFFORCE,$/;"	e	enum:__anon30
SO_RCVLOWAT	.\include\sparse\sys\socket.h	/^    SO_RCVLOWAT,$/;"	e	enum:__anon30
SO_RCVTIMEO	.\include\sparse\sys\socket.h	/^    SO_RCVTIMEO,$/;"	e	enum:__anon30
SO_REUSEADDR	.\include\sparse\sys\socket.h	/^    SO_REUSEADDR,$/;"	e	enum:__anon30
SO_SNDBUF	.\include\sparse\sys\socket.h	/^    SO_SNDBUF,$/;"	e	enum:__anon30
SO_SNDLOWAT	.\include\sparse\sys\socket.h	/^    SO_SNDLOWAT,$/;"	e	enum:__anon30
SO_SNDTIMEO	.\include\sparse\sys\socket.h	/^    SO_SNDTIMEO,$/;"	e	enum:__anon30
SO_TYPE	.\include\sparse\sys\socket.h	/^    SO_TYPE,$/;"	e	enum:__anon30
SPACES_PER_LEVEL	.\lib\json.c	1419;"	d	file:
SPACES_PER_LEVEL	.\python\ovs\json.py	/^SPACES_PER_LEVEL = 2$/;"	v
SPR	.\lib\odp-util.c	187;"	d	file:
SPR	.\lib\odp-util.c	189;"	d	file:
SPR	.\lib\odp-util.c	199;"	d	file:
SPR	.\lib\odp-util.c	201;"	d	file:
SPR	.\lib\odp-util.h	53;"	d
SPR	.\lib\odp-util.h	55;"	d
SPR	.\lib\odp-util.h	62;"	d
SPR	.\lib\odp-util.h	64;"	d
SSET_FIRST	.\lib\sset.h	94;"	d
SSET_FOR_EACH	.\lib\sset.h	71;"	d
SSET_FOR_EACH_SAFE	.\lib\sset.h	76;"	d
SSET_H	.\lib\sset.h	18;"	d
SSET_INITIALIZER	.\lib\sset.h	37;"	d
SSET_NAME_FROM_HMAP_NODE	.\lib\sset.h	89;"	d
SSET_NEXT	.\lib\sset.h	95;"	d
SSET_NODE_FROM_HMAP_NODE	.\lib\sset.h	87;"	d
SSET_NODE_FROM_NAME	.\lib\sset.h	93;"	d
SS_NTOP_BUFSIZE	.\lib\socket-util.h	91;"	d
STATE	.\lib\rconn.c	1268;"	d	file:
STATE	.\lib\rconn.c	1270;"	d	file:
STATE	.\lib\rconn.c	658;"	d	file:
STATE	.\lib\rconn.c	660;"	d	file:
STATE	.\lib\rconn.c	68;"	d	file:
STATE	.\lib\rconn.c	70;"	d	file:
STATE	.\lib\rconn.c	77;"	d	file:
STATE	.\lib\rconn.c	79;"	d	file:
STATE	.\lib\reconnect.c	36;"	d	file:
STATE	.\lib\reconnect.c	38;"	d	file:
STATE	.\lib\reconnect.c	82;"	d	file:
STATE	.\lib\reconnect.c	84;"	d	file:
STATES	.\lib\rconn.c	/^    STATES$/;"	e	enum:state	file:
STATES	.\lib\rconn.c	60;"	d	file:
STATES	.\lib\reconnect.c	/^    STATES$/;"	e	enum:state	file:
STATES	.\lib\reconnect.c	27;"	d	file:
STATE_ADMIN_DOWN	.\lib\bfd.c	/^    STATE_ADMIN_DOWN = 0 << 6,$/;"	e	enum:state	file:
STATE_DOWN	.\lib\bfd.c	/^    STATE_DOWN = 1 << 6,$/;"	e	enum:state	file:
STATE_INIT	.\lib\bfd.c	/^    STATE_INIT = 2 << 6,$/;"	e	enum:state	file:
STATE_MASK	.\lib\bfd.c	146;"	d	file:
STATE_SSL_CONNECTING	.\lib\stream-ssl.c	/^    STATE_SSL_CONNECTING$/;"	e	enum:ssl_state	file:
STATE_TCP_CONNECTING	.\lib\stream-ssl.c	/^    STATE_TCP_CONNECTING,$/;"	e	enum:ssl_state	file:
STATE_UP	.\lib\bfd.c	/^    STATE_UP = 3 << 6$/;"	e	enum:state	file:
STATUS_CHECK_AGAIN_MSEC	.\vswitchd\bridge.c	188;"	d	file:
STDERR_FILENO	.\include\windows\unistd.h	24;"	d
STDIN_FILENO	.\include\windows\unistd.h	22;"	d
STDOUT_FILENO	.\include\windows\unistd.h	23;"	d
STP_BLOCKING	.\lib\stp.h	/^    STP_BLOCKING = 1 << 4        \/* 8.4.1: Initial boot state. *\/$/;"	e	enum:stp_state
STP_CONFIG_TOPOLOGY_CHANGE	.\lib\stp.c	/^    STP_CONFIG_TOPOLOGY_CHANGE = 0x01$/;"	e	enum:stp_config_bpdu_flags	file:
STP_CONFIG_TOPOLOGY_CHANGE_ACK	.\lib\stp.c	/^    STP_CONFIG_TOPOLOGY_CHANGE_ACK = 0x80,$/;"	e	enum:stp_config_bpdu_flags	file:
STP_DEFAULT_BRIDGE_PRIORITY	.\lib\stp.h	36;"	d
STP_DEFAULT_FWD_DELAY	.\lib\stp.h	42;"	d
STP_DEFAULT_HELLO_TIME	.\lib\stp.h	41;"	d
STP_DEFAULT_MAX_AGE	.\lib\stp.h	40;"	d
STP_DEFAULT_PORT_PRIORITY	.\lib\stp.h	37;"	d
STP_DISABLED	.\lib\stp.h	/^    STP_DISABLED = 1 << 0,       \/* 8.4.5: See note above. *\/$/;"	e	enum:stp_state
STP_FORWARDING	.\lib\stp.h	/^    STP_FORWARDING = 1 << 3,     \/* 8.4.4: Learning and relaying frames. *\/$/;"	e	enum:stp_state
STP_H	.\lib\stp.h	18;"	d
STP_ID_ARGS	.\lib\stp.h	50;"	d
STP_ID_FMT	.\lib\stp.h	49;"	d
STP_LEARNING	.\lib\stp.h	/^    STP_LEARNING = 1 << 2,       \/* 8.4.3: Learning but not relaying frames. *\/$/;"	e	enum:stp_state
STP_LISTENING	.\lib\stp.h	/^    STP_LISTENING = 1 << 1,      \/* 8.4.2: Not learning or relaying frames. *\/$/;"	e	enum:stp_state
STP_LLC_CNTL	.\lib\stp.h	33;"	d
STP_LLC_DSAP	.\lib\stp.h	32;"	d
STP_LLC_SSAP	.\lib\stp.h	31;"	d
STP_MAX_PORTS	.\lib\stp.h	57;"	d
STP_PORT_ID_FMT	.\lib\stp.h	54;"	d
STP_PROTOCOL_ID	.\lib\stp.c	39;"	d	file:
STP_PROTOCOL_VERSION	.\lib\stp.c	40;"	d	file:
STP_ROLE_ALTERNATE	.\lib\stp.h	/^    STP_ROLE_ALTERNATE,          \/* Backup path to root bridge. *\/$/;"	e	enum:stp_role
STP_ROLE_DESIGNATED	.\lib\stp.h	/^    STP_ROLE_DESIGNATED,         \/* Path to LAN segments. *\/$/;"	e	enum:stp_role
STP_ROLE_DISABLED	.\lib\stp.h	/^    STP_ROLE_DISABLED            \/* Port does not participate in STP. *\/$/;"	e	enum:stp_role
STP_ROLE_ROOT	.\lib\stp.h	/^    STP_ROLE_ROOT,               \/* Path to root bridge. *\/$/;"	e	enum:stp_role
STP_TYPE_CONFIG	.\lib\stp.c	41;"	d	file:
STP_TYPE_TCN	.\lib\stp.c	42;"	d	file:
STREAM_CONNECT	.\lib\stream.h	/^    STREAM_CONNECT,$/;"	e	enum:stream_wait_type
STREAM_FD_H	.\lib\stream-fd.h	21;"	d
STREAM_H	.\lib\stream.h	18;"	d
STREAM_INIT	.\lib\vconn-stream.c	364;"	d	file:
STREAM_JSONRPC	.\lib\stream.h	/^    STREAM_JSONRPC$/;"	e	enum:stream_content_type
STREAM_OPENFLOW	.\lib\stream.h	/^    STREAM_OPENFLOW,$/;"	e	enum:stream_content_type
STREAM_PROVIDER_H	.\lib\stream-provider.h	18;"	d
STREAM_RECV	.\lib\stream.h	/^    STREAM_RECV,$/;"	e	enum:stream_wait_type
STREAM_SEND	.\lib\stream.h	/^    STREAM_SEND$/;"	e	enum:stream_wait_type
STREAM_SSL	.\lib\stream.h	/^    STREAM_SSL,$/;"	e	enum:stream_content_type
STREAM_SSL_H	.\lib\stream-ssl.h	17;"	d
STREAM_SSL_LONG_OPTIONS	.\lib\stream-ssl.h	29;"	d
STREAM_SSL_OPTION_HANDLERS	.\lib\stream-ssl.h	34;"	d
STREAM_UNKNOWN	.\lib\stream.h	/^    STREAM_UNKNOWN,$/;"	e	enum:stream_content_type
STRFTIME_FORMAT	.\lib\compiler.h	32;"	d
STRFTIME_FORMAT	.\lib\compiler.h	44;"	d
STRINGIZE	.\lib\util.h	181;"	d
STRINGIZE2	.\lib\util.h	182;"	d
SUCCESS	.\python\ovs\db\idl.py	/^    SUCCESS = "success"          # Commit successful.$/;"	v	class:Transaction
SVEC_EMPTY_INITIALIZER	.\lib\svec.h	33;"	d
SVEC_FOR_EACH	.\lib\svec.h	67;"	d
SVEC_H	.\lib\svec.h	18;"	d
SWITCH	.\tests\test-sflow.c	/^        uint32_t SWITCH;$/;"	m	struct:sflow_xdr::__anon160	file:
SW_FLOW_KEY_MEMCPY	.\datapath\flow_netlink.c	92;"	d	file:
SW_FLOW_KEY_PUT	.\datapath\flow_netlink.c	80;"	d	file:
SYSLOG_H	.\include\windows\syslog.h	18;"	d
SYSTEM_STATS_INTERVAL	.\vswitchd\system-stats.c	525;"	d	file:
SYS_RESOURCE_H	.\include\windows\sys\resource.h	18;"	d
S_CONNECTING	.\lib\learning-switch.c	/^    S_CONNECTING,               \/* Waiting for connection to complete. *\/$/;"	e	enum:lswitch_state	file:
S_EVICT	.\ofproto\ofproto.c	/^    S_EVICT,                    \/* Evicting flows from over-limit tables. *\/$/;"	e	enum:ofproto_state	file:
S_FEATURES_REPLY	.\lib\learning-switch.c	/^    S_FEATURES_REPLY,           \/* Waiting for features reply. *\/$/;"	e	enum:lswitch_state	file:
S_FLUSH	.\ofproto\ofproto.c	/^    S_FLUSH,                    \/* Deleting all flow table rules. *\/$/;"	e	enum:ofproto_state	file:
S_OPENFLOW	.\ofproto\ofproto.c	/^    S_OPENFLOW,                 \/* Processing OpenFlow commands. *\/$/;"	e	enum:ofproto_state	file:
S_SWITCHING	.\lib\learning-switch.c	/^    S_SWITCHING,                \/* Switching flows. *\/$/;"	e	enum:lswitch_state	file:
SchemaHelper	.\python\ovs\db\idl.py	/^class SchemaHelper(object):$/;"	c
SelectPoll	.\python\ovs\poller.py	/^SelectPoll = _SelectSelect$/;"	v
Session	.\python\ovs\jsonrpc.py	/^class Session(object):$/;"	c
Session	.\tests\MockXenAPI.py	/^class Session(object):$/;"	c
SetController	.\xenserver\usr_lib_xsconsole_plugins-base_XSFeatureVSwitch.py	/^    def SetController(self, ip):$/;"	m	class:VSwitchControllerDialogue
Stats	.\python\ovs\reconnect.py	/^        class Stats(object):$/;"	c	function:Reconnect.get_stats
StatusUpdateHandler	.\xenserver\usr_lib_xsconsole_plugins-base_XSFeatureVSwitch.py	/^    def StatusUpdateHandler(cls, inPane):$/;"	m	class:XSFeatureVSwitch
Stream	.\python\ovs\stream.py	/^class Stream(object):$/;"	c
StringIO	.\python\ovs\json.py	/^import StringIO$/;"	i
StringType	.\python\ovs\db\types.py	/^StringType = AtomicType("string", "", (str, unicode))$/;"	v
TABLE_H	.\lib\table.h	18;"	d
TABLE_LONG_OPTIONS	.\lib\table.h	90;"	d
TABLE_OPTION_ENUMS	.\lib\table.h	85;"	d
TABLE_OPTION_HANDLERS	.\lib\table.h	97;"	d
TABLE_STYLE_DEFAULT	.\lib\table.h	83;"	d
TAG_ALL	.\lib\tag.h	71;"	d
TAG_ARBITRARY	.\lib\tag.h	74;"	d
TAG_H	.\lib\tag.h	18;"	d
TBL_INTERNAL	.\ofproto\ofproto-dpif.h	/^enum { TBL_INTERNAL = N_TABLES - 1 };    \/* Used for internal hidden rules. *\/$/;"	e	enum:__anon145
TBL_MIN_BUCKETS	.\datapath\flow_table.c	49;"	d	file:
TCPStream	.\python\ovs\stream.py	/^class TCPStream(Stream):$/;"	c
TCP_ACK	.\lib\packets.h	533;"	d
TCP_CTL	.\lib\packets.h	539;"	d
TCP_CWR	.\lib\packets.h	536;"	d
TCP_ECE	.\lib\packets.h	535;"	d
TCP_FIN	.\lib\packets.h	529;"	d
TCP_FLAGS	.\lib\packets.h	540;"	d
TCP_FLAGS_BE16	.\datapath\flow.c	65;"	d	file:
TCP_FLAGS_BE16	.\lib\packets.h	541;"	d
TCP_FLAGS_BE32	.\lib\flow.c	79;"	d	file:
TCP_FLAGS_BE32	.\lib\flow.c	82;"	d	file:
TCP_HEADER_LEN	.\lib\packets.h	544;"	d
TCP_NS	.\lib\packets.h	537;"	d
TCP_OFFSET	.\lib\packets.h	542;"	d
TCP_PSH	.\lib\packets.h	532;"	d
TCP_RST	.\lib\packets.h	531;"	d
TCP_SYN	.\lib\packets.h	530;"	d
TCP_URG	.\lib\packets.h	534;"	d
TC_INITIALIZER	.\lib\netdev-linux.c	166;"	d	file:
TC_RTAB_SIZE	.\lib\netdev-linux.c	107;"	d	file:
TEST	.\tests\test-lockfile.c	241;"	d	file:
TEST	.\tests\test-lockfile.c	254;"	d	file:
TESTPKI_FILES	.\tests\automake.mk	/^TESTPKI_FILES = \\$/;"	m
TESTSUITE	.\tests\automake.mk	/^TESTSUITE = $(srcdir)\/tests\/testsuite$/;"	m
TESTSUITE_AT	.\tests\automake.mk	/^TESTSUITE_AT = \\$/;"	m
TEST_ATOMIC_TYPE	.\tests\test-atomic.c	23;"	d	file:
TEST_CASE	.\tests\test-csum.c	39;"	d	file:
TEST_TYPE	.\tests\test-type-props.c	31;"	d	file:
TF_CSV	.\lib\table.h	/^    TF_CSV,                     \/* Comma-separated lines. *\/$/;"	e	enum:table_format
TF_HTML	.\lib\table.h	/^    TF_HTML,                    \/* HTML table. *\/$/;"	e	enum:table_format
TF_JSON	.\lib\table.h	/^    TF_JSON                     \/* JSON. *\/$/;"	e	enum:table_format
TF_LIST	.\lib\table.h	/^    TF_LIST,                    \/* One cell per line, one row per paragraph. *\/$/;"	e	enum:table_format
TF_TABLE	.\lib\table.h	/^    TF_TABLE,                   \/* 2-d table. *\/$/;"	e	enum:table_format
TIMER_H	.\lib\timer.h	18;"	d
TIMEVAL_H	.\lib\timeval.h	18;"	d
TIME_MAX	.\lib\timeval.h	40;"	d
TIME_MIN	.\lib\timeval.h	41;"	d
TOKEN_BUCKET_H	.\lib\token-bucket.h	18;"	d
TOKEN_BUCKET_INIT	.\lib\token-bucket.h	33;"	d
TP_PORTS_OFS32	.\lib\classifier.c	37;"	d	file:
TP_STATUS_VLAN_TPID_VALID	.\lib\netdev-linux.c	126;"	d	file:
TP_STATUS_VLAN_VALID	.\lib\netdev-linux.c	123;"	d	file:
TRIE_PREFIX_BITS	.\lib\classifier.c	1954;"	d	file:
TRY_AGAIN	.\python\ovs\db\idl.py	/^    TRY_AGAIN = "try again"      # Commit failed because a "verify" operation$/;"	v	class:Transaction
TRY_LOCK_FUNCTION	.\lib\ovs-thread.c	74;"	d	file:
TUNNEL_CLASS	.\lib\netdev-vport.c	819;"	d	file:
TUNNEL_CSUM	.\datapath\linux\compat\include\net\ip_tunnels.h	41;"	d
TUNNEL_DONT_FRAGMENT	.\datapath\linux\compat\include\net\ip_tunnels.h	49;"	d
TUNNEL_H	.\ofproto\tunnel.h	17;"	d
TUNNEL_KEY	.\datapath\linux\compat\include\net\ip_tunnels.h	43;"	d
TUNNEL_NO_KEY	.\datapath\linux\compat\include\net\ip_tunnels.h	48;"	d
TUNNEL_REC	.\datapath\linux\compat\include\net\ip_tunnels.h	46;"	d
TUNNEL_ROUTING	.\datapath\linux\compat\include\net\ip_tunnels.h	42;"	d
TUNNEL_SEQ	.\datapath\linux\compat\include\net\ip_tunnels.h	44;"	d
TUNNEL_STRICT	.\datapath\linux\compat\include\net\ip_tunnels.h	45;"	d
TUNNEL_VERSION	.\datapath\linux\compat\include\net\ip_tunnels.h	47;"	d
TXN_ABORTED	.\lib\ovsdb-idl.h	/^    TXN_ABORTED,                \/* ovsdb_idl_txn_abort() called. *\/$/;"	e	enum:ovsdb_idl_txn_status
TXN_ERROR	.\lib\ovsdb-idl.h	/^    TXN_ERROR                   \/* Commit failed due to a hard error. *\/$/;"	e	enum:ovsdb_idl_txn_status
TXN_INCOMPLETE	.\lib\ovsdb-idl.h	/^    TXN_INCOMPLETE,             \/* Commit in progress, please wait. *\/$/;"	e	enum:ovsdb_idl_txn_status
TXN_NOT_LOCKED	.\lib\ovsdb-idl.h	/^    TXN_NOT_LOCKED,             \/* Server hasn't given us the lock yet. *\/$/;"	e	enum:ovsdb_idl_txn_status
TXN_SUCCESS	.\lib\ovsdb-idl.h	/^    TXN_SUCCESS,                \/* Commit successful. *\/$/;"	e	enum:ovsdb_idl_txn_status
TXN_TRY_AGAIN	.\lib\ovsdb-idl.h	/^    TXN_TRY_AGAIN,              \/* Commit failed because a "verify" operation$/;"	e	enum:ovsdb_idl_txn_status
TXN_UNCHANGED	.\lib\ovsdb-idl.h	/^    TXN_UNCHANGED,              \/* Transaction didn't include any changes. *\/$/;"	e	enum:ovsdb_idl_txn_status
TXN_UNCOMMITTED	.\lib\ovsdb-idl.h	/^    TXN_UNCOMMITTED,            \/* Not yet committed or aborted. *\/$/;"	e	enum:ovsdb_idl_txn_status
TX_HTHRESH	.\lib\netdev-dpdk.c	79;"	d	file:
TX_PTHRESH	.\lib\netdev-dpdk.c	78;"	d	file:
TX_WTHRESH	.\lib\netdev-dpdk.c	80;"	d	file:
TYPE_IS_INTEGER	.\lib\type-props.h	22;"	d
TYPE_IS_SIGNED	.\lib\type-props.h	23;"	d
TYPE_MAXIMUM	.\lib\type-props.h	28;"	d
TYPE_MINIMUM	.\lib\type-props.h	25;"	d
TYPE_PROPS_H	.\lib\type-props.h	18;"	d
TYPE_VALUE_BITS	.\lib\type-props.h	24;"	d
T_BEGIN_ARRAY	.\lib\json.c	/^    T_BEGIN_ARRAY = '[',$/;"	e	enum:json_token_type	file:
T_BEGIN_OBJECT	.\lib\json.c	/^    T_BEGIN_OBJECT = '{',$/;"	e	enum:json_token_type	file:
T_END_ARRAY	.\lib\json.c	/^    T_END_ARRAY = ']',$/;"	e	enum:json_token_type	file:
T_END_OBJECT	.\lib\json.c	/^    T_END_OBJECT = '}',$/;"	e	enum:json_token_type	file:
T_EOF	.\lib\json.c	/^    T_EOF = 0,$/;"	e	enum:json_token_type	file:
T_ERROR	.\python\ovs\jsonrpc.py	/^    T_ERROR = 3                 # Error reply.$/;"	v	class:Message
T_FALSE	.\lib\json.c	/^    T_FALSE = UCHAR_MAX + 1,$/;"	e	enum:json_token_type	file:
T_INTEGER	.\lib\json.c	/^    T_INTEGER,$/;"	e	enum:json_token_type	file:
T_NAME_SEPARATOR	.\lib\json.c	/^    T_NAME_SEPARATOR = ':',$/;"	e	enum:json_token_type	file:
T_NOTIFY	.\python\ovs\jsonrpc.py	/^    T_NOTIFY = 1                # Notification.$/;"	v	class:Message
T_NULL	.\lib\json.c	/^    T_NULL,$/;"	e	enum:json_token_type	file:
T_REAL	.\lib\json.c	/^    T_REAL,$/;"	e	enum:json_token_type	file:
T_REPLY	.\python\ovs\jsonrpc.py	/^    T_REPLY = 2                 # Successful reply.$/;"	v	class:Message
T_REQUEST	.\python\ovs\jsonrpc.py	/^    T_REQUEST = 0               # Request.$/;"	v	class:Message
T_STRING	.\lib\json.c	/^    T_STRING$/;"	e	enum:json_token_type	file:
T_TRUE	.\lib\json.c	/^    T_TRUE,$/;"	e	enum:json_token_type	file:
T_VALUE_SEPARATOR	.\lib\json.c	/^    T_VALUE_SEPARATOR = ',',$/;"	e	enum:json_token_type	file:
Table	.\tests\MockXenAPI.py	/^class Table(object):$/;"	c
TableSchema	.\python\ovs\db\schema.py	/^class TableSchema(object):$/;"	c
TcpListenerConnection	.\python\ovstest\tcp.py	/^class TcpListenerConnection(Protocol):$/;"	c
TcpListenerFactory	.\python\ovstest\tcp.py	/^class TcpListenerFactory(Factory):$/;"	c
TcpSenderConnection	.\python\ovstest\tcp.py	/^class TcpSenderConnection(Protocol):$/;"	c
TcpSenderFactory	.\python\ovstest\tcp.py	/^class TcpSenderFactory(ClientFactory):$/;"	c
Te0	.\lib\aes128.c	/^static const uint32_t Te0[256] = {$/;"	v	file:
Te1	.\lib\aes128.c	/^static const uint32_t Te1[256] = {$/;"	v	file:
Te2	.\lib\aes128.c	/^static const uint32_t Te2[256] = {$/;"	v	file:
Te3	.\lib\aes128.c	/^static const uint32_t Te3[256] = {$/;"	v	file:
Te4	.\lib\aes128.c	/^static const uint32_t Te4[256] = {$/;"	v	file:
TestArena	.\python\ovstest\rpcserver.py	/^class TestArena(xmlrpc.XMLRPC):$/;"	c
Transaction	.\python\ovs\db\idl.py	/^class Transaction(object):$/;"	c
Type	.\python\ovs\db\types.py	/^class Type(object):$/;"	c
UDP_ENCAP_LISP	.\datapath\vport-lisp.c	276;"	d	file:
UDP_HEADER_LEN	.\lib\packets.h	520;"	d
UNALIGNED_H	.\lib\unaligned.h	18;"	d
UNCHANGED	.\python\ovs\db\idl.py	/^    UNCHANGED = "unchanged"      # Transaction didn't include any changes.$/;"	v	class:Transaction
UNCOMMITTED	.\python\ovs\db\idl.py	/^    UNCOMMITTED = "uncommitted"  # Not yet committed or aborted.$/;"	v	class:Transaction
UNICODE_H	.\lib\unicode.h	18;"	d
UNIXCTL_H	.\lib\unixctl.h	18;"	d
UNLOCK_FUNCTION	.\lib\ovs-thread.c	102;"	d	file:
UNROLL_LOOPS	.\lib\sha1.c	40;"	d	file:
USER_ACTION_COOKIE_FLOW_SAMPLE	.\lib\odp-util.h	/^    USER_ACTION_COOKIE_FLOW_SAMPLE,  \/* Packet for per-flow sampling. *\/$/;"	e	enum:user_action_cookie_type
USER_ACTION_COOKIE_IPFIX	.\lib\odp-util.h	/^    USER_ACTION_COOKIE_IPFIX,        \/* Packet for per-bridge IPFIX sampling. *\/$/;"	e	enum:user_action_cookie_type
USER_ACTION_COOKIE_SFLOW	.\lib\odp-util.h	/^    USER_ACTION_COOKIE_SFLOW,        \/* Packet for per-bridge sFlow sampling. *\/$/;"	e	enum:user_action_cookie_type
USER_ACTION_COOKIE_SLOW_PATH	.\lib\odp-util.h	/^    USER_ACTION_COOKIE_SLOW_PATH,    \/* Userspace must process this flow. *\/$/;"	e	enum:user_action_cookie_type
USER_ACTION_COOKIE_UNSPEC	.\lib\odp-util.h	/^    USER_ACTION_COOKIE_UNSPEC,$/;"	e	enum:user_action_cookie_type
USER_HZ	.\vswitchd\system-stats.c	229;"	d	file:
USE_KERNEL_TUNNEL_API	.\datapath\linux\compat\include\net\ip_tunnels.h	11;"	d
USHRT_MAX	.\datapath\linux\compat\include\linux\kernel.h	50;"	d
UTIL_H	.\lib\util.h	18;"	d
UUID	.\python\compat\uuid.py	/^class UUID(object):$/;"	c
UUID_ARGS	.\lib\uuid.h	47;"	d
UUID_BIT	.\lib\uuid.h	24;"	d
UUID_FMT	.\lib\uuid.h	46;"	d
UUID_H	.\lib\uuid.h	17;"	d
UUID_LEN	.\lib\uuid.h	45;"	d
UUID_OCTET	.\lib\uuid.h	/^BUILD_ASSERT_DECL(sizeof(struct uuid) == UUID_OCTET);$/;"	v
UUID_OCTET	.\lib\uuid.h	25;"	d
UdpListener	.\python\ovstest\udp.py	/^class UdpListener(DatagramProtocol):$/;"	c
UdpSender	.\python\ovstest\udp.py	/^class UdpSender(DatagramProtocol):$/;"	c
UniqueServerAction	.\python\ovstest\args.py	/^class UniqueServerAction(argparse.Action):$/;"	c
UnixStream	.\python\ovs\stream.py	/^class UnixStream(Stream):$/;"	c
UnixctlClient	.\python\ovs\unixctl\client.py	/^class UnixctlClient(object):$/;"	c
UnixctlClient	.\python\ovs\unixctl\server.py	/^class UnixctlClient(object):$/;"	c
UnixctlConnection	.\python\ovs\unixctl\server.py	/^class UnixctlConnection(object):$/;"	c
UnixctlServer	.\python\ovs\unixctl\server.py	/^class UnixctlServer(object):$/;"	c
UpdateFields	.\xenserver\usr_lib_xsconsole_plugins-base_XSFeatureVSwitch.py	/^    def UpdateFields(self):$/;"	m	class:VSwitchControllerDialogue
UpdateFieldsGETCONTROLLER	.\xenserver\usr_lib_xsconsole_plugins-base_XSFeatureVSwitch.py	/^    def UpdateFieldsGETCONTROLLER(self):$/;"	m	class:VSwitchControllerDialogue
UpdateFieldsINITIAL	.\xenserver\usr_lib_xsconsole_plugins-base_XSFeatureVSwitch.py	/^    def UpdateFieldsINITIAL(self):$/;"	m	class:VSwitchControllerDialogue
UuidType	.\python\ovs\db\types.py	/^UuidType = AtomicType("uuid", ovs.ovsuuid.zero(), (uuid.UUID,))$/;"	v
VALGRIND	.\tests\automake.mk	/^VALGRIND = valgrind --log-file=valgrind.%p --leak-check=full \\$/;"	m
VALGRIND_H	.\lib\valgrind.h	18;"	d
VALID_CARRIER	.\lib\netdev-bsd.c	/^    VALID_CARRIER = 1 << 5$/;"	e	enum:__anon53	file:
VALID_DRVINFO	.\lib\netdev-linux.c	/^    VALID_DRVINFO           = 1 << 7,$/;"	e	enum:__anon58	file:
VALID_ETHERADDR	.\lib\netdev-bsd.c	/^    VALID_ETHERADDR = 1 << 1,$/;"	e	enum:__anon53	file:
VALID_ETHERADDR	.\lib\netdev-linux.c	/^    VALID_ETHERADDR         = 1 << 1,$/;"	e	enum:__anon58	file:
VALID_FEATURES	.\lib\netdev-linux.c	/^    VALID_FEATURES          = 1 << 8,$/;"	e	enum:__anon58	file:
VALID_IFINDEX	.\lib\netdev-bsd.c	/^    VALID_IFINDEX = 1 << 0,$/;"	e	enum:__anon53	file:
VALID_IFINDEX	.\lib\netdev-linux.c	/^    VALID_IFINDEX           = 1 << 0,$/;"	e	enum:__anon58	file:
VALID_IN4	.\lib\netdev-bsd.c	/^    VALID_IN4 = 1 << 2,$/;"	e	enum:__anon53	file:
VALID_IN4	.\lib\netdev-linux.c	/^    VALID_IN4               = 1 << 2,$/;"	e	enum:__anon58	file:
VALID_IN6	.\lib\netdev-bsd.c	/^    VALID_IN6 = 1 << 3,$/;"	e	enum:__anon53	file:
VALID_IN6	.\lib\netdev-linux.c	/^    VALID_IN6               = 1 << 3,$/;"	e	enum:__anon58	file:
VALID_MTU	.\lib\netdev-bsd.c	/^    VALID_MTU = 1 << 4,$/;"	e	enum:__anon53	file:
VALID_MTU	.\lib\netdev-linux.c	/^    VALID_MTU               = 1 << 4,$/;"	e	enum:__anon58	file:
VALID_POLICING	.\lib\netdev-linux.c	/^    VALID_POLICING          = 1 << 5,$/;"	e	enum:__anon58	file:
VALID_VPORT_STAT_ERROR	.\lib\netdev-linux.c	/^    VALID_VPORT_STAT_ERROR  = 1 << 6,$/;"	e	enum:__anon58	file:
VCONN_H	.\lib\vconn.h	18;"	d
VCONN_PROVIDER_H	.\lib\vconn-provider.h	18;"	d
VCS_CONNECTED	.\lib\vconn.c	/^    VCS_CONNECTED,              \/* Connection established. *\/$/;"	e	enum:vconn_state	file:
VCS_CONNECTING	.\lib\vconn.c	/^    VCS_CONNECTING,             \/* Underlying vconn is not connected. *\/$/;"	e	enum:vconn_state	file:
VCS_DISCONNECTED	.\lib\vconn.c	/^    VCS_DISCONNECTED            \/* Connection failed or connection closed. *\/$/;"	e	enum:vconn_state	file:
VCS_RECV_HELLO	.\lib\vconn.c	/^    VCS_RECV_HELLO,             \/* Waiting to receive OFPT_HELLO message. *\/$/;"	e	enum:vconn_state	file:
VCS_SEND_ERROR	.\lib\vconn.c	/^    VCS_SEND_ERROR,             \/* Sending OFPT_ERROR message. *\/$/;"	e	enum:vconn_state	file:
VCS_SEND_HELLO	.\lib\vconn.c	/^    VCS_SEND_HELLO,             \/* Waiting to send OFPT_HELLO message. *\/$/;"	e	enum:vconn_state	file:
VERSION	.\datapath\datapath.c	/^MODULE_VERSION(VERSION);$/;"	v
VERSION	.\python\ovs\version.py	/^VERSION = "2.3.1"$/;"	v
VERS_SHIFT	.\lib\bfd.c	145;"	d	file:
VIF	.\tests\MockXenAPI.py	/^class VIF(Table):$/;"	c
VLANDEV_H	.\lib\vlandev.h	18;"	d
VLAN_BITMAP_H	.\lib\vlan-bitmap.h	17;"	d
VLAN_CFI	.\lib\packets.h	307;"	d
VLAN_CFI_MASK	.\datapath\linux\compat\include\linux\if_vlan.h	66;"	d
VLAN_CFI_SHIFT	.\lib\packets.h	308;"	d
VLAN_ETH_HEADER_LEN	.\lib\packets.h	341;"	d
VLAN_H	.\datapath\vlan.h	20;"	d
VLAN_HEADER_LEN	.\lib\packets.h	334;"	d
VLAN_PCP_MASK	.\lib\packets.h	304;"	d
VLAN_PCP_SHIFT	.\lib\packets.h	305;"	d
VLAN_PRIO_MASK	.\datapath\linux\compat\include\linux\if_vlan.h	64;"	d
VLAN_PRIO_SHIFT	.\datapath\linux\compat\include\linux\if_vlan.h	65;"	d
VLAN_TAG_PRESENT	.\datapath\linux\compat\include\linux\if_vlan.h	67;"	d
VLAN_VID_MASK	.\lib\packets.h	301;"	d
VLAN_VID_SHIFT	.\lib\packets.h	302;"	d
VLF_ANY_FACILITY	.\lib\vlog.h	/^    VLF_ANY_FACILITY = -1$/;"	e	enum:vlog_facility
VLF_N_FACILITIES	.\lib\vlog.h	/^    VLF_N_FACILITIES,$/;"	e	enum:vlog_facility
VLL_N_LEVELS	.\lib\vlog.h	/^    VLL_N_LEVELS$/;"	e	enum:vlog_level
VLOG	.\lib\vlog.h	243;"	d
VLOG_ABORT	.\lib\vlog.h	185;"	d
VLOG_DBG	.\lib\vlog.h	190;"	d
VLOG_DBG_ONCE	.\lib\vlog.h	217;"	d
VLOG_DBG_RL	.\lib\vlog.h	206;"	d
VLOG_DEFINE_MODULE	.\lib\vlog.h	93;"	d
VLOG_DEFINE_MODULE__	.\lib\vlog.h	266;"	d
VLOG_DEFINE_THIS_MODULE	.\lib\vlog.h	174;"	d
VLOG_DROP_DBG	.\lib\vlog.h	211;"	d
VLOG_DROP_ERR	.\lib\vlog.h	208;"	d
VLOG_DROP_INFO	.\lib\vlog.h	210;"	d
VLOG_DROP_WARN	.\lib\vlog.h	209;"	d
VLOG_EMER	.\lib\vlog.h	186;"	d
VLOG_ERR	.\lib\vlog.h	187;"	d
VLOG_ERR_ONCE	.\lib\vlog.h	214;"	d
VLOG_ERR_RL	.\lib\vlog.h	203;"	d
VLOG_FACILITIES	.\lib\vlog.h	/^    VLOG_FACILITIES$/;"	e	enum:vlog_facility
VLOG_FACILITIES	.\lib\vlog.h	65;"	d
VLOG_FACILITY	.\lib\vlog.c	92;"	d	file:
VLOG_FACILITY	.\lib\vlog.c	94;"	d	file:
VLOG_FACILITY	.\lib\vlog.h	70;"	d
VLOG_FACILITY	.\lib\vlog.h	72;"	d
VLOG_FATAL	.\lib\vlog.h	184;"	d
VLOG_H	.\lib\vlog.h	18;"	d
VLOG_INFO	.\lib\vlog.h	189;"	d
VLOG_INFO_ONCE	.\lib\vlog.h	216;"	d
VLOG_INFO_RL	.\lib\vlog.h	205;"	d
VLOG_IS_DBG_ENABLED	.\lib\vlog.h	198;"	d
VLOG_IS_ERR_ENABLED	.\lib\vlog.h	195;"	d
VLOG_IS_INFO_ENABLED	.\lib\vlog.h	197;"	d
VLOG_IS_WARN_ENABLED	.\lib\vlog.h	196;"	d
VLOG_LEVEL	.\lib\vlog.c	53;"	d	file:
VLOG_LEVEL	.\lib\vlog.c	55;"	d	file:
VLOG_LEVEL	.\lib\vlog.c	60;"	d	file:
VLOG_LEVEL	.\lib\vlog.c	62;"	d	file:
VLOG_LEVEL	.\lib\vlog.c	68;"	d	file:
VLOG_LEVEL	.\lib\vlog.h	55;"	d
VLOG_LEVEL	.\lib\vlog.h	57;"	d
VLOG_LEVELS	.\lib\vlog.c	71;"	d	file:
VLOG_LEVELS	.\lib\vlog.h	/^    VLOG_LEVELS$/;"	e	enum:vlog_level
VLOG_LEVELS	.\lib\vlog.h	47;"	d
VLOG_LONG_OPTIONS	.\lib\vlog.h	224;"	d
VLOG_MSG_TOKENS	.\lib\vlog.h	113;"	d
VLOG_ONCE	.\lib\vlog.h	257;"	d
VLOG_OPTION_ENUMS	.\lib\vlog.h	220;"	d
VLOG_OPTION_HANDLERS	.\lib\vlog.h	229;"	d
VLOG_RATE_LIMIT_INIT	.\lib\vlog.h	117;"	d
VLOG_RL	.\lib\vlog.h	250;"	d
VLOG_WARN	.\lib\vlog.h	188;"	d
VLOG_WARN_ONCE	.\lib\vlog.h	215;"	d
VLOG_WARN_RL	.\lib\vlog.h	204;"	d
VM	.\tests\MockXenAPI.py	/^class VM(Table):$/;"	c
VPORT_ALIGN	.\datapath\vport.h	182;"	d
VPORT_E_RX_DROPPED	.\datapath\vport.h	/^	VPORT_E_RX_DROPPED,$/;"	e	enum:vport_err_type
VPORT_E_RX_ERROR	.\datapath\vport.h	/^	VPORT_E_RX_ERROR,$/;"	e	enum:vport_err_type
VPORT_E_TX_DROPPED	.\datapath\vport.h	/^	VPORT_E_TX_DROPPED,$/;"	e	enum:vport_err_type
VPORT_E_TX_ERROR	.\datapath\vport.h	/^	VPORT_E_TX_ERROR,$/;"	e	enum:vport_err_type
VPORT_FUNCTIONS	.\lib\netdev-vport.c	756;"	d	file:
VPORT_H	.\datapath\vport.h	20;"	d
VPORT_HASH_BUCKETS	.\datapath\vport.c	56;"	d	file:
VPORT_INTERNAL_DEV_H	.\datapath\vport-internal_dev.h	20;"	d
VPORT_NETDEV_H	.\datapath\vport-netdev.h	20;"	d
VSWITCHD_BRIDGE_H	.\vswitchd\bridge.h	17;"	d
VSWITCHD_SYSTEM_STATS	.\vswitchd\system-stats.h	17;"	d
VSWITCHD_XENSERVER_H	.\vswitchd\xenserver.h	17;"	d
VSWITCH_DOT_DIAGRAM_ARG	.\vswitchd\automake.mk	/^VSWITCH_DOT_DIAGRAM_ARG = --er-diagram=$(VSWITCH_PIC)$/;"	m
VSWITCH_IDL_FILES	.\lib\automake.mk	/^VSWITCH_IDL_FILES = \\$/;"	m
VSWITCH_PIC	.\vswitchd\automake.mk	/^VSWITCH_PIC = vswitchd\/vswitch.pic$/;"	m
VSwitchConfig	.\xenserver\usr_lib_xsconsole_plugins-base_XSFeatureVSwitch.py	/^class VSwitchConfig:$/;"	c
VSwitchControllerDialogue	.\xenserver\usr_lib_xsconsole_plugins-base_XSFeatureVSwitch.py	/^class VSwitchControllerDialogue(Dialogue):$/;"	c
VSwitchService	.\xenserver\usr_lib_xsconsole_plugins-base_XSFeatureVSwitch.py	/^class VSwitchService:$/;"	c
VTEPREC_ARP_SOURCES_LOCAL_COL_LOCATOR	.\lib\vtep-idl.h	/^    VTEPREC_ARP_SOURCES_LOCAL_COL_LOCATOR,$/;"	e	enum:__anon117
VTEPREC_ARP_SOURCES_LOCAL_COL_SRC_MAC	.\lib\vtep-idl.h	/^    VTEPREC_ARP_SOURCES_LOCAL_COL_SRC_MAC,$/;"	e	enum:__anon117
VTEPREC_ARP_SOURCES_LOCAL_FOR_EACH	.\lib\vtep-idl.h	39;"	d
VTEPREC_ARP_SOURCES_LOCAL_FOR_EACH_SAFE	.\lib\vtep-idl.h	43;"	d
VTEPREC_ARP_SOURCES_LOCAL_N_COLUMNS	.\lib\vtep-idl.h	/^    VTEPREC_ARP_SOURCES_LOCAL_N_COLUMNS$/;"	e	enum:__anon117
VTEPREC_ARP_SOURCES_REMOTE_COL_LOCATOR	.\lib\vtep-idl.h	/^    VTEPREC_ARP_SOURCES_REMOTE_COL_LOCATOR,$/;"	e	enum:__anon118
VTEPREC_ARP_SOURCES_REMOTE_COL_SRC_MAC	.\lib\vtep-idl.h	/^    VTEPREC_ARP_SOURCES_REMOTE_COL_SRC_MAC,$/;"	e	enum:__anon118
VTEPREC_ARP_SOURCES_REMOTE_FOR_EACH	.\lib\vtep-idl.h	90;"	d
VTEPREC_ARP_SOURCES_REMOTE_FOR_EACH_SAFE	.\lib\vtep-idl.h	94;"	d
VTEPREC_ARP_SOURCES_REMOTE_N_COLUMNS	.\lib\vtep-idl.h	/^    VTEPREC_ARP_SOURCES_REMOTE_N_COLUMNS$/;"	e	enum:__anon118
VTEPREC_GLOBAL_COL_MANAGERS	.\lib\vtep-idl.h	/^    VTEPREC_GLOBAL_COL_MANAGERS,$/;"	e	enum:__anon119
VTEPREC_GLOBAL_COL_SWITCHES	.\lib\vtep-idl.h	/^    VTEPREC_GLOBAL_COL_SWITCHES,$/;"	e	enum:__anon119
VTEPREC_GLOBAL_FOR_EACH	.\lib\vtep-idl.h	143;"	d
VTEPREC_GLOBAL_FOR_EACH_SAFE	.\lib\vtep-idl.h	147;"	d
VTEPREC_GLOBAL_N_COLUMNS	.\lib\vtep-idl.h	/^    VTEPREC_GLOBAL_N_COLUMNS$/;"	e	enum:__anon119
VTEPREC_IDL_HEADER	.\lib\vtep-idl.h	4;"	d
VTEPREC_LOGICAL_BINDING_STATS_COL_BYTES_FROM_LOCAL	.\lib\vtep-idl.h	/^    VTEPREC_LOGICAL_BINDING_STATS_COL_BYTES_FROM_LOCAL,$/;"	e	enum:__anon120
VTEPREC_LOGICAL_BINDING_STATS_COL_BYTES_TO_LOCAL	.\lib\vtep-idl.h	/^    VTEPREC_LOGICAL_BINDING_STATS_COL_BYTES_TO_LOCAL,$/;"	e	enum:__anon120
VTEPREC_LOGICAL_BINDING_STATS_COL_PACKETS_FROM_LOCAL	.\lib\vtep-idl.h	/^    VTEPREC_LOGICAL_BINDING_STATS_COL_PACKETS_FROM_LOCAL,$/;"	e	enum:__anon120
VTEPREC_LOGICAL_BINDING_STATS_COL_PACKETS_TO_LOCAL	.\lib\vtep-idl.h	/^    VTEPREC_LOGICAL_BINDING_STATS_COL_PACKETS_TO_LOCAL,$/;"	e	enum:__anon120
VTEPREC_LOGICAL_BINDING_STATS_FOR_EACH	.\lib\vtep-idl.h	204;"	d
VTEPREC_LOGICAL_BINDING_STATS_FOR_EACH_SAFE	.\lib\vtep-idl.h	208;"	d
VTEPREC_LOGICAL_BINDING_STATS_N_COLUMNS	.\lib\vtep-idl.h	/^    VTEPREC_LOGICAL_BINDING_STATS_N_COLUMNS$/;"	e	enum:__anon120
VTEPREC_LOGICAL_ROUTER_COL_DESCRIPTION	.\lib\vtep-idl.h	/^    VTEPREC_LOGICAL_ROUTER_COL_DESCRIPTION,$/;"	e	enum:__anon121
VTEPREC_LOGICAL_ROUTER_COL_NAME	.\lib\vtep-idl.h	/^    VTEPREC_LOGICAL_ROUTER_COL_NAME,$/;"	e	enum:__anon121
VTEPREC_LOGICAL_ROUTER_COL_STATIC_ROUTES	.\lib\vtep-idl.h	/^    VTEPREC_LOGICAL_ROUTER_COL_STATIC_ROUTES,$/;"	e	enum:__anon121
VTEPREC_LOGICAL_ROUTER_COL_SWITCH_BINDING	.\lib\vtep-idl.h	/^    VTEPREC_LOGICAL_ROUTER_COL_SWITCH_BINDING,$/;"	e	enum:__anon121
VTEPREC_LOGICAL_ROUTER_FOR_EACH	.\lib\vtep-idl.h	273;"	d
VTEPREC_LOGICAL_ROUTER_FOR_EACH_SAFE	.\lib\vtep-idl.h	277;"	d
VTEPREC_LOGICAL_ROUTER_N_COLUMNS	.\lib\vtep-idl.h	/^    VTEPREC_LOGICAL_ROUTER_N_COLUMNS$/;"	e	enum:__anon121
VTEPREC_LOGICAL_SWITCH_COL_DESCRIPTION	.\lib\vtep-idl.h	/^    VTEPREC_LOGICAL_SWITCH_COL_DESCRIPTION,$/;"	e	enum:__anon122
VTEPREC_LOGICAL_SWITCH_COL_NAME	.\lib\vtep-idl.h	/^    VTEPREC_LOGICAL_SWITCH_COL_NAME,$/;"	e	enum:__anon122
VTEPREC_LOGICAL_SWITCH_COL_TUNNEL_KEY	.\lib\vtep-idl.h	/^    VTEPREC_LOGICAL_SWITCH_COL_TUNNEL_KEY,$/;"	e	enum:__anon122
VTEPREC_LOGICAL_SWITCH_FOR_EACH	.\lib\vtep-idl.h	336;"	d
VTEPREC_LOGICAL_SWITCH_FOR_EACH_SAFE	.\lib\vtep-idl.h	340;"	d
VTEPREC_LOGICAL_SWITCH_N_COLUMNS	.\lib\vtep-idl.h	/^    VTEPREC_LOGICAL_SWITCH_N_COLUMNS$/;"	e	enum:__anon122
VTEPREC_MANAGER_COL_INACTIVITY_PROBE	.\lib\vtep-idl.h	/^    VTEPREC_MANAGER_COL_INACTIVITY_PROBE,$/;"	e	enum:__anon123
VTEPREC_MANAGER_COL_IS_CONNECTED	.\lib\vtep-idl.h	/^    VTEPREC_MANAGER_COL_IS_CONNECTED,$/;"	e	enum:__anon123
VTEPREC_MANAGER_COL_MAX_BACKOFF	.\lib\vtep-idl.h	/^    VTEPREC_MANAGER_COL_MAX_BACKOFF,$/;"	e	enum:__anon123
VTEPREC_MANAGER_COL_OTHER_CONFIG	.\lib\vtep-idl.h	/^    VTEPREC_MANAGER_COL_OTHER_CONFIG,$/;"	e	enum:__anon123
VTEPREC_MANAGER_COL_STATUS	.\lib\vtep-idl.h	/^    VTEPREC_MANAGER_COL_STATUS,$/;"	e	enum:__anon123
VTEPREC_MANAGER_COL_TARGET	.\lib\vtep-idl.h	/^    VTEPREC_MANAGER_COL_TARGET,$/;"	e	enum:__anon123
VTEPREC_MANAGER_FOR_EACH	.\lib\vtep-idl.h	412;"	d
VTEPREC_MANAGER_FOR_EACH_SAFE	.\lib\vtep-idl.h	416;"	d
VTEPREC_MANAGER_N_COLUMNS	.\lib\vtep-idl.h	/^    VTEPREC_MANAGER_N_COLUMNS$/;"	e	enum:__anon123
VTEPREC_MCAST_MACS_LOCAL_COL_IPADDR	.\lib\vtep-idl.h	/^    VTEPREC_MCAST_MACS_LOCAL_COL_IPADDR,$/;"	e	enum:__anon124
VTEPREC_MCAST_MACS_LOCAL_COL_LOCATOR_SET	.\lib\vtep-idl.h	/^    VTEPREC_MCAST_MACS_LOCAL_COL_LOCATOR_SET,$/;"	e	enum:__anon124
VTEPREC_MCAST_MACS_LOCAL_COL_LOGICAL_SWITCH	.\lib\vtep-idl.h	/^    VTEPREC_MCAST_MACS_LOCAL_COL_LOGICAL_SWITCH,$/;"	e	enum:__anon124
VTEPREC_MCAST_MACS_LOCAL_COL_MAC	.\lib\vtep-idl.h	/^    VTEPREC_MCAST_MACS_LOCAL_COL_MAC,$/;"	e	enum:__anon124
VTEPREC_MCAST_MACS_LOCAL_FOR_EACH	.\lib\vtep-idl.h	485;"	d
VTEPREC_MCAST_MACS_LOCAL_FOR_EACH_SAFE	.\lib\vtep-idl.h	489;"	d
VTEPREC_MCAST_MACS_LOCAL_N_COLUMNS	.\lib\vtep-idl.h	/^    VTEPREC_MCAST_MACS_LOCAL_N_COLUMNS$/;"	e	enum:__anon124
VTEPREC_MCAST_MACS_REMOTE_COL_IPADDR	.\lib\vtep-idl.h	/^    VTEPREC_MCAST_MACS_REMOTE_COL_IPADDR,$/;"	e	enum:__anon125
VTEPREC_MCAST_MACS_REMOTE_COL_LOCATOR_SET	.\lib\vtep-idl.h	/^    VTEPREC_MCAST_MACS_REMOTE_COL_LOCATOR_SET,$/;"	e	enum:__anon125
VTEPREC_MCAST_MACS_REMOTE_COL_LOGICAL_SWITCH	.\lib\vtep-idl.h	/^    VTEPREC_MCAST_MACS_REMOTE_COL_LOGICAL_SWITCH,$/;"	e	enum:__anon125
VTEPREC_MCAST_MACS_REMOTE_COL_MAC	.\lib\vtep-idl.h	/^    VTEPREC_MCAST_MACS_REMOTE_COL_MAC,$/;"	e	enum:__anon125
VTEPREC_MCAST_MACS_REMOTE_FOR_EACH	.\lib\vtep-idl.h	552;"	d
VTEPREC_MCAST_MACS_REMOTE_FOR_EACH_SAFE	.\lib\vtep-idl.h	556;"	d
VTEPREC_MCAST_MACS_REMOTE_N_COLUMNS	.\lib\vtep-idl.h	/^    VTEPREC_MCAST_MACS_REMOTE_N_COLUMNS$/;"	e	enum:__anon125
VTEPREC_N_TABLES	.\lib\vtep-idl.h	/^    VTEPREC_N_TABLES$/;"	e	enum:__anon133
VTEPREC_PHYSICAL_LOCATOR_COL_DST_IP	.\lib\vtep-idl.h	/^    VTEPREC_PHYSICAL_LOCATOR_COL_DST_IP,$/;"	e	enum:__anon126
VTEPREC_PHYSICAL_LOCATOR_COL_ENCAPSULATION_TYPE	.\lib\vtep-idl.h	/^    VTEPREC_PHYSICAL_LOCATOR_COL_ENCAPSULATION_TYPE,$/;"	e	enum:__anon126
VTEPREC_PHYSICAL_LOCATOR_FOR_EACH	.\lib\vtep-idl.h	609;"	d
VTEPREC_PHYSICAL_LOCATOR_FOR_EACH_SAFE	.\lib\vtep-idl.h	613;"	d
VTEPREC_PHYSICAL_LOCATOR_N_COLUMNS	.\lib\vtep-idl.h	/^    VTEPREC_PHYSICAL_LOCATOR_N_COLUMNS$/;"	e	enum:__anon126
VTEPREC_PHYSICAL_LOCATOR_SET_COL_LOCATORS	.\lib\vtep-idl.h	/^    VTEPREC_PHYSICAL_LOCATOR_SET_COL_LOCATORS,$/;"	e	enum:__anon127
VTEPREC_PHYSICAL_LOCATOR_SET_FOR_EACH	.\lib\vtep-idl.h	656;"	d
VTEPREC_PHYSICAL_LOCATOR_SET_FOR_EACH_SAFE	.\lib\vtep-idl.h	660;"	d
VTEPREC_PHYSICAL_LOCATOR_SET_N_COLUMNS	.\lib\vtep-idl.h	/^    VTEPREC_PHYSICAL_LOCATOR_SET_N_COLUMNS$/;"	e	enum:__anon127
VTEPREC_PHYSICAL_PORT_COL_DESCRIPTION	.\lib\vtep-idl.h	/^    VTEPREC_PHYSICAL_PORT_COL_DESCRIPTION,$/;"	e	enum:__anon128
VTEPREC_PHYSICAL_PORT_COL_NAME	.\lib\vtep-idl.h	/^    VTEPREC_PHYSICAL_PORT_COL_NAME,$/;"	e	enum:__anon128
VTEPREC_PHYSICAL_PORT_COL_PORT_FAULT_STATUS	.\lib\vtep-idl.h	/^    VTEPREC_PHYSICAL_PORT_COL_PORT_FAULT_STATUS,$/;"	e	enum:__anon128
VTEPREC_PHYSICAL_PORT_COL_VLAN_BINDINGS	.\lib\vtep-idl.h	/^    VTEPREC_PHYSICAL_PORT_COL_VLAN_BINDINGS,$/;"	e	enum:__anon128
VTEPREC_PHYSICAL_PORT_COL_VLAN_STATS	.\lib\vtep-idl.h	/^    VTEPREC_PHYSICAL_PORT_COL_VLAN_STATS,$/;"	e	enum:__anon128
VTEPREC_PHYSICAL_PORT_FOR_EACH	.\lib\vtep-idl.h	724;"	d
VTEPREC_PHYSICAL_PORT_FOR_EACH_SAFE	.\lib\vtep-idl.h	728;"	d
VTEPREC_PHYSICAL_PORT_N_COLUMNS	.\lib\vtep-idl.h	/^    VTEPREC_PHYSICAL_PORT_N_COLUMNS$/;"	e	enum:__anon128
VTEPREC_PHYSICAL_SWITCH_COL_DESCRIPTION	.\lib\vtep-idl.h	/^    VTEPREC_PHYSICAL_SWITCH_COL_DESCRIPTION,$/;"	e	enum:__anon129
VTEPREC_PHYSICAL_SWITCH_COL_MANAGEMENT_IPS	.\lib\vtep-idl.h	/^    VTEPREC_PHYSICAL_SWITCH_COL_MANAGEMENT_IPS,$/;"	e	enum:__anon129
VTEPREC_PHYSICAL_SWITCH_COL_NAME	.\lib\vtep-idl.h	/^    VTEPREC_PHYSICAL_SWITCH_COL_NAME,$/;"	e	enum:__anon129
VTEPREC_PHYSICAL_SWITCH_COL_PORTS	.\lib\vtep-idl.h	/^    VTEPREC_PHYSICAL_SWITCH_COL_PORTS,$/;"	e	enum:__anon129
VTEPREC_PHYSICAL_SWITCH_COL_SWITCH_FAULT_STATUS	.\lib\vtep-idl.h	/^    VTEPREC_PHYSICAL_SWITCH_COL_SWITCH_FAULT_STATUS,$/;"	e	enum:__anon129
VTEPREC_PHYSICAL_SWITCH_COL_TUNNELS	.\lib\vtep-idl.h	/^    VTEPREC_PHYSICAL_SWITCH_COL_TUNNELS,$/;"	e	enum:__anon129
VTEPREC_PHYSICAL_SWITCH_COL_TUNNEL_IPS	.\lib\vtep-idl.h	/^    VTEPREC_PHYSICAL_SWITCH_COL_TUNNEL_IPS,$/;"	e	enum:__anon129
VTEPREC_PHYSICAL_SWITCH_FOR_EACH	.\lib\vtep-idl.h	814;"	d
VTEPREC_PHYSICAL_SWITCH_FOR_EACH_SAFE	.\lib\vtep-idl.h	818;"	d
VTEPREC_PHYSICAL_SWITCH_N_COLUMNS	.\lib\vtep-idl.h	/^    VTEPREC_PHYSICAL_SWITCH_N_COLUMNS$/;"	e	enum:__anon129
VTEPREC_TABLE_ARP_SOURCES_LOCAL	.\lib\vtep-idl.h	/^    VTEPREC_TABLE_ARP_SOURCES_LOCAL,$/;"	e	enum:__anon133
VTEPREC_TABLE_ARP_SOURCES_REMOTE	.\lib\vtep-idl.h	/^    VTEPREC_TABLE_ARP_SOURCES_REMOTE,$/;"	e	enum:__anon133
VTEPREC_TABLE_GLOBAL	.\lib\vtep-idl.h	/^    VTEPREC_TABLE_GLOBAL,$/;"	e	enum:__anon133
VTEPREC_TABLE_LOGICAL_BINDING_STATS	.\lib\vtep-idl.h	/^    VTEPREC_TABLE_LOGICAL_BINDING_STATS,$/;"	e	enum:__anon133
VTEPREC_TABLE_LOGICAL_ROUTER	.\lib\vtep-idl.h	/^    VTEPREC_TABLE_LOGICAL_ROUTER,$/;"	e	enum:__anon133
VTEPREC_TABLE_LOGICAL_SWITCH	.\lib\vtep-idl.h	/^    VTEPREC_TABLE_LOGICAL_SWITCH,$/;"	e	enum:__anon133
VTEPREC_TABLE_MANAGER	.\lib\vtep-idl.h	/^    VTEPREC_TABLE_MANAGER,$/;"	e	enum:__anon133
VTEPREC_TABLE_MCAST_MACS_LOCAL	.\lib\vtep-idl.h	/^    VTEPREC_TABLE_MCAST_MACS_LOCAL,$/;"	e	enum:__anon133
VTEPREC_TABLE_MCAST_MACS_REMOTE	.\lib\vtep-idl.h	/^    VTEPREC_TABLE_MCAST_MACS_REMOTE,$/;"	e	enum:__anon133
VTEPREC_TABLE_PHYSICAL_LOCATOR	.\lib\vtep-idl.h	/^    VTEPREC_TABLE_PHYSICAL_LOCATOR,$/;"	e	enum:__anon133
VTEPREC_TABLE_PHYSICAL_LOCATOR_SET	.\lib\vtep-idl.h	/^    VTEPREC_TABLE_PHYSICAL_LOCATOR_SET,$/;"	e	enum:__anon133
VTEPREC_TABLE_PHYSICAL_PORT	.\lib\vtep-idl.h	/^    VTEPREC_TABLE_PHYSICAL_PORT,$/;"	e	enum:__anon133
VTEPREC_TABLE_PHYSICAL_SWITCH	.\lib\vtep-idl.h	/^    VTEPREC_TABLE_PHYSICAL_SWITCH,$/;"	e	enum:__anon133
VTEPREC_TABLE_TUNNEL	.\lib\vtep-idl.h	/^    VTEPREC_TABLE_TUNNEL,$/;"	e	enum:__anon133
VTEPREC_TABLE_UCAST_MACS_LOCAL	.\lib\vtep-idl.h	/^    VTEPREC_TABLE_UCAST_MACS_LOCAL,$/;"	e	enum:__anon133
VTEPREC_TABLE_UCAST_MACS_REMOTE	.\lib\vtep-idl.h	/^    VTEPREC_TABLE_UCAST_MACS_REMOTE,$/;"	e	enum:__anon133
VTEPREC_TUNNEL_COL_BFD_CONFIG_LOCAL	.\lib\vtep-idl.h	/^    VTEPREC_TUNNEL_COL_BFD_CONFIG_LOCAL,$/;"	e	enum:__anon130
VTEPREC_TUNNEL_COL_BFD_CONFIG_REMOTE	.\lib\vtep-idl.h	/^    VTEPREC_TUNNEL_COL_BFD_CONFIG_REMOTE,$/;"	e	enum:__anon130
VTEPREC_TUNNEL_COL_BFD_PARAMS	.\lib\vtep-idl.h	/^    VTEPREC_TUNNEL_COL_BFD_PARAMS,$/;"	e	enum:__anon130
VTEPREC_TUNNEL_COL_BFD_STATUS	.\lib\vtep-idl.h	/^    VTEPREC_TUNNEL_COL_BFD_STATUS,$/;"	e	enum:__anon130
VTEPREC_TUNNEL_COL_LOCAL	.\lib\vtep-idl.h	/^    VTEPREC_TUNNEL_COL_LOCAL,$/;"	e	enum:__anon130
VTEPREC_TUNNEL_COL_REMOTE	.\lib\vtep-idl.h	/^    VTEPREC_TUNNEL_COL_REMOTE,$/;"	e	enum:__anon130
VTEPREC_TUNNEL_FOR_EACH	.\lib\vtep-idl.h	900;"	d
VTEPREC_TUNNEL_FOR_EACH_SAFE	.\lib\vtep-idl.h	904;"	d
VTEPREC_TUNNEL_N_COLUMNS	.\lib\vtep-idl.h	/^    VTEPREC_TUNNEL_N_COLUMNS$/;"	e	enum:__anon130
VTEPREC_UCAST_MACS_LOCAL_COL_IPADDR	.\lib\vtep-idl.h	/^    VTEPREC_UCAST_MACS_LOCAL_COL_IPADDR,$/;"	e	enum:__anon131
VTEPREC_UCAST_MACS_LOCAL_COL_LOCATOR	.\lib\vtep-idl.h	/^    VTEPREC_UCAST_MACS_LOCAL_COL_LOCATOR,$/;"	e	enum:__anon131
VTEPREC_UCAST_MACS_LOCAL_COL_LOGICAL_SWITCH	.\lib\vtep-idl.h	/^    VTEPREC_UCAST_MACS_LOCAL_COL_LOGICAL_SWITCH,$/;"	e	enum:__anon131
VTEPREC_UCAST_MACS_LOCAL_COL_MAC	.\lib\vtep-idl.h	/^    VTEPREC_UCAST_MACS_LOCAL_COL_MAC,$/;"	e	enum:__anon131
VTEPREC_UCAST_MACS_LOCAL_FOR_EACH	.\lib\vtep-idl.h	973;"	d
VTEPREC_UCAST_MACS_LOCAL_FOR_EACH_SAFE	.\lib\vtep-idl.h	977;"	d
VTEPREC_UCAST_MACS_LOCAL_N_COLUMNS	.\lib\vtep-idl.h	/^    VTEPREC_UCAST_MACS_LOCAL_N_COLUMNS$/;"	e	enum:__anon131
VTEPREC_UCAST_MACS_REMOTE_COL_IPADDR	.\lib\vtep-idl.h	/^    VTEPREC_UCAST_MACS_REMOTE_COL_IPADDR,$/;"	e	enum:__anon132
VTEPREC_UCAST_MACS_REMOTE_COL_LOCATOR	.\lib\vtep-idl.h	/^    VTEPREC_UCAST_MACS_REMOTE_COL_LOCATOR,$/;"	e	enum:__anon132
VTEPREC_UCAST_MACS_REMOTE_COL_LOGICAL_SWITCH	.\lib\vtep-idl.h	/^    VTEPREC_UCAST_MACS_REMOTE_COL_LOGICAL_SWITCH,$/;"	e	enum:__anon132
VTEPREC_UCAST_MACS_REMOTE_COL_MAC	.\lib\vtep-idl.h	/^    VTEPREC_UCAST_MACS_REMOTE_COL_MAC,$/;"	e	enum:__anon132
VTEPREC_UCAST_MACS_REMOTE_FOR_EACH	.\lib\vtep-idl.h	1040;"	d
VTEPREC_UCAST_MACS_REMOTE_FOR_EACH_SAFE	.\lib\vtep-idl.h	1044;"	d
VTEPREC_UCAST_MACS_REMOTE_N_COLUMNS	.\lib\vtep-idl.h	/^    VTEPREC_UCAST_MACS_REMOTE_N_COLUMNS$/;"	e	enum:__anon132
VTEP_DOT_DIAGRAM_ARG	.\vtep\automake.mk	/^VTEP_DOT_DIAGRAM_ARG = --er-diagram=$(VTEP_PIC)$/;"	m
VTEP_IDL_FILES	.\lib\automake.mk	/^VTEP_IDL_FILES = \\$/;"	m
VTEP_PIC	.\vtep\automake.mk	/^VTEP_PIC = vtep\/vtep.pic$/;"	m
VXLAN_DST_PORT	.\lib\netdev-vport.c	45;"	d	file:
VXLAN_FLAGS	.\datapath\linux\compat\vxlan.c	65;"	d	file:
VXLAN_HLEN	.\datapath\linux\compat\vxlan.c	63;"	d	file:
Vlog	.\python\ovs\vlog.py	/^class Vlog:$/;"	c
Void	.\python\ovs\reconnect.py	/^    class Void(object):$/;"	c	class:Reconnect
VoidType	.\python\ovs\db\types.py	/^VoidType = AtomicType("void", None, ())$/;"	v
WAIT_CONNECT	.\lib\vconn.h	/^    WAIT_CONNECT,$/;"	e	enum:vconn_wait_type
WAIT_RECV	.\lib\vconn.h	/^    WAIT_RECV,$/;"	e	enum:vconn_wait_type
WAIT_SEND	.\lib\vconn.h	/^    WAIT_SEND$/;"	e	enum:vconn_wait_type
WARN_UNUSED_RESULT	.\lib\compiler.h	35;"	d
WARN_UNUSED_RESULT	.\lib\compiler.h	47;"	d
WINDEFS_H	.\include\windows\windefs.h	18;"	d
W_CONNECT	.\python\ovs\stream.py	/^    W_CONNECT = 0               # Connect complete (success or failure).$/;"	v	class:Stream
W_RECV	.\python\ovs\stream.py	/^    W_RECV = 1                  # Data received.$/;"	v	class:Stream
W_SEND	.\python\ovs\stream.py	/^    W_SEND = 2                  # Send buffer room available.$/;"	v	class:Stream
X8	.\lib\netdev-linux.c	2431;"	d	file:
XC_BOND	.\ofproto\ofproto-dpif-xlate.c	/^    XC_BOND,$/;"	e	enum:xc_type	file:
XC_ENTRY_FOR_EACH	.\ofproto\ofproto-dpif-xlate.c	287;"	d	file:
XC_FIN_TIMEOUT	.\ofproto\ofproto-dpif-xlate.c	/^    XC_FIN_TIMEOUT,$/;"	e	enum:xc_type	file:
XC_LEARN	.\ofproto\ofproto-dpif-xlate.c	/^    XC_LEARN,$/;"	e	enum:xc_type	file:
XC_MIRROR	.\ofproto\ofproto-dpif-xlate.c	/^    XC_MIRROR,$/;"	e	enum:xc_type	file:
XC_NETDEV	.\ofproto\ofproto-dpif-xlate.c	/^    XC_NETDEV,$/;"	e	enum:xc_type	file:
XC_NETFLOW	.\ofproto\ofproto-dpif-xlate.c	/^    XC_NETFLOW,$/;"	e	enum:xc_type	file:
XC_NORMAL	.\ofproto\ofproto-dpif-xlate.c	/^    XC_NORMAL,$/;"	e	enum:xc_type	file:
XC_RULE	.\ofproto\ofproto-dpif-xlate.c	/^    XC_RULE,$/;"	e	enum:xc_type	file:
XPTHREAD_FUNC1	.\lib\ovs-thread.c	124;"	d	file:
XPTHREAD_FUNC2	.\lib\ovs-thread.c	133;"	d	file:
XPTHREAD_FUNC3	.\lib\ovs-thread.c	142;"	d	file:
XSFeatureVSwitch	.\xenserver\usr_lib_xsconsole_plugins-base_XSFeatureVSwitch.py	/^class XSFeatureVSwitch:$/;"	c
XenAPI	.\tests\MockXenAPI.py	/^class XenAPI(object):$/;"	c
XenAPI	.\xenserver\opt_xensource_libexec_InterfaceReconfigure.py	/^            import XenAPI$/;"	i
ZERO_OR_MORE	.\python\compat\argparse.py	/^ZERO_OR_MORE = '*'$/;"	v
_	.\python\compat\argparse.py	/^from gettext import gettext as _$/;"	i
_ASM_HASH_WRAPPER_H	.\datapath\linux\compat\include\asm\hash.h	2;"	d
_ActionsContainer	.\python\compat\argparse.py	/^class _ActionsContainer(object):$/;"	c
_AppendAction	.\python\compat\argparse.py	/^class _AppendAction(Action):$/;"	c
_AppendConstAction	.\python\compat\argparse.py	/^class _AppendConstAction(Action):$/;"	c
_ArgumentGroup	.\python\compat\argparse.py	/^class _ArgumentGroup(_ActionsContainer):$/;"	c
_AttributeHolder	.\python\compat\argparse.py	/^class _AttributeHolder(object):$/;"	c
_BOND_ATTRS	.\xenserver\opt_xensource_libexec_InterfaceReconfigure.py	/^_BOND_ATTRS = { 'uuid': (_str_to_xml,_str_from_xml),$/;"	v
_BOND_XML_TAG	.\xenserver\opt_xensource_libexec_InterfaceReconfigure.py	/^_BOND_XML_TAG = "bond"$/;"	v
_ChoicesPseudoAction	.\python\compat\argparse.py	/^    class _ChoicesPseudoAction(Action):$/;"	c	class:_SubParsersAction
_CountAction	.\python\compat\argparse.py	/^class _CountAction(Action):$/;"	c
_DIAGASSERT	.\lib\getopt_long.c	63;"	d	file:
_DIAGASSERT	.\lib\strsep.c	44;"	d	file:
_ETHTOOL_OTHERCONFIG_ATTRS	.\xenserver\opt_xensource_libexec_InterfaceReconfigure.py	/^_ETHTOOL_OTHERCONFIG_ATTRS = ['ethtool-%s' % x for x in 'autoneg', 'speed', 'duplex', 'rx', 'tx', 'sg', 'tso', 'ufo', 'gso', 'gro', 'lro' ]$/;"	v
_GETOPT_H_	.\include\windows\getopt.h	31;"	d
_HelpAction	.\python\compat\argparse.py	/^class _HelpAction(Action):$/;"	c
_InsertedRow	.\python\ovs\db\idl.py	/^class _InsertedRow(object):$/;"	c
_LINUX_HASH_WRAPPER_H	.\datapath\linux\compat\include\linux\hash.h	2;"	d
_LINUX_OPENVSWITCH_H	.\include\linux\openvswitch.h	41;"	d
_LINUX_RECIPROCAL_DIV_WRAPPER_H	.\datapath\linux\compat\include\linux\reciprocal_div.h	2;"	d
_LINUX_U64_STATS_SYNC_WRAPPER_H	.\datapath\linux\compat\include\linux\u64_stats_sync.h	2;"	d
_MutuallyExclusiveGroup	.\python\compat\argparse.py	/^class _MutuallyExclusiveGroup(_ArgumentGroup):$/;"	c
_NETINET_ICMP6_H_	.\include\windows\netinet\icmp6.h	62;"	d
_NETINET_IP6_H_	.\include\windows\netinet\ip6.h	62;"	d
_NETWORK_ATTRS	.\xenserver\opt_xensource_libexec_InterfaceReconfigure.py	/^_NETWORK_ATTRS = { 'uuid': (_str_to_xml,_str_from_xml),$/;"	v
_NETWORK_OTHERCONFIG_ATTRS	.\xenserver\opt_xensource_libexec_InterfaceReconfigure.py	/^_NETWORK_OTHERCONFIG_ATTRS = [ 'mtu',$/;"	v
_NETWORK_XML_TAG	.\xenserver\opt_xensource_libexec_InterfaceReconfigure.py	/^_NETWORK_XML_TAG = "network"$/;"	v
_NET_FLOW_KEYS_WRAPPER_H	.\datapath\linux\compat\include\net\flow_keys.h	2;"	d
_PIF_ATTRS	.\xenserver\opt_xensource_libexec_InterfaceReconfigure.py	/^_PIF_ATTRS = { 'uuid': (_str_to_xml,_str_from_xml),$/;"	v
_PIF_OTHERCONFIG_ATTRS	.\xenserver\opt_xensource_libexec_InterfaceReconfigure.py	/^                        [ 'bond-%s' % x for x in 'mode', 'miimon', 'downdelay',$/;"	v
_PIF_XML_TAG	.\xenserver\opt_xensource_libexec_InterfaceReconfigure.py	/^_PIF_XML_TAG = "pif"$/;"	v
_POOL_ATTRS	.\xenserver\opt_xensource_libexec_InterfaceReconfigure.py	/^_POOL_ATTRS = { 'other_config': (lambda x, p, t, v: _otherconfig_to_xml(x, p, v, _POOL_OTHERCONFIG_ATTRS),$/;"	v
_POOL_OTHERCONFIG_ATTRS	.\xenserver\opt_xensource_libexec_InterfaceReconfigure.py	/^_POOL_OTHERCONFIG_ATTRS = ['vswitch-controller-fail-mode']$/;"	v
_POOL_XML_TAG	.\xenserver\opt_xensource_libexec_InterfaceReconfigure.py	/^_POOL_XML_TAG = "pool"$/;"	v
_SFLAddress	.\lib\sflow.h	/^typedef struct _SFLAddress {$/;"	s
_SFLAddress_value	.\lib\sflow.h	/^typedef union _SFLAddress_value {$/;"	u
_SFLAgent	.\lib\sflow_api.h	/^typedef struct _SFLAgent {$/;"	s
_SFLCounters_sample	.\lib\sflow.h	/^typedef struct _SFLCounters_sample {$/;"	s
_SFLCounters_sample_element	.\lib\sflow.h	/^typedef struct _SFLCounters_sample_element {$/;"	s
_SFLCounters_sample_expanded	.\lib\sflow.h	/^typedef struct _SFLCounters_sample_expanded {$/;"	s
_SFLCounters_type	.\lib\sflow.h	/^typedef union _SFLCounters_type {$/;"	u
_SFLDataSource_instance	.\lib\sflow_api.h	/^typedef struct _SFLDataSource_instance {$/;"	s
_SFLEthernet_counters	.\lib\sflow.h	/^typedef struct _SFLEthernet_counters {$/;"	s
_SFLExtended_as_path_segment	.\lib\sflow.h	/^typedef struct _SFLExtended_as_path_segment {$/;"	s
_SFLExtended_gateway	.\lib\sflow.h	/^typedef struct _SFLExtended_gateway {$/;"	s
_SFLExtended_mpls	.\lib\sflow.h	/^typedef struct _SFLExtended_mpls {$/;"	s
_SFLExtended_mpls_FTN	.\lib\sflow.h	/^typedef struct _SFLExtended_mpls_FTN {$/;"	s
_SFLExtended_mpls_LDP_FEC	.\lib\sflow.h	/^typedef struct _SFLExtended_mpls_LDP_FEC {$/;"	s
_SFLExtended_mpls_tunnel	.\lib\sflow.h	/^typedef struct _SFLExtended_mpls_tunnel {$/;"	s
_SFLExtended_mpls_vc	.\lib\sflow.h	/^typedef struct _SFLExtended_mpls_vc {$/;"	s
_SFLExtended_nat	.\lib\sflow.h	/^typedef struct _SFLExtended_nat {$/;"	s
_SFLExtended_router	.\lib\sflow.h	/^typedef struct _SFLExtended_router {$/;"	s
_SFLExtended_switch	.\lib\sflow.h	/^typedef struct _SFLExtended_switch {$/;"	s
_SFLExtended_url	.\lib\sflow.h	/^typedef struct _SFLExtended_url {$/;"	s
_SFLExtended_user	.\lib\sflow.h	/^typedef struct _SFLExtended_user {$/;"	s
_SFLExtended_vlan_tunnel	.\lib\sflow.h	/^typedef struct _SFLExtended_vlan_tunnel {$/;"	s
_SFLFlow_sample	.\lib\sflow.h	/^typedef struct _SFLFlow_sample {$/;"	s
_SFLFlow_sample_element	.\lib\sflow.h	/^typedef struct _SFLFlow_sample_element {$/;"	s
_SFLFlow_sample_expanded	.\lib\sflow.h	/^typedef struct _SFLFlow_sample_expanded {$/;"	s
_SFLFlow_type	.\lib\sflow.h	/^typedef union _SFLFlow_type {$/;"	u
_SFLIf_counters	.\lib\sflow.h	/^typedef struct _SFLIf_counters {$/;"	s
_SFLLabelStack	.\lib\sflow.h	/^typedef struct _SFLLabelStack {$/;"	s
_SFLPoller	.\lib\sflow_api.h	/^typedef struct _SFLPoller {$/;"	s
_SFLReceiver	.\lib\sflow_api.h	/^typedef struct _SFLReceiver {$/;"	s
_SFLSampleCollector	.\lib\sflow_api.h	/^typedef struct _SFLSampleCollector {$/;"	s
_SFLSample_datagram_hdr	.\lib\sflow.h	/^typedef struct _SFLSample_datagram_hdr {$/;"	s
_SFLSampled_ethernet	.\lib\sflow.h	/^typedef struct _SFLSampled_ethernet {$/;"	s
_SFLSampled_header	.\lib\sflow.h	/^typedef struct _SFLSampled_header {$/;"	s
_SFLSampled_ipv4	.\lib\sflow.h	/^typedef struct _SFLSampled_ipv4 {$/;"	s
_SFLSampled_ipv6	.\lib\sflow.h	/^typedef struct _SFLSampled_ipv6 {$/;"	s
_SFLSampler	.\lib\sflow_api.h	/^typedef struct _SFLSampler {$/;"	s
_SFLString	.\lib\sflow.h	/^typedef struct _SFLString {$/;"	s
_SFLTokenring_counters	.\lib\sflow.h	/^typedef struct _SFLTokenring_counters {$/;"	s
_SFLVg_counters	.\lib\sflow.h	/^typedef struct _SFLVg_counters {$/;"	s
_SFLVlan_counters	.\lib\sflow.h	/^typedef struct _SFLVlan_counters {$/;"	s
_SOCKET_METHODS	.\python\ovs\stream.py	/^    _SOCKET_METHODS = {}$/;"	v	class:Stream
_Section	.\python\compat\argparse.py	/^    class _Section(object):$/;"	c	class:HelpFormatter
_SelectSelect	.\python\ovs\poller.py	/^class _SelectSelect(object):$/;"	c
_Serializer	.\python\ovs\json.py	/^class _Serializer(object):$/;"	c
_StoreAction	.\python\compat\argparse.py	/^class _StoreAction(Action):$/;"	c
_StoreConstAction	.\python\compat\argparse.py	/^class _StoreConstAction(Action):$/;"	c
_StoreFalseAction	.\python\compat\argparse.py	/^class _StoreFalseAction(_StoreConstAction):$/;"	c
_StoreTrueAction	.\python\compat\argparse.py	/^class _StoreTrueAction(_StoreConstAction):$/;"	c
_SubParsersAction	.\python\compat\argparse.py	/^class _SubParsersAction(Action):$/;"	c
_TUNNEL_ATTRS	.\xenserver\opt_xensource_libexec_InterfaceReconfigure.py	/^_TUNNEL_ATTRS = { 'uuid': (_str_to_xml,_str_from_xml),$/;"	v
_TUNNEL_XML_TAG	.\xenserver\opt_xensource_libexec_InterfaceReconfigure.py	/^_TUNNEL_XML_TAG = "tunnel"$/;"	v
_UNISTD_H	.\include\windows\unistd.h	17;"	d
_UNRECOGNIZED_ARGS_ATTR	.\python\compat\argparse.py	/^_UNRECOGNIZED_ARGS_ATTR = '_unrecognized_args'$/;"	v
_UnixctlCommand	.\python\ovs\unixctl\__init__.py	/^class _UnixctlCommand(object):$/;"	c
_UuidCreate	.\python\compat\uuid.py	/^    _UuidCreate = getattr(lib, 'UuidCreateSequential',$/;"	v
_VLAN_ATTRS	.\xenserver\opt_xensource_libexec_InterfaceReconfigure.py	/^_VLAN_ATTRS = { 'uuid': (_str_to_xml,_str_from_xml),$/;"	v
_VLAN_XML_TAG	.\xenserver\opt_xensource_libexec_InterfaceReconfigure.py	/^_VLAN_XML_TAG = "vlan"$/;"	v
_VersionAction	.\python\compat\argparse.py	/^class _VersionAction(Action):$/;"	c
__4hex_re	.\python\ovs\json.py	/^    __4hex_re = re.compile("[0-9a-fA-F]{4}")$/;"	v	class:Parser
__ARG_PLACEHOLDER_1	.\datapath\linux\compat\include\linux\kconfig.h	29;"	d
__ARRAY_CHECK	.\lib\util.h	95;"	d
__ARRAY_FAIL	.\lib\util.h	99;"	d
__ARRAY_SIZE	.\lib\util.h	100;"	d
__ARRAY_SIZE	.\lib\util.h	104;"	d
__ARRAY_SIZE_NOCHECK	.\lib\util.h	92;"	d
__ASM_PERCPU_WRAPPER_H	.\datapath\linux\compat\include\asm\percpu.h	2;"	d
__CHECK_ENDIAN__	.\include\linux\types.h	34;"	d
__CMSG_ALIGNTO	.\include\sparse\sys\socket.h	58;"	d
__CTRL_ATTR_MAX	.\lib\netlink-protocol.h	/^        __CTRL_ATTR_MAX,$/;"	e	enum:__anon63
__CTRL_ATTR_MCAST_GRP_MAX	.\lib\netlink-protocol.h	/^    __CTRL_ATTR_MCAST_GRP_MAX,$/;"	e	enum:__anon65
__CTRL_ATTR_OP_MAX	.\lib\netlink-protocol.h	/^        __CTRL_ATTR_OP_MAX,$/;"	e	enum:__anon64
__CTRL_CMD_MAX	.\lib\netlink-protocol.h	/^        __CTRL_CMD_MAX,$/;"	e	enum:__anon62
__KERNEL_H_WRAPPER	.\datapath\linux\compat\include\linux\kernel.h	2;"	d
__LINUX_BUG_WRAPPER_H	.\datapath\linux\compat\include\linux\bug.h	2;"	d
__LINUX_COMPILER_WRAPPER_H	.\datapath\linux\compat\include\linux\compiler.h	2;"	d
__LINUX_CPUMASK_WRAPPER_H	.\datapath\linux\compat\include\linux\cpumask.h	2;"	d
__LINUX_ERR_WRAPPER_H	.\datapath\linux\compat\include\linux\err.h	2;"	d
__LINUX_ETHERDEVICE_WRAPPER_H	.\datapath\linux\compat\include\linux\etherdevice.h	2;"	d
__LINUX_FLEX_ARRAY_WRAPPER_H	.\datapath\linux\compat\include\linux\flex_array.h	2;"	d
__LINUX_GRE_WRAPPER_H	.\datapath\linux\compat\include\net\gre.h	2;"	d
__LINUX_GSO_WRAPPER_H	.\datapath\linux\compat\gso.h	2;"	d
__LINUX_ICMPV6_WRAPPER_H	.\datapath\linux\compat\include\linux\icmpv6.h	2;"	d
__LINUX_ICMP_WRAPPER_H	.\datapath\linux\compat\include\linux\icmp.h	2;"	d
__LINUX_IF_ARP_WRAPPER_H	.\datapath\linux\compat\include\linux\if_arp.h	2;"	d
__LINUX_IF_ETHER_WRAPPER_H	.\datapath\linux\compat\include\linux\if_ether.h	2;"	d
__LINUX_IF_VLAN_WRAPPER_H	.\datapath\linux\compat\include\linux\if_vlan.h	2;"	d
__LINUX_IF_WRAPPER_H	.\datapath\linux\compat\include\linux\if.h	2;"	d
__LINUX_IN_WRAPPER_H	.\datapath\linux\compat\include\linux\in.h	2;"	d
__LINUX_IPV6_WRAPPER_H	.\datapath\linux\compat\include\linux\ipv6.h	2;"	d
__LINUX_IP_WRAPPER_H	.\datapath\linux\compat\include\linux\ip.h	2;"	d
__LINUX_JIFFIES_WRAPPER_H	.\datapath\linux\compat\include\linux\jiffies.h	2;"	d
__LINUX_KCONFIG_WRAPPER_H	.\datapath\linux\compat\include\linux\kconfig.h	2;"	d
__LINUX_LIST_WRAPPER_H	.\datapath\linux\compat\include\linux\list.h	2;"	d
__LINUX_LOG2_WRAPPER	.\datapath\linux\compat\include\linux\log2.h	2;"	d
__LINUX_NETDEVICE_WRAPPER_H	.\datapath\linux\compat\include\linux\netdevice.h	2;"	d
__LINUX_NETDEV_FEATURES_WRAPPER_H	.\datapath\linux\compat\include\linux\netdev_features.h	2;"	d
__LINUX_NETLINK_WRAPPER_H	.\datapath\linux\compat\include\linux\netlink.h	2;"	d
__LINUX_NET_WRAPPER_H	.\datapath\linux\compat\include\linux\net.h	2;"	d
__LINUX_POISON_WRAPPER_H	.\datapath\linux\compat\include\linux\poison.h	2;"	d
__LINUX_RANDOM_WRAPPER_H	.\datapath\linux\compat\include\linux\random.h	2;"	d
__LINUX_RCULIST_WRAPPER_H	.\datapath\linux\compat\include\linux\rculist.h	2;"	d
__LINUX_SCTP_WRAPPER_H	.\datapath\linux\compat\include\linux\sctp.h	2;"	d
__LINUX_SKBUFF_WRAPPER_H	.\datapath\linux\compat\include\linux\skbuff.h	2;"	d
__LINUX_STDDEF_WRAPPER_H	.\datapath\linux\compat\include\linux\stddef.h	2;"	d
__LINUX_TCP_WRAPPER_H	.\datapath\linux\compat\include\linux\tcp.h	2;"	d
__LINUX_TYPES_WRAPPER_H	.\datapath\linux\compat\include\linux\types.h	2;"	d
__LINUX_UDP_WRAPPER_H	.\datapath\linux\compat\include\linux\udp.h	2;"	d
__LINUX_WORKQUEUE_WRAPPER_H	.\datapath\linux\compat\include\linux\workqueue.h	2;"	d
__NETINET_IN_SPARSE	.\include\sparse\netinet\in.h	22;"	d
__NETINET_IP6_SPARSE	.\include\sparse\netinet\ip6.h	22;"	d
__NETINET_IP_H	.\include\windows\netinet\ip.h	18;"	d
__NETPACKET_PACKET_SPARSE	.\include\sparse\netpacket\packet.h	22;"	d
__NET_CHECKSUM_WRAPPER_H	.\datapath\linux\compat\include\net\checksum.h	2;"	d
__NET_DST_WRAPPER_H	.\datapath\linux\compat\include\net\dst.h	2;"	d
__NET_GENERIC_NETLINK_WRAPPER_H	.\datapath\linux\compat\include\net\genetlink.h	2;"	d
__NET_IF_H	.\include\windows\net\if.h	18;"	d
__NET_INET_FRAG_WRAPPER_H	.\datapath\linux\compat\include\net\inet_frag.h	2;"	d
__NET_IPV6_WRAPPER_H	.\datapath\linux\compat\include\net\ipv6.h	2;"	d
__NET_IP_TUNNELS_WRAPPER_H	.\datapath\linux\compat\include\net\ip_tunnels.h	2;"	d
__NET_IP_WRAPPER_H	.\datapath\linux\compat\include\net\ip.h	2;"	d
__NET_NETLINK_WRAPPER_H	.\datapath\linux\compat\include\net\netlink.h	2;"	d
__NET_NET_NAMESPACE_WRAPPER_H	.\datapath\linux\compat\include\net\net_namespace.h	2;"	d
__NET_SOCK_WRAPPER_H	.\datapath\linux\compat\include\net\sock.h	2;"	d
__NET_VXLAN_WRAPPER_H	.\datapath\linux\compat\include\net\vxlan.h	2;"	d
__OVS_ACTION_ATTR_MAX	.\include\linux\openvswitch.h	/^	__OVS_ACTION_ATTR_MAX$/;"	e	enum:ovs_action_attr
__OVS_DP_ATTR_MAX	.\include\linux\openvswitch.h	/^	__OVS_DP_ATTR_MAX$/;"	e	enum:ovs_datapath_attr
__OVS_FLOW_ATTR_MAX	.\include\linux\openvswitch.h	/^	__OVS_FLOW_ATTR_MAX$/;"	e	enum:ovs_flow_attr
__OVS_FRAG_TYPE_MAX	.\include\linux\openvswitch.h	/^	__OVS_FRAG_TYPE_MAX$/;"	e	enum:ovs_frag_type
__OVS_KEY_ATTR_MAX	.\include\linux\openvswitch.h	/^	__OVS_KEY_ATTR_MAX$/;"	e	enum:ovs_key_attr
__OVS_PACKET_ATTR_MAX	.\include\linux\openvswitch.h	/^	__OVS_PACKET_ATTR_MAX$/;"	e	enum:ovs_packet_attr
__OVS_SAMPLE_ATTR_MAX	.\include\linux\openvswitch.h	/^	__OVS_SAMPLE_ATTR_MAX,$/;"	e	enum:ovs_sample_attr
__OVS_TUNNEL_ATTR_MAX	.\include\linux\openvswitch.h	/^	__OVS_TUNNEL_ATTR_MAX$/;"	e	enum:__anon20
__OVS_TUNNEL_KEY_ATTR_MAX	.\include\linux\openvswitch.h	/^	__OVS_TUNNEL_KEY_ATTR_MAX$/;"	e	enum:ovs_tunnel_key_attr
__OVS_USERSPACE_ATTR_MAX	.\include\linux\openvswitch.h	/^	__OVS_USERSPACE_ATTR_MAX$/;"	e	enum:ovs_userspace_attr
__OVS_VPORT_ATTR_MAX	.\include\linux\openvswitch.h	/^	__OVS_VPORT_ATTR_MAX$/;"	e	enum:ovs_vport_attr
__OVS_VPORT_TYPE_MAX	.\include\linux\openvswitch.h	/^	__OVS_VPORT_TYPE_MAX$/;"	e	enum:ovs_vport_type
__RCUPDATE_WRAPPER_H	.\datapath\linux\compat\include\linux\rcupdate.h	2;"	d
__RTNETLINK_WRAPPER_H	.\datapath\linux\compat\include\linux\rtnetlink.h	2;"	d
__SCTP_CHECKSUM_WRAPPER_H	.\datapath\linux\compat\include\net\sctp\checksum.h	2;"	d
__STATE	.\xenserver\opt_xensource_libexec_InterfaceReconfigure.py	/^    __STATE = {"OPEN":"OPEN",$/;"	v	class:ConfigurationFile
__SYS_MATH_SPARSE	.\include\sparse\math.h	22;"	d
__SYS_SOCKET_H	.\include\windows\sys\socket.h	18;"	d
__SYS_SOCKET_SPARSE	.\include\sparse\sys\socket.h	22;"	d
__SYS_WAIT_SPARSE	.\include\sparse\sys\wait.h	22;"	d
__S_CONNECTED	.\python\ovs\stream.py	/^    __S_CONNECTED = 1$/;"	v	class:Stream
__S_CONNECTING	.\python\ovs\stream.py	/^    __S_CONNECTING = 0$/;"	v	class:Stream
__S_DISCONNECTED	.\python\ovs\stream.py	/^    __S_DISCONNECTED = 2$/;"	v	class:Stream
__UNCONST	.\lib\getopt_long.c	62;"	d	file:
___NET_RANDOM_STATIC_KEY_INIT	.\datapath\linux\compat\include\linux\net.h	36;"	d
___config_enabled	.\datapath\linux\compat\include\linux\kconfig.h	33;"	d
__acquire_handle	.\python\ovstest\rpcserver.py	/^    def __acquire_handle(self, value):$/;"	m	class:TestArena	file:
__all__	.\python\compat\argparse.py	/^__all__ = [$/;"	v
__always_unused	.\datapath\linux\compat\include\linux\compiler-gcc.h	12;"	d
__author__	.\python\compat\uuid.py	/^__author__ = 'Ka-Ping Yee <ping@zesty.ca>'$/;"	v
__be16	.\include\linux\types.h	/^typedef uint16_t __bitwise__ __be16;$/;"	t
__be32	.\include\linux\types.h	/^typedef uint32_t __bitwise__ __be32;$/;"	t
__be64	.\include\linux\types.h	/^typedef uint64_t __bitwise__ __be64;$/;"	t
__bitwise__	.\include\linux\types.h	43;"	d
__bitwise__	.\include\linux\types.h	45;"	d
__build_header	.\datapath\vport-gre.c	/^static struct sk_buff *__build_header(struct sk_buff *skb,$/;"	f	file:
__call__	.\python\compat\argparse.py	/^    def __call__(self, parser, namespace, values, option_string=None):$/;"	m	class:Action	file:
__call__	.\python\compat\argparse.py	/^    def __call__(self, parser, namespace, values, option_string=None):$/;"	m	class:_AppendAction	file:
__call__	.\python\compat\argparse.py	/^    def __call__(self, parser, namespace, values, option_string=None):$/;"	m	class:_AppendConstAction	file:
__call__	.\python\compat\argparse.py	/^    def __call__(self, parser, namespace, values, option_string=None):$/;"	m	class:_CountAction	file:
__call__	.\python\compat\argparse.py	/^    def __call__(self, parser, namespace, values, option_string=None):$/;"	m	class:_HelpAction	file:
__call__	.\python\compat\argparse.py	/^    def __call__(self, parser, namespace, values, option_string=None):$/;"	m	class:_StoreAction	file:
__call__	.\python\compat\argparse.py	/^    def __call__(self, parser, namespace, values, option_string=None):$/;"	m	class:_StoreConstAction	file:
__call__	.\python\compat\argparse.py	/^    def __call__(self, parser, namespace, values, option_string=None):$/;"	m	class:_SubParsersAction	file:
__call__	.\python\compat\argparse.py	/^    def __call__(self, parser, namespace, values, option_string=None):$/;"	m	class:_VersionAction	file:
__call__	.\python\compat\argparse.py	/^    def __call__(self, string):$/;"	m	class:FileType	file:
__call__	.\python\ovstest\args.py	/^    def __call__(self, parser, namespace, values, option_string=None):$/;"	m	class:UniqueServerAction	file:
__check_json_type	.\python\ovs\db\idl.py	/^    def __check_json_type(json, types, name):$/;"	m	class:Transaction	file:
__clear	.\python\ovs\db\idl.py	/^    def __clear(self):$/;"	m	class:Idl	file:
__cmp__	.\python\compat\uuid.py	/^    def __cmp__(self, other):$/;"	m	class:UUID	file:
__cmp__	.\python\ovs\db\data.py	/^    def __cmp__(self, other):$/;"	m	class:Atom	file:
__cmp__	.\python\ovs\db\data.py	/^    def __cmp__(self, other):$/;"	m	class:Datum	file:
__cmsg_nxthdr	.\include\sparse\sys\socket.h	/^__cmsg_nxthdr(struct msghdr *msg, struct cmsghdr *cmsg)$/;"	f
__config_enabled	.\datapath\linux\compat\include\linux\kconfig.h	32;"	d
__connect	.\python\ovs\jsonrpc.py	/^    def __connect(self):$/;"	m	class:Session	file:
__contains__	.\python\compat\argparse.py	/^    def __contains__(self, key):$/;"	m	class:Namespace	file:
__contains__	.\python\ovs\db\data.py	/^    def __contains__(self, item):$/;"	m	class:Datum	file:
__create_bond_device	.\xenserver\opt_xensource_libexec_InterfaceReconfigureBridge.py	/^def __create_bond_device(name):$/;"	f	file:
__create_row	.\python\ovs\db\idl.py	/^    def __create_row(self, table, uuid):$/;"	m	class:Idl	file:
__del__	.\python\ovs\stream.py	/^    def __del__(self):$/;"	m	class:PassiveStream	file:
__del__	.\python\ovs\stream.py	/^    def __del__(self):$/;"	m	class:Stream	file:
__delete_handle	.\python\ovstest\rpcserver.py	/^    def __delete_handle(self, handle):$/;"	m	class:TestArena	file:
__destroy_bond_device	.\xenserver\opt_xensource_libexec_InterfaceReconfigureBridge.py	/^def __destroy_bond_device(name):$/;"	f	file:
__disassemble	.\python\ovs\db\idl.py	/^    def __disassemble(self):$/;"	m	class:Transaction	file:
__disconnect	.\python\ovs\jsonrpc.py	/^    def __disconnect(self):$/;"	m	class:Session	file:
__do_parse_update	.\python\ovs\db\idl.py	/^    def __do_parse_update(self, table_updates):$/;"	m	class:Idl	file:
__do_send_lock_request	.\python\ovs\db\idl.py	/^    def __do_send_lock_request(self, method):$/;"	m	class:Idl	file:
__dp_destroy	.\datapath\datapath.c	/^static void __dp_destroy(struct datapath *dp)$/;"	f	file:
__eq__	.\python\compat\argparse.py	/^    def __eq__(self, other):$/;"	m	class:Namespace	file:
__eq__	.\python\ovs\db\types.py	/^    def __eq__(self, other):$/;"	m	class:BaseType	file:
__eq__	.\python\ovs\db\types.py	/^    def __eq__(self, other):$/;"	m	class:Type	file:
__error	.\python\ovs\db\idl.py	/^    def __error(self):$/;"	m	class:Idl	file:
__error	.\python\ovs\json.py	/^    def __error(self, message):$/;"	m	class:Parser	file:
__fa_get_part	.\datapath\linux\compat\flex_array.c	/^__fa_get_part(struct flex_array *fa, int part_nr, gfp_t flags)$/;"	f	file:
__file_handler	.\python\ovs\vlog.py	/^    __file_handler = None$/;"	v	class:Vlog
__flow_hash_3words	.\datapath\linux\compat\flow_dissector.c	/^static __always_inline u32 __flow_hash_3words(u32 a, u32 b, u32 c)$/;"	f	file:
__flow_hash_secret_init	.\datapath\linux\compat\flow_dissector.c	/^static __always_inline void __flow_hash_secret_init(void)$/;"	f	file:
__follow_ref_table	.\python\ovs\db\schema.py	/^    def __follow_ref_table(self, column, base, base_name):$/;"	m	class:DbSchema	file:
__from_xml	.\xenserver\opt_xensource_libexec_InterfaceReconfigure.py	/^    def __from_xml(self, e, attrs):$/;"	m	class:DatabaseCache	file:
__func__	.\include\windows\windefs.h	31;"	d
__genl_register_family	.\datapath\linux\compat\include\net\genetlink.h	87;"	d
__get	.\python\ovs\db\parser.py	/^    def __get(self, name, types, optional, default=None):$/;"	m	class:Parser	file:
__get_bond_records_from_xapi	.\xenserver\opt_xensource_libexec_InterfaceReconfigure.py	/^    def __get_bond_records_from_xapi(self, session):$/;"	m	class:DatabaseCache	file:
__get_handle_resources	.\python\ovstest\rpcserver.py	/^    def __get_handle_resources(self, handle):$/;"	m	class:TestArena	file:
__get_network_records_from_xapi	.\xenserver\opt_xensource_libexec_InterfaceReconfigure.py	/^    def __get_network_records_from_xapi(self, session):$/;"	m	class:DatabaseCache	file:
__get_pif_records_from_xapi	.\xenserver\opt_xensource_libexec_InterfaceReconfigure.py	/^    def __get_pif_records_from_xapi(self, session, host):$/;"	m	class:DatabaseCache	file:
__get_pool_records_from_xapi	.\xenserver\opt_xensource_libexec_InterfaceReconfigure.py	/^    def __get_pool_records_from_xapi(self, session):$/;"	m	class:DatabaseCache	file:
__get_tunnel_records_from_xapi	.\xenserver\opt_xensource_libexec_InterfaceReconfigure.py	/^    def __get_tunnel_records_from_xapi(self, session):$/;"	m	class:DatabaseCache	file:
__get_vlan_records_from_xapi	.\xenserver\opt_xensource_libexec_InterfaceReconfigure.py	/^    def __get_vlan_records_from_xapi(self, session):$/;"	m	class:DatabaseCache	file:
__getattr__	.\python\ovs\db\idl.py	/^    def __getattr__(self, column_name):$/;"	m	class:Row	file:
__getitem__	.\python\ovs\db\data.py	/^    def __getitem__(self, key):$/;"	m	class:Datum	file:
__has_extension	.\lib\compiler.h	24;"	d
__has_feature	.\lib\compiler.h	21;"	d
__hash__	.\python\compat\argparse.py	/^    __hash__ = None$/;"	v	class:Namespace
__hash__	.\python\compat\uuid.py	/^    def __hash__(self):$/;"	m	class:UUID	file:
__hash__	.\python\ovs\db\data.py	/^    __hash__ = None$/;"	v	class:Datum
__hash__	.\python\ovs\db\data.py	/^    def __hash__(self):$/;"	m	class:Atom	file:
__indent_line	.\python\ovs\json.py	/^    def __indent_line(self):$/;"	m	class:_Serializer	file:
__init__	.\python\compat\argparse.py	/^        def __init__(self, formatter, parent, heading=None):$/;"	m	class:HelpFormatter._Section
__init__	.\python\compat\argparse.py	/^        def __init__(self, name, help):$/;"	m	class:_SubParsersAction._ChoicesPseudoAction
__init__	.\python\compat\argparse.py	/^    def __init__(self, **kwargs):$/;"	m	class:Namespace
__init__	.\python\compat\argparse.py	/^    def __init__(self, argument, message):$/;"	m	class:ArgumentError
__init__	.\python\compat\argparse.py	/^    def __init__(self, container, required=False):$/;"	m	class:_MutuallyExclusiveGroup
__init__	.\python\compat\argparse.py	/^    def __init__(self, container, title=None, description=None, **kwargs):$/;"	m	class:_ArgumentGroup
__init__	.\python\compat\argparse.py	/^    def __init__(self, mode='r', bufsize=-1):$/;"	m	class:FileType
__init__	.\python\compat\argparse.py	/^    def __init__(self,$/;"	m	class:Action
__init__	.\python\compat\argparse.py	/^    def __init__(self,$/;"	m	class:ArgumentParser
__init__	.\python\compat\argparse.py	/^    def __init__(self,$/;"	m	class:HelpFormatter
__init__	.\python\compat\argparse.py	/^    def __init__(self,$/;"	m	class:_ActionsContainer
__init__	.\python\compat\argparse.py	/^    def __init__(self,$/;"	m	class:_AppendAction
__init__	.\python\compat\argparse.py	/^    def __init__(self,$/;"	m	class:_AppendConstAction
__init__	.\python\compat\argparse.py	/^    def __init__(self,$/;"	m	class:_CountAction
__init__	.\python\compat\argparse.py	/^    def __init__(self,$/;"	m	class:_HelpAction
__init__	.\python\compat\argparse.py	/^    def __init__(self,$/;"	m	class:_StoreAction
__init__	.\python\compat\argparse.py	/^    def __init__(self,$/;"	m	class:_StoreConstAction
__init__	.\python\compat\argparse.py	/^    def __init__(self,$/;"	m	class:_StoreFalseAction
__init__	.\python\compat\argparse.py	/^    def __init__(self,$/;"	m	class:_StoreTrueAction
__init__	.\python\compat\argparse.py	/^    def __init__(self,$/;"	m	class:_SubParsersAction
__init__	.\python\compat\argparse.py	/^    def __init__(self,$/;"	m	class:_VersionAction
__init__	.\python\compat\uuid.py	/^    def __init__(self, hex=None, bytes=None, bytes_le=None, fields=None,$/;"	m	class:UUID
__init__	.\python\ovs\db\data.py	/^    def __init__(self, msg, json=None):$/;"	m	class:ConstraintViolation
__init__	.\python\ovs\db\data.py	/^    def __init__(self, type_, value=None):$/;"	m	class:Atom
__init__	.\python\ovs\db\data.py	/^    def __init__(self, type_, values={}):$/;"	m	class:Datum
__init__	.\python\ovs\db\error.py	/^    def __init__(self, msg, json=None, tag=None):$/;"	m	class:Error
__init__	.\python\ovs\db\idl.py	/^    def __init__(self, idl):$/;"	m	class:Transaction
__init__	.\python\ovs\db\idl.py	/^    def __init__(self, idl, table, uuid, data):$/;"	m	class:Row
__init__	.\python\ovs\db\idl.py	/^    def __init__(self, location=None, schema_json=None):$/;"	m	class:SchemaHelper
__init__	.\python\ovs\db\idl.py	/^    def __init__(self, op_index):$/;"	m	class:_InsertedRow
__init__	.\python\ovs\db\idl.py	/^    def __init__(self, remote, schema):$/;"	m	class:Idl
__init__	.\python\ovs\db\parser.py	/^    def __init__(self, json, name):$/;"	m	class:Parser
__init__	.\python\ovs\db\schema.py	/^    def __init__(self, name, columns, mutable=True, max_rows=sys.maxint,$/;"	m	class:TableSchema
__init__	.\python\ovs\db\schema.py	/^    def __init__(self, name, mutable, persistent, type_):$/;"	m	class:ColumnSchema
__init__	.\python\ovs\db\schema.py	/^    def __init__(self, name, version, tables):$/;"	m	class:DbSchema
__init__	.\python\ovs\db\schema.py	/^    def __init__(self, name, version, tables, idlPrefix, idlHeader):$/;"	m	class:IdlSchema
__init__	.\python\ovs\db\types.py	/^    def __init__(self, key, value=None, n_min=DEFAULT_MIN, n_max=DEFAULT_MAX):$/;"	m	class:Type
__init__	.\python\ovs\db\types.py	/^    def __init__(self, name, default, python_types):$/;"	m	class:AtomicType
__init__	.\python\ovs\db\types.py	/^    def __init__(self, type_, enum=None, min=None, max=None,$/;"	m	class:BaseType
__init__	.\python\ovs\json.py	/^    def __init__(self, check_trailer=False):$/;"	m	class:Parser
__init__	.\python\ovs\json.py	/^    def __init__(self, stream, pretty, sort_keys):$/;"	m	class:_Serializer
__init__	.\python\ovs\jsonrpc.py	/^    def __init__(self, reconnect, rpc):$/;"	m	class:Session
__init__	.\python\ovs\jsonrpc.py	/^    def __init__(self, stream):$/;"	m	class:Connection
__init__	.\python\ovs\jsonrpc.py	/^    def __init__(self, type_, method, params, result, error, id):$/;"	m	class:Message
__init__	.\python\ovs\poller.py	/^    def __init__(self):$/;"	m	class:Poller
__init__	.\python\ovs\poller.py	/^    def __init__(self):$/;"	m	class:_SelectSelect
__init__	.\python\ovs\reconnect.py	/^    def __init__(self, now):$/;"	m	class:Reconnect
__init__	.\python\ovs\stream.py	/^    def __init__(self, sock, name, bind_path):$/;"	m	class:PassiveStream
__init__	.\python\ovs\stream.py	/^    def __init__(self, socket, name, status):$/;"	m	class:Stream
__init__	.\python\ovs\unixctl\__init__.py	/^    def __init__(self, usage, min_args, max_args, callback, aux):$/;"	m	class:_UnixctlCommand
__init__	.\python\ovs\unixctl\client.py	/^    def __init__(self, conn):$/;"	m	class:UnixctlClient
__init__	.\python\ovs\unixctl\server.py	/^    def __init__(self, conn):$/;"	m	class:UnixctlClient
__init__	.\python\ovs\unixctl\server.py	/^    def __init__(self, listener):$/;"	m	class:UnixctlServer
__init__	.\python\ovs\unixctl\server.py	/^    def __init__(self, rpc):$/;"	m	class:UnixctlConnection
__init__	.\python\ovs\vlog.py	/^    def __init__(self, name):$/;"	m	class:Vlog
__init__	.\python\ovstest\rpcserver.py	/^    def __init__(self):$/;"	m	class:TestArena
__init__	.\python\ovstest\tcp.py	/^    def __init__(self):$/;"	m	class:TcpListenerConnection
__init__	.\python\ovstest\tcp.py	/^    def __init__(self):$/;"	m	class:TcpListenerFactory
__init__	.\python\ovstest\tcp.py	/^    def __init__(self, duration):$/;"	m	class:TcpSenderFactory
__init__	.\python\ovstest\tcp.py	/^    def __init__(self, proto, duration):$/;"	m	class:Producer
__init__	.\python\ovstest\udp.py	/^    def __init__(self):$/;"	m	class:UdpListener
__init__	.\python\ovstest\udp.py	/^    def __init__(self, host, count, size, duration):$/;"	m	class:UdpSender
__init__	.\tests\MockXenAPI.py	/^    def __init__(self):$/;"	m	class:Network
__init__	.\tests\MockXenAPI.py	/^    def __init__(self):$/;"	m	class:Pool
__init__	.\tests\MockXenAPI.py	/^    def __init__(self):$/;"	m	class:Session
__init__	.\tests\MockXenAPI.py	/^    def __init__(self):$/;"	m	class:VIF
__init__	.\tests\MockXenAPI.py	/^    def __init__(self):$/;"	m	class:VM
__init__	.\tests\MockXenAPI.py	/^    def __init__(self):$/;"	m	class:XenAPI
__init__	.\tests\MockXenAPI.py	/^    def __init__(self, attrs):$/;"	m	class:RecordRef
__init__	.\tests\MockXenAPI.py	/^    def __init__(self, records):$/;"	m	class:Table
__init__	.\xenserver\opt_xensource_libexec_InterfaceReconfigure.py	/^    def __init__(self, msg):$/;"	m	class:Error
__init__	.\xenserver\opt_xensource_libexec_InterfaceReconfigure.py	/^    def __init__(self, path):$/;"	m	class:ConfigurationFile
__init__	.\xenserver\opt_xensource_libexec_InterfaceReconfigure.py	/^    def __init__(self, pif):$/;"	m	class:Datapath
__init__	.\xenserver\opt_xensource_libexec_InterfaceReconfigure.py	/^    def __init__(self, session_ref=None, cache_file=None):$/;"	m	class:DatabaseCache
__init__	.\xenserver\opt_xensource_libexec_InterfaceReconfigureBridge.py	/^    def __init__(self, pif):$/;"	m	class:DatapathBridge
__init__	.\xenserver\opt_xensource_libexec_InterfaceReconfigureVswitch.py	/^    def __init__(self, pif):$/;"	m	class:DatapathVswitch
__init__	.\xenserver\usr_lib_xsconsole_plugins-base_XSFeatureVSwitch.py	/^    def __init__(self):$/;"	m	class:VSwitchControllerDialogue
__init__	.\xenserver\usr_lib_xsconsole_plugins-base_XSFeatureVSwitch.py	/^    def __init__(self, name, processname=None):$/;"	m	class:VSwitchService
__inited	.\python\ovs\vlog.py	/^    __inited = False$/;"	v	class:Vlog
__int__	.\python\compat\uuid.py	/^    def __int__(self):$/;"	m	class:UUID	file:
__is_enabled	.\python\ovs\vlog.py	/^    def __is_enabled(self, level):$/;"	m	class:Vlog	file:
__is_leading_surrogate	.\python\ovs\json.py	/^    def __is_leading_surrogate(c):$/;"	m	class:Parser	file:
__is_trailing_surrogate	.\python\ovs\json.py	/^    def __is_trailing_surrogate(c):$/;"	m	class:Parser	file:
__lex_4hex	.\python\ovs\json.py	/^    def __lex_4hex(self, s):$/;"	m	class:Parser	file:
__lex_alpha	.\python\ovs\json.py	/^    __lex_alpha = {}$/;"	v	class:Parser
__lex_finish_keyword	.\python\ovs\json.py	/^    def __lex_finish_keyword(self):$/;"	m	class:Parser	file:
__lex_finish_number	.\python\ovs\json.py	/^    def __lex_finish_number(self):$/;"	m	class:Parser	file:
__lex_finish_string	.\python\ovs\json.py	/^    def __lex_finish_string(self):$/;"	m	class:Parser	file:
__lex_input	.\python\ovs\json.py	/^    def __lex_input(self, c):$/;"	m	class:Parser	file:
__lex_keyword	.\python\ovs\json.py	/^    def __lex_keyword(self, c):$/;"	m	class:Parser	file:
__lex_number	.\python\ovs\json.py	/^    def __lex_number(self, c):$/;"	m	class:Parser	file:
__lex_start	.\python\ovs\json.py	/^    def __lex_start(self, c):$/;"	m	class:Parser	file:
__lex_start_actions	.\python\ovs\json.py	/^    __lex_start_actions = {}$/;"	v	class:Parser
__lex_start_alpha	.\python\ovs\json.py	/^    def __lex_start_alpha(self, c):$/;"	m	class:Parser	file:
__lex_start_error	.\python\ovs\json.py	/^    def __lex_start_error(self, c):$/;"	m	class:Parser	file:
__lex_start_number	.\python\ovs\json.py	/^    def __lex_start_number(self, c):$/;"	m	class:Parser	file:
__lex_start_space	.\python\ovs\json.py	/^    def __lex_start_space(self, c):$/;"	m	class:Parser	file:
__lex_start_string	.\python\ovs\json.py	/^    def __lex_start_string(self, _):$/;"	m	class:Parser	file:
__lex_start_token	.\python\ovs\json.py	/^    def __lex_start_token(self, c):$/;"	m	class:Parser	file:
__lex_string	.\python\ovs\json.py	/^    def __lex_string(self, c):$/;"	m	class:Parser	file:
__lex_string_escape	.\python\ovs\json.py	/^    def __lex_string_escape(self, c):$/;"	m	class:Parser	file:
__log	.\python\ovs\vlog.py	/^    def __log(self, level, message, **kwargs):$/;"	m	class:Vlog	file:
__log_file	.\python\ovs\vlog.py	/^    __log_file = None$/;"	v	class:Vlog
__log_msg	.\python\ovs\jsonrpc.py	/^    def __log_msg(self, title, msg):$/;"	m	class:Connection	file:
__log_patterns	.\python\ovs\vlog.py	/^    __log_patterns = PATTERNS$/;"	v	class:Vlog
__log_wakeup	.\python\ovs\poller.py	/^    def __log_wakeup(self, events):$/;"	m	class:Poller	file:
__may_retry	.\python\ovs\reconnect.py	/^    def __may_retry(self):$/;"	m	class:Reconnect	file:
__mfl	.\python\ovs\vlog.py	/^    __mfl = {}  # Module -> facility -> level$/;"	v	class:Vlog
__msg_num	.\python\ovs\vlog.py	/^    __msg_num = 0$/;"	v	class:Vlog
__n_from_json	.\python\ovs\db\types.py	/^    def __n_from_json(json, default):$/;"	m	class:Type	file:
__ne__	.\python\compat\argparse.py	/^    def __ne__(self, other):$/;"	m	class:Namespace	file:
__ne__	.\python\ovs\db\types.py	/^    def __ne__(self, other):$/;"	m	class:BaseType	file:
__ne__	.\python\ovs\db\types.py	/^    def __ne__(self, other):$/;"	m	class:Type	file:
__need_quotes_re	.\python\ovs\db\data.py	/^    __need_quotes_re = re.compile("$|true|false|[^_a-zA-Z]|.*[^-._a-zA-Z]")$/;"	v	class:Atom
__net_get_random_once	.\datapath\linux\compat\utils.c	/^bool __net_get_random_once(void *buf, int nbytes, bool *done,$/;"	f
__number_re	.\python\ovs\json.py	/^    __number_re = re.compile("(-)?(0|[1-9][0-9]*)"$/;"	v	class:Parser
__packed	.\datapath\flow.h	/^} __packed;$/;"	v	typeref:struct:arp_eth_header
__packed	.\datapath\linux\compat\include\linux\compiler-gcc.h	8;"	d
__parse_array_init	.\python\ovs\json.py	/^    def __parse_array_init(self, token, string):$/;"	m	class:Parser	file:
__parse_array_next	.\python\ovs\json.py	/^    def __parse_array_next(self, token, unused_string):$/;"	m	class:Parser	file:
__parse_array_value	.\python\ovs\json.py	/^    def __parse_array_value(self, token, string):$/;"	m	class:Parser	file:
__parse_end	.\python\ovs\json.py	/^    def __parse_end(self, unused_token, unused_string):$/;"	m	class:Parser	file:
__parse_flow_nlattrs	.\datapath\flow_netlink.c	/^static int __parse_flow_nlattrs(const struct nlattr *attr,$/;"	f	file:
__parse_lock_notify	.\python\ovs\db\idl.py	/^    def __parse_lock_notify(self, params, new_has_lock):$/;"	m	class:Idl	file:
__parse_lock_reply	.\python\ovs\db\idl.py	/^    def __parse_lock_reply(self, result):$/;"	m	class:Idl	file:
__parse_object_colon	.\python\ovs\json.py	/^    def __parse_object_colon(self, token, unused_string):$/;"	m	class:Parser	file:
__parse_object_init	.\python\ovs\json.py	/^    def __parse_object_init(self, token, string):$/;"	m	class:Parser	file:
__parse_object_name	.\python\ovs\json.py	/^    def __parse_object_name(self, token, string):$/;"	m	class:Parser	file:
__parse_object_next	.\python\ovs\json.py	/^    def __parse_object_next(self, token, unused_string):$/;"	m	class:Parser	file:
__parse_object_value	.\python\ovs\json.py	/^    def __parse_object_value(self, token, string):$/;"	m	class:Parser	file:
__parse_start	.\python\ovs\json.py	/^    def __parse_start(self, token, unused_string):$/;"	m	class:Parser	file:
__parse_uint	.\python\ovs\db\types.py	/^    def __parse_uint(parser, name, default):$/;"	m	class:BaseType	file:
__parse_update	.\python\ovs\db\idl.py	/^    def __parse_update(self, update):$/;"	m	class:Idl	file:
__parse_value	.\python\ovs\json.py	/^    def __parse_value(self, token, string, next_state):$/;"	m	class:Parser	file:
__parser_input	.\python\ovs\json.py	/^    def __parser_input(self, token, string=None):$/;"	m	class:Parser	file:
__parser_pop	.\python\ovs\json.py	/^    def __parser_pop(self):$/;"	m	class:Parser	file:
__parser_push	.\python\ovs\json.py	/^    def __parser_push(self, new_json, next_state):$/;"	m	class:Parser	file:
__percpu	.\datapath\linux\compat\include\linux\compiler.h	7;"	d
__pif_on_host	.\xenserver\opt_xensource_libexec_InterfaceReconfigure.py	/^    def __pif_on_host(self,pif):$/;"	m	class:DatabaseCache	file:
__pop_vlan_tci	.\datapath\actions.c	/^static int __pop_vlan_tci(struct sk_buff *skb, __be16 *current_tci)$/;"	f	file:
__process_inc_reply	.\python\ovs\db\idl.py	/^    def __process_inc_reply(self, ops):$/;"	m	class:Transaction	file:
__process_insert_reply	.\python\ovs\db\idl.py	/^    def __process_insert_reply(self, insert, ops):$/;"	m	class:Transaction	file:
__process_msg	.\python\ovs\jsonrpc.py	/^    def __process_msg(self):$/;"	m	class:Connection	file:
__process_update	.\python\ovs\db\idl.py	/^    def __process_update(self, table, uuid, old, new):$/;"	m	class:Idl	file:
__push_array	.\python\ovs\json.py	/^    def __push_array(self):$/;"	m	class:Parser	file:
__push_object	.\python\ovs\json.py	/^    def __push_object(self):$/;"	m	class:Parser	file:
__put_value	.\python\ovs\json.py	/^    def __put_value(self, value):$/;"	m	class:Parser	file:
__pychecker__	.\python\ovs\db\idl.py	/^__pychecker__ = 'no-classattr no-objattrs'$/;"	v
__pychecker__	.\python\ovs\json.py	/^__pychecker__ = 'no-stringiter'$/;"	v
__raise_error	.\python\ovs\db\parser.py	/^    def __raise_error(self, message):$/;"	m	class:Parser	file:
__rcu	.\datapath\linux\compat\include\linux\compiler.h	11;"	d
__read_mostly	.\datapath\datapath.c	/^int ovs_net_id __read_mostly;$/;"	v
__read_mostly	.\datapath\flow_table.c	/^struct kmem_cache *flow_stats_cache __read_mostly;$/;"	v	typeref:struct:flow_stats_cache
__read_mostly	.\datapath\linux\compat\flow_dissector.c	/^static u32 hashrnd __read_mostly;$/;"	v	file:
__read_mostly	.\datapath\linux\compat\gre.c	/^static const struct gre_protocol __rcu *gre_proto[GREPROTO_MAX] __read_mostly;$/;"	v	typeref:struct:gre_proto	file:
__read_mostly	.\datapath\linux\compat\gso.c	/^static int vlan_tso __read_mostly;$/;"	v	file:
__read_mostly	.\datapath\linux\compat\hash.c	/^static bool arch_inited __read_mostly;$/;"	v	file:
__read_mostly	.\datapath\linux\compat\hash.c	/^static struct fast_hash_ops arch_hash_ops __read_mostly = {$/;"	v	typeref:struct:arch_hash_ops	file:
__read_pidfile	.\python\ovs\daemon.py	/^def __read_pidfile(pidfile, delete_if_stale):$/;"	f	file:
__read_xensource_inventory	.\xenserver\opt_xensource_libexec_InterfaceReconfigure.py	/^    def __read_xensource_inventory(self):$/;"	m	class:DatabaseCache	file:
__records	.\tests\MockXenAPI.py	/^    __records = ({"uuid": "6ab1b260-398e-49ba-827b-c7696108964c",$/;"	v	class:VIF
__records	.\tests\MockXenAPI.py	/^    __records = ({"uuid": "7a793edf-e5f4-4994-a0f9-cee784c0cda3",$/;"	v	class:Pool
__records	.\tests\MockXenAPI.py	/^    __records = ({"uuid": "9b66c68b-a74e-4d34-89a5-20a8ab352d1e",$/;"	v	class:Network
__records	.\tests\MockXenAPI.py	/^    __records = ({"uuid": "fcb8a3f6-dc04-41d2-8b8a-55afd2b755b8",$/;"	v	class:VM
__repr__	.\python\compat\argparse.py	/^    def __repr__(self):$/;"	m	class:FileType	file:
__repr__	.\python\compat\argparse.py	/^    def __repr__(self):$/;"	m	class:_AttributeHolder	file:
__repr__	.\python\compat\uuid.py	/^    def __repr__(self):$/;"	m	class:UUID	file:
__reset	.\python\ovs\poller.py	/^    def __reset(self):$/;"	m	class:Poller	file:
__root_set_size	.\python\ovs\db\schema.py	/^    def __root_set_size(self):$/;"	m	class:DbSchema	file:
__row_update	.\python\ovs\db\idl.py	/^    def __row_update(self, table, row, row_json):$/;"	m	class:Idl	file:
__rte_pktmbuf_init	.\lib\netdev-dpdk.c	/^__rte_pktmbuf_init(struct rte_mempool *mp,$/;"	f	file:
__scs_connecting	.\python\ovs\stream.py	/^    def __scs_connecting(self):$/;"	m	class:Stream	file:
__send	.\datapath\vport-gre.c	/^static int __send(struct vport *vport, struct sk_buff *skb,$/;"	f	file:
__send_lock_request	.\python\ovs\db\idl.py	/^    def __send_lock_request(self):$/;"	m	class:Idl	file:
__send_monitor_request	.\python\ovs\db\idl.py	/^    def __send_monitor_request(self):$/;"	m	class:Idl	file:
__send_unlock_request	.\python\ovs\db\idl.py	/^    def __send_unlock_request(self):$/;"	m	class:Idl	file:
__serialize_string	.\python\ovs\json.py	/^    def __serialize_string(self, s):$/;"	m	class:_Serializer	file:
__set_error_json	.\python\ovs\db\idl.py	/^    def __set_error_json(self, json):$/;"	m	class:Transaction	file:
__setattr__	.\python\compat\uuid.py	/^    def __setattr__(self, name, value):$/;"	m	class:UUID	file:
__setattr__	.\python\ovs\db\idl.py	/^    def __setattr__(self, column_name, value):$/;"	m	class:Row	file:
__sk_user_data	.\datapath\linux\compat\include\net\sock.h	7;"	d
__skb_cow	.\datapath\linux\compat\include\linux\skbuff.h	/^static inline int __skb_cow(struct sk_buff *skb, unsigned int headroom,$/;"	f
__skb_fill_page_desc	.\datapath\linux\compat\include\linux\skbuff.h	/^static inline void __skb_fill_page_desc(struct sk_buff *skb, int i,$/;"	f
__skb_frag_ref	.\datapath\linux\compat\include\linux\skbuff.h	/^static inline void __skb_frag_ref(skb_frag_t *frag)$/;"	f
__skb_frag_set_page	.\datapath\linux\compat\include\linux\skbuff.h	/^static inline void __skb_frag_set_page(skb_frag_t *frag, struct page *page)$/;"	f
__skb_frag_unref	.\datapath\linux\compat\include\linux\skbuff.h	/^static inline void __skb_frag_unref(skb_frag_t *frag)$/;"	f
__skb_get_hash	.\datapath\linux\compat\flow_dissector.c	/^u32 __skb_get_hash(struct sk_buff *skb)$/;"	f
__skb_get_hash	.\datapath\linux\compat\include\linux\skbuff.h	256;"	d
__skb_gso_segment	.\datapath\linux\compat\include\linux\netdevice.h	/^static inline struct sk_buff *__skb_gso_segment(struct sk_buff *skb,$/;"	f
__skb_network_protocol	.\datapath\linux\compat\gso.c	/^static __be16 __skb_network_protocol(struct sk_buff *skb)$/;"	f	file:
__skb_warn_lro_forwarding	.\datapath\linux\compat\skbuff-openvswitch.c	/^void __skb_warn_lro_forwarding(const struct sk_buff *skb)$/;"	f
__start_time	.\python\ovs\vlog.py	/^    __start_time = 0$/;"	v	class:Vlog
__str__	.\python\compat\argparse.py	/^    def __str__(self):$/;"	m	class:ArgumentError	file:
__str__	.\python\compat\uuid.py	/^    def __str__(self):$/;"	m	class:UUID	file:
__str__	.\python\ovs\db\data.py	/^    def __str__(self):$/;"	m	class:Datum	file:
__str__	.\python\ovs\db\types.py	/^    def __str__(self):$/;"	m	class:AtomicType	file:
__str__	.\python\ovs\jsonrpc.py	/^    def __str__(self):$/;"	m	class:Message	file:
__string_needs_quotes	.\python\ovs\db\data.py	/^    def __string_needs_quotes(s):$/;"	m	class:Atom	file:
__sum16	.\datapath\linux\compat\include\linux\types.h	/^typedef __u16 __bitwise __sum16;$/;"	t
__table_instance_destroy	.\datapath\flow_table.c	/^static void __table_instance_destroy(struct table_instance *ti)$/;"	f	file:
__timer_wait	.\python\ovs\poller.py	/^    def __timer_wait(self, msec):$/;"	m	class:Poller	file:
__to_xml	.\xenserver\opt_xensource_libexec_InterfaceReconfigure.py	/^    def __to_xml(self, xml, parent, key, ref, rec, attrs):$/;"	m	class:DatabaseCache	file:
__txn_abort_all	.\python\ovs\db\idl.py	/^    def __txn_abort_all(self):$/;"	m	class:Idl	file:
__txn_process_reply	.\python\ovs\db\idl.py	/^    def __txn_process_reply(self, msg):$/;"	m	class:Idl	file:
__types	.\python\ovs\jsonrpc.py	/^    __types = {T_REQUEST: "request",$/;"	v	class:Message
__u16	.\include\linux\types.h	/^typedef uint16_t __u16;$/;"	t
__u32	.\include\linux\types.h	/^typedef uint32_t __u32;$/;"	t
__u64	.\include\linux\types.h	/^typedef uint64_t __u64;$/;"	t
__u8	.\include\linux\types.h	/^typedef uint8_t  __u8;$/;"	t
__unescape	.\python\ovs\json.py	/^    __unescape = {'"': u'"',$/;"	v	class:Parser
__update_has_lock	.\python\ovs\db\idl.py	/^    def __update_has_lock(self, new_has_lock):$/;"	m	class:Idl	file:
__utf16_decode_surrogate_pair	.\python\ovs\json.py	/^    def __utf16_decode_surrogate_pair(leading, trailing):$/;"	m	class:Parser	file:
__validate_arg	.\python\ovs\jsonrpc.py	/^    def __validate_arg(self, value, name, must_have):$/;"	m	class:Message	file:
__version__	.\python\compat\argparse.py	/^__version__ = '1.1'$/;"	v
__vlan_hwaccel_put_tag	.\datapath\linux\compat\include\linux\if_vlan.h	57;"	d
__vlan_put_tag	.\datapath\linux\compat\include\linux\if_vlan.h	23;"	d
__wsum	.\datapath\linux\compat\include\linux\types.h	/^typedef __u32 __bitwise __wsum;$/;"	t
_add_action	.\python\compat\argparse.py	/^    def _add_action(self, action):$/;"	m	class:ArgumentParser
_add_action	.\python\compat\argparse.py	/^    def _add_action(self, action):$/;"	m	class:_ActionsContainer
_add_action	.\python\compat\argparse.py	/^    def _add_action(self, action):$/;"	m	class:_ArgumentGroup
_add_action	.\python\compat\argparse.py	/^    def _add_action(self, action):$/;"	m	class:_MutuallyExclusiveGroup
_add_container_actions	.\python\compat\argparse.py	/^    def _add_container_actions(self, container):$/;"	m	class:_ActionsContainer
_add_item	.\python\compat\argparse.py	/^    def _add_item(self, func, args):$/;"	m	class:HelpFormatter
_added_hook	.\python\ovs\fatal_signal.py	/^_added_hook = False$/;"	v
_atexit_handler	.\python\ovs\fatal_signal.py	/^def _atexit_handler():$/;"	f
_bool_from_xml	.\xenserver\opt_xensource_libexec_InterfaceReconfigure.py	/^def _bool_from_xml(n):$/;"	f
_bool_to_xml	.\xenserver\opt_xensource_libexec_InterfaceReconfigure.py	/^def _bool_to_xml(xml, parent, tag, val):$/;"	f
_buffer	.\python\compat\uuid.py	/^    _buffer = ctypes.create_string_buffer(16)$/;"	v
_build_message	.\python\ovs\vlog.py	/^    def _build_message(self, message, facility, level, msg_num):$/;"	m	class:Vlog
_call_hooks	.\python\ovs\fatal_signal.py	/^def _call_hooks(signr):$/;"	f
_callable	.\python\compat\argparse.py	/^def _callable(obj):$/;"	f
_cancel_files	.\python\ovs\fatal_signal.py	/^def _cancel_files():$/;"	f
_chdir	.\python\ovs\daemon.py	/^_chdir = True$/;"	v
_check_already_running	.\python\ovs\daemon.py	/^def _check_already_running():$/;"	f
_check_conflict	.\python\compat\argparse.py	/^    def _check_conflict(self, action):$/;"	m	class:_ActionsContainer
_check_id	.\python\ovs\db\schema.py	/^def _check_id(name, json):$/;"	f
_check_value	.\python\compat\argparse.py	/^    def _check_value(self, action, value):$/;"	m	class:ArgumentParser
_close	.\python\ovs\unixctl\server.py	/^    def _close(self):$/;"	m	class:UnixctlConnection
_close_standard_fds	.\python\ovs\daemon.py	/^def _close_standard_fds():$/;"	f
_collections	.\python\compat\argparse.py	/^import collections as _collections$/;"	i
_commafy	.\python\ovs\db\types.py	/^def _commafy(s):$/;"	f
_config_enabled	.\datapath\linux\compat\include\linux\kconfig.h	31;"	d
_configure_bond_interface	.\xenserver\opt_xensource_libexec_InterfaceReconfigureBridge.py	/^def _configure_bond_interface(pif):$/;"	f
_configure_physical_interface	.\xenserver\opt_xensource_libexec_InterfaceReconfigureBridge.py	/^def _configure_physical_interface(pif):$/;"	f
_configure_pif	.\xenserver\opt_xensource_libexec_InterfaceReconfigureBridge.py	/^def _configure_pif(pif):$/;"	f
_configure_vlan_interface	.\xenserver\opt_xensource_libexec_InterfaceReconfigureBridge.py	/^def _configure_vlan_interface(pif):$/;"	f
_copy	.\python\compat\argparse.py	/^import copy as _copy$/;"	i
_create_id	.\python\ovs\jsonrpc.py	/^    def _create_id():$/;"	m	class:Message
_daemonize_fd	.\python\ovs\daemon.py	/^_daemonize_fd = None$/;"	v
_db	.\xenserver\opt_xensource_libexec_InterfaceReconfigure.py	/^_db = None$/;"	v
_dedent	.\python\compat\argparse.py	/^    def _dedent(self):$/;"	m	class:HelpFormatter
_detach	.\python\ovs\daemon.py	/^_detach = False$/;"	v
_ensure_value	.\python\compat\argparse.py	/^def _ensure_value(namespace, name, value):$/;"	f
_expand_help	.\python\compat\argparse.py	/^    def _expand_help(self, action):$/;"	m	class:HelpFormatter
_fatal	.\python\ovs\daemon.py	/^def _fatal(msg):$/;"	f
_files	.\python\ovs\fatal_signal.py	/^_files = {}$/;"	v
_fill_text	.\python\compat\argparse.py	/^    def _fill_text(self, text, width, indent):$/;"	m	class:HelpFormatter
_fill_text	.\python\compat\argparse.py	/^    def _fill_text(self, text, width, indent):$/;"	m	class:RawDescriptionHelpFormatter
_find_mac	.\python\compat\uuid.py	/^def _find_mac(command, args, hw_identifiers, get_index):$/;"	f
_find_method	.\python\ovs\stream.py	/^    def _find_method(name):$/;"	m	class:Stream
_fork_and_wait_for_startup	.\python\ovs\daemon.py	/^def _fork_and_wait_for_startup():$/;"	f
_fork_notify_startup	.\python\ovs\daemon.py	/^def _fork_notify_startup(fd):$/;"	f
_format_action	.\python\compat\argparse.py	/^    def _format_action(self, action):$/;"	m	class:HelpFormatter
_format_action_invocation	.\python\compat\argparse.py	/^    def _format_action_invocation(self, action):$/;"	m	class:HelpFormatter
_format_actions_usage	.\python\compat\argparse.py	/^    def _format_actions_usage(self, actions, groups):$/;"	m	class:HelpFormatter
_format_args	.\python\compat\argparse.py	/^    def _format_args(self, action, default_metavar):$/;"	m	class:HelpFormatter
_format_field	.\python\ovs\vlog.py	/^    def _format_field(self, tmp, match, replace):$/;"	m	class:Vlog
_format_text	.\python\compat\argparse.py	/^    def _format_text(self, text):$/;"	m	class:HelpFormatter
_format_time	.\python\ovs\vlog.py	/^    def _format_time(self, tmp):$/;"	m	class:Vlog
_format_usage	.\python\compat\argparse.py	/^    def _format_usage(self, usage, actions, groups, prefix):$/;"	m	class:HelpFormatter
_get_action_name	.\python\compat\argparse.py	/^def _get_action_name(argument):$/;"	f
_get_args	.\python\compat\argparse.py	/^    def _get_args(self):$/;"	m	class:_AttributeHolder
_get_formatter	.\python\compat\argparse.py	/^    def _get_formatter(self):$/;"	m	class:ArgumentParser
_get_handler	.\python\compat\argparse.py	/^    def _get_handler(self):$/;"	m	class:_ActionsContainer
_get_help_string	.\python\compat\argparse.py	/^    def _get_help_string(self, action):$/;"	m	class:ArgumentDefaultsHelpFormatter
_get_help_string	.\python\compat\argparse.py	/^    def _get_help_string(self, action):$/;"	m	class:HelpFormatter
_get_kwargs	.\python\compat\argparse.py	/^    def _get_kwargs(self):$/;"	m	class:Action
_get_kwargs	.\python\compat\argparse.py	/^    def _get_kwargs(self):$/;"	m	class:ArgumentParser
_get_kwargs	.\python\compat\argparse.py	/^    def _get_kwargs(self):$/;"	m	class:_AttributeHolder
_get_nargs_pattern	.\python\compat\argparse.py	/^    def _get_nargs_pattern(self, action):$/;"	m	class:ArgumentParser
_get_option_tuples	.\python\compat\argparse.py	/^    def _get_option_tuples(self, option_string):$/;"	m	class:ArgumentParser
_get_optional_actions	.\python\compat\argparse.py	/^    def _get_optional_actions(self):$/;"	m	class:ArgumentParser
_get_optional_kwargs	.\python\compat\argparse.py	/^    def _get_optional_kwargs(self, *args, **kwargs):$/;"	m	class:_ActionsContainer
_get_positional_actions	.\python\compat\argparse.py	/^    def _get_positional_actions(self):$/;"	m	class:ArgumentParser
_get_positional_kwargs	.\python\compat\argparse.py	/^    def _get_positional_kwargs(self, dest, **kwargs):$/;"	m	class:_ActionsContainer
_get_subactions	.\python\compat\argparse.py	/^    def _get_subactions(self):$/;"	m	class:_SubParsersAction
_get_value	.\python\compat\argparse.py	/^    def _get_value(self, action, arg_string):$/;"	m	class:ArgumentParser
_get_values	.\python\compat\argparse.py	/^    def _get_values(self, action, arg_strings):$/;"	m	class:ArgumentParser
_handle_conflict_error	.\python\compat\argparse.py	/^    def _handle_conflict_error(self, action, conflicting_actions):$/;"	m	class:_ActionsContainer
_handle_conflict_resolve	.\python\compat\argparse.py	/^    def _handle_conflict_resolve(self, action, conflicting_actions):$/;"	m	class:_ActionsContainer
_hooks	.\python\ovs\fatal_signal.py	/^_hooks = []$/;"	v
_ifconfig_getnode	.\python\compat\uuid.py	/^def _ifconfig_getnode():$/;"	f
_increment	.\python\ovs\db\idl.py	/^    def _increment(self, row, column):$/;"	m	class:Transaction
_indent	.\python\compat\argparse.py	/^    def _indent(self):$/;"	m	class:HelpFormatter
_init	.\python\ovs\fatal_signal.py	/^def _init():$/;"	f
_inited	.\python\ovs\fatal_signal.py	/^_inited = False$/;"	v
_ipconfig_getnode	.\python\compat\uuid.py	/^def _ipconfig_getnode():$/;"	f
_iter_indented_subactions	.\python\compat\argparse.py	/^    def _iter_indented_subactions(self, action):$/;"	m	class:HelpFormatter
_join_parts	.\python\compat\argparse.py	/^    def _join_parts(self, part_strings):$/;"	m	class:HelpFormatter
_keep_table_columns	.\python\ovs\db\idl.py	/^    def _keep_table_columns(self, schema, table_name, columns):$/;"	m	class:SchemaHelper
_last_timestamp	.\python\compat\uuid.py	/^_last_timestamp = None$/;"	v
_make_pidfile	.\python\ovs\daemon.py	/^def _make_pidfile():$/;"	f
_map_from_xml	.\xenserver\opt_xensource_libexec_InterfaceReconfigure.py	/^def _map_from_xml(n, attrs):$/;"	f
_map_to_xml	.\xenserver\opt_xensource_libexec_InterfaceReconfigure.py	/^def _map_to_xml(xml, parent, tag, val, attrs):$/;"	f
_match_argument	.\python\compat\argparse.py	/^    def _match_argument(self, action, arg_strings_pattern):$/;"	m	class:ArgumentParser
_match_arguments_partial	.\python\compat\argparse.py	/^    def _match_arguments_partial(self, actions, arg_strings_pattern):$/;"	m	class:ArgumentParser
_metavar_formatter	.\python\compat\argparse.py	/^    def _metavar_formatter(self, action, default_metavar):$/;"	m	class:HelpFormatter
_modifyPoolConfig	.\xenserver\usr_lib_xsconsole_plugins-base_XSFeatureVSwitch.py	/^    def _modifyPoolConfig(self, session, value):$/;"	m	class:VSwitchControllerDialogue
_monitor	.\python\ovs\daemon.py	/^_monitor = False$/;"	v
_monitor_daemon	.\python\ovs\daemon.py	/^def _monitor_daemon(daemon_pid):$/;"	f
_netbios_getnode	.\python\compat\uuid.py	/^def _netbios_getnode():$/;"	f
_next_id	.\python\ovs\jsonrpc.py	/^    _next_id = 0$/;"	v	class:Message
_node	.\python\compat\uuid.py	/^_node = None$/;"	v
_open	.\python\ovs\stream.py	/^    def _open(suffix, dscp):$/;"	m	class:Stream
_open	.\python\ovs\stream.py	/^    def _open(suffix, dscp):$/;"	m	class:TCPStream
_open	.\python\ovs\stream.py	/^    def _open(suffix, dscp):$/;"	m	class:UnixStream
_os	.\python\compat\argparse.py	/^import os as _os$/;"	i
_otherconfig_from_xml	.\xenserver\opt_xensource_libexec_InterfaceReconfigure.py	/^def _otherconfig_from_xml(n, attrs):$/;"	f
_otherconfig_to_xml	.\xenserver\opt_xensource_libexec_InterfaceReconfigure.py	/^def _otherconfig_to_xml(xml, parent, val, attrs):$/;"	f
_overwrite_pidfile	.\python\ovs\daemon.py	/^_overwrite_pidfile = False$/;"	v
_parse_known_args	.\python\compat\argparse.py	/^    def _parse_known_args(self, arg_strings, namespace):$/;"	m	class:ArgumentParser
_parse_optional	.\python\compat\argparse.py	/^    def _parse_optional(self, arg_string):$/;"	m	class:ArgumentParser
_pidfile	.\python\ovs\daemon.py	/^_pidfile = None$/;"	v
_pidfile_dev	.\python\ovs\daemon.py	/^_pidfile_dev = None$/;"	v
_pidfile_ino	.\python\ovs\daemon.py	/^_pidfile_ino = None$/;"	v
_pop_action_class	.\python\compat\argparse.py	/^    def _pop_action_class(self, kwargs, default=None):$/;"	m	class:_ActionsContainer
_print_message	.\python\compat\argparse.py	/^    def _print_message(self, message, file=None):$/;"	m	class:ArgumentParser
_process_command	.\python\ovs\unixctl\server.py	/^    def _process_command(self, request):$/;"	m	class:UnixctlConnection
_process_reply	.\python\ovs\db\idl.py	/^    def _process_reply(self, msg):$/;"	m	class:Transaction
_random_getnode	.\python\compat\uuid.py	/^def _random_getnode():$/;"	f
_re	.\python\compat\argparse.py	/^import re as _re$/;"	i
_read_args_from_files	.\python\compat\argparse.py	/^    def _read_args_from_files(self, arg_strings):$/;"	m	class:ArgumentParser
_registry_get	.\python\compat\argparse.py	/^    def _registry_get(self, registry_name, value, default=None):$/;"	m	class:_ActionsContainer
_remove_action	.\python\compat\argparse.py	/^    def _remove_action(self, action):$/;"	m	class:_ActionsContainer
_remove_action	.\python\compat\argparse.py	/^    def _remove_action(self, action):$/;"	m	class:_ArgumentGroup
_remove_action	.\python\compat\argparse.py	/^    def _remove_action(self, action):$/;"	m	class:_MutuallyExclusiveGroup
_reply_impl	.\python\ovs\unixctl\server.py	/^    def _reply_impl(self, success, body):$/;"	m	class:UnixctlConnection
_row_to_uuid	.\python\ovs\db\idl.py	/^def _row_to_uuid(value):$/;"	f
_sh	.\utilities\ovs-dev.py	/^def _sh(*args, **kwargs):$/;"	f
_should_restart	.\python\ovs\daemon.py	/^def _should_restart(status):$/;"	f
_signal_handler	.\python\ovs\fatal_signal.py	/^def _signal_handler(signr, _):$/;"	f
_signal_status_msg	.\python\ovs\process.py	/^def _signal_status_msg(type_, signr):$/;"	f
_split_lines	.\python\compat\argparse.py	/^    def _split_lines(self, text, width):$/;"	m	class:HelpFormatter
_split_lines	.\python\compat\argparse.py	/^    def _split_lines(self, text, width):$/;"	m	class:RawTextHelpFormatter
_str_from_xml	.\xenserver\opt_xensource_libexec_InterfaceReconfigure.py	/^def _str_from_xml(n):$/;"	f
_str_to_xml	.\xenserver\opt_xensource_libexec_InterfaceReconfigure.py	/^def _str_to_xml(xml, parent, tag, val):$/;"	f
_strlist_from_xml	.\xenserver\opt_xensource_libexec_InterfaceReconfigure.py	/^def _strlist_from_xml(n, ltag, itag):$/;"	f
_strlist_to_xml	.\xenserver\opt_xensource_libexec_InterfaceReconfigure.py	/^def _strlist_to_xml(xml, parent, ltag, itag, val):$/;"	f
_substitute_uuids	.\python\ovs\db\idl.py	/^    def _substitute_uuids(self, json):$/;"	m	class:Transaction
_sys	.\python\compat\argparse.py	/^import sys as _sys$/;"	i
_textwrap	.\python\compat\argparse.py	/^import textwrap as _textwrap$/;"	i
_transition	.\python\ovs\reconnect.py	/^    def _transition(self, now, state):$/;"	m	class:Reconnect
_unixctl_help	.\python\ovs\unixctl\__init__.py	/^def _unixctl_help(conn, unused_argv, unused_aux):$/;"	f
_unixctl_version	.\python\ovs\unixctl\server.py	/^def _unixctl_version(conn, unused_argv, version):$/;"	f
_unixctl_vlog_list	.\python\ovs\vlog.py	/^    def _unixctl_vlog_list(conn, unused_argv, unused_aux):$/;"	m	class:Vlog
_unixctl_vlog_reopen	.\python\ovs\vlog.py	/^    def _unixctl_vlog_reopen(conn, unused_argv, unused_aux):$/;"	m	class:Vlog
_unixctl_vlog_set	.\python\ovs\vlog.py	/^    def _unixctl_vlog_set(conn, argv, unused_aux):$/;"	m	class:Vlog
_unixdll_getnode	.\python\compat\uuid.py	/^def _unixdll_getnode():$/;"	f
_unlink	.\python\ovs\fatal_signal.py	/^def _unlink(file_):$/;"	f
_unlink_files	.\python\ovs\fatal_signal.py	/^def _unlink_files():$/;"	f
_updateActiveServers	.\xenserver\usr_lib_xsconsole_plugins-base_XSFeatureVSwitch.py	/^    def _updateActiveServers(self, session):$/;"	m	class:VSwitchControllerDialogue
_updateThisServer	.\xenserver\usr_lib_xsconsole_plugins-base_XSFeatureVSwitch.py	/^    def _updateThisServer(self, session):$/;"	m	class:VSwitchControllerDialogue
_using_eventlet_green_select	.\python\ovs\poller.py	/^    def _using_eventlet_green_select():$/;"	f
_uuid_generate_random	.\python\compat\uuid.py	/^            _uuid_generate_random = lib.uuid_generate_random$/;"	v
_uuid_generate_time	.\python\compat\uuid.py	/^            _uuid_generate_time = lib.uuid_generate_time$/;"	v
_uuid_name_from_uuid	.\python\ovs\db\idl.py	/^def _uuid_name_from_uuid(uuid):$/;"	f
_uuid_to_row	.\python\ovs\db\idl.py	/^def _uuid_to_row(atom, base):$/;"	f
_wait	.\python\ovs\unixctl\server.py	/^    def _wait(self, poller):$/;"	m	class:UnixctlConnection
_waitpid	.\python\ovs\daemon.py	/^def _waitpid(pid, options):$/;"	f
_where_uuid_equals	.\python\ovs\db\idl.py	/^def _where_uuid_equals(uuid):$/;"	f
_windll_getnode	.\python\compat\uuid.py	/^def _windll_getnode():$/;"	f
_write	.\python\ovs\db\idl.py	/^    def _write(self, row, column, datum):$/;"	m	class:Transaction
a	.\tests\test-sflow.c	/^    } a;$/;"	m	struct:sflow_addr	typeref:union:sflow_addr::__anon159	file:
abort	.\python\ovs\db\idl.py	/^    def abort(self):$/;"	m	class:Transaction
abs_file_name	.\lib\util.c	/^abs_file_name(const char *dir, const char *file_name)$/;"	f
abs_file_name	.\python\ovs\util.py	/^def abs_file_name(dir_, file_name):$/;"	f
accept	.\lib\stream-provider.h	/^    int (*accept)(struct pstream *pstream, struct stream **new_streamp);$/;"	m	struct:pstream_class
accept	.\lib\vconn-provider.h	/^    int (*accept)(struct pvconn *pvconn, struct vconn **new_vconnp);$/;"	m	struct:pvconn_class
accept	.\python\ovs\stream.py	/^    def accept(self):$/;"	m	class:PassiveStream
accept_cb	.\lib\stream-fd-unix.c	/^    int (*accept_cb)(int fd, const struct sockaddr_storage *, size_t ss_len,$/;"	m	struct:fd_pstream	file:
accept_cb	.\lib\stream-fd-windows.c	/^    int (*accept_cb)(int fd, const struct sockaddr_storage *, size_t ss_len,$/;"	m	struct:fd_pstream	file:
action_is_valid	.\lib\ofp-actions.c	/^action_is_valid(const union ofp_action *a, size_t max_actions)$/;"	f	file:
action_next	.\lib\ofp-actions.c	/^action_next(const union ofp_action *a)$/;"	f	file:
action_normal	.\lib\learning-switch.c	/^    bool action_normal;         \/* Use OFPP_NORMAL? *\/$/;"	m	struct:lswitch	file:
action_normal	.\tests\test-controller.c	/^static bool action_normal = false;$/;"	v	file:
action_set	.\ofproto\ofproto-dpif-xlate.c	/^    struct ofpbuf action_set;   \/* Action set. *\/$/;"	m	struct:xlate_ctx	typeref:struct:xlate_ctx::ofpbuf	file:
action_set_stub	.\ofproto\ofproto-dpif-xlate.c	/^    uint64_t action_set_stub[1024 \/ 8];$/;"	m	struct:xlate_ctx	file:
actions	.\datapath\flow.h	/^	struct nlattr actions[];$/;"	m	struct:sw_flow_actions	typeref:struct:sw_flow_actions::nlattr
actions	.\include\openflow\openflow-1.0.h	/^    struct ofp_action_header actions[0]; \/* Actions. *\/$/;"	m	struct:ofp10_flow_stats	typeref:struct:ofp10_flow_stats::ofp_action_header
actions	.\include\openflow\openflow-1.0.h	/^    struct ofp_action_header actions[0]; \/* The action length is inferred$/;"	m	struct:ofp10_flow_mod	typeref:struct:ofp10_flow_mod::ofp_action_header
actions	.\include\openflow\openflow-1.2.h	/^    ovs_be32  actions[4];      \/* Bitmaps of OFPAT_* that are supported. *\/$/;"	m	struct:ofp12_group_features_stats
actions	.\include\openflow\openflow-common.h	/^    ovs_be32 actions;       \/* Bitmap of supported "ofp_action_type"s.$/;"	m	struct:ofp_switch_features
actions	.\lib\dpif-linux.c	/^    const struct nlattr *actions;       \/* OVS_FLOW_ATTR_ACTIONS. *\/$/;"	m	struct:dpif_linux_flow	typeref:struct:dpif_linux_flow::nlattr	file:
actions	.\lib\dpif-netdev.c	/^    OVSRCU_TYPE(struct dp_netdev_actions *) actions;$/;"	m	struct:dp_netdev_flow	file:
actions	.\lib\dpif-netdev.c	/^    struct nlattr *actions;     \/* Sequence of OVS_ACTION_ATTR_* attributes. *\/$/;"	m	struct:dp_netdev_actions	typeref:struct:dp_netdev_actions::nlattr	file:
actions	.\lib\dpif.h	/^    const struct nlattr *actions;   \/* Actions to execute on packet. *\/$/;"	m	struct:dpif_execute	typeref:struct:dpif_execute::nlattr
actions	.\lib\dpif.h	/^    const struct nlattr *actions;   \/* Actions to perform on flow. *\/$/;"	m	struct:dpif_flow_put	typeref:struct:dpif_flow_put::nlattr
actions	.\lib\ofp-actions.h	/^    struct ofpact actions[];$/;"	m	struct:ofpact_nest	typeref:struct:ofpact_nest::ofpact
actions	.\lib\ofp-util.h	/^            uint32_t actions;     \/* Bitmap of supported OFPAT*. *\/$/;"	m	struct:ofputil_table_features::ofputil_table_instruction_features::ofputil_table_action_features
actions	.\lib\ofp-util.h	/^    enum ofputil_action_bitmap actions;$/;"	m	struct:ofputil_switch_features	typeref:enum:ofputil_switch_features::ofputil_action_bitmap
actions	.\lib\ofp-util.h	/^    uint32_t  actions[4];$/;"	m	struct:ofputil_group_features
actions	.\ofproto\ofproto-provider.h	/^    OVSRCU_TYPE(const struct rule_actions *) actions;$/;"	m	struct:rule
actions	.\ofproto\ofproto-provider.h	/^    return ovsrcu_get(const struct rule_actions *, &rule->actions);$/;"	v
actions	.\ofproto\ofproto.c	/^    const struct rule_actions *actions;$/;"	m	struct:ofoperation	typeref:struct:ofoperation::rule_actions	file:
actions	.\utilities\ovs-dpctl.c	/^    struct ofpbuf actions;$/;"	m	struct:actions_for_flow	typeref:struct:actions_for_flow::ofpbuf	file:
actions_for_flow	.\utilities\ovs-dpctl.c	/^struct actions_for_flow {$/;"	s	file:
actions_len	.\datapath\flow.h	/^	u32 actions_len;$/;"	m	struct:sw_flow_actions
actions_len	.\include\openflow\openflow-1.0.h	/^    ovs_be16 actions_len;         \/* Size of action array in bytes. *\/$/;"	m	struct:ofp10_packet_out
actions_len	.\include\openflow\openflow-1.1.h	/^    ovs_be16 actions_len;     \/* Size of action array in bytes. *\/$/;"	m	struct:ofp11_packet_out
actions_len	.\lib\dpif-linux.c	/^    size_t actions_len;$/;"	m	struct:dpif_linux_flow	file:
actions_len	.\lib\dpif.h	/^    size_t actions_len;             \/* Length of 'actions' in bytes. *\/$/;"	m	struct:dpif_execute
actions_len	.\lib\dpif.h	/^    size_t actions_len;             \/* Length of 'actions' in bytes. *\/$/;"	m	struct:dpif_flow_put
actions_output_to_local_port	.\ofproto\ofproto-dpif-xlate.c	/^actions_output_to_local_port(const struct xlate_ctx *ctx)$/;"	f	file:
active	.\lib\lacp.c	/^    bool active;                  \/* Active or Passive. *\/$/;"	m	struct:lacp	file:
active	.\lib\lacp.h	/^    bool active;                      \/* Active or passive mode? *\/$/;"	m	struct:lacp_settings
active	.\lib\stp.c	/^    bool active;                 \/* Timer in use? *\/$/;"	m	struct:stp_timer	file:
active_count	.\include\openflow\openflow-1.0.h	/^    ovs_be32 active_count;   \/* Number of active entries. *\/$/;"	m	struct:ofp10_table_stats
active_count	.\include\openflow\openflow-1.1.h	/^    ovs_be32 active_count;   \/* Number of active entries. *\/$/;"	m	struct:ofp11_table_stats
active_count	.\include\openflow\openflow-1.2.h	/^    ovs_be32 active_count;   \/* Number of active entries. *\/$/;"	m	struct:ofp12_table_stats
active_count	.\include\openflow\openflow-1.3.h	/^    ovs_be32 active_count;  \/* Number of active entries. *\/$/;"	m	struct:ofp13_action_self_learning::ofp13_table_stats
active_slave	.\ofproto\bond.c	/^    struct bond_slave *active_slave;$/;"	m	struct:bond	typeref:struct:bond::bond_slave	file:
active_slave_changed	.\ofproto\bond.c	/^    bool active_slave_changed; \/* Set to true whenever the bond changes$/;"	m	struct:bond	file:
active_slave_mac	.\ofproto\bond.c	/^    uint8_t active_slave_mac[ETH_ADDR_LEN];$/;"	m	struct:bond	file:
active_slave_mac	.\ofproto\bond.h	/^    uint8_t active_slave_mac[6];\/* The MAC address of the interface$/;"	m	struct:bond_settings
active_timeout	.\lib\vswitch-idl.h	/^	int64_t active_timeout;$/;"	m	struct:ovsrec_netflow
active_timeout	.\ofproto\netflow.c	/^    long long int active_timeout; \/* Timeout for flows that are still active. *\/$/;"	m	struct:netflow	file:
active_timeout	.\ofproto\netflow.h	/^    int active_timeout;$/;"	m	struct:netflow_options
activity	.\python\ovs\reconnect.py	/^    def activity(self, now):$/;"	m	class:Reconnect
actual	.\ovsdb\execution.c	/^    struct ovsdb_row_hash *actual;$/;"	m	struct:wait_auxdata	typeref:struct:wait_auxdata::ovsdb_row_hash	file:
add_action	.\datapath\flow_netlink.c	/^static int add_action(struct sw_flow_actions **sfa, int attrtype, void *data, int len)$/;"	f	file:
add_args	.\python\ovs\daemon.py	/^def add_args(parser):$/;"	f
add_args	.\python\ovs\vlog.py	/^def add_args(parser):$/;"	f
add_argument	.\python\compat\argparse.py	/^    def add_argument(self, *args, **kwargs):$/;"	m	class:_ActionsContainer
add_argument	.\python\compat\argparse.py	/^    def add_argument(self, action):$/;"	m	class:HelpFormatter
add_argument_group	.\python\compat\argparse.py	/^    def add_argument_group(self, *args, **kwargs):$/;"	m	class:_ActionsContainer
add_arguments	.\python\compat\argparse.py	/^    def add_arguments(self, actions):$/;"	m	class:HelpFormatter
add_bridge_to_cache	.\utilities\ovs-vsctl.c	/^add_bridge_to_cache(struct vsctl_context *ctx,$/;"	f	file:
add_column	.\ovsdb\ovsdb-client.c	/^add_column(const char *server, const struct ovsdb_column *column,$/;"	f	file:
add_column	.\ovsdb\table.c	/^add_column(struct ovsdb_table_schema *ts, struct ovsdb_column *column)$/;"	f	file:
add_command	.\tests\ovstest.c	/^add_command(struct command *cmd)$/;"	f	file:
add_comment	.\python\ovs\db\idl.py	/^    def add_comment(self, comment):$/;"	m	class:Transaction
add_del_bridges	.\vswitchd\bridge.c	/^add_del_bridges(const struct ovsrec_open_vswitch *cfg)$/;"	f	file:
add_del_mcast_entry	.\vtep\vtep-ctl.c	/^add_del_mcast_entry(struct vtep_ctl_context *ctx, bool add, bool local)$/;"	f	file:
add_double	.\ovsdb\mutation.c	/^add_double(double *x, double y)$/;"	f	file:
add_file_to_unlink	.\python\ovs\fatal_signal.py	/^def add_file_to_unlink(file):$/;"	f
add_group	.\ofproto\ofproto.c	/^add_group(struct ofproto *ofproto, struct ofputil_group_mod *gm)$/;"	f	file:
add_hook	.\python\ovs\fatal_signal.py	/^def add_hook(hook, cancel, run_at_exit):$/;"	f
add_id_to_iface	.\ofproto\netflow.c	/^    bool add_id_to_iface;         \/* Put the 7 least significiant bits of$/;"	m	struct:netflow	file:
add_id_to_iface	.\ofproto\netflow.h	/^    bool add_id_to_iface;$/;"	m	struct:netflow_options
add_id_to_interface	.\lib\vswitch-idl.h	/^	bool add_id_to_interface;$/;"	m	struct:ovsrec_netflow
add_iface_to_cache	.\utilities\ovs-vsctl.c	/^add_iface_to_cache(struct vsctl_context *ctx, struct vsctl_port *parent,$/;"	f	file:
add_int	.\ovsdb\mutation.c	/^add_int(int64_t *x, int64_t y)$/;"	f	file:
add_internal_flows	.\ofproto\ofproto-dpif.c	/^add_internal_flows(struct ofproto_dpif *ofproto)$/;"	f	file:
add_internal_miss_flow	.\ofproto\ofproto-dpif.c	/^add_internal_miss_flow(struct ofproto_dpif *ofproto, int id,$/;"	f	file:
add_ipfix_action	.\ofproto\ofproto-dpif-xlate.c	/^add_ipfix_action(struct xlate_ctx *ctx)$/;"	f	file:
add_ls_binding_to_cache	.\vtep\vtep-ctl.c	/^add_ls_binding_to_cache(struct vtep_ctl_port *port,$/;"	f	file:
add_lswitch_to_cache	.\vtep\vtep-ctl.c	/^add_lswitch_to_cache(struct vtep_ctl_context *ctx,$/;"	f	file:
add_manager_options	.\ovsdb\ovsdb-server.c	/^add_manager_options(struct shash *remotes, const struct ovsdb_row *row)$/;"	f	file:
add_mcast_entry	.\vtep\vtep-ctl.c	/^add_mcast_entry(struct vtep_ctl_context *ctx,$/;"	f	file:
add_mcast_mac_to_cache	.\vtep\vtep-ctl.c	/^add_mcast_mac_to_cache(struct vtep_ctl_context *ctx,$/;"	f	file:
add_mirror_actions	.\ofproto\ofproto-dpif-xlate.c	/^add_mirror_actions(struct xlate_ctx *ctx, const struct flow *orig_flow)$/;"	f	file:
add_monitored_table	.\ovsdb\ovsdb-client.c	/^add_monitored_table(int argc, char *argv[],$/;"	f	file:
add_mutation	.\ovsdb\mutation.c	/^static const struct ovsdb_scalar_mutation add_mutation = {$/;"	v	typeref:struct:ovsdb_scalar_mutation	file:
add_mutation	.\ovsdb\mutation.c	/^static const struct ovsdb_scalar_mutation add_mutation;$/;"	v	typeref:struct:ovsdb_scalar_mutation	file:
add_mutually_exclusive_group	.\python\compat\argparse.py	/^    def add_mutually_exclusive_group(self, **kwargs):$/;"	m	class:_ActionsContainer
add_nested_action_end	.\datapath\flow_netlink.c	/^static inline void add_nested_action_end(struct sw_flow_actions *sfa,$/;"	f	file:
add_nested_action_start	.\datapath\flow_netlink.c	/^static inline int add_nested_action_start(struct sw_flow_actions **sfa,$/;"	f	file:
add_nxm_field	.\lib\meta-flow.c	/^add_nxm_field(uint32_t header, const struct mf_field *mf)$/;"	f	file:
add_ofp_port	.\vswitchd\bridge.c	/^add_ofp_port(ofp_port_t port, ofp_port_t *ports, size_t *n, size_t *allocated)$/;"	f	file:
add_option	.\utilities\ovs-vsctl.c	/^add_option(struct option **optionsp, size_t *n_optionsp,$/;"	f	file:
add_option	.\vtep\vtep-ctl.c	/^add_option(struct option **optionsp, size_t *n_optionsp,$/;"	f	file:
add_parser	.\python\compat\argparse.py	/^    def add_parser(self, name, **kwargs):$/;"	m	class:_SubParsersAction
add_ploc_to_cache	.\vtep\vtep-ctl.c	/^add_ploc_to_cache(struct vtep_ctl_context *ctx,$/;"	f	file:
add_ploc_to_mcast_mac	.\vtep\vtep-ctl.c	/^add_ploc_to_mcast_mac(struct vtep_ctl_mcast_mac *mcast_mac,$/;"	f	file:
add_port	.\utilities\ovs-vsctl.c	/^add_port(struct vsctl_context *ctx,$/;"	f	file:
add_port	.\vtep\vtep-ctl.c	/^add_port(struct vtep_ctl_context *ctx, const char *ps_name,$/;"	f	file:
add_port_queue	.\tests\test-controller.c	/^add_port_queue(char *s)$/;"	f	file:
add_port_to_cache	.\utilities\ovs-vsctl.c	/^add_port_to_cache(struct vsctl_context *ctx, struct vsctl_bridge *parent,$/;"	f	file:
add_port_to_cache	.\vtep\vtep-ctl.c	/^add_port_to_cache(struct vtep_ctl_context *ctx,$/;"	f	file:
add_pr_rule	.\ofproto\bond.c	/^add_pr_rule(struct bond *bond, const struct match *match,$/;"	f	file:
add_pswitch_to_cache	.\vtep\vtep-ctl.c	/^add_pswitch_to_cache(struct vtep_ctl_context *ctx,$/;"	f	file:
add_ref_table	.\lib\ovsdb-idl.c	/^add_ref_table(struct ovsdb_idl *idl, const struct ovsdb_base_type *base)$/;"	f	file:
add_remote	.\ovsdb\ovsdb-server.c	/^add_remote(struct shash *remotes, const char *target)$/;"	f	file:
add_router	.\lib\netdev-provider.h	/^    int (*add_router)(struct netdev *netdev, struct in_addr router);$/;"	m	struct:netdev_class
add_rule	.\ofproto\in-band.c	/^add_rule(struct in_band *ib, const struct match *match, unsigned int priority)$/;"	f	file:
add_sflow_action	.\ofproto\ofproto-dpif-xlate.c	/^add_sflow_action(struct xlate_ctx *ctx)$/;"	f	file:
add_snooper	.\ofproto\connmgr.c	/^add_snooper(struct connmgr *mgr, struct vconn *vconn)$/;"	f	file:
add_sort_criterion	.\utilities\ovs-ofctl.c	/^add_sort_criterion(enum sort_order order, const char *field)$/;"	f	file:
add_subparsers	.\python\compat\argparse.py	/^    def add_subparsers(self, **kwargs):$/;"	m	class:ArgumentParser
add_text	.\python\compat\argparse.py	/^    def add_text(self, text):$/;"	m	class:HelpFormatter
add_top_level_commands	.\tests\ovstest.c	/^add_top_level_commands(void)$/;"	f	file:
add_ucast_entry	.\vtep\vtep-ctl.c	/^add_ucast_entry(struct vtep_ctl_context *ctx, bool local)$/;"	f	file:
add_usage	.\python\compat\argparse.py	/^    def add_usage(self, usage, actions, groups, prefix=None):$/;"	m	class:HelpFormatter
add_vlan_splinter_ports	.\vswitchd\bridge.c	/^add_vlan_splinter_ports(struct bridge *br,$/;"	f	file:
add_weak_ref	.\ovsdb\transaction.c	/^add_weak_ref(struct ovsdb_txn *txn,$/;"	f	file:
added_hook	.\lib\fatal-signal.c	/^static bool added_hook;$/;"	v	file:
addr	.\datapath\flow.h	/^			} addr;$/;"	m	struct:sw_flow_key::__anon5::__anon6	typeref:struct:sw_flow_key::__anon5::__anon6::__anon7
addr	.\datapath\flow.h	/^			} addr;$/;"	m	struct:sw_flow_key::__anon5::__anon9	typeref:struct:sw_flow_key::__anon5::__anon9::__anon10
addr	.\lib\rtnetlink-link.h	/^    uint8_t addr[ETH_ALEN];$/;"	m	struct:rtnetlink_link_change
addr	.\lib\sflow.h	/^    u_char addr[16];$/;"	m	struct:__anon93
addr	.\lib\sflow.h	/^    u_int32_t addr;$/;"	m	struct:__anon92
address	.\lib\netdev-linux.c	/^    struct in_addr address, netmask;$/;"	m	struct:netdev_linux	typeref:struct:netdev_linux::in_addr	file:
address	.\lib\sflow.h	/^    SFLAddress_value address;$/;"	m	struct:_SFLAddress
addressEncodingLength	.\lib\sflow_receiver.c	/^inline static u_int32_t addressEncodingLength(SFLAddress *addr) {$/;"	f	file:
adjust_limits	.\ofproto\pinsched.c	/^adjust_limits(int *rate_limit, int *burst_limit)$/;"	f	file:
admin_state	.\lib\vswitch-idl.h	/^	char *admin_state;$/;"	m	struct:ovsrec_interface
advance_txq	.\ofproto\pinsched.c	/^advance_txq(struct pinsched *ps)$/;"	f	file:
advertise	.\include\openflow\openflow-1.0.h	/^    ovs_be32 advertise;     \/* Bitmap of "ofp_port_features"s.  Zero all$/;"	m	struct:ofp10_port_mod
advertise	.\include\openflow\openflow-1.1.h	/^    ovs_be32 advertise;     \/* Bitmap of OFPPF_* and OFPPF11_*.  Zero all bits$/;"	m	struct:ofp11_port_mod
advertise	.\include\openflow\openflow-1.4.h	/^    ovs_be32      advertise;  \/* Bitmap of OFPPF_*.  Zero all bits to prevent$/;"	m	struct:ofp14_port_mod_prop_ethernet
advertise	.\lib\ofp-util.h	/^    enum netdev_features advertise;$/;"	m	struct:ofputil_port_mod	typeref:enum:ofputil_port_mod::netdev_features
advertised	.\include\openflow\openflow-1.0.h	/^    ovs_be32 advertised;    \/* Features being advertised by the port. *\/$/;"	m	struct:ofp10_phy_port
advertised	.\include\openflow\openflow-1.1.h	/^    ovs_be32 advertised;    \/* Features being advertised by the port. *\/$/;"	m	struct:ofp11_port
advertised	.\include\openflow\openflow-1.4.h	/^    ovs_be32 advertised;    \/* Features being advertised by the port. *\/$/;"	m	struct:ofp14_port_desc_prop_ethernet
advertised	.\lib\netdev-linux.c	/^    enum netdev_features advertised; \/* Cached from ETHTOOL_GSET. *\/$/;"	m	struct:netdev_linux	typeref:enum:netdev_linux::netdev_features	file:
advertised	.\lib\ofp-util.h	/^    enum netdev_features advertised; \/* Features advertised by the port. *\/$/;"	m	struct:ofputil_phy_port	typeref:enum:ofputil_phy_port::netdev_features
aes128	.\lib\aes128.h	/^struct aes128 {$/;"	s
aes128_encrypt	.\lib\aes128.c	/^aes128_encrypt(const struct aes128 *aes, const void *input_, void *output_)$/;"	f
aes128_schedule	.\lib\aes128.c	/^aes128_schedule(struct aes128 *aes, const uint8_t key[16])$/;"	f
af_inet_ifreq_ioctl	.\lib\socket-util.c	/^af_inet_ifreq_ioctl(const char *name, struct ifreq *ifr, unsigned long int cmd,$/;"	f
af_inet_ioctl	.\lib\socket-util.c	/^af_inet_ioctl(unsigned long int command, const void *arg)$/;"	f
af_link_ioctl	.\lib\netdev-bsd.c	/^af_link_ioctl(unsigned long command, const void *arg)$/;"	f
af_packet_sock	.\lib\netdev-linux.c	/^af_packet_sock(void)$/;"	f	file:
age_secs	.\ofproto\ofproto.c	/^age_secs(long long int age_ms)$/;"	f	file:
agent	.\lib\sflow_api.h	/^    struct _SFLAgent *agent;    \/* pointer to my agent *\/$/;"	m	struct:_SFLReceiver	typeref:struct:_SFLReceiver::_SFLAgent
agent	.\lib\sflow_api.h	/^    struct _SFLAgent *agent; \/* pointer to my agent *\/$/;"	m	struct:_SFLPoller	typeref:struct:_SFLPoller::_SFLAgent
agent	.\lib\sflow_api.h	/^    struct _SFLAgent *agent; \/* pointer to my agent *\/$/;"	m	struct:_SFLSampler	typeref:struct:_SFLSampler::_SFLAgent
agent	.\lib\vswitch-idl.h	/^	char *agent;$/;"	m	struct:ovsrec_sflow
agentAddr	.\tests\test-sflow.c	/^    struct sflow_addr agentAddr;$/;"	m	struct:sflow_xdr	typeref:struct:sflow_xdr::sflow_addr	file:
agentIPStr	.\tests\test-sflow.c	/^    char agentIPStr[INET6_ADDRSTRLEN + 2];$/;"	m	struct:sflow_xdr	file:
agent_address	.\lib\sflow.h	/^    SFLAddress agent_address;        \/* IP address of sampling agent *\/$/;"	m	struct:_SFLSample_datagram_hdr
agent_device	.\ofproto\ofproto.h	/^    char *agent_device;$/;"	m	struct:ofproto_sflow_options
aggregate	.\lib\ofp-util.h	/^    bool aggregate;             \/* Aggregate results? *\/$/;"	m	struct:ofputil_flow_stats_request
aiocb_head	.\lib\async-append-aio.c	/^    unsigned int aiocb_head, aiocb_tail;$/;"	m	struct:async_append	file:
aiocb_tail	.\lib\async-append-aio.c	/^    unsigned int aiocb_head, aiocb_tail;$/;"	m	struct:async_append	file:
aiocbs	.\lib\async-append-aio.c	/^    struct aiocb *aiocbs;$/;"	m	struct:async_append	typeref:struct:async_append::aiocb	file:
algorithm	.\include\openflow\nicira-ext.h	/^    ovs_be16 algorithm;         \/* One of NX_BD_ALG_*. *\/$/;"	m	struct:nx_action_bundle
algorithm	.\include\openflow\nicira-ext.h	/^    ovs_be16 algorithm;         \/* One of NX_MP_ALG_*. *\/$/;"	m	struct:nx_action_multipath
algorithm	.\lib\ofp-actions.h	/^    enum nx_bd_algorithm algorithm;$/;"	m	struct:ofpact_bundle	typeref:enum:ofpact_bundle::nx_bd_algorithm
algorithm	.\lib\ofp-actions.h	/^    enum nx_mp_algorithm algorithm;$/;"	m	struct:ofpact_multipath	typeref:enum:ofpact_multipath::nx_mp_algorithm
algorithm_hrw	.\lib\multipath.c	/^algorithm_hrw(uint32_t hash, unsigned int n_links)$/;"	f	file:
algorithm_iter_hash	.\lib\multipath.c	/^algorithm_iter_hash(uint32_t hash, unsigned int n_links, unsigned int modulo)$/;"	f	file:
all_bfds__	.\lib\bfd.c	/^static struct hmap all_bfds__ = HMAP_INITIALIZER(&all_bfds__);$/;"	v	typeref:struct:hmap	file:
all_bonds__	.\ofproto\bond.c	/^static struct hmap all_bonds__ = HMAP_INITIALIZER(&all_bonds__);$/;"	v	typeref:struct:hmap	file:
all_bridges	.\vswitchd\bridge.c	/^static struct hmap all_bridges = HMAP_INITIALIZER(&all_bridges);$/;"	v	typeref:struct:hmap	file:
all_cfms__	.\lib\cfm.c	/^static struct hmap all_cfms__ = HMAP_INITIALIZER(&all_cfms__);$/;"	v	typeref:struct:hmap	file:
all_commands	.\ovsdb\ovsdb-client.c	/^static const struct ovsdb_client_command all_commands[] = {$/;"	v	typeref:struct:ovsdb_client_command	file:
all_commands	.\ovsdb\ovsdb-tool.c	/^static const struct command all_commands[] = {$/;"	v	typeref:struct:command	file:
all_commands	.\tests\test-jsonrpc.c	/^static struct command all_commands[] = {$/;"	v	typeref:struct:command	file:
all_commands	.\tests\test-ovsdb.c	/^static struct command all_commands[] = {$/;"	v	typeref:struct:command	file:
all_commands	.\tests\test-reconnect.c	/^static const struct command all_commands[] = {$/;"	v	typeref:struct:command	file:
all_commands	.\utilities\ovs-benchmark.c	/^static const struct command all_commands[] = {$/;"	v	typeref:struct:command	file:
all_commands	.\utilities\ovs-dpctl.c	/^static const struct command all_commands[] = {$/;"	v	typeref:struct:command	file:
all_commands	.\utilities\ovs-ofctl.c	/^static const struct command all_commands[] = {$/;"	v	typeref:struct:command	file:
all_commands	.\utilities\ovs-vsctl.c	/^static const struct vsctl_command_syntax all_commands[] = {$/;"	v	typeref:struct:vsctl_command_syntax	file:
all_commands	.\vtep\vtep-ctl.c	/^static const struct vtep_ctl_command_syntax all_commands[] = {$/;"	v	typeref:struct:vtep_ctl_command_syntax	file:
all_conns	.\ofproto\connmgr.c	/^    struct list all_conns;     \/* All controllers. *\/$/;"	m	struct:connmgr	typeref:struct:connmgr::list	file:
all_dbs	.\ovsdb\ovsdb-server.c	/^    struct shash *all_dbs;$/;"	m	struct:server_config	typeref:struct:server_config::shash	file:
all_dpif_backers	.\ofproto\ofproto-dpif.c	/^static struct shash all_dpif_backers = SHASH_INITIALIZER(&all_dpif_backers);$/;"	v	typeref:struct:shash	file:
all_fields	.\lib\meta-flow.c	/^static struct hmap all_fields;$/;"	v	typeref:struct:hmap	file:
all_frags	.\lib\meta-flow.c	/^static const struct frag_handling all_frags[] = {$/;"	v	typeref:struct:frag_handling	file:
all_lacps__	.\lib\lacp.c	/^static struct list all_lacps__ = LIST_INITIALIZER(&all_lacps__);$/;"	v	typeref:struct:list	file:
all_notifiers	.\lib\netlink-notifier.c	/^    struct list all_notifiers;   \/* All nln notifiers. *\/$/;"	m	struct:nln	typeref:struct:nln::list	file:
all_notifiers	.\lib\rtbsd.c	/^static struct list all_notifiers = LIST_INITIALIZER(&all_notifiers);$/;"	v	typeref:struct:list	file:
all_ofproto_dpifs	.\ofproto\ofproto-dpif.c	/^static struct hmap all_ofproto_dpifs = HMAP_INITIALIZER(&all_ofproto_dpifs);$/;"	v	typeref:struct:hmap	file:
all_ofproto_dpifs_node	.\ofproto\ofproto-dpif.c	/^    struct hmap_node all_ofproto_dpifs_node; \/* In 'all_ofproto_dpifs'. *\/$/;"	m	struct:ofproto_dpif	typeref:struct:ofproto_dpif::hmap_node	file:
all_ofprotos	.\ofproto\ofproto.c	/^static struct hmap all_ofprotos = HMAP_INITIALIZER(&all_ofprotos);$/;"	v	typeref:struct:hmap	file:
all_processes	.\lib\process.c	/^static struct list all_processes = LIST_INITIALIZER(&all_processes);$/;"	v	typeref:struct:list	file:
all_slashes_name	.\lib\util.c	/^all_slashes_name(const char *s)$/;"	f	file:
all_stps__	.\lib\stp.c	/^static struct list all_stps__ = LIST_INITIALIZER(&all_stps__);$/;"	v	typeref:struct:list	file:
all_udpifs	.\ofproto\ofproto-dpif-upcall.c	/^static struct list all_udpifs = LIST_INITIALIZER(&all_udpifs);$/;"	v	typeref:struct:list	file:
alloc	.\lib\netdev-provider.h	/^    struct netdev *(*alloc)(void);$/;"	m	struct:netdev_class	typeref:struct:netdev_class::alloc
alloc	.\ofproto\ofproto-dpif.c	/^alloc(void)$/;"	f	file:
alloc	.\ofproto\ofproto-provider.h	/^    struct ofproto *(*alloc)(void);$/;"	m	struct:ofproto_class	typeref:struct:ofproto_class::alloc
allocFn	.\lib\sflow_api.h	/^    allocFn_t allocFn;$/;"	m	struct:_SFLAgent
allocFn_t	.\lib\sflow_api.h	/^typedef void *(*allocFn_t)(void *magic,               \/* callback to allocate space on heap *\/$/;"	t
alloc_buckets	.\datapath\flow_table.c	/^static struct flex_array *alloc_buckets(unsigned int n_buckets)$/;"	f	file:
alloc_default_atoms	.\lib\ovsdb-data.c	/^alloc_default_atoms(enum ovsdb_atomic_type type, size_t n)$/;"	f	file:
alloc_ofp_port	.\ofproto\ofproto.c	/^alloc_ofp_port(struct ofproto *ofproto, const char *netdev_name)$/;"	f	file:
alloc_port_no	.\ofproto\ofproto-provider.h	/^    uint16_t alloc_port_no;     \/* Last allocated OpenFlow port number. *\/$/;"	m	struct:ofproto
alloc_size	.\lib\classifier.c	/^    size_t alloc_size;     \/* Number of allocated elements. *\/$/;"	m	struct:cls_subtable_cache	file:
alloc_xid	.\lib\ofp-msgs.c	/^alloc_xid(void)$/;"	f	file:
allocate_row	.\ovsdb\row.c	/^allocate_row(const struct ovsdb_table *table)$/;"	f	file:
allocated	.\lib\dynamic-string.h	/^    size_t allocated;   \/* Bytes allocated, not including null terminator. *\/$/;"	m	struct:ds
allocated	.\lib\heap.h	/^    size_t allocated;           \/* Max 'n' before 'array' must be enlarged. *\/$/;"	m	struct:heap
allocated	.\lib\ofpbuf.h	/^    uint32_t allocated;         \/* Number of bytes allocated. *\/$/;"	m	struct:ofpbuf
allocated	.\lib\svec.h	/^    size_t allocated;$/;"	m	struct:svec
allocated_columns	.\lib\table.h	/^    size_t n_columns, allocated_columns;$/;"	m	struct:table
allocated_columns	.\ovsdb\column.h	/^    size_t n_columns, allocated_columns;$/;"	m	struct:ovsdb_column_set
allocated_commands	.\tests\ovstest.c	/^static size_t allocated_commands = 0;$/;"	v	file:
allocated_coverage_counters	.\lib\coverage.c	/^static size_t allocated_coverage_counters = 0;$/;"	v	file:
allocated_criteria	.\utilities\ovs-ofctl.c	/^static size_t n_criteria, allocated_criteria;$/;"	v	file:
allocated_height	.\lib\json.c	/^    size_t height, allocated_height;$/;"	m	struct:json_parser	file:
allocated_neoteric_ifaces	.\utilities\ovs-vsctl.c	/^static size_t allocated_neoteric_ifaces;$/;"	v	file:
allocated_ofproto_classes	.\ofproto\ofproto.c	/^static size_t allocated_ofproto_classes;$/;"	v	file:
allocated_recs	.\vswitchd\bridge.c	/^static size_t n_recs, allocated_recs;$/;"	v	file:
allocated_rows	.\lib\table.h	/^    size_t n_rows, allocated_rows;$/;"	m	struct:table
allocated_rows	.\ovsdb\row.h	/^    size_t n_rows, allocated_rows;$/;"	m	struct:ovsdb_row_set
allocated_rules	.\tests\test-classifier.c	/^    size_t allocated_rules;$/;"	m	struct:tcls	file:
allocation_size	.\lib\ovsdb-idl-provider.h	/^    size_t allocation_size;$/;"	m	struct:ovsdb_idl_table_class
allowed_protocols	.\utilities\ovs-ofctl.c	/^static enum ofputil_protocol allowed_protocols = OFPUTIL_P_ANY;$/;"	v	typeref:enum:ofputil_protocol	file:
allowed_versions	.\lib\ofp-version-opt.c	/^static uint32_t allowed_versions = 0;$/;"	v	file:
allowed_versions	.\lib\rconn.c	/^    uint32_t allowed_versions;$/;"	m	struct:rconn	file:
allowed_versions	.\lib\vconn-provider.h	/^    uint32_t allowed_versions;  \/* Bitmap of versions we will accept. *\/$/;"	m	struct:vconn
allowed_versions	.\lib\vconn-provider.h	/^    uint32_t allowed_versions;$/;"	m	struct:pvconn
allowed_versions	.\ofproto\connmgr.c	/^    uint32_t allowed_versions;  \/* OpenFlow protocol versions that may$/;"	m	struct:ofservice	file:
ambig	.\lib\getopt_long.c	/^static const char ambig[] = "ambiguous option -- %.*s";$/;"	v	file:
answer_port_query	.\lib\dpif-netdev.c	/^answer_port_query(const struct dp_netdev_port *port,$/;"	f	file:
any_addresses_changed	.\ofproto\in-band.c	/^any_addresses_changed(struct in_band *ib,$/;"	f	file:
any_extras_changed	.\ofproto\connmgr.c	/^any_extras_changed(const struct connmgr *mgr,$/;"	f	file:
any_random_flow	.\tests\test-classifier.c	/^any_random_flow(struct flow *flow)$/;"	f	file:
append_group_desc	.\ofproto\ofproto.c	/^append_group_desc(struct ofgroup *group, struct list *replies)$/;"	f	file:
append_port_desc	.\ofproto\ofproto.c	/^append_port_desc(struct ofport *port, struct list *replies)$/;"	f	file:
append_port_stat	.\ofproto\ofproto.c	/^append_port_stat(struct ofport *port, struct list *replies)$/;"	f	file:
apply	.\lib\ofp-util.h	/^        } write, apply;$/;"	m	struct:ofputil_table_features::ofputil_table_instruction_features	typeref:struct:ofputil_table_features::ofputil_table_instruction_features::ofputil_table_action_features
apply	.\xenserver\opt_xensource_libexec_InterfaceReconfigure.py	/^    def apply(self):$/;"	m	class:ConfigurationFile
apply_actions	.\include\openflow\openflow-1.1.h	/^    ovs_be32 apply_actions;  \/* Bitmap of OFPAT_* that are supported$/;"	m	struct:ofp11_table_stats
apply_actions	.\include\openflow\openflow-1.2.h	/^    ovs_be32 apply_actions;  \/* Bitmap of OFPAT_* that are supported$/;"	m	struct:ofp12_table_stats
apply_setfields	.\include\openflow\openflow-1.2.h	/^    ovs_be64 apply_setfields;\/* Bitmap of (1 << OFPXMT_*) header fields that$/;"	m	struct:ofp12_table_stats
ar_hln	.\datapath\flow.h	/^	unsigned char   ar_hln;	\/* length of hardware address   *\/$/;"	m	struct:arp_eth_header
ar_hln	.\lib\packets.h	/^    uint8_t ar_hln;            \/* Hardware address length. *\/$/;"	m	struct:arp_eth_header
ar_hrd	.\datapath\flow.h	/^	__be16      ar_hrd;	\/* format of hardware address   *\/$/;"	m	struct:arp_eth_header
ar_hrd	.\lib\packets.h	/^    ovs_be16 ar_hrd;           \/* Hardware type. *\/$/;"	m	struct:arp_eth_header
ar_op	.\datapath\flow.h	/^	__be16      ar_op;	\/* ARP opcode (command)     *\/$/;"	m	struct:arp_eth_header
ar_op	.\lib\packets.h	/^    ovs_be16 ar_op;            \/* Opcode. *\/$/;"	m	struct:arp_eth_header
ar_pln	.\datapath\flow.h	/^	unsigned char   ar_pln;	\/* length of protocol address   *\/$/;"	m	struct:arp_eth_header
ar_pln	.\lib\packets.h	/^    uint8_t ar_pln;            \/* Protocol address length. *\/$/;"	m	struct:arp_eth_header
ar_pro	.\datapath\flow.h	/^	__be16      ar_pro;	\/* format of protocol address   *\/$/;"	m	struct:arp_eth_header
ar_pro	.\lib\packets.h	/^    ovs_be16 ar_pro;           \/* Protocol type. *\/$/;"	m	struct:arp_eth_header
ar_sha	.\datapath\flow.h	/^	unsigned char       ar_sha[ETH_ALEN];	\/* sender hardware address  *\/$/;"	m	struct:arp_eth_header
ar_sha	.\lib\packets.h	/^    uint8_t ar_sha[ETH_ADDR_LEN]; \/* Sender hardware address. *\/$/;"	m	struct:arp_eth_header
ar_sip	.\datapath\flow.h	/^	unsigned char       ar_sip[4];		\/* sender IP address        *\/$/;"	m	struct:arp_eth_header
ar_spa	.\lib\packets.h	/^    ovs_16aligned_be32 ar_spa;           \/* Sender protocol address. *\/$/;"	m	struct:arp_eth_header
ar_tha	.\datapath\flow.h	/^	unsigned char       ar_tha[ETH_ALEN];	\/* target hardware address  *\/$/;"	m	struct:arp_eth_header
ar_tha	.\lib\packets.h	/^    uint8_t ar_tha[ETH_ADDR_LEN]; \/* Target hardware address. *\/$/;"	m	struct:arp_eth_header
ar_tip	.\datapath\flow.h	/^	unsigned char       ar_tip[4];		\/* target IP address        *\/$/;"	m	struct:arp_eth_header
ar_tpa	.\lib\packets.h	/^    ovs_16aligned_be32 ar_tpa;           \/* Target protocol address. *\/$/;"	m	struct:arp_eth_header
arch_fast_hash	.\datapath\linux\compat\hash.c	/^u32 arch_fast_hash(const void *data, u32 len, u32 seed)$/;"	f
arch_fast_hash2	.\datapath\linux\compat\hash.c	/^u32 arch_fast_hash2(const u32 *data, u32 len, u32 seed)$/;"	f
arg	.\include\openflow\nicira-ext.h	/^    ovs_be32 arg;               \/* Algorithm-specific argument. *\/$/;"	m	struct:nx_action_multipath
arg	.\lib\ofp-actions.h	/^    uint32_t arg;               \/* Algorithm-specific argument. *\/$/;"	m	struct:ofpact_multipath
arg	.\lib\ovs-thread.c	/^    void *arg;$/;"	m	struct:ovsthread_aux	file:
arg	.\ovsdb\condition.h	/^    struct ovsdb_datum arg;$/;"	m	struct:ovsdb_clause	typeref:struct:ovsdb_clause::ovsdb_datum
arg	.\ovsdb\mutation.h	/^    struct ovsdb_datum arg;$/;"	m	struct:ovsdb_mutation	typeref:struct:ovsdb_mutation::ovsdb_datum
argc	.\utilities\ovs-vsctl.c	/^    int argc;$/;"	m	struct:vsctl_command	file:
argc	.\utilities\ovs-vsctl.c	/^    int argc;$/;"	m	struct:vsctl_context	file:
argc	.\vtep\vtep-ctl.c	/^    int argc;$/;"	m	struct:vtep_ctl_command	file:
argc	.\vtep\vtep-ctl.c	/^    int argc;$/;"	m	struct:vtep_ctl_context	file:
argparse	.\python\ovstest\args.py	/^import argparse$/;"	i
argparse	.\tests\appctl.py	/^import argparse$/;"	i
argparse	.\tests\test-daemon.py	/^import argparse$/;"	i
argparse	.\tests\test-jsonrpc.py	/^import argparse$/;"	i
argparse	.\tests\test-unixctl.py	/^import argparse$/;"	i
argparse	.\tests\test-vlog.py	/^import argparse$/;"	i
args	.\tests\test-jsonrpc.py	/^    args = args.command_args$/;"	v
args	.\tests\test-jsonrpc.py	/^    args = parser.parse_args()$/;"	v
args_needed	.\ovsdb\ovsdb-client.c	/^enum args_needed {$/;"	g	file:
argv	.\utilities\ovs-vsctl.c	/^    char **argv;$/;"	m	struct:vsctl_command	file:
argv	.\utilities\ovs-vsctl.c	/^    char **argv;$/;"	m	struct:vsctl_context	file:
argv	.\vtep\vtep-ctl.c	/^    char **argv;$/;"	m	struct:vtep_ctl_command	file:
argv	.\vtep\vtep-ctl.c	/^    char **argv;$/;"	m	struct:vtep_ctl_context	file:
arp	.\datapath\flow.h	/^			} arp;$/;"	m	struct:sw_flow_key::__anon5::__anon6	typeref:struct:sw_flow_key::__anon5::__anon6::__anon8
arp_eth_header	.\datapath\flow.h	/^struct arp_eth_header {$/;"	s
arp_eth_header	.\lib\packets.h	/^struct arp_eth_header {$/;"	s
arp_hdr	.\datapath\linux\compat\include\linux\if_arp.h	/^static inline struct arphdr *arp_hdr(const struct sk_buff *skb)$/;"	f
arp_lookup	.\lib\netdev-provider.h	/^    int (*arp_lookup)(const struct netdev *netdev, ovs_be32 ip,$/;"	m	struct:netdev_class
arp_op	.\include\linux\openvswitch.h	/^	__be16 arp_op;$/;"	m	struct:ovs_key_arp
arp_sha	.\include\linux\openvswitch.h	/^	__u8   arp_sha[ETH_ALEN];$/;"	m	struct:ovs_key_arp
arp_sha	.\lib\flow.h	/^    uint8_t arp_sha[6];         \/* ARP\/ND source hardware address. *\/$/;"	m	struct:flow
arp_sip	.\include\linux\openvswitch.h	/^	__be32 arp_sip;$/;"	m	struct:ovs_key_arp
arp_tha	.\include\linux\openvswitch.h	/^	__u8   arp_tha[ETH_ALEN];$/;"	m	struct:ovs_key_arp
arp_tha	.\lib\flow.h	/^    uint8_t arp_tha[6];         \/* ARP\/ND target hardware address. *\/$/;"	m	struct:flow
arp_tip	.\include\linux\openvswitch.h	/^	__be32 arp_tip;$/;"	m	struct:ovs_key_arp
arphdr_ok	.\datapath\flow.c	/^static bool arphdr_ok(struct sk_buff *skb)$/;"	f	file:
array	.\lib\heap.h	/^    struct heap_node **array;   \/* Data in elements 1...n, element 0 unused. *\/$/;"	m	struct:heap	typeref:struct:heap::heap_node
array	.\lib\json.h	/^        struct json_array array;$/;"	m	union:json::__anon49	typeref:struct:json::__anon49::json_array
array	.\python\ovstest\udp.py	/^import array$/;"	i
array	.\python\ovstest\util.py	/^import array$/;"	i
array_contains	.\tests\test-classifier.c	/^array_contains(int *array, int n, int value)$/;"	f	file:
as	.\lib\sflow.h	/^    u_int32_t as;                             \/* AS number for this gateway *\/$/;"	m	struct:_SFLExtended_gateway
as	.\lib\sflow.h	/^    } as;$/;"	m	struct:_SFLExtended_as_path_segment	typeref:union:_SFLExtended_as_path_segment::__anon94
as_dict	.\python\ovs\db\data.py	/^    def as_dict(self):$/;"	m	class:Datum
as_list	.\python\ovs\db\data.py	/^    def as_list(self):$/;"	m	class:Datum
as_scalar	.\python\ovs\db\data.py	/^    def as_scalar(self):$/;"	m	class:Datum
assert	.\include\sparse\assert.h	22;"	d
assert_single_threaded	.\lib\ovs-thread.h	625;"	d
assert_single_threaded_at	.\lib\ovs-thread.c	/^assert_single_threaded_at(const char *where)$/;"	f
assess_weak_refs	.\ovsdb\transaction.c	/^assess_weak_refs(struct ovsdb_txn *txn, struct ovsdb_txn_row *txn_row)$/;"	f	file:
assign_c_value_casting_away_const	.\python\ovs\db\types.py	/^    def assign_c_value_casting_away_const(self, dst, src):$/;"	m	class:BaseType
async_append	.\lib\async-append-aio.c	/^struct async_append {$/;"	s	file:
async_append_create	.\lib\async-append-aio.c	/^async_append_create(int fd)$/;"	f
async_append_create	.\lib\async-append-null.c	/^async_append_create(int fd OVS_UNUSED)$/;"	f
async_append_destroy	.\lib\async-append-aio.c	/^async_append_destroy(struct async_append *ap)$/;"	f
async_append_destroy	.\lib\async-append-null.c	/^async_append_destroy(struct async_append *ap)$/;"	f
async_append_flush	.\lib\async-append-aio.c	/^async_append_flush(struct async_append *ap)$/;"	f
async_append_flush	.\lib\async-append-null.c	/^async_append_flush(struct async_append *ap OVS_UNUSED)$/;"	f
async_append_is_empty	.\lib\async-append-aio.c	/^async_append_is_empty(const struct async_append *ap)$/;"	f	file:
async_append_is_full	.\lib\async-append-aio.c	/^async_append_is_full(const struct async_append *ap)$/;"	f	file:
async_append_wait	.\lib\async-append-aio.c	/^async_append_wait(struct async_append *ap)$/;"	f	file:
async_append_write	.\lib\async-append-aio.c	/^async_append_write(struct async_append *ap, const void *data_, size_t size)$/;"	f
async_append_write	.\lib\async-append-null.c	/^async_append_write(struct async_append *ap OVS_UNUSED,$/;"	f
atexit	.\python\ovs\fatal_signal.py	/^import atexit$/;"	i
atexit_handler	.\lib\fatal-signal.c	/^atexit_handler(void)$/;"	f	file:
atom_arrays_compare_3way	.\lib\ovsdb-data.c	/^atom_arrays_compare_3way(const union ovsdb_atom *a,$/;"	f	file:
atomic_add	.\lib\ovs-atomic-c11.h	34;"	d
atomic_add	.\lib\ovs-atomic-clang.h	56;"	d
atomic_add	.\lib\ovs-atomic-gcc4+.h	124;"	d
atomic_add	.\lib\ovs-atomic-gcc4.7+.h	50;"	d
atomic_add	.\lib\ovs-atomic-pthreads.h	70;"	d
atomic_add_explicit	.\lib\ovs-atomic-c11.h	45;"	d
atomic_add_explicit	.\lib\ovs-atomic-clang.h	67;"	d
atomic_add_explicit	.\lib\ovs-atomic-gcc4+.h	130;"	d
atomic_add_explicit	.\lib\ovs-atomic-gcc4.7+.h	61;"	d
atomic_add_explicit	.\lib\ovs-atomic-pthreads.h	76;"	d
atomic_and	.\lib\ovs-atomic-c11.h	42;"	d
atomic_and	.\lib\ovs-atomic-clang.h	64;"	d
atomic_and	.\lib\ovs-atomic-gcc4+.h	128;"	d
atomic_and	.\lib\ovs-atomic-gcc4.7+.h	58;"	d
atomic_and	.\lib\ovs-atomic-pthreads.h	74;"	d
atomic_and_explicit	.\lib\ovs-atomic-c11.h	53;"	d
atomic_and_explicit	.\lib\ovs-atomic-clang.h	75;"	d
atomic_and_explicit	.\lib\ovs-atomic-gcc4+.h	138;"	d
atomic_and_explicit	.\lib\ovs-atomic-gcc4.7+.h	69;"	d
atomic_and_explicit	.\lib\ovs-atomic-pthreads.h	84;"	d
atomic_bool	.\lib\ovs-atomic.h	/^typedef ATOMIC(bool)               atomic_bool;$/;"	t
atomic_char	.\lib\ovs-atomic.h	/^typedef ATOMIC(char)               atomic_char;$/;"	t
atomic_flag	.\lib\ovs-atomic-flag-gcc4.7+.h	/^} atomic_flag;$/;"	t	typeref:struct:__anon80
atomic_flag	.\lib\ovs-atomic-gcc4+.h	/^} atomic_flag;$/;"	t	typeref:struct:__anon82
atomic_flag	.\lib\ovs-atomic-pthreads.h	/^} atomic_flag;$/;"	t	typeref:struct:__anon85
atomic_flag_clear	.\lib\ovs-atomic-flag-gcc4.7+.h	/^atomic_flag_clear(volatile atomic_flag *object)$/;"	f
atomic_flag_clear	.\lib\ovs-atomic-gcc4+.h	/^atomic_flag_clear(volatile atomic_flag *object)$/;"	f
atomic_flag_clear	.\lib\ovs-atomic-pthreads.h	/^atomic_flag_clear(volatile atomic_flag *flag_)$/;"	f
atomic_flag_clear_explicit	.\lib\ovs-atomic-flag-gcc4.7+.h	/^atomic_flag_clear_explicit(volatile atomic_flag *object, memory_order order)$/;"	f
atomic_flag_clear_explicit	.\lib\ovs-atomic-gcc4+.h	/^atomic_flag_clear_explicit(volatile atomic_flag *object,$/;"	f
atomic_flag_clear_explicit	.\lib\ovs-atomic-pthreads.h	/^atomic_flag_clear_explicit(volatile atomic_flag *flag,$/;"	f
atomic_flag_test_and_set	.\lib\ovs-atomic-flag-gcc4.7+.h	/^atomic_flag_test_and_set(volatile atomic_flag *object)$/;"	f
atomic_flag_test_and_set	.\lib\ovs-atomic-gcc4+.h	/^atomic_flag_test_and_set(volatile atomic_flag *object)$/;"	f
atomic_flag_test_and_set	.\lib\ovs-atomic-pthreads.h	/^atomic_flag_test_and_set(volatile atomic_flag *flag_)$/;"	f
atomic_flag_test_and_set_explicit	.\lib\ovs-atomic-flag-gcc4.7+.h	/^atomic_flag_test_and_set_explicit(volatile atomic_flag *object,$/;"	f
atomic_flag_test_and_set_explicit	.\lib\ovs-atomic-gcc4+.h	/^atomic_flag_test_and_set_explicit(volatile atomic_flag *object,$/;"	f
atomic_flag_test_and_set_explicit	.\lib\ovs-atomic-pthreads.h	/^atomic_flag_test_and_set_explicit(volatile atomic_flag *flag,$/;"	f
atomic_init	.\lib\ovs-atomic-clang.h	28;"	d
atomic_init	.\lib\ovs-atomic-gcc4+.h	47;"	d
atomic_init	.\lib\ovs-atomic-gcc4.7+.h	34;"	d
atomic_init	.\lib\ovs-atomic-pthreads.h	46;"	d
atomic_int	.\lib\ovs-atomic.h	/^typedef ATOMIC(int)                atomic_int;$/;"	t
atomic_int16_t	.\lib\ovs-atomic.h	/^typedef ATOMIC(int16_t)   atomic_int16_t;$/;"	t
atomic_int32_t	.\lib\ovs-atomic.h	/^typedef ATOMIC(int32_t)   atomic_int32_t;$/;"	t
atomic_int8_t	.\lib\ovs-atomic.h	/^typedef ATOMIC(int8_t)    atomic_int8_t;$/;"	t
atomic_intmax_t	.\lib\ovs-atomic.h	/^typedef ATOMIC(intmax_t)           atomic_intmax_t;$/;"	t
atomic_intptr_t	.\lib\ovs-atomic.h	/^typedef ATOMIC(intptr_t)           atomic_intptr_t;$/;"	t
atomic_is_lock_free	.\lib\ovs-atomic-gcc4+.h	73;"	d
atomic_is_lock_free	.\lib\ovs-atomic-gcc4.7+.h	38;"	d
atomic_is_lock_free	.\lib\ovs-atomic-pthreads.h	60;"	d
atomic_llong	.\lib\ovs-atomic.h	/^typedef ATOMIC(long long)          atomic_llong;$/;"	t
atomic_long	.\lib\ovs-atomic.h	/^typedef ATOMIC(long)               atomic_long;$/;"	t
atomic_op__	.\lib\ovs-atomic-gcc4+.h	111;"	d
atomic_op_locked	.\lib\ovs-atomic-locked.h	28;"	d
atomic_op_locked_add	.\lib\ovs-atomic-locked.h	23;"	d
atomic_op_locked_and	.\lib\ovs-atomic-locked.h	27;"	d
atomic_op_locked_or	.\lib\ovs-atomic-locked.h	25;"	d
atomic_op_locked_sub	.\lib\ovs-atomic-locked.h	24;"	d
atomic_op_locked_xor	.\lib\ovs-atomic-locked.h	26;"	d
atomic_or	.\lib\ovs-atomic-c11.h	38;"	d
atomic_or	.\lib\ovs-atomic-clang.h	60;"	d
atomic_or	.\lib\ovs-atomic-gcc4+.h	126;"	d
atomic_or	.\lib\ovs-atomic-gcc4.7+.h	54;"	d
atomic_or	.\lib\ovs-atomic-pthreads.h	72;"	d
atomic_or_explicit	.\lib\ovs-atomic-c11.h	49;"	d
atomic_or_explicit	.\lib\ovs-atomic-clang.h	71;"	d
atomic_or_explicit	.\lib\ovs-atomic-gcc4+.h	134;"	d
atomic_or_explicit	.\lib\ovs-atomic-gcc4.7+.h	65;"	d
atomic_or_explicit	.\lib\ovs-atomic-pthreads.h	80;"	d
atomic_ptrdiff_t	.\lib\ovs-atomic.h	/^typedef ATOMIC(ptrdiff_t)          atomic_ptrdiff_t;$/;"	t
atomic_read	.\lib\ovs-atomic-c11.h	28;"	d
atomic_read	.\lib\ovs-atomic-clang.h	50;"	d
atomic_read	.\lib\ovs-atomic-gcc4+.h	94;"	d
atomic_read	.\lib\ovs-atomic-gcc4.7+.h	44;"	d
atomic_read	.\lib\ovs-atomic-pthreads.h	66;"	d
atomic_read_explicit	.\lib\ovs-atomic-c11.h	30;"	d
atomic_read_explicit	.\lib\ovs-atomic-clang.h	52;"	d
atomic_read_explicit	.\lib\ovs-atomic-gcc4+.h	96;"	d
atomic_read_explicit	.\lib\ovs-atomic-gcc4.7+.h	46;"	d
atomic_read_explicit	.\lib\ovs-atomic-pthreads.h	67;"	d
atomic_read_locked	.\lib\ovs-atomic-locked.h	17;"	d
atomic_schar	.\lib\ovs-atomic.h	/^typedef ATOMIC(signed char)        atomic_schar;$/;"	t
atomic_short	.\lib\ovs-atomic.h	/^typedef ATOMIC(short)              atomic_short;$/;"	t
atomic_signal_fence	.\lib\ovs-atomic-clang.h	42;"	d
atomic_signal_fence	.\lib\ovs-atomic-gcc4+.h	/^atomic_signal_fence(memory_order order OVS_UNUSED)$/;"	f
atomic_signal_fence	.\lib\ovs-atomic-gcc4.7+.h	37;"	d
atomic_signal_fence	.\lib\ovs-atomic-pthreads.h	/^atomic_signal_fence(memory_order order OVS_UNUSED)$/;"	f
atomic_size_t	.\lib\ovs-atomic.h	/^typedef ATOMIC(size_t)             atomic_size_t;$/;"	t
atomic_store	.\lib\ovs-atomic-clang.h	44;"	d
atomic_store	.\lib\ovs-atomic-gcc4+.h	77;"	d
atomic_store	.\lib\ovs-atomic-gcc4.7+.h	40;"	d
atomic_store	.\lib\ovs-atomic-pthreads.h	62;"	d
atomic_store_explicit	.\lib\ovs-atomic-clang.h	46;"	d
atomic_store_explicit	.\lib\ovs-atomic-gcc4+.h	79;"	d
atomic_store_explicit	.\lib\ovs-atomic-gcc4.7+.h	42;"	d
atomic_store_explicit	.\lib\ovs-atomic-pthreads.h	63;"	d
atomic_store_locked	.\lib\ovs-atomic-locked.h	11;"	d
atomic_sub	.\lib\ovs-atomic-c11.h	36;"	d
atomic_sub	.\lib\ovs-atomic-clang.h	58;"	d
atomic_sub	.\lib\ovs-atomic-gcc4+.h	125;"	d
atomic_sub	.\lib\ovs-atomic-gcc4.7+.h	52;"	d
atomic_sub	.\lib\ovs-atomic-pthreads.h	71;"	d
atomic_sub_explicit	.\lib\ovs-atomic-c11.h	47;"	d
atomic_sub_explicit	.\lib\ovs-atomic-clang.h	69;"	d
atomic_sub_explicit	.\lib\ovs-atomic-gcc4+.h	132;"	d
atomic_sub_explicit	.\lib\ovs-atomic-gcc4.7+.h	63;"	d
atomic_sub_explicit	.\lib\ovs-atomic-pthreads.h	78;"	d
atomic_thread_fence	.\lib\ovs-atomic-clang.h	41;"	d
atomic_thread_fence	.\lib\ovs-atomic-gcc4+.h	/^atomic_thread_fence(memory_order order)$/;"	f
atomic_thread_fence	.\lib\ovs-atomic-gcc4.7+.h	36;"	d
atomic_thread_fence	.\lib\ovs-atomic-pthreads.h	/^atomic_thread_fence(memory_order order OVS_UNUSED)$/;"	f
atomic_thread_fence_if_seq_cst	.\lib\ovs-atomic-gcc4+.h	/^atomic_thread_fence_if_seq_cst(memory_order order)$/;"	f
atomic_uchar	.\lib\ovs-atomic.h	/^typedef ATOMIC(unsigned char)      atomic_uchar;$/;"	t
atomic_uint	.\lib\ovs-atomic.h	/^typedef ATOMIC(unsigned int)       atomic_uint;$/;"	t
atomic_uint16_t	.\lib\ovs-atomic.h	/^typedef ATOMIC(uint16_t)  atomic_uint16_t;$/;"	t
atomic_uint32_t	.\lib\ovs-atomic.h	/^typedef ATOMIC(uint32_t)  atomic_uint32_t;$/;"	t
atomic_uint8_t	.\lib\ovs-atomic.h	/^typedef ATOMIC(uint8_t)   atomic_uint8_t;$/;"	t
atomic_uintmax_t	.\lib\ovs-atomic.h	/^typedef ATOMIC(uintmax_t)          atomic_uintmax_t;$/;"	t
atomic_uintptr_t	.\lib\ovs-atomic.h	/^typedef ATOMIC(uintptr_t)          atomic_uintptr_t;$/;"	t
atomic_ullong	.\lib\ovs-atomic.h	/^typedef ATOMIC(unsigned long long) atomic_ullong;$/;"	t
atomic_ulong	.\lib\ovs-atomic.h	/^typedef ATOMIC(unsigned long)      atomic_ulong;$/;"	t
atomic_ushort	.\lib\ovs-atomic.h	/^typedef ATOMIC(unsigned short)     atomic_ushort;$/;"	t
atomic_xor	.\lib\ovs-atomic-c11.h	40;"	d
atomic_xor	.\lib\ovs-atomic-clang.h	62;"	d
atomic_xor	.\lib\ovs-atomic-gcc4+.h	127;"	d
atomic_xor	.\lib\ovs-atomic-gcc4.7+.h	56;"	d
atomic_xor	.\lib\ovs-atomic-pthreads.h	73;"	d
atomic_xor_explicit	.\lib\ovs-atomic-c11.h	51;"	d
atomic_xor_explicit	.\lib\ovs-atomic-clang.h	73;"	d
atomic_xor_explicit	.\lib\ovs-atomic-gcc4+.h	136;"	d
atomic_xor_explicit	.\lib\ovs-atomic-gcc4.7+.h	67;"	d
atomic_xor_explicit	.\lib\ovs-atomic-pthreads.h	82;"	d
attach_child	.\xenserver\opt_xensource_libexec_InterfaceReconfigure.py	/^    def attach_child(self, child):$/;"	m	class:ConfigurationFile
attached	.\lib\lacp.c	/^    bool attached;                \/* Attached. Traffic may flow. *\/$/;"	m	struct:slave	file:
attrbuf	.\datapath\linux\compat\include\net\genetlink.h	/^	struct nlattr **        attrbuf;        \/* private *\/$/;"	m	struct:rpl_genl_family	typeref:struct:rpl_genl_family::nlattr
aux	.\lib\fatal-signal.c	/^    void *aux;$/;"	m	struct:hook	file:
aux	.\lib\lacp.c	/^    void *aux;                    \/* Handle used to identify this slave. *\/$/;"	m	struct:slave	file:
aux	.\lib\netlink-notifier.c	/^    void *aux;$/;"	m	struct:nln_notifier	file:
aux	.\lib\ovs-rcu.c	/^    void *aux;$/;"	m	struct:ovsrcu_cb	file:
aux	.\lib\rtbsd.h	/^    void *aux;$/;"	m	struct:rtbsd_notifier
aux	.\lib\stp.c	/^    void *aux;                      \/* Auxiliary data the user may retrieve. *\/$/;"	m	struct:stp_port	file:
aux	.\lib\stp.c	/^    void *aux;$/;"	m	struct:stp	file:
aux	.\lib\unixctl.c	/^    void *aux;$/;"	m	struct:unixctl_command	file:
aux	.\ofproto\bond.c	/^    void *aux;                  \/* Client-provided handle for this slave. *\/$/;"	m	struct:bond_slave	file:
aux	.\ofproto\ofproto-dpif-mirror.c	/^    void *aux;                  \/* Key supplied by ofproto's client. *\/$/;"	m	struct:mirror	file:
aux	.\ofproto\ofproto-dpif.c	/^    void *aux;                  \/* Key supplied by ofproto's client. *\/$/;"	m	struct:ofbundle	file:
aux	.\tests\test-classifier.c	/^    int aux;                    \/* Auxiliary data. *\/$/;"	m	struct:test_rule	file:
auxdata_has_vlan_tci	.\lib\netdev-linux.c	/^auxdata_has_vlan_tci(const struct tpacket_auxdata *aux)$/;"	f	file:
auxdata_to_vlan_tpid	.\lib\netdev-linux.c	/^auxdata_to_vlan_tpid(const struct tpacket_auxdata *aux)$/;"	f	file:
auxiliary_id	.\include\openflow\openflow-common.h	/^    uint8_t auxiliary_id;   \/* OF 1.3: Identify auxiliary connections *\/$/;"	m	struct:ofp_switch_features
auxiliary_id	.\lib\ofp-util.h	/^    uint8_t auxiliary_id;       \/* Identify auxiliary connections *\/$/;"	m	struct:ofputil_switch_features
avg_n_flows	.\ofproto\ofproto-dpif-upcall.c	/^    unsigned int avg_n_flows;$/;"	m	struct:udpif	file:
b	.\lib\ovs-atomic-flag-gcc4.7+.h	/^    unsigned char b;$/;"	m	struct:__anon80
b	.\lib\ovs-atomic-gcc4+.h	/^    int b;$/;"	m	struct:__anon82
b	.\lib\ovs-atomic-pthreads.h	/^    bool b;$/;"	m	struct:__anon85
b	.\tests\idltest.h	/^	bool b;$/;"	m	struct:idltest_simple
ba	.\tests\idltest.h	/^	bool *ba;$/;"	m	struct:idltest_simple
backer	.\ofproto\ofproto-dpif-upcall.c	/^    struct dpif_backer *backer;        \/* Opaque dpif_backer pointer. *\/$/;"	m	struct:udpif	typeref:struct:udpif::dpif_backer	file:
backer	.\ofproto\ofproto-dpif.c	/^    struct dpif_backer *backer;$/;"	m	struct:ofproto_dpif	typeref:struct:ofproto_dpif::dpif_backer	file:
backlog	.\lib\jsonrpc.c	/^    size_t backlog;$/;"	m	struct:jsonrpc	file:
backoff	.\lib\rconn.c	/^    int backoff;$/;"	m	struct:rconn	file:
backoff	.\lib\reconnect.c	/^    int backoff;$/;"	m	struct:reconnect	file:
backoff	.\lib\reconnect.h	/^    int backoff;                     \/* Current backoff duration.  *\/$/;"	m	struct:reconnect_stats
backoffThreshold	.\lib\sflow_api.h	/^    u_int32_t backoffThreshold;$/;"	m	struct:_SFLSampler
backoff_deadline	.\lib\rconn.c	/^    time_t backoff_deadline;$/;"	m	struct:rconn	file:
backtrace	.\lib\backtrace.c	/^VLOG_DEFINE_THIS_MODULE(backtrace);$/;"	v
backtrace	.\lib\backtrace.h	/^struct backtrace {$/;"	s
backtrace_capture	.\lib\backtrace.c	/^backtrace_capture(struct backtrace *b)$/;"	f
backtrace_capture	.\lib\backtrace.c	/^backtrace_capture(struct backtrace *backtrace)$/;"	f
backtrace_format	.\lib\backtrace.c	/^backtrace_format(const struct backtrace *b, struct ds *ds)$/;"	f	file:
bad_ofmsg_rl	.\lib\ofp-util.c	/^static struct vlog_rate_limit bad_ofmsg_rl = VLOG_RATE_LIMIT_INIT(1, 5);$/;"	v	typeref:struct:vlog_rate_limit	file:
bad_ofmsg_rl	.\lib\vconn.c	/^static struct vlog_rate_limit bad_ofmsg_rl = VLOG_RATE_LIMIT_INIT(1, 5);$/;"	v	typeref:struct:vlog_rate_limit	file:
bal_node	.\ofproto\bond.c	/^    struct list bal_node;       \/* In bond_rebalance()'s 'bals' list. *\/$/;"	m	struct:bond_slave	typeref:struct:bond_slave::list	file:
balance	.\ofproto\bond.c	/^    enum bond_mode balance;     \/* Balancing mode, one of BM_*. *\/$/;"	m	struct:bond	typeref:enum:bond::bond_mode	file:
balance	.\ofproto\bond.h	/^    enum bond_mode balance;$/;"	m	struct:bond_settings	typeref:enum:bond_settings::bond_mode
band	.\ofproto\connmgr.c	/^    enum ofproto_band band;     \/* In-band or out-of-band? *\/$/;"	m	struct:ofconn	typeref:enum:ofconn::ofproto_band	file:
band	.\ofproto\ofproto.h	/^    enum ofproto_band band;     \/* In-band or out-of-band? *\/$/;"	m	struct:ofproto_controller	typeref:enum:ofproto_controller::ofproto_band
band_stats	.\include\openflow\openflow-1.3.h	/^    struct ofp13_meter_band_stats band_stats[0];  \/* The band_stats length is$/;"	m	struct:ofp13_action_self_learning::ofp13_meter_stats	typeref:struct:ofp13_action_self_learning::ofp13_meter_stats::ofp13_meter_band_stats
band_types	.\include\openflow\openflow-1.3.h	/^    ovs_be32   band_types;    \/* Bitmaps of OFPMBT13_* values supported. *\/$/;"	m	struct:ofp13_action_self_learning::ofp13_meter_features
band_types	.\lib\ofp-util.h	/^    uint32_t band_types;        \/* Can support max 32 band types. *\/$/;"	m	struct:ofputil_meter_features
bands	.\lib\ofp-util.h	/^    struct ofputil_meter_band *bands;$/;"	m	struct:ofputil_meter_config	typeref:struct:ofputil_meter_config::ofputil_meter_band
bands	.\lib\ofp-util.h	/^    struct ofputil_meter_band_stats *bands;$/;"	m	struct:ofputil_meter_stats	typeref:struct:ofputil_meter_stats::ofputil_meter_band_stats
bands	.\ofproto\ofproto.c	/^    struct ofputil_meter_band *bands;$/;"	m	struct:meter	typeref:struct:meter::ofputil_meter_band	file:
bandwidth	.\python\ovstest\args.py	/^def bandwidth(string):$/;"	f
bandwidth_to_string	.\python\ovstest\util.py	/^def bandwidth_to_string(bwidth):$/;"	f
barrier_aux	.\utilities\ovs-ofctl.c	/^struct barrier_aux {$/;"	s	file:
base	.\ofproto\ofproto-dpif-rid.c	/^    uint32_t base;         \/* IDs in the range of [base, base + n_ids). *\/$/;"	m	struct:rid_pool	file:
base_dpif_classes	.\lib\dpif.c	/^static const struct dpif_class *base_dpif_classes[] = {$/;"	v	typeref:struct:dpif_class	file:
base_flow	.\ofproto\ofproto-dpif-xlate.c	/^    struct flow base_flow;$/;"	m	struct:xlate_ctx	typeref:struct:xlate_ctx::flow	file:
base_name	.\lib\dpif-provider.h	/^    char *base_name;$/;"	m	struct:dpif
base_name	.\lib\util.c	/^base_name(const char *file_name)$/;"	f
basis	.\include\openflow\nicira-ext.h	/^    ovs_be16 basis;             \/* Universal hash parameter. *\/$/;"	m	struct:nx_action_bundle
basis	.\include\openflow\nicira-ext.h	/^    ovs_be16 basis;             \/* Universal hash parameter. *\/$/;"	m	struct:nx_action_multipath
basis	.\lib\ofp-actions.h	/^    uint16_t basis;             \/* Universal hash parameter. *\/$/;"	m	struct:ofpact_bundle
basis	.\lib\ofp-actions.h	/^    uint16_t basis;             \/* Universal hash parameter. *\/$/;"	m	struct:ofpact_multipath
basis	.\ofproto\bond.c	/^    uint32_t basis;             \/* Basis for flow hash function. *\/$/;"	m	struct:bond	file:
basis	.\ofproto\bond.h	/^    uint32_t basis;             \/* Flow hashing basis. *\/$/;"	m	struct:bond_settings
be16	.\lib\meta-flow.h	/^    ovs_be16 be16;$/;"	m	union:mf_value
be16	.\lib\meta-flow.h	/^    ovs_be16 be16[8];$/;"	m	union:mf_subvalue
be16	.\lib\packets.h	/^    ovs_be16 be16[8];$/;"	m	union:ovs_16aligned_in6_addr
be32	.\lib\meta-flow.h	/^    ovs_be32 be32;$/;"	m	union:mf_value
be32	.\lib\meta-flow.h	/^    ovs_be32 be32[4];$/;"	m	union:mf_subvalue
be32	.\lib\packets.h	/^    ovs_16aligned_be32 be32[4];$/;"	m	union:ovs_16aligned_in6_addr
be32_prefix_mask	.\lib\util.h	/^static inline ovs_be32 be32_prefix_mask(int plen)$/;"	f
be32ofs	.\lib\classifier.c	/^    uint8_t be32ofs;         \/* U32 offset of the field in question. *\/$/;"	m	struct:trie_ctx	file:
be64	.\lib\meta-flow.h	/^    ovs_be64 be64;$/;"	m	union:mf_value
be64	.\lib\meta-flow.h	/^    ovs_be64 be64[2];$/;"	m	union:mf_subvalue
be64_get_high32	.\datapath\vport-gre.c	/^static __be32 be64_get_high32(__be64 x)$/;"	f	file:
be64_get_low32	.\datapath\vport-gre.c	/^static __be32 be64_get_low32(__be64 x)$/;"	f	file:
be_get_bit_at	.\lib\classifier.c	/^be_get_bit_at(const ovs_be32 value[], unsigned int ofs)$/;"	f	file:
bfd	.\lib\bfd.c	/^VLOG_DEFINE_THIS_MODULE(bfd);$/;"	v
bfd	.\lib\bfd.c	/^struct bfd {$/;"	s	file:
bfd	.\lib\vswitch-idl.h	/^	struct smap bfd;$/;"	m	struct:ovsrec_interface	typeref:struct:ovsrec_interface::smap
bfd	.\ofproto\ofproto-dpif-monitor.c	/^    struct bfd *bfd;                  \/* Reference to bfd. *\/$/;"	m	struct:mport	typeref:struct:mport::bfd	file:
bfd	.\ofproto\ofproto-dpif-xlate.c	/^            struct bfd *bfd;$/;"	m	struct:xc_entry::__anon136::__anon137	typeref:struct:xc_entry::__anon136::__anon137::bfd	file:
bfd	.\ofproto\ofproto-dpif-xlate.c	/^    struct bfd *bfd;                 \/* BFD handle or null. *\/$/;"	m	struct:xport	typeref:struct:xport::bfd	file:
bfd	.\ofproto\ofproto-dpif.c	/^    struct bfd *bfd;            \/* BFD, if any. *\/$/;"	m	struct:ofport_dpif	typeref:struct:ofport_dpif::bfd	file:
bfd_account_rx	.\lib\bfd.c	/^bfd_account_rx(struct bfd *bfd, const struct dpif_flow_stats *stats)$/;"	f
bfd_config_local	.\lib\vtep-idl.h	/^	struct smap bfd_config_local;$/;"	m	struct:vteprec_tunnel	typeref:struct:vteprec_tunnel::smap
bfd_config_remote	.\lib\vtep-idl.h	/^	struct smap bfd_config_remote;$/;"	m	struct:vteprec_tunnel	typeref:struct:vteprec_tunnel::smap
bfd_diag_str	.\lib\bfd.c	/^bfd_diag_str(enum diag diag) {$/;"	f	file:
bfd_flag_str	.\lib\bfd.c	/^bfd_flag_str(enum flags flags)$/;"	f	file:
bfd_lookup_ip	.\lib\bfd.c	/^bfd_lookup_ip(const char *host_name, struct in_addr *addr)$/;"	f	file:
bfd_params	.\lib\vtep-idl.h	/^	struct smap bfd_params;$/;"	m	struct:vteprec_tunnel	typeref:struct:vteprec_tunnel::smap
bfd_ref	.\lib\bfd.c	/^bfd_ref(const struct bfd *bfd_)$/;"	f
bfd_should_process_flow	.\lib\bfd.c	/^bfd_should_process_flow(const struct bfd *bfd_, const struct flow *flow,$/;"	f
bfd_state_str	.\lib\bfd.c	/^bfd_state_str(enum state state)$/;"	f	file:
bfd_status	.\lib\vswitch-idl.h	/^	struct smap bfd_status;$/;"	m	struct:ovsrec_interface	typeref:struct:ovsrec_interface::smap
bfd_status	.\lib\vtep-idl.h	/^	struct smap bfd_status;$/;"	m	struct:vteprec_tunnel	typeref:struct:vteprec_tunnel::smap
bin_to_hex	.\tests\test-sflow.c	/^bin_to_hex(int hexit)$/;"	f	file:
bind_local_port	.\utilities\ovs-benchmark.c	/^bind_local_port(int fd, unsigned short int *local_port,$/;"	f	file:
bind_unix_socket	.\lib\socket-util.c	/^bind_unix_socket(int fd, struct sockaddr *sun, socklen_t sun_len)$/;"	f	file:
bindings	.\vtep\vtep-ctl.c	/^    struct shash bindings;      \/* Maps from vlan to vtep_ctl_lswitch. *\/$/;"	m	struct:vtep_ctl_port	typeref:struct:vtep_ctl_port::shash	file:
bitmap_allocate	.\lib\bitmap.h	/^bitmap_allocate(size_t n_bits)$/;"	f
bitmap_allocate1	.\lib\bitmap.c	/^bitmap_allocate1(size_t n_bits)$/;"	f
bitmap_bit__	.\lib\bitmap.h	/^bitmap_bit__(size_t offset)$/;"	f
bitmap_clone	.\lib\bitmap.h	/^bitmap_clone(const unsigned long *bitmap, size_t n_bits)$/;"	f
bitmap_count1	.\lib\bitmap.c	/^bitmap_count1(const unsigned long int *bitmap, size_t n)$/;"	f
bitmap_equal	.\lib\bitmap.c	/^bitmap_equal(const unsigned long *a, const unsigned long *b, size_t n)$/;"	f
bitmap_free	.\lib\bitmap.h	/^bitmap_free(unsigned long *bitmap)$/;"	f
bitmap_is_set	.\lib\bitmap.h	/^bitmap_is_set(const unsigned long *bitmap, size_t offset)$/;"	f
bitmap_n_bytes	.\lib\bitmap.h	/^bitmap_n_bytes(size_t n_bits)$/;"	f
bitmap_n_longs	.\lib\bitmap.h	/^bitmap_n_longs(size_t n_bits)$/;"	f
bitmap_scan	.\lib\bitmap.c	/^bitmap_scan(const unsigned long int *bitmap, bool target,$/;"	f
bitmap_set	.\lib\bitmap.h	/^bitmap_set(unsigned long *bitmap, size_t offset, bool value)$/;"	f
bitmap_set0	.\lib\bitmap.h	/^bitmap_set0(unsigned long *bitmap, size_t offset)$/;"	f
bitmap_set1	.\lib\bitmap.h	/^bitmap_set1(unsigned long *bitmap, size_t offset)$/;"	f
bitmap_set_multiple	.\lib\bitmap.c	/^bitmap_set_multiple(unsigned long *bitmap, size_t start, size_t count,$/;"	f
bitmap_unit__	.\lib\bitmap.h	/^bitmap_unit__(const unsigned long *bitmap, size_t offset)$/;"	f
bitwise_copy	.\lib\util.c	/^bitwise_copy(const void *src_, unsigned int src_len, unsigned int src_ofs,$/;"	f
bitwise_get	.\lib\util.c	/^bitwise_get(const void *src, unsigned int src_len,$/;"	f
bitwise_is_all_zeros	.\lib\util.c	/^bitwise_is_all_zeros(const void *p_, unsigned int len, unsigned int ofs,$/;"	f
bitwise_one	.\lib\util.c	/^bitwise_one(void *dst_, unsigned int dst_len, unsigned dst_ofs,$/;"	f
bitwise_put	.\lib\util.c	/^bitwise_put(uint64_t value,$/;"	f
bitwise_zero	.\lib\util.c	/^bitwise_zero(void *dst_, unsigned int dst_len, unsigned dst_ofs,$/;"	f
block	.\python\ovs\poller.py	/^    def block(self):$/;"	m	class:Poller
blocked	.\ofproto\connmgr.c	/^    struct ofpbuf *blocked;     \/* Postponed OpenFlow message, if any. *\/$/;"	m	struct:ofconn	typeref:struct:ofconn::ofpbuf	file:
bogus_packet_counter	.\ofproto\fail-open.c	/^    struct rconn_packet_counter *bogus_packet_counter;$/;"	m	struct:fail_open	typeref:struct:fail_open::rconn_packet_counter	file:
bond	.\ofproto\bond.c	/^    struct bond *bond;          \/* The bond that contains this slave. *\/$/;"	m	struct:bond_slave	typeref:struct:bond_slave::bond	file:
bond	.\ofproto\bond.c	/^VLOG_DEFINE_THIS_MODULE(bond);$/;"	v
bond	.\ofproto\bond.c	/^struct bond {$/;"	s	file:
bond	.\ofproto\ofproto-dpif-xlate.c	/^            struct bond *bond;$/;"	m	struct:xc_entry::__anon136::__anon140	typeref:struct:xc_entry::__anon136::__anon140::bond	file:
bond	.\ofproto\ofproto-dpif-xlate.c	/^        } bond;$/;"	m	union:xc_entry::__anon136	typeref:struct:xc_entry::__anon136::__anon140	file:
bond	.\ofproto\ofproto-dpif-xlate.c	/^    struct bond *bond;             \/* Nonnull iff more than one port. *\/$/;"	m	struct:xbundle	typeref:struct:xbundle::bond	file:
bond	.\ofproto\ofproto-dpif.c	/^    struct bond *bond;          \/* Nonnull iff more than one port. *\/$/;"	m	struct:ofbundle	typeref:struct:ofbundle::bond	file:
bond	.\ofproto\ofproto.h	/^    struct bond_settings *bond; \/* Must be nonnull iff if n_slaves > 1. *\/$/;"	m	struct:ofproto_bundle_settings	typeref:struct:ofproto_bundle_settings::bond_settings
bond_account	.\ofproto\bond.c	/^bond_account(struct bond *bond, const struct flow *flow, uint16_t vlan,$/;"	f
bond_active_slave	.\lib\vswitch-idl.h	/^	char *bond_active_slave;$/;"	m	struct:ovsrec_port
bond_active_slave_changed	.\ofproto\bond.c	/^bond_active_slave_changed(struct bond *bond)$/;"	f	file:
bond_check_admissibility	.\ofproto\bond.c	/^bond_check_admissibility(struct bond *bond, const void *slave_,$/;"	f
bond_choose_active_slave	.\ofproto\bond.c	/^bond_choose_active_slave(struct bond *bond)$/;"	f	file:
bond_choose_output_slave	.\ofproto\bond.c	/^bond_choose_output_slave(struct bond *bond, const struct flow *flow,$/;"	f
bond_choose_slave	.\ofproto\bond.c	/^bond_choose_slave(const struct bond *bond)$/;"	f	file:
bond_compose_learning_packet	.\ofproto\bond.c	/^bond_compose_learning_packet(struct bond *bond,$/;"	f
bond_create	.\ofproto\bond.c	/^bond_create(const struct bond_settings *s, struct ofproto_dpif *ofproto)$/;"	f
bond_device_exists	.\xenserver\opt_xensource_libexec_InterfaceReconfigureBridge.py	/^def bond_device_exists(name):$/;"	f
bond_downdelay	.\lib\vswitch-idl.h	/^	int64_t bond_downdelay;$/;"	m	struct:ovsrec_port
bond_enable_slave	.\ofproto\bond.c	/^bond_enable_slave(struct bond_slave *slave, bool enable)$/;"	f	file:
bond_entry	.\ofproto\bond.c	/^struct bond_entry {$/;"	s	file:
bond_entry_reset	.\ofproto\bond.c	/^bond_entry_reset(struct bond *bond)$/;"	f	file:
bond_fake_iface	.\lib\vswitch-idl.h	/^	bool bond_fake_iface;$/;"	m	struct:ovsrec_port
bond_find_slave_by_mac	.\ofproto\bond.c	/^bond_find_slave_by_mac(const struct bond *bond, const uint8_t mac[6])$/;"	f	file:
bond_get_changed_active_slave	.\ofproto\bond.c	/^bond_get_changed_active_slave(const char *name, uint8_t* mac, bool force)$/;"	f
bond_hash	.\ofproto\bond.c	/^bond_hash(const struct bond *bond, const struct flow *flow, uint16_t vlan)$/;"	f	file:
bond_hash_src	.\ofproto\bond.c	/^bond_hash_src(const uint8_t mac[ETH_ADDR_LEN], uint16_t vlan, uint32_t basis)$/;"	f	file:
bond_hash_tcp	.\ofproto\bond.c	/^bond_hash_tcp(const struct flow *flow, uint16_t vlan, uint32_t basis)$/;"	f	file:
bond_init	.\ofproto\bond.c	/^bond_init(void)$/;"	f
bond_link_status_update	.\ofproto\bond.c	/^bond_link_status_update(struct bond_slave *slave)$/;"	f	file:
bond_lookup_slave	.\ofproto\bond.c	/^bond_lookup_slave(struct bond *bond, const char *slave_name)$/;"	f	file:
bond_may_recirc	.\ofproto\bond.c	/^bond_may_recirc(const struct bond *bond, uint32_t *recirc_id,$/;"	f
bond_mode	.\lib\vswitch-idl.h	/^	char *bond_mode;$/;"	m	struct:ovsrec_port
bond_mode	.\ofproto\bond.h	/^enum bond_mode {$/;"	g
bond_mode_from_string	.\ofproto\bond.c	/^bond_mode_from_string(enum bond_mode *balance, const char *s)$/;"	f
bond_mode_to_string	.\ofproto\bond.c	/^bond_mode_to_string(enum bond_mode balance) {$/;"	f
bond_op	.\ofproto\bond.c	/^enum bond_op {$/;"	g	file:
bond_pr_rule_op	.\ofproto\bond.c	/^struct bond_pr_rule_op {$/;"	s	file:
bond_rebalance	.\ofproto\bond.c	/^bond_rebalance(struct bond *bond)$/;"	f
bond_reconfigure	.\ofproto\bond.c	/^bond_reconfigure(struct bond *bond, const struct bond_settings *s)$/;"	f
bond_ref	.\ofproto\bond.c	/^bond_ref(const struct bond *bond_)$/;"	f
bond_revalidate	.\ofproto\bond.c	/^    bool bond_revalidate;       \/* True if flows need revalidation. *\/$/;"	m	struct:bond	file:
bond_run	.\ofproto\bond.c	/^bond_run(struct bond *bond, enum lacp_status lacp_status)$/;"	f
bond_settings	.\ofproto\bond.h	/^struct bond_settings {$/;"	s
bond_should_send_learning_packets	.\ofproto\bond.c	/^bond_should_send_learning_packets(struct bond *bond)$/;"	f
bond_slave	.\ofproto\bond.c	/^struct bond_slave {$/;"	s	file:
bond_slave_lookup	.\ofproto\bond.c	/^bond_slave_lookup(struct bond *bond, const void *slave_)$/;"	f	file:
bond_slave_register	.\ofproto\bond.c	/^bond_slave_register(struct bond *bond, void *slave_,$/;"	f
bond_slave_set_may_enable	.\ofproto\bond.c	/^bond_slave_set_may_enable(struct bond *bond, void *slave_, bool may_enable)$/;"	f
bond_slave_set_netdev	.\ofproto\bond.c	/^bond_slave_set_netdev(struct bond *bond, void *slave_, struct netdev *netdev)$/;"	f
bond_slave_unregister	.\ofproto\bond.c	/^bond_slave_unregister(struct bond *bond, const void *slave_)$/;"	f
bond_unixctl_disable_slave	.\ofproto\bond.c	/^bond_unixctl_disable_slave(struct unixctl_conn *conn,$/;"	f	file:
bond_unixctl_enable_slave	.\ofproto\bond.c	/^bond_unixctl_enable_slave(struct unixctl_conn *conn,$/;"	f	file:
bond_unixctl_hash	.\ofproto\bond.c	/^bond_unixctl_hash(struct unixctl_conn *conn, int argc, const char *argv[],$/;"	f	file:
bond_unixctl_list	.\ofproto\bond.c	/^bond_unixctl_list(struct unixctl_conn *conn,$/;"	f	file:
bond_unixctl_migrate	.\ofproto\bond.c	/^bond_unixctl_migrate(struct unixctl_conn *conn,$/;"	f	file:
bond_unixctl_set_active_slave	.\ofproto\bond.c	/^bond_unixctl_set_active_slave(struct unixctl_conn *conn,$/;"	f	file:
bond_unixctl_show	.\ofproto\bond.c	/^bond_unixctl_show(struct unixctl_conn *conn,$/;"	f	file:
bond_unref	.\ofproto\bond.c	/^bond_unref(struct bond *bond)$/;"	f
bond_update_fake_slave_stats	.\ofproto\bond.c	/^bond_update_fake_slave_stats(struct bond *bond)$/;"	f	file:
bond_update_post_recirc_rules	.\ofproto\bond.c	/^bond_update_post_recirc_rules(struct bond* bond, const bool force)$/;"	f
bond_updelay	.\lib\vswitch-idl.h	/^	int64_t bond_updelay;$/;"	m	struct:ovsrec_port
bond_verdict	.\ofproto\bond.h	/^enum bond_verdict {$/;"	g
bond_wait	.\ofproto\bond.c	/^bond_wait(struct bond *bond)$/;"	f
bonding_driver_loaded	.\xenserver\opt_xensource_libexec_InterfaceReconfigureBridge.py	/^def bonding_driver_loaded():$/;"	f
bool	.\datapath\linux\compat\include\linux\types.h	/^typedef _Bool bool;$/;"	t
boolean	.\lib\ovsdb-data.h	/^    bool boolean;$/;"	m	union:ovsdb_atom
bootTime	.\lib\sflow_api.h	/^    time_t bootTime;        \/* time when we booted or started *\/$/;"	m	struct:_SFLAgent
boot_time	.\lib\timeval.c	/^static long long int boot_time;$/;"	v	file:
boot_time	.\ofproto\netflow.c	/^    long long int boot_time;      \/* Time when netflow_create() was called. *\/$/;"	m	struct:netflow	file:
booted	.\lib\cfm.c	/^    bool booted;           \/* A full fault interval has occurred. *\/$/;"	m	struct:cfm	file:
booted	.\vswitchd\system-stats.c	/^    long long int booted;       \/* ms since monitor started. *\/$/;"	m	struct:process_info	file:
bootstrap_ca_cert	.\lib\stream-ssl.c	/^static bool bootstrap_ca_cert;$/;"	v	file:
bootstrap_ca_cert	.\lib\vswitch-idl.h	/^	bool bootstrap_ca_cert;$/;"	m	struct:ovsrec_ssl
bootstrap_ca_cert	.\ovsdb\ovsdb-server.c	/^static bool bootstrap_ca_cert;$/;"	v	file:
both_modules	.\datapath\Modules.mk	/^both_modules = openvswitch$/;"	m
bound_port	.\lib\stream-provider.h	/^    ovs_be16 bound_port;$/;"	m	struct:pstream
bound_port	.\ovsdb\jsonrpc-server.h	/^    ovs_be16 bound_port;$/;"	m	struct:ovsdb_jsonrpc_remote_status
bpdu	.\tests\test-stp.c	/^struct bpdu {$/;"	s	file:
br_cfg	.\utilities\ovs-vsctl.c	/^    struct ovsrec_bridge *br_cfg;$/;"	m	struct:vsctl_bridge	typeref:struct:vsctl_bridge::ovsrec_bridge	file:
br_name	.\ofproto\ofproto.h	/^    char *br_name;              \/* Name of owning bridge. *\/$/;"	m	struct:iface_hint
br_refresh_stp_status	.\vswitchd\bridge.c	/^br_refresh_stp_status(struct bridge *br)$/;"	f	file:
br_should_route_hook	.\datapath\vport-netdev.c	/^EXPORT_SYMBOL(br_should_route_hook);$/;"	v
br_type	.\ofproto\ofproto.h	/^    char *br_type;              \/* Type of owning bridge. *\/$/;"	m	struct:iface_hint
bridge	.\lib\vswitch-idl.h	/^	struct ovsrec_bridge *bridge;$/;"	m	struct:ovsrec_flow_sample_collector_set	typeref:struct:ovsrec_flow_sample_collector_set::ovsrec_bridge
bridge	.\tests\test-stp.c	/^    struct bridge *bridge;$/;"	m	struct:lan_conn	typeref:struct:lan_conn::bridge	file:
bridge	.\tests\test-stp.c	/^struct bridge {$/;"	s	file:
bridge	.\utilities\ovs-vsctl.c	/^    struct vsctl_bridge *bridge;$/;"	m	struct:vsctl_port	typeref:struct:vsctl_port::vsctl_bridge	file:
bridge	.\vswitchd\bridge.c	/^    struct bridge *bridge;$/;"	m	struct:mirror	typeref:struct:mirror::bridge	file:
bridge	.\vswitchd\bridge.c	/^    struct bridge *bridge;$/;"	m	struct:port	typeref:struct:port::bridge	file:
bridge	.\vswitchd\bridge.c	/^VLOG_DEFINE_THIS_MODULE(bridge);$/;"	v
bridge	.\vswitchd\bridge.c	/^struct bridge {$/;"	s	file:
bridgePort	.\lib\sflow_api.h	/^    u_int32_t bridgePort; \/* port number local to bridge *\/$/;"	m	struct:_SFLPoller
bridge_add_ports	.\vswitchd\bridge.c	/^bridge_add_ports(struct bridge *br, const struct shash *wanted_ports)$/;"	f	file:
bridge_add_ports__	.\vswitchd\bridge.c	/^bridge_add_ports__(struct bridge *br, const struct shash *wanted_ports,$/;"	f	file:
bridge_collect_wanted_ports	.\vswitchd\bridge.c	/^bridge_collect_wanted_ports(struct bridge *br,$/;"	f	file:
bridge_configure_datapath_id	.\vswitchd\bridge.c	/^bridge_configure_datapath_id(struct bridge *br)$/;"	f	file:
bridge_configure_dp_desc	.\vswitchd\bridge.c	/^bridge_configure_dp_desc(struct bridge *br)$/;"	f	file:
bridge_configure_forward_bpdu	.\vswitchd\bridge.c	/^bridge_configure_forward_bpdu(struct bridge *br)$/;"	f	file:
bridge_configure_ipfix	.\vswitchd\bridge.c	/^bridge_configure_ipfix(struct bridge *br)$/;"	f	file:
bridge_configure_local_iface_netdev	.\vswitchd\bridge.c	/^bridge_configure_local_iface_netdev(struct bridge *br,$/;"	f	file:
bridge_configure_mac_table	.\vswitchd\bridge.c	/^bridge_configure_mac_table(struct bridge *br)$/;"	f	file:
bridge_configure_mirrors	.\vswitchd\bridge.c	/^bridge_configure_mirrors(struct bridge *br)$/;"	f	file:
bridge_configure_netflow	.\vswitchd\bridge.c	/^bridge_configure_netflow(struct bridge *br)$/;"	f	file:
bridge_configure_remotes	.\vswitchd\bridge.c	/^bridge_configure_remotes(struct bridge *br,$/;"	f	file:
bridge_configure_sflow	.\vswitchd\bridge.c	/^bridge_configure_sflow(struct bridge *br, int *sflow_bridge_number)$/;"	f	file:
bridge_configure_stp	.\vswitchd\bridge.c	/^bridge_configure_stp(struct bridge *br)$/;"	f	file:
bridge_configure_tables	.\vswitchd\bridge.c	/^bridge_configure_tables(struct bridge *br)$/;"	f	file:
bridge_create	.\vswitchd\bridge.c	/^bridge_create(const struct ovsrec_bridge *br_cfg)$/;"	f	file:
bridge_del_ports	.\vswitchd\bridge.c	/^bridge_del_ports(struct bridge *br, const struct shash *wanted_ports)$/;"	f	file:
bridge_delete_ofprotos	.\vswitchd\bridge.c	/^bridge_delete_ofprotos(void)$/;"	f	file:
bridge_delete_or_reconfigure_ports	.\vswitchd\bridge.c	/^bridge_delete_or_reconfigure_ports(struct bridge *br)$/;"	f	file:
bridge_delete_port	.\utilities\ovs-vsctl.c	/^bridge_delete_port(struct ovsrec_bridge *br, struct ovsrec_port *port)$/;"	f	file:
bridge_destroy	.\vswitchd\bridge.c	/^bridge_destroy(struct bridge *br)$/;"	f	file:
bridge_exit	.\vswitchd\bridge.c	/^bridge_exit(void)$/;"	f
bridge_exporter	.\ofproto\ofproto-dpif-ipfix.c	/^    struct dpif_ipfix_bridge_exporter bridge_exporter;$/;"	m	struct:dpif_ipfix	typeref:struct:dpif_ipfix::dpif_ipfix_bridge_exporter	file:
bridge_forward_delay	.\lib\stp.c	/^    int bridge_forward_delay;       \/* 8.5.3.10: forward_delay as root. *\/$/;"	m	struct:stp	file:
bridge_get_allowed_versions	.\vswitchd\bridge.c	/^bridge_get_allowed_versions(struct bridge *br)$/;"	f	file:
bridge_get_controllers	.\vswitchd\bridge.c	/^bridge_get_controllers(const struct bridge *br,$/;"	f	file:
bridge_get_memory_usage	.\vswitchd\bridge.c	/^bridge_get_memory_usage(struct simap *usage)$/;"	f
bridge_has_bond_fake_iface	.\vswitchd\bridge.c	/^bridge_has_bond_fake_iface(const struct bridge *br, const char *name)$/;"	f	file:
bridge_hello_time	.\lib\stp.c	/^    int bridge_hello_time;          \/* 8.5.3.9: hello_time as root. *\/$/;"	m	struct:stp	file:
bridge_id	.\lib\stp.c	/^    stp_identifier bridge_id;       \/* 8.5.3.7: This bridge. *\/$/;"	m	struct:stp	file:
bridge_id	.\ofproto\ofproto.h	/^    stp_identifier bridge_id;$/;"	m	struct:ofproto_stp_status
bridge_init	.\vswitchd\bridge.c	/^bridge_init(const char *remote)$/;"	f
bridge_init_ofproto	.\vswitchd\bridge.c	/^bridge_init_ofproto(const struct ovsrec_open_vswitch *cfg)$/;"	f	file:
bridge_insert_port	.\utilities\ovs-vsctl.c	/^bridge_insert_port(struct ovsrec_bridge *br, struct ovsrec_port *port)$/;"	f	file:
bridge_lookup	.\vswitchd\bridge.c	/^bridge_lookup(const char *name)$/;"	f	file:
bridge_max_age	.\lib\stp.c	/^    int bridge_max_age;             \/* 8.5.3.8: max_age when we're root. *\/$/;"	m	struct:stp	file:
bridge_ofproto_controller_for_mgmt	.\vswitchd\bridge.c	/^bridge_ofproto_controller_for_mgmt(const struct bridge *br,$/;"	f	file:
bridge_ofproto_controller_from_ovsrec	.\vswitchd\bridge.c	/^bridge_ofproto_controller_from_ovsrec(const struct ovsrec_controller *c,$/;"	f	file:
bridge_pick_datapath_id	.\vswitchd\bridge.c	/^bridge_pick_datapath_id(struct bridge *br,$/;"	f	file:
bridge_pick_local_hw_addr	.\vswitchd\bridge.c	/^bridge_pick_local_hw_addr(struct bridge *br, uint8_t ea[ETH_ADDR_LEN],$/;"	f	file:
bridge_reconfigure	.\vswitchd\bridge.c	/^COVERAGE_DEFINE(bridge_reconfigure);$/;"	v
bridge_reconfigure	.\vswitchd\bridge.c	/^bridge_reconfigure(const struct ovsrec_open_vswitch *ovs_cfg)$/;"	f	file:
bridge_run	.\vswitchd\bridge.c	/^bridge_run(void)$/;"	f
bridge_run__	.\vswitchd\bridge.c	/^bridge_run__(void)$/;"	f	file:
bridge_unixctl_dump_flows	.\vswitchd\bridge.c	/^bridge_unixctl_dump_flows(struct unixctl_conn *conn, int argc OVS_UNUSED,$/;"	f	file:
bridge_unixctl_dump_flows	.\vswitchd\bridge.c	/^static unixctl_cb_func bridge_unixctl_dump_flows;$/;"	v	file:
bridge_unixctl_reconnect	.\vswitchd\bridge.c	/^bridge_unixctl_reconnect(struct unixctl_conn *conn, int argc,$/;"	f	file:
bridge_unixctl_reconnect	.\vswitchd\bridge.c	/^static unixctl_cb_func bridge_unixctl_reconnect;$/;"	v	file:
bridge_wait	.\vswitchd\bridge.c	/^bridge_wait(void)$/;"	f
bridges	.\lib\vswitch-idl.h	/^	struct ovsrec_bridge **bridges;$/;"	m	struct:ovsrec_open_vswitch	typeref:struct:ovsrec_open_vswitch::ovsrec_bridge
bridges	.\tests\test-stp.c	/^    struct bridge *bridges[16];$/;"	m	struct:test_case	typeref:struct:test_case::bridge	file:
bridges	.\utilities\ovs-vsctl.c	/^    struct shash bridges;   \/* Maps from bridge name to struct vsctl_bridge. *\/$/;"	m	struct:vsctl_context	typeref:struct:vsctl_context::shash	file:
bring_down	.\xenserver\opt_xensource_libexec_InterfaceReconfigure.py	/^    def bring_down(self):$/;"	m	class:Datapath
bring_down	.\xenserver\opt_xensource_libexec_InterfaceReconfigureBridge.py	/^    def bring_down(self):$/;"	m	class:DatapathBridge
bring_down	.\xenserver\opt_xensource_libexec_InterfaceReconfigureVswitch.py	/^    def bring_down(self):$/;"	m	class:DatapathVswitch
bring_down_existing	.\xenserver\opt_xensource_libexec_InterfaceReconfigure.py	/^    def bring_down_existing(self):$/;"	m	class:Datapath
bring_down_existing	.\xenserver\opt_xensource_libexec_InterfaceReconfigureBridge.py	/^    def bring_down_existing(self):$/;"	m	class:DatapathBridge
bring_down_existing	.\xenserver\opt_xensource_libexec_InterfaceReconfigureVswitch.py	/^    def bring_down_existing(self):$/;"	m	class:DatapathVswitch
bring_down_interface	.\xenserver\opt_xensource_libexec_InterfaceReconfigureBridge.py	/^def bring_down_interface(pif, destroy=False):$/;"	f
bring_up_interface	.\xenserver\opt_xensource_libexec_InterfaceReconfigureBridge.py	/^def bring_up_interface(pif):$/;"	f
broadcastPkts	.\lib\sflow.h	/^    u_int32_t broadcastPkts;$/;"	m	struct:_SFLVlan_counters
bucket	.\lib\dpif-netdev.c	/^    uint32_t bucket;$/;"	m	struct:dp_netdev_flow_iter	file:
bucket	.\lib\dpif-netdev.c	/^    uint32_t bucket;$/;"	m	struct:dp_netdev_port_state	file:
bucket	.\ofproto\ofproto-dpif.c	/^    uint32_t bucket;$/;"	m	struct:port_dump_state	file:
bucket_counter	.\lib\ofp-util.h	/^struct bucket_counter {$/;"	s
bucket_is_alive	.\ofproto\ofproto-dpif-xlate.c	/^bucket_is_alive(const struct xlate_ctx *ctx,$/;"	f	file:
bucket_stats	.\lib\ofp-util.h	/^    struct bucket_counter *bucket_stats;$/;"	m	struct:ofputil_group_stats	typeref:struct:ofputil_group_stats::bucket_counter
buckets	.\datapath\flow_table.h	/^	struct flex_array *buckets;$/;"	m	struct:table_instance	typeref:struct:table_instance::flex_array
buckets	.\lib\hindex.h	/^    struct hindex_node **buckets; \/* Must point to 'one' iff 'mask' == 0. *\/$/;"	m	struct:hindex	typeref:struct:hindex::hindex_node
buckets	.\lib\hmap.h	/^    struct hmap_node **buckets; \/* Must point to 'one' iff 'mask' == 0. *\/$/;"	m	struct:hmap	typeref:struct:hmap::hmap_node
buckets	.\lib\ofp-util.h	/^    struct list buckets;          \/* Contains "struct ofputil_bucket"s. *\/$/;"	m	struct:ofputil_group_mod	typeref:struct:ofputil_group_mod::list
buckets	.\lib\ofp-util.h	/^    struct list buckets;        \/* Contains "struct ofputil_bucket"s. *\/$/;"	m	struct:ofputil_group_desc	typeref:struct:ofputil_group_desc::list
buckets	.\lib\ovs-thread.h	/^    void *volatile buckets[16];$/;"	m	struct:ovsthread_stats
buckets	.\ofproto\ofproto-provider.h	/^    struct list buckets;        \/* Contains "struct ofputil_bucket"s. *\/$/;"	m	struct:ofgroup	typeref:struct:ofgroup::list
buf	.\lib\dpif-linux.c	/^    struct ofpbuf buf;$/;"	m	struct:dpif_linux_port_state	typeref:struct:dpif_linux_port_state::ofpbuf	file:
buf	.\lib\dpif-netdev.c	/^    struct ofpbuf buf;          \/* ofpbuf instance for upcall.packet. *\/$/;"	m	struct:dp_netdev_upcall	typeref:struct:dp_netdev_upcall::ofpbuf	file:
buf	.\lib\netdev-linux.c	/^    struct ofpbuf buf;$/;"	m	struct:queue_dump_state	typeref:struct:queue_dump_state::ofpbuf	file:
buf_size	.\lib\netdev-dpdk.c	/^    int buf_size;$/;"	m	struct:netdev_dpdk	file:
buffer	.\lib\async-append-aio.c	/^    uint8_t *buffer;$/;"	m	struct:async_append	file:
buffer	.\lib\byteq.h	/^    uint8_t *buffer;            \/* Circular queue. *\/$/;"	m	struct:byteq
buffer	.\lib\dpif-linux.c	/^    struct ofpbuf buffer;         \/* Always used to store flows. *\/$/;"	m	struct:dpif_linux_flow_state	typeref:struct:dpif_linux_flow_state::ofpbuf	file:
buffer	.\lib\json.c	/^    struct ds buffer;           \/* Buffer for accumulating token text. *\/$/;"	m	struct:json_parser	typeref:struct:json_parser::ds	file:
buffer	.\ofproto\pktbuf.c	/^    struct ofpbuf *buffer;$/;"	m	struct:packet	typeref:struct:packet::ofpbuf	file:
buffer_hz	.\lib\netdev-linux.c	/^static unsigned int buffer_hz;$/;"	v	file:
buffer_id	.\include\openflow\nicira-ext.h	/^    ovs_be32 buffer_id;           \/* Buffered packet to apply to (or -1).$/;"	m	struct:nx_flow_mod
buffer_id	.\include\openflow\nicira-ext.h	/^    ovs_be32 buffer_id;       \/* ID assigned by datapath. *\/$/;"	m	struct:nx_packet_in
buffer_id	.\include\openflow\openflow-1.0.h	/^    ovs_be32 buffer_id;           \/* Buffered packet to apply to (or -1).$/;"	m	struct:ofp10_flow_mod
buffer_id	.\include\openflow\openflow-1.0.h	/^    ovs_be32 buffer_id;           \/* ID assigned by datapath or UINT32_MAX. *\/$/;"	m	struct:ofp10_packet_out
buffer_id	.\include\openflow\openflow-1.0.h	/^    ovs_be32 buffer_id;     \/* ID assigned by datapath. *\/$/;"	m	struct:ofp10_packet_in
buffer_id	.\include\openflow\openflow-1.1.h	/^    ovs_be32 buffer_id;          \/* Buffered packet to apply to (or -1).$/;"	m	struct:ofp11_flow_mod
buffer_id	.\include\openflow\openflow-1.1.h	/^    ovs_be32 buffer_id;       \/* ID assigned by datapath (-1 if none). *\/$/;"	m	struct:ofp11_packet_out
buffer_id	.\include\openflow\openflow-1.1.h	/^    ovs_be32 buffer_id;     \/* ID assigned by datapath. *\/$/;"	m	struct:ofp11_packet_in
buffer_id	.\include\openflow\openflow-1.2.h	/^    ovs_be32 buffer_id;     \/* ID assigned by datapath. *\/$/;"	m	struct:ofp12_packet_in
buffer_id	.\lib\ofp-util.h	/^    uint32_t buffer_id;         \/* Buffer id or UINT32_MAX if no buffer. *\/$/;"	m	struct:ofputil_packet_out
buffer_id	.\lib\ofp-util.h	/^    uint32_t buffer_id;$/;"	m	struct:ofputil_flow_mod
buffer_id	.\lib\ofp-util.h	/^    uint32_t buffer_id;$/;"	m	struct:ofputil_packet_in
buffer_id	.\ofproto\ofproto.c	/^    uint32_t buffer_id;         \/* Buffer id from original request. *\/$/;"	m	struct:ofopgroup	file:
buffer_idx	.\ofproto\pktbuf.c	/^    unsigned int buffer_idx;$/;"	m	struct:pktbuf	file:
bugtool_plugins	.\utilities\bugtool\automake.mk	/^bugtool_plugins = \\$/;"	m
bugtool_scripts	.\utilities\bugtool\automake.mk	/^bugtool_scripts = \\$/;"	m
bugtoolpluginsdir	.\utilities\bugtool\automake.mk	/^bugtoolpluginsdir = $(pkgdatadir)\/bugtool-plugins$/;"	m
build_headers	.\datapath\Modules.mk	/^build_headers = $(foreach module,$(build_modules),$($(module)_headers))$/;"	m
build_links	.\datapath\Modules.mk	/^build_links = $(notdir $(build_sources))$/;"	m
build_modules	.\datapath\Modules.mk	/^build_modules = $(both_modules)	# Modules to build$/;"	m
build_objects	.\datapath\Modules.mk	/^build_objects = $(notdir $(patsubst %.c,%.o,$(build_sources)))$/;"	m
build_sources	.\datapath\Modules.mk	/^build_sources = $(foreach module,$(build_modules),$($(module)_sources))$/;"	m
bundle	.\lib\bundle.c	/^VLOG_DEFINE_THIS_MODULE(bundle);$/;"	v
bundle	.\lib\ofp-actions.c	/^    struct nx_action_bundle bundle;$/;"	m	union:ofp_action	typeref:struct:ofp_action::nx_action_bundle	file:
bundle	.\ofproto\ofproto-dpif.c	/^    struct ofbundle *bundle;    \/* Bundle that contains this port, if any. *\/$/;"	m	struct:ofport_dpif	typeref:struct:ofport_dpif::ofbundle	file:
bundle_add_port	.\ofproto\ofproto-dpif.c	/^bundle_add_port(struct ofbundle *bundle, ofp_port_t ofp_port,$/;"	f	file:
bundle_check	.\lib\bundle.c	/^bundle_check(const struct ofpact_bundle *bundle, ofp_port_t max_ports,$/;"	f
bundle_del_port	.\ofproto\ofproto-dpif.c	/^bundle_del_port(struct ofport_dpif *port)$/;"	f	file:
bundle_destroy	.\ofproto\ofproto-dpif.c	/^bundle_destroy(struct ofbundle *bundle)$/;"	f	file:
bundle_execute	.\lib\bundle.c	/^bundle_execute(const struct ofpact_bundle *bundle,$/;"	f
bundle_flags_to_name	.\lib\ofp-print.c	/^bundle_flags_to_name(uint32_t bit)$/;"	f	file:
bundle_flush_macs	.\ofproto\ofproto-dpif.c	/^bundle_flush_macs(struct ofbundle *bundle, bool all_ofprotos)$/;"	f	file:
bundle_format	.\lib\bundle.c	/^bundle_format(const struct ofpact_bundle *bundle, struct ds *s)$/;"	f
bundle_from_openflow	.\lib\bundle.c	/^bundle_from_openflow(const struct nx_action_bundle *nab,$/;"	f
bundle_hash	.\ofproto\bundles.c	/^bundle_hash(uint32_t id)$/;"	f	file:
bundle_id	.\include\openflow\openflow-1.4.h	/^    ovs_be32 bundle_id;     \/* Identify the bundle. *\/$/;"	m	struct:ofp14_bundle_ctrl_msg
bundle_id	.\lib\ofp-util.h	/^    uint32_t            bundle_id;$/;"	m	struct:ofputil_bundle_add_msg
bundle_id	.\lib\ofp-util.h	/^    uint32_t    bundle_id;$/;"	m	struct:ofputil_bundle_ctrl_msg
bundle_lookup	.\ofproto\ofproto-dpif.c	/^bundle_lookup(const struct ofproto_dpif *ofproto, void *aux)$/;"	f	file:
bundle_message	.\ofproto\bundles.c	/^struct bundle_message {$/;"	s	file:
bundle_node	.\ofproto\ofproto-dpif-xlate.c	/^    struct list bundle_node;         \/* In parent xbundle (if it exists). *\/$/;"	m	struct:xport	typeref:struct:xport::list	file:
bundle_node	.\ofproto\ofproto-dpif.c	/^    struct list bundle_node;    \/* In struct ofbundle's "ports" list. *\/$/;"	m	struct:ofport_dpif	typeref:struct:ofport_dpif::list	file:
bundle_parse	.\lib\bundle.c	/^bundle_parse(const char *s, struct ofpbuf *ofpacts)$/;"	f
bundle_parse__	.\lib\bundle.c	/^bundle_parse__(const char *s, char **save_ptr,$/;"	f	file:
bundle_parse_load	.\lib\bundle.c	/^bundle_parse_load(const char *s, struct ofpbuf *ofpacts)$/;"	f
bundle_remove	.\ofproto\ofproto-dpif.c	/^bundle_remove(struct ofport *port_)$/;"	f	file:
bundle_remove	.\ofproto\ofproto-provider.h	/^    void (*bundle_remove)(struct ofport *ofport);$/;"	m	struct:ofproto_class
bundle_run	.\ofproto\ofproto-dpif.c	/^bundle_run(struct ofbundle *bundle)$/;"	f	file:
bundle_send_learning_packets	.\ofproto\ofproto-dpif.c	/^bundle_send_learning_packets(struct ofbundle *bundle)$/;"	f	file:
bundle_set	.\ofproto\ofproto-dpif.c	/^bundle_set(struct ofproto *ofproto_, void *aux,$/;"	f	file:
bundle_set	.\ofproto\ofproto-provider.h	/^    int (*bundle_set)(struct ofproto *ofproto, void *aux,$/;"	m	struct:ofproto_class
bundle_state	.\ofproto\bundles.c	/^enum bundle_state {$/;"	g	file:
bundle_to_nxast	.\lib\bundle.c	/^bundle_to_nxast(const struct ofpact_bundle *bundle, struct ofpbuf *openflow)$/;"	f
bundle_update	.\ofproto\ofproto-dpif.c	/^bundle_update(struct ofbundle *bundle)$/;"	f	file:
bundle_wait	.\ofproto\ofproto-dpif.c	/^bundle_wait(struct ofbundle *bundle)$/;"	f	file:
bundles	.\ofproto\bundles.c	/^VLOG_DEFINE_THIS_MODULE(bundles);$/;"	v
bundles	.\ofproto\connmgr.c	/^    struct hmap bundles;$/;"	m	struct:ofconn	typeref:struct:ofconn::hmap	file:
bundles	.\ofproto\ofproto-dpif.c	/^    struct hmap bundles;        \/* Contains "struct ofbundle"s. *\/$/;"	m	struct:ofproto_dpif	typeref:struct:ofproto_dpif::hmap	file:
burst	.\lib\netdev-linux.c	/^    unsigned int burst;         \/* In bytes. *\/$/;"	m	struct:htb_class	file:
burst	.\lib\token-bucket.h	/^    unsigned int burst;         \/* Max cumulative tokens credit. *\/$/;"	m	struct:token_bucket
burst_limit	.\ofproto\connmgr.c	/^    int burst_limit;            \/* Limit on accumulating packet credits. *\/$/;"	m	struct:ofservice	file:
burst_limit	.\ofproto\ofproto.h	/^    int burst_limit;            \/* Limit on accumulating packet credits. *\/$/;"	m	struct:ofproto_controller
burst_pkts	.\lib\netdev-dpdk.c	/^    struct rte_mbuf *burst_pkts[MAX_TX_QUEUE_LEN];$/;"	m	struct:dpdk_tx_queue	typeref:struct:dpdk_tx_queue::rte_mbuf	file:
burst_size	.\include\openflow\openflow-1.3.h	/^    ovs_be32    burst_size;  \/* Size of bursts. *\/$/;"	m	struct:ofp13_action_self_learning::ofp13_meter_band_drop
burst_size	.\include\openflow\openflow-1.3.h	/^    ovs_be32    burst_size;  \/* Size of bursts. *\/$/;"	m	struct:ofp13_action_self_learning::ofp13_meter_band_dscp_remark
burst_size	.\include\openflow\openflow-1.3.h	/^    ovs_be32    burst_size;  \/* Size of bursts. *\/$/;"	m	struct:ofp13_action_self_learning::ofp13_meter_band_experimenter
burst_size	.\include\openflow\openflow-1.3.h	/^    ovs_be32 burst_size; \/* Size of bursts. *\/$/;"	m	struct:ofp13_action_self_learning::ofp13_meter_band_header
burst_size	.\lib\ofp-util.h	/^    uint32_t burst_size;$/;"	m	struct:ofputil_meter_band
byte_band_count	.\include\openflow\openflow-1.3.h	/^    ovs_be64    byte_band_count;        \/* Number of bytes in band. *\/$/;"	m	struct:ofp13_action_self_learning::ofp13_meter_band_stats
byte_count	.\datapath\flow.h	/^	u64 byte_count;			\/* Number of bytes matched. *\/$/;"	m	struct:flow_stats
byte_count	.\include\openflow\nicira-ext.h	/^    ovs_be64 byte_count;      \/* Number of bytes, UINT64_MAX if unknown. *\/$/;"	m	struct:nx_flow_stats
byte_count	.\include\openflow\nicira-ext.h	/^    ovs_be64 byte_count;$/;"	m	struct:nx_flow_removed
byte_count	.\include\openflow\openflow-1.0.h	/^    ovs_32aligned_be64 byte_count;   \/* Number of bytes in flow. *\/$/;"	m	struct:ofp10_flow_stats
byte_count	.\include\openflow\openflow-1.0.h	/^    ovs_be64 byte_count;$/;"	m	struct:ofp10_flow_removed
byte_count	.\include\openflow\openflow-1.1.h	/^    ovs_be64 byte_count;       \/* Number of bytes in flow. *\/$/;"	m	struct:ofp11_flow_stats
byte_count	.\include\openflow\openflow-1.1.h	/^    ovs_be64 byte_count;       \/* Number of bytes processed by group. *\/$/;"	m	struct:ofp11_group_stats
byte_count	.\include\openflow\openflow-1.1.h	/^    ovs_be64 byte_count;     \/* Number of bytes processed by bucket. *\/$/;"	m	struct:ofp11_bucket_counter
byte_count	.\include\openflow\openflow-1.1.h	/^    ovs_be64 byte_count;$/;"	m	struct:ofp11_flow_removed
byte_count	.\include\openflow\openflow-1.2.h	/^    ovs_be64 byte_count;$/;"	m	struct:ofp12_flow_removed
byte_count	.\include\openflow\openflow-common.h	/^    ovs_32aligned_be64 byte_count;   \/* Number of bytes in flows. *\/$/;"	m	struct:ofp_aggregate_stats_reply
byte_count	.\lib\netflow.h	/^    ovs_be32 byte_count;           \/* Number of bytes. *\/$/;"	m	struct:netflow_v5_record
byte_count	.\lib\ofp-util.h	/^    uint64_t byte_count;        \/* Byte count, UINT64_MAX if unknown. *\/$/;"	m	struct:ofputil_aggregate_stats
byte_count	.\lib\ofp-util.h	/^    uint64_t byte_count;        \/* Byte count, UINT64_MAX if unknown. *\/$/;"	m	struct:ofputil_flow_removed
byte_count	.\lib\ofp-util.h	/^    uint64_t byte_count;        \/* Byte count, UINT64_MAX if unknown. *\/$/;"	m	struct:ofputil_flow_stats
byte_count	.\lib\ofp-util.h	/^    uint64_t byte_count;        \/* Byte count, UINT64_MAX if unknown. *\/$/;"	m	struct:ofputil_group_stats
byte_count	.\lib\ofp-util.h	/^    uint64_t byte_count;     \/* Number of bytes processed by bucket. *\/$/;"	m	struct:bucket_counter
byte_count	.\lib\ofp-util.h	/^    uint64_t byte_count;$/;"	m	struct:ofputil_meter_band_stats
byte_count	.\ofproto\netflow.c	/^    uint64_t byte_count;          \/* Bytes from subrules. *\/$/;"	m	struct:netflow_flow	file:
byte_count	.\ofproto\ofproto-dpif-mirror.c	/^    int64_t byte_count;         \/* Number of bytes sent. *\/$/;"	m	struct:mirror	file:
byte_in_count	.\include\openflow\openflow-1.3.h	/^    ovs_be64  byte_in_count;     \/* Number of bytes in input. *\/$/;"	m	struct:ofp13_action_self_learning::ofp13_meter_stats
byte_in_count	.\lib\ofp-util.h	/^    uint64_t byte_in_count;$/;"	m	struct:ofputil_meter_stats
byte_number	.\lib\json.c	/^    int byte_number;$/;"	m	struct:json_parser	file:
byteq	.\lib\async-append-aio.c	/^    struct byteq byteq;$/;"	m	struct:async_append	typeref:struct:async_append::byteq	file:
byteq	.\lib\byteq.h	/^struct byteq {$/;"	s
byteq_advance_head	.\lib\byteq.c	/^byteq_advance_head(struct byteq *q, unsigned int n)$/;"	f
byteq_advance_tail	.\lib\byteq.c	/^byteq_advance_tail(struct byteq *q, unsigned int n)$/;"	f
byteq_avail	.\lib\byteq.c	/^byteq_avail(const struct byteq *q)$/;"	f
byteq_get	.\lib\byteq.c	/^byteq_get(struct byteq *q)$/;"	f
byteq_head	.\lib\byteq.c	/^byteq_head(struct byteq *q)$/;"	f
byteq_headroom	.\lib\byteq.c	/^byteq_headroom(const struct byteq *q)$/;"	f
byteq_init	.\lib\byteq.c	/^byteq_init(struct byteq *q, uint8_t *buffer, size_t size)$/;"	f
byteq_is_empty	.\lib\byteq.c	/^byteq_is_empty(const struct byteq *q)$/;"	f
byteq_is_full	.\lib\byteq.c	/^byteq_is_full(const struct byteq *q)$/;"	f
byteq_put	.\lib\byteq.c	/^byteq_put(struct byteq *q, uint8_t c)$/;"	f
byteq_put_string	.\lib\byteq.c	/^byteq_put_string(struct byteq *q, const char *s)$/;"	f
byteq_putn	.\lib\byteq.c	/^byteq_putn(struct byteq *q, const void *p_, size_t n)$/;"	f
byteq_read	.\lib\byteq.c	/^byteq_read(struct byteq *q, int fd)$/;"	f
byteq_tail	.\lib\byteq.c	/^byteq_tail(const struct byteq *q)$/;"	f
byteq_tailroom	.\lib\byteq.c	/^byteq_tailroom(const struct byteq *q)$/;"	f
byteq_used	.\lib\byteq.c	/^byteq_used(const struct byteq *q)$/;"	f
byteq_write	.\lib\byteq.c	/^byteq_write(struct byteq *q, int fd)$/;"	f
bytes	.\python\compat\uuid.py	/^    bytes = property(get_bytes)$/;"	v	class:UUID
bytes_from_local	.\lib\vtep-idl.h	/^	int64_t bytes_from_local;$/;"	m	struct:vteprec_logical_binding_stats
bytes_le	.\python\compat\uuid.py	/^    bytes_le = property(get_bytes_le)$/;"	v	class:UUID
bytes_to_local	.\lib\vtep-idl.h	/^	int64_t bytes_to_local;$/;"	m	struct:vteprec_logical_binding_stats
cDeclComment	.\python\ovs\db\types.py	/^    def cDeclComment(self):$/;"	m	class:Type
cInitAtom	.\python\ovs\db\data.py	/^    def cInitAtom(self, var):$/;"	m	class:Atom
cInitBaseType	.\python\ovs\db\types.py	/^    def cInitBaseType(self, indent, var):$/;"	m	class:BaseType
cInitDatum	.\python\ovs\db\data.py	/^    def cInitDatum(self, var):$/;"	m	class:Datum
cInitType	.\python\ovs\db\types.py	/^    def cInitType(self, indent, var):$/;"	m	class:Type
ca_cert	.\lib\stream-ssl.c	/^static struct ssl_config_file ca_cert;$/;"	v	typeref:struct:ssl_config_file	file:
ca_cert	.\lib\vswitch-idl.h	/^	char *ca_cert;	\/* Always nonnull. *\/$/;"	m	struct:ovsrec_ssl
ca_cert_file	.\ovsdb\ovsdb-server.c	/^static char *ca_cert_file;$/;"	v	file:
cache_active_timeout	.\lib\vswitch-idl.h	/^	int64_t *cache_active_timeout;$/;"	m	struct:ovsrec_ipfix
cache_active_timeout	.\ofproto\ofproto-dpif-ipfix.c	/^    uint32_t cache_active_timeout;  \/* In seconds. *\/$/;"	m	struct:dpif_ipfix_exporter	file:
cache_active_timeout	.\ofproto\ofproto.h	/^    uint32_t cache_active_timeout;$/;"	m	struct:ofproto_ipfix_bridge_exporter_options
cache_active_timeout	.\ofproto\ofproto.h	/^    uint32_t cache_active_timeout;$/;"	m	struct:ofproto_ipfix_flow_exporter_options
cache_flow_key_map	.\ofproto\ofproto-dpif-ipfix.c	/^    struct hmap cache_flow_key_map;  \/* ipfix_flow_cache_entry. *\/$/;"	m	struct:dpif_ipfix_exporter	typeref:struct:dpif_ipfix_exporter::hmap	file:
cache_flow_start_timestamp_list	.\ofproto\ofproto-dpif-ipfix.c	/^    struct list cache_flow_start_timestamp_list;  \/* ipfix_flow_cache_entry. *\/$/;"	m	struct:dpif_ipfix_exporter	typeref:struct:dpif_ipfix_exporter::list	file:
cache_flow_start_timestamp_list_node	.\ofproto\ofproto-dpif-ipfix.c	/^    struct list cache_flow_start_timestamp_list_node;$/;"	m	struct:ipfix_flow_cache_entry	typeref:struct:ipfix_flow_cache_entry::list	file:
cache_max_flows	.\lib\vswitch-idl.h	/^	int64_t *cache_max_flows;$/;"	m	struct:ovsrec_ipfix
cache_max_flows	.\ofproto\ofproto-dpif-ipfix.c	/^    uint32_t cache_max_flows;$/;"	m	struct:dpif_ipfix_exporter	file:
cache_max_flows	.\ofproto\ofproto.h	/^    uint32_t cache_max_flows;$/;"	m	struct:ofproto_ipfix_bridge_exporter_options
cache_max_flows	.\ofproto\ofproto.h	/^    uint32_t cache_max_flows;$/;"	m	struct:ofproto_ipfix_flow_exporter_options
cache_notifier_ref	.\lib\netdev-bsd.c	/^cache_notifier_ref(void)$/;"	f	file:
cache_notifier_refcount	.\lib\netdev-bsd.c	/^static int cache_notifier_refcount;$/;"	v	file:
cache_notifier_unref	.\lib\netdev-bsd.c	/^cache_notifier_unref(void)$/;"	f	file:
cache_valid	.\lib\netdev-bsd.c	/^    unsigned int cache_valid;$/;"	m	struct:netdev_bsd	file:
cache_valid	.\lib\netdev-linux.c	/^    unsigned int cache_valid;$/;"	m	struct:netdev_linux	file:
cache_valid	.\lib\vlandev.c	/^static bool cache_valid;$/;"	v	file:
cache_valid	.\utilities\ovs-vsctl.c	/^    bool cache_valid;$/;"	m	struct:vsctl_context	file:
cache_valid	.\vtep\vtep-ctl.c	/^    bool cache_valid;$/;"	m	struct:vtep_ctl_context	file:
calc_duration	.\ofproto\ofproto.c	/^calc_duration(long long int start, long long int now,$/;"	f	file:
calc_mask	.\lib\hmap.c	/^calc_mask(size_t capacity)$/;"	f	file:
call_hooks	.\lib\fatal-signal.c	/^call_hooks(int sig_nr)$/;"	f	file:
can_checksum_protocol	.\datapath\linux\compat\netdevice.c	/^static bool can_checksum_protocol(netdev_features_t features, __be16 protocol)$/;"	f	file:
cancel_cb	.\lib\fatal-signal.c	/^    void (*cancel_cb)(void *aux);$/;"	m	struct:hook	file:
cancel_files	.\lib\fatal-signal.c	/^cancel_files(void *aux OVS_UNUSED)$/;"	f	file:
capabilities	.\include\openflow\openflow-1.2.h	/^    ovs_be32  capabilities;    \/* Bitmap of OFPGFC12_* capability supported. *\/$/;"	m	struct:ofp12_group_features_stats
capabilities	.\include\openflow\openflow-1.3.h	/^    ovs_be32   capabilities;  \/* Bitmaps of "ofp13_meter_flags". *\/$/;"	m	struct:ofp13_action_self_learning::ofp13_meter_features
capabilities	.\include\openflow\openflow-common.h	/^    ovs_be32 capabilities;  \/* OFPC_*, OFPC10_*, OFPC11_*, OFPC12_*. *\/$/;"	m	struct:ofp_switch_features
capabilities	.\lib\ofp-util.h	/^    enum ofputil_capabilities capabilities;$/;"	m	struct:ofputil_switch_features	typeref:enum:ofputil_switch_features::ofputil_capabilities
capabilities	.\lib\ofp-util.h	/^    uint32_t  capabilities;    \/* Bitmap of OFPGFC12_* capability supported. *\/$/;"	m	struct:ofputil_group_features
capabilities	.\lib\ofp-util.h	/^    uint32_t capabilities;      \/* Supported flags. *\/$/;"	m	struct:ofputil_meter_features
capacity	.\ofproto\ofproto-provider.h	/^    size_t capacity;            \/* Number of rules that will fit in 'rules'. *\/$/;"	m	struct:rule_collection
caption	.\lib\table.h	/^    char *caption;$/;"	m	struct:table
carrier	.\lib\netdev-bsd.c	/^    int carrier;$/;"	m	struct:netdev_bsd	file:
carrier_resets	.\lib\netdev-linux.c	/^    long long int carrier_resets;$/;"	m	struct:netdev_linux	file:
carrier_seq	.\ofproto\ofproto-dpif.c	/^    long long int carrier_seq;  \/* Carrier status changes. *\/$/;"	m	struct:ofport_dpif	file:
carrier_status	.\lib\netdev-vport.c	/^    bool carrier_status;$/;"	m	struct:netdev_vport	file:
cb	.\lib\netlink-notifier.c	/^    nln_notify_func *cb;$/;"	m	struct:nln_notifier	file:
cb	.\lib\rtbsd.h	/^    rtbsd_notify_func *cb;$/;"	m	struct:rtbsd_notifier
cb	.\lib\unixctl.c	/^    unixctl_cb_func *cb;$/;"	m	struct:unixctl_command	file:
cbs	.\lib\ovs-rcu.c	/^    struct ovsrcu_cb cbs[16];$/;"	m	struct:ovsrcu_cbset	typeref:struct:ovsrcu_cbset::ovsrcu_cb	file:
cbset	.\lib\ovs-rcu.c	/^    struct ovsrcu_cbset *cbset;$/;"	m	struct:ovsrcu_perthread	typeref:struct:ovsrcu_perthread::ovsrcu_cbset	file:
ccm_interval	.\lib\cfm.c	/^    uint8_t ccm_interval;  \/* The CCM transmission interval. *\/$/;"	m	struct:cfm	file:
ccm_interval_ms	.\lib\cfm.c	/^    int ccm_interval_ms;   \/* 'ccm_interval' in milliseconds. *\/$/;"	m	struct:cfm	file:
ccm_interval_to_ms	.\lib\cfm.c	/^ccm_interval_to_ms(uint8_t interval)$/;"	f	file:
ccm_pcp	.\lib\cfm.c	/^    uint8_t ccm_pcp;       \/* Priority of CCM PDUs. *\/$/;"	m	struct:cfm	file:
ccm_pcp	.\lib\cfm.h	/^    uint8_t ccm_pcp;            \/* CCM Priority. Zero if none. *\/$/;"	m	struct:cfm_settings
ccm_vlan	.\lib\cfm.c	/^    uint16_t ccm_vlan;     \/* Vlan tag of CCM PDUs.  CFM_RANDOM_VLAN if$/;"	m	struct:cfm	file:
ccm_vlan	.\lib\cfm.h	/^    uint16_t ccm_vlan;          \/* CCM Vlan tag. Zero if none.$/;"	m	struct:cfm_settings
cell	.\lib\table.h	/^struct cell {$/;"	s
cell_destroy	.\lib\table.c	/^cell_destroy(struct cell *cell)$/;"	f	file:
cell_format	.\lib\table.h	/^    enum cell_format cell_format; \/* CF_*. *\/$/;"	m	struct:table_style	typeref:enum:table_style::cell_format
cell_format	.\lib\table.h	/^enum cell_format {$/;"	g
cell_to_text	.\lib\table.c	/^cell_to_text(struct cell *cell, const struct table_style *style)$/;"	f	file:
cells	.\lib\table.h	/^    struct cell *cells;$/;"	m	struct:table	typeref:struct:table::cell
certificate	.\lib\stream-ssl.c	/^static struct ssl_config_file certificate;$/;"	v	typeref:struct:ssl_config_file	file:
certificate	.\lib\vswitch-idl.h	/^	char *certificate;	\/* Always nonnull. *\/$/;"	m	struct:ovsrec_ssl
certificate_file	.\ovsdb\ovsdb-server.c	/^static char *certificate_file;$/;"	v	file:
cfg	.\vswitchd\bridge.c	/^    const struct ovsrec_bridge *cfg;$/;"	m	struct:bridge	typeref:struct:bridge::ovsrec_bridge	file:
cfg	.\vswitchd\bridge.c	/^    const struct ovsrec_interface *cfg;$/;"	m	struct:iface	typeref:struct:iface::ovsrec_interface	file:
cfg	.\vswitchd\bridge.c	/^    const struct ovsrec_mirror *cfg;$/;"	m	struct:mirror	typeref:struct:mirror::ovsrec_mirror	file:
cfg	.\vswitchd\bridge.c	/^    const struct ovsrec_port *cfg;$/;"	m	struct:port	typeref:struct:port::ovsrec_port	file:
cfg_min_rx	.\lib\bfd.c	/^    long long int cfg_min_rx;     \/* Configured required minimum RX rate. *\/$/;"	m	struct:bfd	file:
cfg_min_tx	.\lib\bfd.c	/^    long long int cfg_min_tx;     \/* Configured minimum TX rate. *\/$/;"	m	struct:bfd	file:
cfm	.\lib\cfm.c	/^VLOG_DEFINE_THIS_MODULE(cfm);$/;"	v
cfm	.\lib\cfm.c	/^struct cfm {$/;"	s	file:
cfm	.\ofproto\ofproto-dpif-monitor.c	/^    struct cfm *cfm;                  \/* Reference to cfm. *\/$/;"	m	struct:mport	typeref:struct:mport::cfm	file:
cfm	.\ofproto\ofproto-dpif-xlate.c	/^    struct cfm *cfm;                 \/* CFM handle or null. *\/$/;"	m	struct:xport	typeref:struct:xport::cfm	file:
cfm	.\ofproto\ofproto-dpif.c	/^    struct cfm *cfm;            \/* Connectivity Fault Management, if any. *\/$/;"	m	struct:ofport_dpif	typeref:struct:ofport_dpif::cfm	file:
cfm_ccm_addr	.\lib\cfm.c	/^cfm_ccm_addr(struct cfm *cfm)$/;"	f	file:
cfm_fault	.\lib\vswitch-idl.h	/^	bool *cfm_fault;$/;"	m	struct:ovsrec_interface
cfm_fault_bit_index	.\lib\cfm.h	/^enum cfm_fault_bit_index {$/;"	g
cfm_fault_reason	.\lib\cfm.h	/^enum cfm_fault_reason {$/;"	g
cfm_fault_reason_to_str	.\lib\cfm.c	/^cfm_fault_reason_to_str(int reason)$/;"	f
cfm_fault_status	.\lib\vswitch-idl.h	/^	char **cfm_fault_status;$/;"	m	struct:ovsrec_interface
cfm_flap_count	.\lib\vswitch-idl.h	/^	int64_t *cfm_flap_count;$/;"	m	struct:ovsrec_interface
cfm_health	.\lib\vswitch-idl.h	/^	int64_t *cfm_health;$/;"	m	struct:ovsrec_interface
cfm_init	.\lib\cfm.c	/^cfm_init(void)$/;"	f
cfm_is_valid_mpid	.\lib\cfm.c	/^cfm_is_valid_mpid(bool extended, uint64_t mpid)$/;"	f	file:
cfm_mpid	.\lib\vswitch-idl.h	/^	int64_t *cfm_mpid;$/;"	m	struct:ovsrec_interface
cfm_ref	.\lib\cfm.c	/^cfm_ref(const struct cfm *cfm_)$/;"	f
cfm_remote_mpids	.\lib\vswitch-idl.h	/^	int64_t *cfm_remote_mpids;$/;"	m	struct:ovsrec_interface
cfm_remote_opstate	.\lib\vswitch-idl.h	/^	char *cfm_remote_opstate;$/;"	m	struct:ovsrec_interface
cfm_settings	.\lib\cfm.h	/^struct cfm_settings {$/;"	s
cfm_should_process_flow	.\lib\cfm.c	/^cfm_should_process_flow(const struct cfm *cfm_, const struct flow *flow,$/;"	f
cfm_unixctl_set_fault	.\lib\cfm.c	/^static unixctl_cb_func cfm_unixctl_set_fault;$/;"	v	file:
cfm_unixctl_show	.\lib\cfm.c	/^static unixctl_cb_func cfm_unixctl_show;$/;"	v	file:
chaddr	.\lib\dhcp.h	/^    uint8_t chaddr[16];         \/* Client hardware address. *\/$/;"	m	struct:dhcp_header
change	.\lib\netlink-notifier.c	/^    void *change;                \/* Change passed to parse. *\/$/;"	m	struct:nln	file:
change_detection_enabled	.\lib\stp.c	/^    bool change_detection_enabled;  \/* 8.5.5.10: Detect topology changes? *\/$/;"	m	struct:stp_port	file:
change_seq	.\lib\dpif-netdev.c	/^    atomic_uint change_seq;$/;"	m	struct:pmd_thread	file:
change_seq	.\lib\netdev-provider.h	/^    uint64_t change_seq;$/;"	m	struct:netdev
change_seq	.\ofproto\bond.c	/^    unsigned int change_seq;    \/* Tracks changes in 'netdev'. *\/$/;"	m	struct:bond_slave	file:
change_seq	.\ofproto\ofproto-dpif.c	/^    uint64_t change_seq;           \/* Connectivity status changes. *\/$/;"	m	struct:ofproto_dpif	file:
change_seq	.\ofproto\ofproto-provider.h	/^    uint64_t change_seq;        \/* Change sequence for netdev status. *\/$/;"	m	struct:ofproto
change_seq	.\ofproto\ofproto-provider.h	/^    uint64_t change_seq;$/;"	m	struct:ofport
change_seq	.\ofproto\tunnel.c	/^    unsigned int change_seq;$/;"	m	struct:tnl_port	file:
change_seq	.\vswitchd\bridge.c	/^    uint64_t change_seq;$/;"	m	struct:iface	file:
change_seqno	.\lib\ovsdb-idl.c	/^    unsigned int change_seqno;$/;"	m	struct:ovsdb_idl	file:
changed	.\ovsdb\transaction.c	/^    unsigned long changed[];    \/* Bits set to 1 for columns that changed. *\/$/;"	m	struct:ovsdb_txn_row	file:
changed	.\xenserver\opt_xensource_libexec_InterfaceReconfigure.py	/^    def changed(self):$/;"	m	class:ConfigurationFile
changes	.\ovsdb\jsonrpc-server.c	/^    struct hmap changes;$/;"	m	struct:ovsdb_jsonrpc_monitor_table	typeref:struct:ovsdb_jsonrpc_monitor_table::hmap	file:
channels	.\lib\dpif-linux.c	/^    struct dpif_channel *channels;\/* Array of channels for each handler. *\/$/;"	m	struct:dpif_handler	typeref:struct:dpif_handler::dpif_channel	file:
chdir_	.\lib\daemon-unix.c	/^static bool chdir_ = true;$/;"	v	file:
check	.\tests\test-lockfile.c	/^check(int a, int b,$/;"	f	file:
check	.\tests\test-vconn.c	/^check(int a, int b, const char *as, const char *file, int line)$/;"	f	file:
check	.\utilities\ovs-dev.py	/^def check():$/;"	f
check_3word_hash	.\tests\test-hash.c	/^check_3word_hash(uint32_t (*hash)(const uint32_t[], size_t, uint32_t),$/;"	f	file:
check_already_running	.\lib\daemon-unix.c	/^check_already_running(void)$/;"	f	file:
check_checksum	.\datapath\linux\compat\gre.c	/^static __sum16 check_checksum(struct sk_buff *skb)$/;"	f	file:
check_clz32	.\tests\test-util.c	/^check_clz32(uint32_t x, int n)$/;"	f	file:
check_clz64	.\tests\test-util.c	/^check_clz64(uint64_t x, int n)$/;"	f	file:
check_conflicts	.\utilities\ovs-vsctl.c	/^check_conflicts(struct vsctl_context *ctx, const char *name,$/;"	f	file:
check_connection_completion	.\lib\socket-util.c	/^check_connection_completion(int fd)$/;"	f
check_connection_completion	.\python\ovs\socket_util.py	/^def check_connection_completion(sock):$/;"	f
check_constraints	.\python\ovs\db\data.py	/^    def check_constraints(self):$/;"	m	class:Datum
check_constraints	.\python\ovs\db\data.py	/^    def check_constraints(self, base):$/;"	m	class:Atom
check_count_1bits	.\tests\test-util.c	/^check_count_1bits(uint64_t x, int n)$/;"	f	file:
check_ctz32	.\tests\test-util.c	/^check_ctz32(uint32_t x, int n)$/;"	f	file:
check_ctz64	.\tests\test-util.c	/^check_ctz64(uint64_t x, int n)$/;"	f	file:
check_errno	.\tests\test-vconn.c	/^check_errno(int a, int b, const char *as, const char *file, int line)$/;"	f	file:
check_expectations	.\lib\odp-util.c	/^check_expectations(uint64_t present_attrs, int out_of_range_attr,$/;"	f	file:
check_header	.\datapath\flow.c	/^static int check_header(struct sk_buff *skb, int len)$/;"	f	file:
check_heap	.\tests\test-heap.c	/^check_heap(const struct heap *heap, const uint32_t priorities[], size_t n)$/;"	f	file:
check_hindex	.\tests\test-hindex.c	/^check_hindex(struct hindex *hindex, const int values[], size_t n,$/;"	f	file:
check_hmap	.\tests\test-hmap.c	/^check_hmap(struct hmap *hmap, const int values[], size_t n,$/;"	f	file:
check_index_uniqueness	.\ovsdb\transaction.c	/^check_index_uniqueness(struct ovsdb_txn *txn OVS_UNUSED,$/;"	f	file:
check_int_div	.\ovsdb\mutation.c	/^check_int_div(int64_t x, int64_t y)$/;"	f	file:
check_iphdr	.\datapath\flow.c	/^static int check_iphdr(struct sk_buff *skb)$/;"	f	file:
check_json_type	.\lib\ovsdb-idl.c	/^check_json_type(const struct json *json, enum json_type type, const char *name)$/;"	f	file:
check_link_status	.\lib\netdev-dpdk.c	/^check_link_status(struct netdev_dpdk *dev)$/;"	f	file:
check_list	.\tests\test-list.c	/^check_list(struct list *list, const int values[], size_t n)$/;"	f	file:
check_log_2_floor	.\tests\test-util.c	/^check_log_2_floor(uint32_t x, int n)$/;"	f	file:
check_mask_consistency	.\lib\nx-match.c	/^check_mask_consistency(const uint8_t *p, const struct mf_field *mf)$/;"	f	file:
check_max_mpls_depth	.\ofproto\ofproto-dpif.c	/^check_max_mpls_depth(struct dpif_backer *backer)$/;"	f	file:
check_max_rows	.\ovsdb\transaction.c	/^check_max_rows(struct ovsdb_txn *txn)$/;"	f	file:
check_mutable	.\utilities\ovs-vsctl.c	/^check_mutable(const struct vsctl_table_class *table,$/;"	f	file:
check_mutable	.\vtep\vtep-ctl.c	/^check_mutable(const struct vtep_ctl_table_class *table,$/;"	f	file:
check_ovsdb_error	.\ovsdb\ovsdb-client.c	/^check_ovsdb_error(struct ovsdb_error *error)$/;"	f	file:
check_ovsdb_error	.\ovsdb\ovsdb-tool.c	/^check_ovsdb_error(struct ovsdb_error *error)$/;"	f	file:
check_ovsdb_error	.\tests\test-ovsdb.c	/^check_ovsdb_error(struct ovsdb_error *error)$/;"	f	file:
check_rdp2	.\tests\test-util.c	/^check_rdp2(uint32_t x, int n)$/;"	f	file:
check_real_range	.\ovsdb\mutation.c	/^check_real_range(double x)$/;"	f	file:
check_recirc	.\ofproto\ofproto-dpif.c	/^check_recirc(struct dpif_backer *backer)$/;"	f	file:
check_ref_count	.\ovsdb\transaction.c	/^check_ref_count(struct ovsdb_txn *txn OVS_UNUSED, struct ovsdb_txn_row *r)$/;"	f	file:
check_rup2	.\tests\test-util.c	/^check_rup2(uint32_t x, int n)$/;"	f	file:
check_service	.\lib\daemon-windows.c	/^check_service()$/;"	f	file:
check_stream_classes	.\lib\stream.c	/^check_stream_classes(void)$/;"	f	file:
check_string_constraints	.\lib\ovsdb-data.c	/^check_string_constraints(const char *s,$/;"	f	file:
check_table_id	.\ofproto\ofproto.c	/^check_table_id(const struct ofproto *ofproto, uint8_t table_id)$/;"	f	file:
check_tnl_key	.\lib\bfd.c	/^    atomic_bool check_tnl_key;    \/* Verify tunnel key of inbound packets? *\/$/;"	m	struct:bfd	file:
check_tnl_key	.\lib\cfm.c	/^    atomic_bool check_tnl_key; \/* Verify the tunnel key of inbound packets? *\/$/;"	m	struct:cfm	file:
check_tnl_key	.\lib\cfm.h	/^    bool check_tnl_key;         \/* Verify inbound packet key? *\/$/;"	m	struct:cfm_settings
check_tries	.\lib\classifier.c	/^check_tries(struct trie_ctx trie_ctx[CLS_MAX_TRIES], unsigned int n_tries,$/;"	f	file:
check_txn	.\ovsdb\ovsdb-client.c	/^check_txn(int error, struct jsonrpc_msg **reply_)$/;"	f	file:
check_variable_length_userdata	.\ofproto\ofproto-dpif.c	/^check_variable_length_userdata(struct dpif_backer *backer)$/;"	f	file:
check_vconn_classes	.\lib\vconn.c	/^check_vconn_classes(void)$/;"	f	file:
check_word_hash	.\tests\test-hash.c	/^check_word_hash(uint32_t (*hash)(uint32_t), const char *name,$/;"	f	file:
children	.\utilities\ovs-vsctl.c	/^    struct hmap children;        \/* VLAN bridges indexed by 'vlan'. *\/$/;"	m	struct:vsctl_bridge	typeref:struct:vsctl_bridge::hmap	file:
children_node	.\utilities\ovs-vsctl.c	/^    struct hmap_node children_node; \/* Node in parent's 'children' hmap. *\/$/;"	m	struct:vsctl_bridge	typeref:struct:vsctl_bridge::hmap_node	file:
choose	.\tests\test-classifier.c	/^choose(unsigned int n, unsigned int *idxp)$/;"	f	file:
choose_miss_rule	.\ofproto\ofproto-dpif.c	/^choose_miss_rule(enum ofputil_port_config config, struct rule_dpif *miss_rule,$/;"	f
choose_output_slave	.\ofproto\bond.c	/^choose_output_slave(const struct bond *bond, const struct flow *flow,$/;"	f	file:
ciaddr	.\lib\dhcp.h	/^    ovs_be32 ciaddr;            \/* Client IP, if it has a lease for one. *\/$/;"	m	struct:dhcp_header
cksum	.\ovsdb\ovsdb.h	/^    char *cksum;$/;"	m	struct:ovsdb_schema
clamp	.\lib\stp.c	/^clamp(int x, int min, int max)$/;"	f	file:
class	.\lib\dpif-netdev.c	/^    const struct dpif_class *const class;$/;"	m	struct:dp_netdev	file:
class	.\lib\netdev.c	/^    const struct netdev_class *class;$/;"	m	struct:netdev_registered_class	typeref:struct:netdev_registered_class::netdev_class	file:
class	.\lib\ovsdb-idl.c	/^    const struct ovsdb_idl_class *class;$/;"	m	struct:ovsdb_idl	typeref:struct:ovsdb_idl::ovsdb_idl_class	file:
class	.\tests\test-ovsdb.c	/^    struct do_query_distinct_class *class;$/;"	m	struct:do_query_distinct_row	typeref:struct:do_query_distinct_row::do_query_distinct_class	file:
class	.\utilities\ovs-vsctl.c	/^    struct ovsdb_idl_table_class *class;$/;"	m	struct:vsctl_table_class	typeref:struct:vsctl_table_class::ovsdb_idl_table_class	file:
class	.\vtep\vtep-ctl.c	/^    struct ovsdb_idl_table_class *class;$/;"	m	struct:vtep_ctl_table_class	typeref:struct:vtep_ctl_table_class::ovsdb_idl_table_class	file:
class_delete	.\lib\netdev-linux.c	/^    int (*class_delete)(struct netdev *, struct tc_queue *queue);$/;"	m	struct:tc_ops	file:
class_dump_stats	.\lib\netdev-linux.c	/^    int (*class_dump_stats)(const struct netdev *netdev,$/;"	m	struct:tc_ops	file:
class_get	.\lib\netdev-linux.c	/^    int (*class_get)(const struct netdev *netdev, const struct tc_queue *queue,$/;"	m	struct:tc_ops	file:
class_get_stats	.\lib\netdev-linux.c	/^    int (*class_get_stats)(const struct netdev *netdev,$/;"	m	struct:tc_ops	file:
class_set	.\lib\netdev-linux.c	/^    int (*class_set)(struct netdev *, unsigned int queue_id,$/;"	m	struct:tc_ops	file:
classifier	.\lib\classifier.c	/^VLOG_DEFINE_THIS_MODULE(classifier);$/;"	v
classifier	.\lib\classifier.h	/^struct classifier {$/;"	s
classifier_count	.\lib\classifier.c	/^classifier_count(const struct classifier *cls)$/;"	f
classifier_destroy	.\lib\classifier.c	/^classifier_destroy(struct classifier *cls_)$/;"	f
classifier_find_match_exactly	.\lib\classifier.c	/^classifier_find_match_exactly(const struct classifier *cls,$/;"	f
classifier_find_rule_exactly	.\lib\classifier.c	/^classifier_find_rule_exactly(const struct classifier *cls_,$/;"	f
classifier_init	.\lib\classifier.c	/^classifier_init(struct classifier *cls_, const uint8_t *flow_segments)$/;"	f
classifier_insert	.\lib\classifier.c	/^classifier_insert(struct classifier *cls, struct cls_rule *rule)$/;"	f
classifier_is_empty	.\lib\classifier.c	/^classifier_is_empty(const struct classifier *cls)$/;"	f
classifier_lookup	.\lib\classifier.c	/^classifier_lookup(const struct classifier *cls_, const struct flow *flow,$/;"	f
classifier_lookup_miniflow_first	.\lib\classifier.c	/^struct cls_rule *classifier_lookup_miniflow_first(const struct classifier *cls_,$/;"	f
classifier_remove	.\lib\classifier.c	/^classifier_remove(struct classifier *cls_, struct cls_rule *rule)$/;"	f
classifier_replace	.\lib\classifier.c	/^classifier_replace(struct classifier *cls_, struct cls_rule *rule)$/;"	f
classifier_rule_overlaps	.\lib\classifier.c	/^classifier_rule_overlaps(const struct classifier *cls_,$/;"	f
classifier_set_prefix_fields	.\lib\classifier.c	/^classifier_set_prefix_fields(struct classifier *cls_,$/;"	f
classify_upcall	.\ofproto\ofproto-dpif-upcall.c	/^classify_upcall(const struct upcall *upcall)$/;"	f	file:
clauses	.\ovsdb\condition.h	/^    struct ovsdb_clause *clauses;$/;"	m	struct:ovsdb_condition	typeref:struct:ovsdb_condition::ovsdb_clause
cleanup	.\python\ovstest\rpcserver.py	/^    def cleanup(self):$/;"	m	class:TestArena
cleanup	.\tests\ovstest.c	/^cleanup(void)$/;"	f	file:
clear	.\lib\dpif-linux.c	/^    bool clear;                         \/* OVS_FLOW_ATTR_CLEAR. *\/$/;"	m	struct:dpif_linux_flow	file:
clear_handle	.\lib\stream-ssl.c	/^clear_handle(int fd OVS_UNUSED, HANDLE wevent OVS_UNUSED)$/;"	f	file:
clear_macs	.\vtep\vtep-ctl.c	/^clear_macs(struct vtep_ctl_context *ctx, bool local)$/;"	f	file:
clear_skb_priorities	.\ofproto\ofproto-dpif-xlate.c	/^clear_skb_priorities(struct xport *xport)$/;"	f	file:
clear_slot	.\lib\ovs-thread.c	/^clear_slot(struct ovsthread_key_slots *slots, unsigned int index)$/;"	f	file:
clear_stats	.\lib\dpif-netdev.c	/^clear_stats(struct dp_netdev_flow *netdev_flow)$/;"	f	file:
client	.\tests\appctl.py	/^import ovs.unixctl.client$/;"	i
clock	.\lib\timeval.c	/^struct clock {$/;"	s	file:
clock_gettime	.\lib\timeval.c	/^clock_gettime(clock_t id, struct timespec *ts)$/;"	f	file:
clock_seq	.\python\compat\uuid.py	/^    clock_seq = property(get_clock_seq)$/;"	v	class:UUID
clock_seq_hi_variant	.\python\compat\uuid.py	/^    clock_seq_hi_variant = property(get_clock_seq_hi_variant)$/;"	v	class:UUID
clock_seq_low	.\python\compat\uuid.py	/^    clock_seq_low = property(get_clock_seq_low)$/;"	v	class:UUID
clockid_t	.\lib\timeval.c	/^typedef unsigned int clockid_t;$/;"	t	file:
clone_atoms	.\lib\ovsdb-data.c	/^clone_atoms(const union ovsdb_atom *old, enum ovsdb_atomic_type type, size_t n)$/;"	f	file:
clone_monitor_row_data	.\ovsdb\jsonrpc-server.c	/^clone_monitor_row_data(const struct ovsdb_jsonrpc_monitor_table *mt,$/;"	f	file:
clone_rule	.\tests\test-classifier.c	/^clone_rule(const struct test_rule *src)$/;"	f	file:
close	.\lib\dpif-provider.h	/^    void (*close)(struct dpif *dpif);$/;"	m	struct:dpif_class
close	.\lib\stream-provider.h	/^    void (*close)(struct pstream *pstream);$/;"	m	struct:pstream_class
close	.\lib\stream-provider.h	/^    void (*close)(struct stream *stream);$/;"	m	struct:stream_class
close	.\lib\vconn-provider.h	/^    void (*close)(struct pvconn *pvconn);$/;"	m	struct:pvconn_class
close	.\lib\vconn-provider.h	/^    void (*close)(struct vconn *vconn);$/;"	m	struct:vconn_class
close	.\python\ovs\db\idl.py	/^    def close(self):$/;"	m	class:Idl
close	.\python\ovs\jsonrpc.py	/^    def close(self):$/;"	m	class:Connection
close	.\python\ovs\jsonrpc.py	/^    def close(self):$/;"	m	class:Session
close	.\python\ovs\stream.py	/^    def close(self):$/;"	m	class:PassiveStream
close	.\python\ovs\stream.py	/^    def close(self):$/;"	m	class:Stream
close	.\python\ovs\unixctl\client.py	/^    def close(self):$/;"	m	class:UnixctlClient
close	.\python\ovs\unixctl\server.py	/^    def close(self):$/;"	m	class:UnixctlClient
close	.\python\ovs\unixctl\server.py	/^    def close(self):$/;"	m	class:UnixctlServer
close	.\xenserver\opt_xensource_libexec_InterfaceReconfigure.py	/^    def close(self):$/;"	m	class:ConfigurationFile
close_dpif_backer	.\ofproto\ofproto-dpif.c	/^close_dpif_backer(struct dpif_backer *backer)$/;"	f	file:
close_standard_fds	.\lib\daemon.c	/^close_standard_fds(void)$/;"	f
closesocket	.\lib\socket-util.h	128;"	d
cls	.\lib\classifier.h	/^    const struct cls_classifier *cls;$/;"	m	struct:cls_cursor	typeref:struct:cls_cursor::cls_classifier
cls	.\lib\classifier.h	/^    struct cls_classifier *cls;$/;"	m	struct:classifier	typeref:struct:classifier::cls_classifier
cls	.\lib\dpif-netdev.c	/^    struct classifier cls;      \/* Classifier.  Protected by cls.rwlock. *\/$/;"	m	struct:dp_netdev	typeref:struct:dp_netdev::classifier	file:
cls	.\ofproto\ofproto-provider.h	/^    struct classifier cls;      \/* Contains "struct rule"s. *\/$/;"	m	struct:oftable	typeref:struct:oftable::classifier
cls_cb_func	.\lib\classifier.h	/^typedef void cls_cb_func(struct cls_rule *, void *aux);$/;"	t
cls_classifier	.\lib\classifier.c	/^struct cls_classifier {$/;"	s	file:
cls_cursor	.\lib\classifier.h	/^struct cls_cursor {$/;"	s
cls_cursor_first	.\lib\classifier.c	/^cls_cursor_first(struct cls_cursor *cursor)$/;"	f
cls_cursor_init	.\lib\classifier.c	/^cls_cursor_init(struct cls_cursor *cursor, const struct classifier *cls,$/;"	f
cls_cursor_next	.\lib\classifier.c	/^cls_cursor_next(struct cls_cursor *cursor, const struct cls_rule *rule_)$/;"	f
cls_field	.\tests\test-classifier.c	/^struct cls_field {$/;"	s	file:
cls_fields	.\tests\test-classifier.c	/^static const struct cls_field cls_fields[CLS_N_FIELDS] = {$/;"	v	typeref:struct:cls_field	file:
cls_match	.\lib\classifier.c	/^struct cls_match {$/;"	s	file:
cls_match	.\lib\classifier.h	/^    struct cls_match *cls_match; \/* NULL if rule is not in a classifier. *\/$/;"	m	struct:cls_rule	typeref:struct:cls_rule::cls_match
cls_match_alloc	.\lib\classifier.c	/^cls_match_alloc(struct cls_rule *rule)$/;"	f	file:
cls_partition	.\lib\classifier.c	/^struct cls_partition {$/;"	s	file:
cls_rule	.\lib\classifier.c	/^    struct cls_rule *cls_rule;$/;"	m	struct:cls_match	typeref:struct:cls_match::cls_rule	file:
cls_rule	.\lib\classifier.h	/^struct cls_rule {$/;"	s
cls_rule	.\tests\test-classifier.c	/^    struct cls_rule cls_rule;   \/* Classifier rule data. *\/$/;"	m	struct:test_rule	typeref:struct:test_rule::cls_rule	file:
cls_rule_clone	.\lib\classifier.c	/^cls_rule_clone(struct cls_rule *dst, const struct cls_rule *src)$/;"	f
cls_rule_destroy	.\lib\classifier.c	/^cls_rule_destroy(struct cls_rule *rule)$/;"	f
cls_rule_equal	.\lib\classifier.c	/^cls_rule_equal(const struct cls_rule *a, const struct cls_rule *b)$/;"	f
cls_rule_format	.\lib\classifier.c	/^cls_rule_format(const struct cls_rule *rule, struct ds *s)$/;"	f
cls_rule_hash	.\lib\classifier.c	/^cls_rule_hash(const struct cls_rule *rule, uint32_t basis)$/;"	f
cls_rule_init	.\lib\classifier.c	/^cls_rule_init(struct cls_rule *rule,$/;"	f
cls_rule_init_from_minimatch	.\lib\classifier.c	/^cls_rule_init_from_minimatch(struct cls_rule *rule,$/;"	f
cls_rule_is_catchall	.\lib\classifier.c	/^cls_rule_is_catchall(const struct cls_rule *rule)$/;"	f
cls_rule_is_loose_match	.\lib\classifier.c	/^cls_rule_is_loose_match(const struct cls_rule *rule,$/;"	f
cls_rule_move	.\lib\classifier.c	/^cls_rule_move(struct cls_rule *dst, struct cls_rule *src)$/;"	f
cls_subtable	.\lib\classifier.c	/^struct cls_subtable {$/;"	s	file:
cls_subtable_cache	.\lib\classifier.c	/^struct cls_subtable_cache {$/;"	s	file:
cls_subtable_cache_destroy	.\lib\classifier.c	/^cls_subtable_cache_destroy(struct cls_subtable_cache *array)$/;"	f	file:
cls_subtable_cache_init	.\lib\classifier.c	/^cls_subtable_cache_init(struct cls_subtable_cache *array)$/;"	f	file:
cls_subtable_cache_move	.\lib\classifier.c	/^cls_subtable_cache_move(struct cls_subtable_entry *to,$/;"	f	file:
cls_subtable_cache_push_back	.\lib\classifier.c	/^cls_subtable_cache_push_back(struct cls_subtable_cache *array,$/;"	f	file:
cls_subtable_cache_remove	.\lib\classifier.c	/^cls_subtable_cache_remove(struct cls_subtable_cache *array,$/;"	f	file:
cls_subtable_cache_reset	.\lib\classifier.c	/^cls_subtable_cache_reset(struct cls_classifier *cls)$/;"	f	file:
cls_subtable_cache_verify	.\lib\classifier.c	/^cls_subtable_cache_verify(struct cls_subtable_cache *array)$/;"	f	file:
cls_subtable_entry	.\lib\classifier.c	/^struct cls_subtable_entry {$/;"	s	file:
cls_trie	.\lib\classifier.c	/^struct cls_trie {$/;"	s	file:
clz32	.\lib\util.h	/^clz32(uint32_t n)$/;"	f
clz64	.\lib\util.h	/^clz64(uint64_t n)$/;"	f
cmd	.\datapath\datapath.h	/^	u8 cmd;$/;"	m	struct:dp_upcall_info
cmd	.\lib\dpif-linux.c	/^    uint8_t cmd;$/;"	m	struct:dpif_linux_dp	file:
cmd	.\lib\dpif-linux.c	/^    uint8_t cmd;$/;"	m	struct:dpif_linux_flow	file:
cmd	.\lib\dpif-linux.h	/^    uint8_t cmd;$/;"	m	struct:dpif_linux_vport
cmd	.\lib\netlink-protocol.h	/^    uint8_t cmd;$/;"	m	struct:genlmsghdr
cmd_add	.\utilities\ovs-vsctl.c	/^cmd_add(struct vsctl_context *ctx)$/;"	f	file:
cmd_add	.\vtep\vtep-ctl.c	/^cmd_add(struct vtep_ctl_context *ctx)$/;"	f	file:
cmd_add_bond	.\utilities\ovs-vsctl.c	/^cmd_add_bond(struct vsctl_context *ctx)$/;"	f	file:
cmd_add_br	.\utilities\ovs-vsctl.c	/^cmd_add_br(struct vsctl_context *ctx)$/;"	f	file:
cmd_add_ls	.\vtep\vtep-ctl.c	/^cmd_add_ls(struct vtep_ctl_context *ctx)$/;"	f	file:
cmd_add_mcast_local	.\vtep\vtep-ctl.c	/^cmd_add_mcast_local(struct vtep_ctl_context *ctx)$/;"	f	file:
cmd_add_mcast_remote	.\vtep\vtep-ctl.c	/^cmd_add_mcast_remote(struct vtep_ctl_context *ctx)$/;"	f	file:
cmd_add_port	.\utilities\ovs-vsctl.c	/^cmd_add_port(struct vsctl_context *ctx)$/;"	f	file:
cmd_add_port	.\vtep\vtep-ctl.c	/^cmd_add_port(struct vtep_ctl_context *ctx)$/;"	f	file:
cmd_add_ps	.\vtep\vtep-ctl.c	/^cmd_add_ps(struct vtep_ctl_context *ctx)$/;"	f	file:
cmd_add_ucast_local	.\vtep\vtep-ctl.c	/^cmd_add_ucast_local(struct vtep_ctl_context *ctx)$/;"	f	file:
cmd_add_ucast_remote	.\vtep\vtep-ctl.c	/^cmd_add_ucast_remote(struct vtep_ctl_context *ctx)$/;"	f	file:
cmd_bind_ls	.\vtep\vtep-ctl.c	/^cmd_bind_ls(struct vtep_ctl_context *ctx)$/;"	f	file:
cmd_br_exists	.\utilities\ovs-vsctl.c	/^cmd_br_exists(struct vsctl_context *ctx)$/;"	f	file:
cmd_br_get_external_id	.\utilities\ovs-vsctl.c	/^cmd_br_get_external_id(struct vsctl_context *ctx)$/;"	f	file:
cmd_br_set_external_id	.\utilities\ovs-vsctl.c	/^cmd_br_set_external_id(struct vsctl_context *ctx)$/;"	f	file:
cmd_br_to_parent	.\utilities\ovs-vsctl.c	/^cmd_br_to_parent(struct vsctl_context *ctx)$/;"	f	file:
cmd_br_to_vlan	.\utilities\ovs-vsctl.c	/^cmd_br_to_vlan(struct vsctl_context *ctx)$/;"	f	file:
cmd_clear	.\utilities\ovs-vsctl.c	/^cmd_clear(struct vsctl_context *ctx)$/;"	f	file:
cmd_clear	.\vtep\vtep-ctl.c	/^cmd_clear(struct vtep_ctl_context *ctx)$/;"	f	file:
cmd_clear_local_macs	.\vtep\vtep-ctl.c	/^cmd_clear_local_macs(struct vtep_ctl_context *ctx)$/;"	f	file:
cmd_clear_remote_macs	.\vtep\vtep-ctl.c	/^cmd_clear_remote_macs(struct vtep_ctl_context *ctx)$/;"	f	file:
cmd_create	.\utilities\ovs-vsctl.c	/^cmd_create(struct vsctl_context *ctx)$/;"	f	file:
cmd_create	.\vtep\vtep-ctl.c	/^cmd_create(struct vtep_ctl_context *ctx)$/;"	f	file:
cmd_del_br	.\utilities\ovs-vsctl.c	/^cmd_del_br(struct vsctl_context *ctx)$/;"	f	file:
cmd_del_controller	.\utilities\ovs-vsctl.c	/^cmd_del_controller(struct vsctl_context *ctx)$/;"	f	file:
cmd_del_fail_mode	.\utilities\ovs-vsctl.c	/^cmd_del_fail_mode(struct vsctl_context *ctx)$/;"	f	file:
cmd_del_ls	.\vtep\vtep-ctl.c	/^cmd_del_ls(struct vtep_ctl_context *ctx)$/;"	f	file:
cmd_del_manager	.\utilities\ovs-vsctl.c	/^cmd_del_manager(struct vsctl_context *ctx)$/;"	f	file:
cmd_del_manager	.\vtep\vtep-ctl.c	/^cmd_del_manager(struct vtep_ctl_context *ctx)$/;"	f	file:
cmd_del_mcast_local	.\vtep\vtep-ctl.c	/^cmd_del_mcast_local(struct vtep_ctl_context *ctx)$/;"	f	file:
cmd_del_mcast_remote	.\vtep\vtep-ctl.c	/^cmd_del_mcast_remote(struct vtep_ctl_context *ctx)$/;"	f	file:
cmd_del_port	.\utilities\ovs-vsctl.c	/^cmd_del_port(struct vsctl_context *ctx)$/;"	f	file:
cmd_del_port	.\vtep\vtep-ctl.c	/^cmd_del_port(struct vtep_ctl_context *ctx)$/;"	f	file:
cmd_del_ps	.\vtep\vtep-ctl.c	/^cmd_del_ps(struct vtep_ctl_context *ctx)$/;"	f	file:
cmd_del_ssl	.\utilities\ovs-vsctl.c	/^cmd_del_ssl(struct vsctl_context *ctx)$/;"	f	file:
cmd_del_ucast_local	.\vtep\vtep-ctl.c	/^cmd_del_ucast_local(struct vtep_ctl_context *ctx)$/;"	f	file:
cmd_del_ucast_remote	.\vtep\vtep-ctl.c	/^cmd_del_ucast_remote(struct vtep_ctl_context *ctx)$/;"	f	file:
cmd_destroy	.\utilities\ovs-vsctl.c	/^cmd_destroy(struct vsctl_context *ctx)$/;"	f	file:
cmd_destroy	.\vtep\vtep-ctl.c	/^cmd_destroy(struct vtep_ctl_context *ctx)$/;"	f	file:
cmd_emer_reset	.\utilities\ovs-vsctl.c	/^cmd_emer_reset(struct vsctl_context *ctx)$/;"	f	file:
cmd_find	.\utilities\ovs-vsctl.c	/^cmd_find(struct vsctl_context *ctx)$/;"	f	file:
cmd_find	.\vtep\vtep-ctl.c	/^cmd_find(struct vtep_ctl_context *ctx)$/;"	f	file:
cmd_get	.\utilities\ovs-vsctl.c	/^cmd_get(struct vsctl_context *ctx)$/;"	f	file:
cmd_get	.\vtep\vtep-ctl.c	/^cmd_get(struct vtep_ctl_context *ctx)$/;"	f	file:
cmd_get_controller	.\utilities\ovs-vsctl.c	/^cmd_get_controller(struct vsctl_context *ctx)$/;"	f	file:
cmd_get_fail_mode	.\utilities\ovs-vsctl.c	/^cmd_get_fail_mode(struct vsctl_context *ctx)$/;"	f	file:
cmd_get_manager	.\utilities\ovs-vsctl.c	/^cmd_get_manager(struct vsctl_context *ctx)$/;"	f	file:
cmd_get_manager	.\vtep\vtep-ctl.c	/^cmd_get_manager(struct vtep_ctl_context *ctx)$/;"	f	file:
cmd_get_ssl	.\utilities\ovs-vsctl.c	/^cmd_get_ssl(struct vsctl_context *ctx)$/;"	f	file:
cmd_help	.\utilities\ovs-benchmark.c	/^cmd_help(int argc OVS_UNUSED, char *argv[] OVS_UNUSED)$/;"	f	file:
cmd_iface_to_br	.\utilities\ovs-vsctl.c	/^cmd_iface_to_br(struct vsctl_context *ctx)$/;"	f	file:
cmd_init	.\utilities\ovs-vsctl.c	/^cmd_init(struct vsctl_context *ctx OVS_UNUSED)$/;"	f	file:
cmd_latency	.\utilities\ovs-benchmark.c	/^cmd_latency(int argc OVS_UNUSED, char *argv[] OVS_UNUSED)$/;"	f	file:
cmd_list	.\utilities\ovs-vsctl.c	/^cmd_list(struct vsctl_context *ctx)$/;"	f	file:
cmd_list	.\vtep\vtep-ctl.c	/^cmd_list(struct vtep_ctl_context *ctx)$/;"	f	file:
cmd_list_bindings	.\vtep\vtep-ctl.c	/^cmd_list_bindings(struct vtep_ctl_context *ctx)$/;"	f	file:
cmd_list_br	.\utilities\ovs-vsctl.c	/^cmd_list_br(struct vsctl_context *ctx)$/;"	f	file:
cmd_list_ifaces	.\utilities\ovs-vsctl.c	/^cmd_list_ifaces(struct vsctl_context *ctx)$/;"	f	file:
cmd_list_local_macs	.\vtep\vtep-ctl.c	/^cmd_list_local_macs(struct vtep_ctl_context *ctx)$/;"	f	file:
cmd_list_ls	.\vtep\vtep-ctl.c	/^cmd_list_ls(struct vtep_ctl_context *ctx)$/;"	f	file:
cmd_list_ports	.\utilities\ovs-vsctl.c	/^cmd_list_ports(struct vsctl_context *ctx)$/;"	f	file:
cmd_list_ports	.\vtep\vtep-ctl.c	/^cmd_list_ports(struct vtep_ctl_context *ctx)$/;"	f	file:
cmd_list_ps	.\vtep\vtep-ctl.c	/^cmd_list_ps(struct vtep_ctl_context *ctx)$/;"	f	file:
cmd_list_remote_macs	.\vtep\vtep-ctl.c	/^cmd_list_remote_macs(struct vtep_ctl_context *ctx)$/;"	f	file:
cmd_listen	.\utilities\ovs-benchmark.c	/^cmd_listen(int argc OVS_UNUSED, char *argv[] OVS_UNUSED)$/;"	f	file:
cmd_ls_exists	.\vtep\vtep-ctl.c	/^cmd_ls_exists(struct vtep_ctl_context *ctx)$/;"	f	file:
cmd_port_to_br	.\utilities\ovs-vsctl.c	/^cmd_port_to_br(struct vsctl_context *ctx)$/;"	f	file:
cmd_ps_exists	.\vtep\vtep-ctl.c	/^cmd_ps_exists(struct vtep_ctl_context *ctx)$/;"	f	file:
cmd_rate	.\utilities\ovs-benchmark.c	/^cmd_rate(int argc OVS_UNUSED, char *argv[] OVS_UNUSED)$/;"	f	file:
cmd_remove	.\utilities\ovs-vsctl.c	/^cmd_remove(struct vsctl_context *ctx)$/;"	f	file:
cmd_remove	.\vtep\vtep-ctl.c	/^cmd_remove(struct vtep_ctl_context *ctx)$/;"	f	file:
cmd_set	.\utilities\ovs-vsctl.c	/^cmd_set(struct vsctl_context *ctx)$/;"	f	file:
cmd_set	.\vtep\vtep-ctl.c	/^cmd_set(struct vtep_ctl_context *ctx)$/;"	f	file:
cmd_set_controller	.\utilities\ovs-vsctl.c	/^cmd_set_controller(struct vsctl_context *ctx)$/;"	f	file:
cmd_set_fail_mode	.\utilities\ovs-vsctl.c	/^cmd_set_fail_mode(struct vsctl_context *ctx)$/;"	f	file:
cmd_set_manager	.\utilities\ovs-vsctl.c	/^cmd_set_manager(struct vsctl_context *ctx)$/;"	f	file:
cmd_set_manager	.\vtep\vtep-ctl.c	/^cmd_set_manager(struct vtep_ctl_context *ctx)$/;"	f	file:
cmd_set_ssl	.\utilities\ovs-vsctl.c	/^cmd_set_ssl(struct vsctl_context *ctx)$/;"	f	file:
cmd_show	.\utilities\ovs-vsctl.c	/^cmd_show(struct vsctl_context *ctx)$/;"	f	file:
cmd_show_find_table_by_name	.\utilities\ovs-vsctl.c	/^cmd_show_find_table_by_name(const char *name)$/;"	f	file:
cmd_show_find_table_by_row	.\utilities\ovs-vsctl.c	/^cmd_show_find_table_by_row(const struct ovsdb_idl_row *row)$/;"	f	file:
cmd_show_row	.\utilities\ovs-vsctl.c	/^cmd_show_row(struct vsctl_context *ctx, const struct ovsdb_idl_row *row,$/;"	f	file:
cmd_show_table	.\utilities\ovs-vsctl.c	/^struct cmd_show_table {$/;"	s	file:
cmd_show_tables	.\utilities\ovs-vsctl.c	/^static struct cmd_show_table cmd_show_tables[] = {$/;"	v	typeref:struct:cmd_show_table	file:
cmd_unbind_ls	.\vtep\vtep-ctl.c	/^cmd_unbind_ls(struct vtep_ctl_context *ctx)$/;"	f	file:
cmd_wait_until	.\utilities\ovs-vsctl.c	/^cmd_wait_until(struct vsctl_context *ctx)$/;"	f	file:
cmd_wait_until	.\vtep\vtep-ctl.c	/^cmd_wait_until(struct vtep_ctl_context *ctx)$/;"	f	file:
cmp_key	.\datapath\flow_table.c	/^static bool cmp_key(const struct sw_flow_key *key1,$/;"	f	file:
cmsg_data	.\include\sparse\sys\socket.h	/^    unsigned char cmsg_data[];$/;"	m	struct:cmsghdr
cmsg_len	.\include\sparse\sys\socket.h	/^    size_t cmsg_len;$/;"	m	struct:cmsghdr
cmsg_level	.\include\sparse\sys\socket.h	/^    int cmsg_level;$/;"	m	struct:cmsghdr
cmsg_type	.\include\sparse\sys\socket.h	/^    int cmsg_type;$/;"	m	struct:cmsghdr
cmsghdr	.\include\sparse\sys\socket.h	/^struct cmsghdr {$/;"	s
cnt_ids	.\lib\ofp-actions.c	/^    struct nx_action_cnt_ids cnt_ids;$/;"	m	union:ofp_action	typeref:struct:ofp_action::nx_action_cnt_ids	file:
cnt_ids	.\lib\ofp-actions.h	/^    uint16_t cnt_ids[];$/;"	m	struct:ofpact_cnt_ids
code	.\include\openflow\nicira-ext.h	/^    ovs_be16 code;              \/* Vendor-defined subtype. *\/$/;"	m	struct:nx_vendor_error
code	.\include\openflow\openflow-common.h	/^    ovs_be16 code;$/;"	m	struct:ofp_error_msg
code	.\lib\ofp-errors.c	/^    int type, code;$/;"	m	struct:triplet	file:
codecs	.\tests\test-json.py	/^import codecs$/;"	i
collect_garbage	.\ovsdb\transaction.c	/^collect_garbage(struct ovsdb_txn *txn, struct ovsdb_txn_row *txn_row)$/;"	f	file:
collect_in_band_managers	.\vswitchd\bridge.c	/^collect_in_band_managers(const struct ovsrec_open_vswitch *ovs_cfg,$/;"	f	file:
collect_splinter_vlans	.\vswitchd\bridge.c	/^collect_splinter_vlans(const struct ovsrec_open_vswitch *ovs_cfg)$/;"	f	file:
collector_set_id	.\include\openflow\nicira-ext.h	/^    ovs_be32 collector_set_id;      \/* ID of collector set in OVSDB. *\/$/;"	m	struct:nx_action_sample
collector_set_id	.\lib\odp-util.h	/^        uint32_t collector_set_id; \/* ID of IPFIX collector set. *\/$/;"	m	struct:user_action_cookie::__anon71
collector_set_id	.\lib\ofp-actions.h	/^    uint32_t collector_set_id;$/;"	m	struct:ofpact_sample
collector_set_id	.\ofproto\ofproto.h	/^    uint32_t collector_set_id;$/;"	m	struct:ofproto_ipfix_flow_exporter_options
collectors	.\ofproto\collectors.c	/^VLOG_DEFINE_THIS_MODULE(collectors);$/;"	v
collectors	.\ofproto\collectors.c	/^struct collectors {$/;"	s	file:
collectors	.\ofproto\netflow.c	/^    struct collectors *collectors; \/* NetFlow collectors. *\/$/;"	m	struct:netflow	typeref:struct:netflow::collectors	file:
collectors	.\ofproto\netflow.h	/^    struct sset collectors;$/;"	m	struct:netflow_options	typeref:struct:netflow_options::sset
collectors	.\ofproto\ofproto-dpif-ipfix.c	/^    struct collectors *collectors;$/;"	m	struct:dpif_ipfix_exporter	typeref:struct:dpif_ipfix_exporter::collectors	file:
collectors	.\ofproto\ofproto-dpif-sflow.c	/^    struct collectors *collectors;$/;"	m	struct:dpif_sflow	typeref:struct:dpif_sflow::collectors	file:
collectors_count	.\ofproto\collectors.c	/^collectors_count(const struct collectors *c)$/;"	f
collectors_create	.\ofproto\collectors.c	/^collectors_create(const struct sset *targets, uint16_t default_port,$/;"	f
collectors_destroy	.\ofproto\collectors.c	/^collectors_destroy(struct collectors *c)$/;"	f
collectors_send	.\ofproto\collectors.c	/^collectors_send(const struct collectors *c, const void *payload, size_t n)$/;"	f
collisions	.\include\openflow\openflow-1.0.h	/^    ovs_32aligned_be64 collisions;   \/* Number of collisions. *\/$/;"	m	struct:ofp10_port_stats
collisions	.\include\openflow\openflow-1.1.h	/^    ovs_be64 collisions;      \/* Number of collisions. *\/$/;"	m	struct:ofp11_port_stats
collisions	.\include\openflow\openflow-1.4.h	/^    ovs_be64 collisions;     \/* Number of collisions. *\/$/;"	m	struct:ofp14_port_stats_prop_ethernet
collisions	.\lib\netdev.h	/^    uint64_t collisions;$/;"	m	struct:netdev_stats
column	.\lib\table.c	/^struct column {$/;"	s	file:
column	.\ovsdb\condition.h	/^    const struct ovsdb_column *column;$/;"	m	struct:ovsdb_clause	typeref:struct:ovsdb_clause::ovsdb_column
column	.\ovsdb\jsonrpc-server.c	/^    const struct ovsdb_column *column;$/;"	m	struct:ovsdb_jsonrpc_monitor_column	typeref:struct:ovsdb_jsonrpc_monitor_column::ovsdb_column	file:
column	.\ovsdb\mutation.h	/^    const struct ovsdb_column *column;$/;"	m	struct:ovsdb_mutation	typeref:struct:ovsdb_mutation::ovsdb_column
column_number	.\lib\json.c	/^    int column_number;$/;"	m	struct:json_parser	file:
column_set_from_json	.\python\ovs\db\schema.py	/^def column_set_from_json(json, columns):$/;"	f
columns	.\lib\ovsdb-idl-provider.h	/^    const struct ovsdb_idl_column *columns;$/;"	m	struct:ovsdb_idl_table_class	typeref:struct:ovsdb_idl_table_class::ovsdb_idl_column
columns	.\lib\ovsdb-idl-provider.h	/^    struct shash columns;    \/* Contains "const struct ovsdb_idl_column *"s. *\/$/;"	m	struct:ovsdb_idl_table	typeref:struct:ovsdb_idl_table::shash
columns	.\lib\table.h	/^    struct column *columns;$/;"	m	struct:table	typeref:struct:table::column
columns	.\ovsdb\column.h	/^    const struct ovsdb_column **columns;$/;"	m	struct:ovsdb_column_set	typeref:struct:ovsdb_column_set::ovsdb_column
columns	.\ovsdb\execution.c	/^    const struct ovsdb_column_set *columns;$/;"	m	struct:update_row_cbdata	typeref:struct:update_row_cbdata::ovsdb_column_set	file:
columns	.\ovsdb\jsonrpc-server.c	/^    struct ovsdb_jsonrpc_monitor_column *columns;$/;"	m	struct:ovsdb_jsonrpc_monitor_table	typeref:struct:ovsdb_jsonrpc_monitor_table::ovsdb_jsonrpc_monitor_column	file:
columns	.\ovsdb\ovsdb-client.c	/^    const struct ovsdb_column **columns;$/;"	m	struct:dump_table_aux	typeref:struct:dump_table_aux::ovsdb_column	file:
columns	.\ovsdb\ovsdb-client.c	/^    struct ovsdb_column_set columns;$/;"	m	struct:monitored_table	typeref:struct:monitored_table::ovsdb_column_set	file:
columns	.\ovsdb\row.c	/^    const struct ovsdb_column_set *columns;$/;"	m	struct:ovsdb_row_set_sort_cbdata	typeref:struct:ovsdb_row_set_sort_cbdata::ovsdb_column_set	file:
columns	.\ovsdb\row.h	/^    struct ovsdb_column_set columns;$/;"	m	struct:ovsdb_row_hash	typeref:struct:ovsdb_row_hash::ovsdb_column_set
columns	.\ovsdb\table.h	/^    struct shash columns;       \/* Contains "struct ovsdb_column *"s. *\/$/;"	m	struct:ovsdb_table_schema	typeref:struct:ovsdb_table_schema::shash
columns	.\utilities\ovs-vsctl.c	/^    const struct ovsdb_idl_column *columns[3];$/;"	m	struct:cmd_show_table	typeref:struct:cmd_show_table::ovsdb_idl_column	file:
commafy	.\python\ovs\db\types.py	/^def commafy(x):$/;"	f
command	.\include\openflow\nicira-ext.h	/^    ovs_be16 command;             \/* OFPFC_* + possibly a table ID (see comment$/;"	m	struct:nx_flow_mod
command	.\include\openflow\openflow-1.0.h	/^    ovs_be16 command;             \/* One of OFPFC_*. *\/$/;"	m	struct:ofp10_flow_mod
command	.\include\openflow\openflow-1.1.h	/^    ovs_be16 command;             \/* One of OFPGC11_*. *\/$/;"	m	struct:ofp11_group_mod
command	.\include\openflow\openflow-1.1.h	/^    uint8_t command;             \/* One of OFPFC_*. *\/$/;"	m	struct:ofp11_flow_mod
command	.\include\openflow\openflow-1.3.h	/^    ovs_be16          command;      \/* One of OFPMC_*. *\/$/;"	m	struct:ofp13_action_self_learning::ofp13_meter_mod
command	.\lib\command-line.h	/^struct command {$/;"	s
command	.\lib\ofp-util.h	/^    uint16_t command;             \/* One of OFPGC11_*. *\/$/;"	m	struct:ofputil_group_mod
command	.\lib\ofp-util.h	/^    uint16_t command;$/;"	m	struct:ofputil_flow_mod
command	.\lib\ofp-util.h	/^    uint16_t command;$/;"	m	struct:ofputil_meter_mod
command_line	.\lib\command-line.c	/^VLOG_DEFINE_THIS_MODULE(command_line);$/;"	v
command_name	.\tests\test-jsonrpc.py	/^    command_name = args.command[0]$/;"	v
command_register	.\python\ovs\unixctl\__init__.py	/^def command_register(name, usage, min_args, max_args, callback, aux):$/;"	f
commands	.\lib\unixctl.c	/^static struct shash commands = SHASH_INITIALIZER(&commands);$/;"	v	typeref:struct:shash	file:
commands	.\python\ovs\unixctl\__init__.py	/^commands = {}$/;"	v
commands	.\tests\ovstest.c	/^static struct command *commands = NULL;$/;"	v	typeref:struct:command	file:
commands	.\tests\test-classifier.c	/^static const struct command commands[] = {$/;"	v	typeref:struct:command	file:
commands	.\tests\test-heap.c	/^static const struct command commands[] = {$/;"	v	typeref:struct:command	file:
commands	.\tests\test-util.c	/^static const struct command commands[] = {$/;"	v	typeref:struct:command	file:
commands	.\tests\test-vconn.c	/^static const struct command commands[] = {$/;"	v	typeref:struct:command	file:
commands	.\utilities\ovs-dev.py	/^commands = []$/;"	v
comment	.\lib\ovsdb-idl.c	/^    struct ds comment;$/;"	m	struct:ovsdb_idl_txn	typeref:struct:ovsdb_idl_txn::ds	file:
comment	.\ovsdb\transaction.c	/^    struct ds comment;$/;"	m	struct:ovsdb_txn	typeref:struct:ovsdb_txn::ds	file:
commit	.\ovsdb\ovsdb.h	/^    struct ovsdb_error *(*commit)(struct ovsdb_replica *,$/;"	m	struct:ovsdb_replica_class	typeref:struct:ovsdb_replica_class::commit
commit	.\python\ovs\db\idl.py	/^    def commit(self):$/;"	m	class:Transaction
commit	.\xenserver\opt_xensource_libexec_InterfaceReconfigure.py	/^    def commit(self):$/;"	m	class:ConfigurationFile
commit_block	.\python\ovs\db\idl.py	/^    def commit_block(self):$/;"	m	class:Transaction
commit_ls_bindings	.\vtep\vtep-ctl.c	/^commit_ls_bindings(struct vtep_ctl_port *port)$/;"	f	file:
commit_mcast_entries	.\vtep\vtep-ctl.c	/^commit_mcast_entries(struct vtep_ctl_mcast_mac *mcast_mac)$/;"	f	file:
commit_mpls_action	.\lib\odp-util.c	/^commit_mpls_action(const struct flow *flow, struct flow *base,$/;"	f	file:
commit_odp_actions	.\lib\odp-util.c	/^commit_odp_actions(const struct flow *flow, struct flow *base,$/;"	f
commit_odp_tunnel_action	.\lib\odp-util.c	/^commit_odp_tunnel_action(const struct flow *flow, struct flow *base,$/;"	f
commit_set_action	.\lib\odp-util.c	/^commit_set_action(struct ofpbuf *odp_actions, enum ovs_key_attr key_type,$/;"	f	file:
commit_set_arp_action	.\lib\odp-util.c	/^commit_set_arp_action(const struct flow *flow, struct flow *base,$/;"	f	file:
commit_set_ether_addr_action	.\lib\odp-util.c	/^commit_set_ether_addr_action(const struct flow *flow, struct flow *base,$/;"	f	file:
commit_set_ipv4_action	.\lib\odp-util.c	/^commit_set_ipv4_action(const struct flow *flow, struct flow *base,$/;"	f	file:
commit_set_ipv6_action	.\lib\odp-util.c	/^commit_set_ipv6_action(const struct flow *flow, struct flow *base,$/;"	f	file:
commit_set_nw_action	.\lib\odp-util.c	/^commit_set_nw_action(const struct flow *flow, struct flow *base,$/;"	f	file:
commit_set_pkt_mark_action	.\lib\odp-util.c	/^commit_set_pkt_mark_action(const struct flow *flow, struct flow *base,$/;"	f	file:
commit_set_port_action	.\lib\odp-util.c	/^commit_set_port_action(const struct flow *flow, struct flow *base,$/;"	f	file:
commit_set_priority_action	.\lib\odp-util.c	/^commit_set_priority_action(const struct flow *flow, struct flow *base,$/;"	f	file:
commit_vlan_action	.\lib\odp-util.c	/^commit_vlan_action(ovs_be16 vlan_tci, struct flow *base,$/;"	f	file:
communities	.\lib\sflow.h	/^    u_int32_t *communities;                   \/* set of communities *\/$/;"	m	struct:_SFLExtended_gateway
communities_length	.\lib\sflow.h	/^    u_int32_t communities_length;             \/* number of communities *\/$/;"	m	struct:_SFLExtended_gateway
compact_or_convert	.\ovsdb\ovsdb-tool.c	/^compact_or_convert(const char *src_name_, const char *dst_name_,$/;"	f	file:
compare_actions_for_flow	.\utilities\ovs-dpctl.c	/^compare_actions_for_flow(const void *a_, const void *b_)$/;"	f	file:
compare_atoms	.\tests\test-ovsdb.c	/^compare_atoms(const void *a_, const void *b_)$/;"	f	file:
compare_atoms_atomic_type	.\tests\test-ovsdb.c	/^static enum ovsdb_atomic_type compare_atoms_atomic_type;$/;"	v	typeref:enum:ovsdb_atomic_type	file:
compare_clauses_3way	.\ovsdb\condition.c	/^compare_clauses_3way(const void *a_, const void *b_)$/;"	f	file:
compare_columns	.\ovsdb\ovsdb-client.c	/^compare_columns(const void *a_, const void *b_)$/;"	f	file:
compare_coverage_counters	.\lib\coverage.c	/^compare_coverage_counters(const void *a_, const void *b_)$/;"	f	file:
compare_data	.\ovsdb\ovsdb-client.c	/^compare_data(size_t a_y, size_t b_y, size_t x,$/;"	f	file:
compare_flows	.\utilities\ovs-ofctl.c	/^compare_flows(const void *afs_, const void *bfs_)$/;"	f	file:
compare_ints	.\tests\test-hindex.c	/^compare_ints(const void *a_, const void *b_)$/;"	f	file:
compare_ints	.\tests\test-hmap.c	/^compare_ints(const void *a_, const void *b_)$/;"	f	file:
compare_lines	.\tests\ovsdb-monitor-sort.pl	/^sub compare_lines {$/;"	s
compare_link1	.\tests\test-ovsdb.c	/^compare_link1(const void *a_, const void *b_)$/;"	f	file:
compare_nodes_by_key	.\lib\smap.c	/^compare_nodes_by_key(const void *a_, const void *b_)$/;"	f	file:
compare_nodes_by_name	.\lib\shash.c	/^compare_nodes_by_name(const void *a_, const void *b_)$/;"	f	file:
compare_nodes_by_name	.\lib\simap.c	/^compare_nodes_by_name(const void *a_, const void *b_)$/;"	f	file:
compare_output_actions	.\utilities\ovs-dpctl.c	/^compare_output_actions(const void *a_, const void *b_)$/;"	f	file:
compare_ovsdb_jsonrpc_monitor_column	.\ovsdb\jsonrpc-server.c	/^compare_ovsdb_jsonrpc_monitor_column(const void *a_, const void *b_)$/;"	f	file:
compare_ports	.\lib\ofp-print.c	/^compare_ports(const void *a_, const void *b_)$/;"	f	file:
compare_rows	.\ovsdb\ovsdb-client.c	/^compare_rows(size_t a_y, size_t b_y, void *aux_)$/;"	f	file:
compare_rows_by_uuid	.\tests\test-ovsdb.c	/^compare_rows_by_uuid(const void *a_, const void *b_)$/;"	f	file:
compare_string_pointers	.\lib\sset.c	/^compare_string_pointers(const void *a_, const void *b_)$/;"	f	file:
compare_strings	.\lib\svec.c	/^compare_strings(const void *a_, const void *b_)$/;"	f	file:
compare_uint32s	.\tests\test-heap.c	/^compare_uint32s(const void *a_, const void *b_)$/;"	f	file:
compat	.\lib\ofp-actions.h	/^    enum ofputil_action_code compat; \/* Original type when added, if any. *\/$/;"	m	struct:ofpact	typeref:enum:ofpact::ofputil_action_code
compat_exit_net	.\datapath\linux\compat\net_namespace.c	/^void compat_exit_net(struct net *net, struct rpl_pernet_operations *pnet)$/;"	f
compat_family	.\datapath\linux\compat\include\net\genetlink.h	/^	struct genl_family	compat_family;$/;"	m	struct:rpl_genl_family	typeref:struct:rpl_genl_family::genl_family
compat_init_net	.\datapath\linux\compat\net_namespace.c	/^int compat_init_net(struct net *net, struct rpl_pernet_operations *pnet)$/;"	f
completions	.\ovsdb\server.h	/^    struct list completions;    \/* Completed triggers. *\/$/;"	m	struct:ovsdb_session	typeref:struct:ovsdb_session::list
compose_dec_mpls_ttl_action	.\ofproto\ofproto-dpif-xlate.c	/^compose_dec_mpls_ttl_action(struct xlate_ctx *ctx)$/;"	f	file:
compose_dec_ttl	.\ofproto\ofproto-dpif-xlate.c	/^compose_dec_ttl(struct xlate_ctx *ctx, struct ofpact_cnt_ids *ids)$/;"	f	file:
compose_flow_sample_cookie	.\ofproto\ofproto-dpif-xlate.c	/^compose_flow_sample_cookie(uint16_t probability, uint32_t collector_set_id,$/;"	f	file:
compose_ipfix_action	.\ofproto\ofproto-dpif-xlate.c	/^compose_ipfix_action(const struct xbridge *xbridge,$/;"	f	file:
compose_ipfix_cookie	.\ofproto\ofproto-dpif-xlate.c	/^compose_ipfix_cookie(union user_action_cookie *cookie)$/;"	f	file:
compose_lacp_pdu	.\lib\lacp.c	/^compose_lacp_pdu(const struct lacp_info *actor,$/;"	f	file:
compose_mpls_pop_action	.\ofproto\ofproto-dpif-xlate.c	/^compose_mpls_pop_action(struct xlate_ctx *ctx, ovs_be16 eth_type)$/;"	f	file:
compose_mpls_push_action	.\ofproto\ofproto-dpif-xlate.c	/^compose_mpls_push_action(struct xlate_ctx *ctx, struct ofpact_push_mpls *mpls)$/;"	f	file:
compose_output_action	.\ofproto\ofproto-dpif-xlate.c	/^compose_output_action(struct xlate_ctx *ctx, ofp_port_t ofp_port)$/;"	f	file:
compose_output_action__	.\ofproto\ofproto-dpif-xlate.c	/^compose_output_action__(struct xlate_ctx *ctx, ofp_port_t ofp_port,$/;"	f	file:
compose_rarp	.\lib\packets.c	/^compose_rarp(struct ofpbuf *b, const uint8_t eth_src[ETH_ADDR_LEN])$/;"	f
compose_report	.\lib\memory.c	/^compose_report(const struct simap *usage, struct ds *s)$/;"	f	file:
compose_sample_action	.\ofproto\ofproto-dpif-xlate.c	/^compose_sample_action(const struct xbridge *xbridge,$/;"	f	file:
compose_set_mpls_label_action	.\ofproto\ofproto-dpif-xlate.c	/^compose_set_mpls_label_action(struct xlate_ctx *ctx, ovs_be32 label)$/;"	f	file:
compose_set_mpls_tc_action	.\ofproto\ofproto-dpif-xlate.c	/^compose_set_mpls_tc_action(struct xlate_ctx *ctx, uint8_t tc)$/;"	f	file:
compose_set_mpls_ttl_action	.\ofproto\ofproto-dpif-xlate.c	/^compose_set_mpls_ttl_action(struct xlate_ctx *ctx, uint8_t ttl)$/;"	f	file:
compose_sflow_action	.\ofproto\ofproto-dpif-xlate.c	/^compose_sflow_action(const struct xbridge *xbridge,$/;"	f	file:
compose_sflow_cookie	.\ofproto\ofproto-dpif-xlate.c	/^compose_sflow_cookie(const struct xbridge *xbridge, ovs_be16 vlan_tci,$/;"	f	file:
compose_slow_path	.\ofproto\ofproto-dpif-upcall.c	/^compose_slow_path(struct udpif *udpif, struct xlate_out *xout,$/;"	f	file:
computeCountersSampleSize	.\lib\sflow_receiver.c	/^static int computeCountersSampleSize(SFLReceiver *receiver, SFL_COUNTERS_SAMPLE_TYPE *cs)$/;"	f	file:
computeFlowSampleSize	.\lib\sflow_receiver.c	/^static int computeFlowSampleSize(SFLReceiver *receiver, SFL_FLOW_SAMPLE_TYPE *fs)$/;"	f	file:
cond	.\vswitchd\system-stats.c	/^static pthread_cond_t cond = PTHREAD_COND_INITIALIZER;$/;"	v	file:
conf	.\utilities\ovs-dev.py	/^def conf():$/;"	f
config	.\include\openflow\openflow-1.0.h	/^    ovs_be32 config;        \/* Bitmap of OFPPC_* and OFPPC10_* flags. *\/$/;"	m	struct:ofp10_phy_port
config	.\include\openflow\openflow-1.0.h	/^    ovs_be32 config;        \/* Bitmap of OFPPC_* flags. *\/$/;"	m	struct:ofp10_port_mod
config	.\include\openflow\openflow-1.1.h	/^    ovs_be32 config;         \/* Bitmap of OFPTC_* values *\/$/;"	m	struct:ofp11_table_stats
config	.\include\openflow\openflow-1.1.h	/^    ovs_be32 config;        \/* Bitmap of OFPPC_* flags. *\/$/;"	m	struct:ofp11_port
config	.\include\openflow\openflow-1.1.h	/^    ovs_be32 config;        \/* Bitmap of OFPPC_* flags. *\/$/;"	m	struct:ofp11_port_mod
config	.\include\openflow\openflow-1.1.h	/^    ovs_be32 config;        \/* Bitmap of OFPTC_* flags *\/$/;"	m	struct:ofp11_table_mod
config	.\include\openflow\openflow-1.2.h	/^    ovs_be32 config;         \/* Bitmap of OFPTC_* values *\/$/;"	m	struct:ofp12_table_stats
config	.\include\openflow\openflow-1.3.h	/^    ovs_be32 config;          \/* Bitmap of OFPTC_* values *\/$/;"	m	struct:ofp13_action_self_learning::ofp13_table_features
config	.\include\openflow\openflow-1.4.h	/^    ovs_be32 config;        \/* Bitmap of OFPPC_* flags. *\/$/;"	m	struct:ofp14_port
config	.\include\openflow\openflow-1.4.h	/^    ovs_be32 config;        \/* Bitmap of OFPPC_* flags. *\/$/;"	m	struct:ofp14_port_mod
config	.\include\openflow\openflow-1.4.h	/^    ovs_be32 config;        \/* Bitmap of OFPTC_* flags *\/$/;"	m	struct:ofp14_table_mod
config	.\lib\ofp-util.h	/^    enum ofp_table_config config;$/;"	m	struct:ofputil_table_mod	typeref:enum:ofputil_table_mod::ofp_table_config
config	.\lib\ofp-util.h	/^    enum ofputil_port_config config;$/;"	m	struct:ofputil_phy_port	typeref:enum:ofputil_phy_port::ofputil_port_config
config	.\lib\ofp-util.h	/^    enum ofputil_port_config config;$/;"	m	struct:ofputil_port_mod	typeref:enum:ofputil_port_mod::ofputil_port_config
config	.\lib\ofp-util.h	/^    uint32_t config;          \/* Bitmap of OFPTC_* values *\/$/;"	m	struct:ofputil_table_features
config	.\ofproto\ofproto-dpif-xlate.c	/^    enum ofputil_port_config config; \/* OpenFlow port configuration. *\/$/;"	m	struct:xport	typeref:enum:xport::ofputil_port_config	file:
config	.\ofproto\ofproto-provider.h	/^    atomic_uint config;$/;"	m	struct:oftable
config_enabled	.\datapath\linux\compat\include\linux\kconfig.h	30;"	d
config_pending	.\lib\stp.c	/^    bool config_pending;            \/* 8.5.5.9: Send BPDU when hold expires? *\/$/;"	m	struct:stp_port	file:
config_tmpfile	.\ovsdb\ovsdb-server.c	/^    FILE *config_tmpfile;$/;"	m	struct:server_config	file:
configure	.\xenserver\opt_xensource_libexec_InterfaceReconfigure.py	/^    def configure(self):$/;"	m	class:Datapath
configure	.\xenserver\opt_xensource_libexec_InterfaceReconfigureBridge.py	/^    def configure(self):$/;"	m	class:DatapathBridge
configure	.\xenserver\opt_xensource_libexec_InterfaceReconfigureVswitch.py	/^    def configure(self):$/;"	m	class:DatapathVswitch
configure_datapath	.\xenserver\opt_xensource_libexec_InterfaceReconfigureVswitch.py	/^def configure_datapath(pif):$/;"	f
configure_ipdev	.\xenserver\opt_xensource_libexec_InterfaceReconfigure.py	/^    def configure_ipdev(self, cfg):$/;"	m	class:Datapath
configure_ipdev	.\xenserver\opt_xensource_libexec_InterfaceReconfigureBridge.py	/^    def configure_ipdev(self, cfg):$/;"	m	class:DatapathBridge
configure_ipdev	.\xenserver\opt_xensource_libexec_InterfaceReconfigureVswitch.py	/^    def configure_ipdev(self, cfg):$/;"	m	class:DatapathVswitch
configure_l3	.\python\ovstest\tests.py	/^def configure_l3(conf, tunnel_mode):$/;"	f
configure_splinter_port	.\vswitchd\bridge.c	/^configure_splinter_port(struct port *port)$/;"	f	file:
conforms_to_type	.\python\ovs\db\data.py	/^    def conforms_to_type(self):$/;"	m	class:Datum
conn	.\utilities\ovs-ofctl.c	/^    struct unixctl_conn *conn;  \/* Connection waiting for barrier response. *\/$/;"	m	struct:barrier_aux	typeref:struct:barrier_aux::unixctl_conn	file:
connect	.\lib\stream-provider.h	/^    int (*connect)(struct stream *stream);$/;"	m	struct:stream_class
connect	.\lib\vconn-provider.h	/^    int (*connect)(struct vconn *vconn);$/;"	m	struct:vconn_class
connect	.\python\ovs\stream.py	/^    def connect(self):$/;"	m	class:Stream
connect_failed	.\python\ovs\reconnect.py	/^    def connect_failed(self, now, error):$/;"	m	class:Reconnect
connect_to_target	.\tests\appctl.py	/^def connect_to_target(target):$/;"	f
connect_to_target	.\utilities\ovs-appctl.c	/^connect_to_target(const char *target)$/;"	f	file:
connect_wait	.\python\ovs\stream.py	/^    def connect_wait(self, poller):$/;"	m	class:Stream
connected	.\python\ovs\reconnect.py	/^    def connected(self, now):$/;"	m	class:Reconnect
connecting	.\python\ovs\reconnect.py	/^    def connecting(self, now):$/;"	m	class:Reconnect
connectionLost	.\python\ovstest\tcp.py	/^    def connectionLost(self, reason):$/;"	m	class:TcpListenerConnection
connectionMade	.\python\ovstest\tcp.py	/^    def connectionMade(self):$/;"	m	class:TcpSenderConnection
connection_mode	.\lib\vswitch-idl.h	/^	char *connection_mode;$/;"	m	struct:ovsrec_controller
connection_mode	.\lib\vswitch-idl.h	/^	char *connection_mode;$/;"	m	struct:ovsrec_manager
connectivity_seq	.\lib\connectivity.c	/^static struct seq *connectivity_seq;$/;"	v	typeref:struct:seq	file:
connectivity_seq_get	.\lib\connectivity.c	/^connectivity_seq_get(void)$/;"	f
connectivity_seqno	.\vswitchd\bridge.c	/^static uint64_t connectivity_seqno = LLONG_MIN;$/;"	v	file:
connmgr	.\ofproto\connmgr.c	/^    struct connmgr *connmgr;    \/* Connection's manager. *\/$/;"	m	struct:ofconn	typeref:struct:ofconn::connmgr	file:
connmgr	.\ofproto\connmgr.c	/^VLOG_DEFINE_THIS_MODULE(connmgr);$/;"	v
connmgr	.\ofproto\connmgr.c	/^struct connmgr {$/;"	s	file:
connmgr	.\ofproto\fail-open.c	/^    struct connmgr *connmgr;$/;"	m	struct:fail_open	typeref:struct:fail_open::connmgr	file:
connmgr	.\ofproto\ofproto-provider.h	/^    struct connmgr *connmgr;$/;"	m	struct:ofproto	typeref:struct:ofproto::connmgr
connmgr_create	.\ofproto\connmgr.c	/^connmgr_create(struct ofproto *ofproto,$/;"	f
connmgr_destroy	.\ofproto\connmgr.c	/^connmgr_destroy(struct connmgr *mgr)$/;"	f
connmgr_failure_duration	.\ofproto\connmgr.c	/^connmgr_failure_duration(const struct connmgr *mgr)$/;"	f
connmgr_free_controller_info	.\ofproto\connmgr.c	/^connmgr_free_controller_info(struct shash *info)$/;"	f
connmgr_get_controller_info	.\ofproto\connmgr.c	/^connmgr_get_controller_info(struct connmgr *mgr, struct shash *info)$/;"	f
connmgr_get_fail_mode	.\ofproto\connmgr.c	/^connmgr_get_fail_mode(const struct connmgr *mgr)$/;"	f
connmgr_get_max_probe_interval	.\ofproto\connmgr.c	/^connmgr_get_max_probe_interval(const struct connmgr *mgr)$/;"	f
connmgr_get_memory_usage	.\ofproto\connmgr.c	/^connmgr_get_memory_usage(const struct connmgr *mgr, struct simap *usage)$/;"	f
connmgr_get_snoops	.\ofproto\connmgr.c	/^connmgr_get_snoops(const struct connmgr *mgr, struct sset *snoops)$/;"	f
connmgr_has_controllers	.\ofproto\connmgr.c	/^connmgr_has_controllers(const struct connmgr *mgr)$/;"	f
connmgr_has_in_band	.\ofproto\connmgr.c	/^connmgr_has_in_band(struct connmgr *mgr)$/;"	f
connmgr_has_snoops	.\ofproto\connmgr.c	/^connmgr_has_snoops(const struct connmgr *mgr)$/;"	f
connmgr_is_any_controller_admitted	.\ofproto\connmgr.c	/^connmgr_is_any_controller_admitted(const struct connmgr *mgr)$/;"	f
connmgr_is_any_controller_connected	.\ofproto\connmgr.c	/^connmgr_is_any_controller_connected(const struct connmgr *mgr)$/;"	f
connmgr_reconnect	.\ofproto\connmgr.c	/^connmgr_reconnect(const struct connmgr *mgr)$/;"	f
connmgr_retry	.\ofproto\connmgr.c	/^connmgr_retry(struct connmgr *mgr)$/;"	f
connmgr_send_flow_removed	.\ofproto\connmgr.c	/^connmgr_send_flow_removed(struct connmgr *mgr,$/;"	f
connmgr_send_packet_in	.\ofproto\connmgr.c	/^connmgr_send_packet_in(struct connmgr *mgr,$/;"	f
connmgr_send_port_status	.\ofproto\connmgr.c	/^connmgr_send_port_status(struct connmgr *mgr, struct ofconn *source,$/;"	f
connmgr_set_extra_in_band_remotes	.\ofproto\connmgr.c	/^connmgr_set_extra_in_band_remotes(struct connmgr *mgr,$/;"	f
connmgr_set_fail_mode	.\ofproto\connmgr.c	/^connmgr_set_fail_mode(struct connmgr *mgr, enum ofproto_fail_mode fail_mode)$/;"	f
connmgr_set_in_band_queue	.\ofproto\connmgr.c	/^connmgr_set_in_band_queue(struct connmgr *mgr, int queue_id)$/;"	f
connmgr_set_snoops	.\ofproto\connmgr.c	/^connmgr_set_snoops(struct connmgr *mgr, const struct sset *snoops)$/;"	f
connmgr_wait	.\ofproto\connmgr.c	/^connmgr_wait(struct connmgr *mgr, bool handling_openflow)$/;"	f
conns	.\lib\memory.c	/^static struct unixctl_conn **conns;$/;"	v	typeref:struct:unixctl_conn	file:
conns	.\lib\unixctl.c	/^    struct list conns;$/;"	m	struct:unixctl_server	typeref:struct:unixctl_server::list	file:
conns	.\tests\test-stp.c	/^    struct lan_conn conns[16];$/;"	m	struct:lan	typeref:struct:lan::lan_conn	file:
constant_hash	.\tests\test-hindex.c	/^constant_hash(int value OVS_UNUSED)$/;"	f	file:
constant_hash	.\tests\test-hmap.c	/^constant_hash(int value OVS_UNUSED)$/;"	f	file:
constraintsToEnglish	.\python\ovs\db\types.py	/^    def constraintsToEnglish(self, escapeLiteral=returnUnchanged,$/;"	m	class:BaseType
constraintsToEnglish	.\python\ovs\db\types.py	/^    def constraintsToEnglish(self, escapeLiteral=returnUnchanged,$/;"	m	class:Type
construct	.\lib\netdev-provider.h	/^    int (*construct)(struct netdev *);$/;"	m	struct:netdev_class
construct	.\ofproto\ofproto-dpif.c	/^construct(struct ofproto *ofproto_)$/;"	f	file:
construct	.\ofproto\ofproto-provider.h	/^    int (*construct)(struct ofproto *ofproto);$/;"	m	struct:ofproto_class
consume_optional	.\python\compat\argparse.py	/^        def consume_optional(start_index):$/;"	f	function:ArgumentParser._parse_known_args
consume_positionals	.\python\compat\argparse.py	/^        def consume_positionals(start_index):$/;"	f	function:ArgumentParser._parse_known_args
consume_skb	.\datapath\linux\compat\include\linux\skbuff.h	188;"	d
control_handler	.\lib\daemon-windows.c	/^control_handler(DWORD request)$/;"	f
control_ip	.\ofproto\ofproto.h	/^    char *control_ip;$/;"	m	struct:ofproto_sflow_options
controller	.\lib\ofp-actions.c	/^    struct nx_action_controller controller;$/;"	m	union:ofp_action	typeref:struct:ofp_action::nx_action_controller	file:
controller	.\lib\vswitch-idl.h	/^	struct ovsrec_controller **controller;$/;"	m	struct:ovsrec_bridge	typeref:struct:ovsrec_bridge::ovsrec_controller
controller	.\tests\test-controller.c	/^VLOG_DEFINE_THIS_MODULE(controller);$/;"	v
controller_burst_limit	.\lib\vswitch-idl.h	/^	int64_t *controller_burst_limit;$/;"	m	struct:ovsrec_controller
controller_from_openflow	.\lib\ofp-actions.c	/^controller_from_openflow(const struct nx_action_controller *nac,$/;"	f	file:
controller_id	.\include\openflow\nicira-ext.h	/^    ovs_be16 controller_id;         \/* Controller ID to send packet-in. *\/$/;"	m	struct:nx_action_controller
controller_id	.\include\openflow\nicira-ext.h	/^    ovs_be16 controller_id;     \/* New controller connection ID. *\/$/;"	m	struct:nx_controller_id
controller_id	.\lib\ofp-actions.h	/^    uint16_t controller_id;     \/* Controller ID to send packet-in. *\/$/;"	m	struct:ofpact_controller
controller_id	.\ofproto\connmgr.c	/^    uint16_t controller_id;     \/* Connection controller ID. *\/$/;"	m	struct:ofconn	file:
controller_id	.\ofproto\connmgr.h	/^    uint16_t controller_id;     \/* Controller ID to send to. *\/$/;"	m	struct:ofproto_packet_in
controller_rate_limit	.\lib\vswitch-idl.h	/^	int64_t *controller_rate_limit;$/;"	m	struct:ovsrec_controller
controllers	.\ofproto\connmgr.c	/^    struct hmap controllers;   \/* All OFCONN_PRIMARY controllers. *\/$/;"	m	struct:connmgr	typeref:struct:connmgr::hmap	file:
convert_arg_line_to_args	.\python\compat\argparse.py	/^    def convert_arg_line_to_args(self, arg_line):$/;"	m	class:ArgumentParser
convert_stats	.\lib\netdev-bsd.c	/^convert_stats(const struct netdev *netdev, struct netdev_stats *stats,$/;"	f	file:
convert_stats_system	.\lib\netdev-bsd.c	/^convert_stats_system(struct netdev_stats *stats, const struct if_data *ifd)$/;"	f	file:
convert_stats_tap	.\lib\netdev-bsd.c	/^convert_stats_tap(struct netdev_stats *stats, const struct if_data *ifd)$/;"	f	file:
cookie	.\include\openflow\nicira-ext.h	/^    ovs_be64 cookie;              \/* Opaque controller-issued identifier. *\/$/;"	m	struct:nx_flow_mod
cookie	.\include\openflow\nicira-ext.h	/^    ovs_be64 cookie;            \/* Cookie for new flow. *\/$/;"	m	struct:nx_action_learn
cookie	.\include\openflow\nicira-ext.h	/^    ovs_be64 cookie;            \/* Opaque controller-issued identifier. *\/$/;"	m	struct:nx_flow_update_full
cookie	.\include\openflow\nicira-ext.h	/^    ovs_be64 cookie;          \/* Cookie of the rule that was looked up. *\/$/;"	m	struct:nx_packet_in
cookie	.\include\openflow\nicira-ext.h	/^    ovs_be64 cookie;          \/* Opaque controller-issued identifier. *\/$/;"	m	struct:nx_flow_removed
cookie	.\include\openflow\nicira-ext.h	/^    ovs_be64 cookie;          \/* Opaque controller-issued identifier. *\/$/;"	m	struct:nx_flow_stats
cookie	.\include\openflow\openflow-1.0.h	/^    ovs_32aligned_be64 cookie;       \/* Opaque controller-issued identifier. *\/$/;"	m	struct:ofp10_flow_stats
cookie	.\include\openflow\openflow-1.0.h	/^    ovs_be64 cookie;             \/* Opaque controller-issued identifier. *\/$/;"	m	struct:ofp10_flow_mod
cookie	.\include\openflow\openflow-1.0.h	/^    ovs_be64 cookie;          \/* Opaque controller-issued identifier. *\/$/;"	m	struct:ofp10_flow_removed
cookie	.\include\openflow\openflow-1.1.h	/^    ovs_be64 cookie;             \/* Opaque controller-issued identifier. *\/$/;"	m	struct:ofp11_flow_mod
cookie	.\include\openflow\openflow-1.1.h	/^    ovs_be64 cookie;           \/* Opaque controller-issued identifier. *\/$/;"	m	struct:ofp11_flow_stats
cookie	.\include\openflow\openflow-1.1.h	/^    ovs_be64 cookie;          \/* Opaque controller-issued identifier. *\/$/;"	m	struct:ofp11_flow_removed
cookie	.\include\openflow\openflow-1.1.h	/^    ovs_be64 cookie;          \/* Require matching entries to contain this$/;"	m	struct:ofp11_flow_stats_request
cookie	.\include\openflow\openflow-1.2.h	/^    ovs_be64 cookie;          \/* Opaque controller-issued identifier. *\/$/;"	m	struct:ofp12_flow_removed
cookie	.\include\openflow\openflow-1.3.h	/^    ovs_be64 cookie;          \/* Cookie of the flow entry that was looked up *\/$/;"	m	struct:ofp13_action_self_learning::ofp13_packet_in
cookie	.\lib\ofp-actions.h	/^    uint64_t cookie;            \/* Cookie for new flow. *\/$/;"	m	struct:ofpact_learn
cookie	.\lib\ofp-util.h	/^    ovs_be64 cookie;                     \/* Flow's cookie. *\/$/;"	m	struct:ofputil_packet_in
cookie	.\lib\ofp-util.h	/^    ovs_be64 cookie;         \/* Cookie bits to match. *\/$/;"	m	struct:ofputil_flow_mod
cookie	.\lib\ofp-util.h	/^    ovs_be64 cookie;$/;"	m	struct:ofputil_flow_removed
cookie	.\lib\ofp-util.h	/^    ovs_be64 cookie;$/;"	m	struct:ofputil_flow_stats
cookie	.\lib\ofp-util.h	/^    ovs_be64 cookie;$/;"	m	struct:ofputil_flow_stats_request
cookie	.\lib\ofp-util.h	/^    ovs_be64 cookie;$/;"	m	struct:ofputil_flow_update
cookie	.\ofproto\ofproto.c	/^    ovs_be64 cookie;$/;"	m	struct:rule_criteria	file:
cookie	.\ofproto\pktbuf.c	/^    uint32_t cookie;$/;"	m	struct:packet	file:
cookie	.\utilities\ovs-ofctl.c	/^    ovs_be64 cookie;$/;"	m	struct:fte_version	file:
cookie_mask	.\include\openflow\openflow-1.1.h	/^    ovs_be64 cookie_mask;        \/* Mask used to restrict the cookie bits$/;"	m	struct:ofp11_flow_mod
cookie_mask	.\include\openflow\openflow-1.1.h	/^    ovs_be64 cookie_mask;     \/* Mask used to restrict the cookie bits that$/;"	m	struct:ofp11_flow_stats_request
cookie_mask	.\lib\ofp-util.h	/^    ovs_be64 cookie_mask;    \/* 1-bit in each 'cookie' bit to match. *\/$/;"	m	struct:ofputil_flow_mod
cookie_mask	.\lib\ofp-util.h	/^    ovs_be64 cookie_mask;$/;"	m	struct:ofputil_flow_stats_request
cookie_mask	.\ofproto\ofproto.c	/^    ovs_be64 cookie_mask;$/;"	m	struct:rule_criteria	file:
copy	.\python\ovs\db\data.py	/^    def copy(self):$/;"	m	class:Datum
copy	.\python\ovs\db\schema.py	/^    def copy(self):$/;"	m	class:DbSchema
copy	.\python\ovs\db\types.py	/^    def copy(self):$/;"	m	class:BaseType
copy	.\python\ovs\db\types.py	/^    def copy(self):$/;"	m	class:Type
copy	.\python\ovs\unixctl\client.py	/^import copy$/;"	i
copy	.\python\ovs\unixctl\server.py	/^import copy$/;"	i
copyCValue	.\python\ovs\db\types.py	/^    def copyCValue(self, dst, src):$/;"	m	class:BaseType
copy_action	.\datapath\flow_netlink.c	/^static int copy_action(const struct nlattr *from,$/;"	f	file:
count	.\datapath\flow_table.h	/^	int count, max;$/;"	m	struct:mask_array
count	.\datapath\flow_table.h	/^	unsigned int count;$/;"	m	struct:flow_table
count	.\lib\coverage.h	/^    unsigned int (*const count)(void); \/* Gets, zeros this thread's count. *\/$/;"	m	struct:coverage_counter
count	.\lib\netdev-dpdk.c	/^    int count;$/;"	m	struct:dpdk_tx_queue	file:
count	.\lib\netflow.h	/^    ovs_be16 count;                \/* Number of records in this message. *\/$/;"	m	struct:netflow_v5_header
count	.\lib\ovs-atomic.h	/^    atomic_uint count;$/;"	m	struct:ovs_refcount
count	.\lib\ovs-thread.h	/^    atomic_uint32_t count;    \/* Number of threads already hit the barrier. *\/$/;"	m	struct:ovs_barrier
count	.\tests\test-ovsdb.c	/^    int count;$/;"	m	struct:do_query_distinct_class	file:
count_1bits	.\lib\util.h	/^count_1bits(uint64_t x)$/;"	f
count_1bits_32__	.\lib\util.h	/^count_1bits_32__(uint32_t x)$/;"	f
count_1bits_8	.\lib\util.c	/^const uint8_t count_1bits_8[256] = {$/;"	v
count_cpu_cores	.\lib\ovs-thread.c	/^count_cpu_cores(void)$/;"	f
count_crashes	.\vswitchd\system-stats.c	/^count_crashes(pid_t pid)$/;"	f	file:
count_fields	.\lib\stream.c	/^count_fields(const char *s_)$/;"	f	file:
count_hi	.\lib\sha1.h	/^    uint32_t count_lo, count_hi; \/* 64-bit bit counts. *\/$/;"	m	struct:sha1_ctx
count_lo	.\lib\sha1.h	/^    uint32_t count_lo, count_hi; \/* 64-bit bit counts. *\/$/;"	m	struct:sha1_ctx
count_ones	.\tests\test-classifier.c	/^count_ones(unsigned long int x)$/;"	f	file:
count_output_actions	.\ofproto\ofproto-dpif-xlate.c	/^count_output_actions(const struct ofpbuf *odp_actions)$/;"	f	file:
counter	.\lib\uuid.c	/^static uint64_t counter[2];$/;"	v	file:
counterBlock	.\lib\sflow.h	/^    SFLCounters_type counterBlock;$/;"	m	struct:_SFLCounters_sample_element
countersCountdown	.\lib\sflow_api.h	/^    time_t countersCountdown;$/;"	m	struct:_SFLPoller
countersSampleSeqNo	.\lib\sflow_api.h	/^    u_int32_t countersSampleSeqNo;$/;"	m	struct:_SFLPoller
counts	.\lib\tag.h	/^    unsigned int counts[N_TAG_BITS];$/;"	m	struct:tag_tracker
counts	.\tests\test-ovsdb.c	/^    int *counts;$/;"	m	struct:do_query_cbdata	file:
coverage	.\lib\coverage.c	/^VLOG_DEFINE_THIS_MODULE(coverage);$/;"	v
coverage_array_sum	.\lib\coverage.c	/^coverage_array_sum(const unsigned int *arr, const unsigned int len)$/;"	f	file:
coverage_clear	.\lib\coverage.c	/^coverage_clear(void)$/;"	f
coverage_counter	.\lib\coverage.h	/^struct coverage_counter {$/;"	s
coverage_counter_register	.\lib\coverage.c	/^coverage_counter_register(struct coverage_counter* counter)$/;"	f
coverage_counters	.\lib\coverage.c	/^static struct coverage_counter **coverage_counters = NULL;$/;"	v	typeref:struct:coverage_counter	file:
coverage_hash	.\lib\coverage.c	/^coverage_hash(void)$/;"	f	file:
coverage_hit	.\lib\coverage.c	/^coverage_hit(uint32_t hash)$/;"	f	file:
coverage_init	.\lib\coverage.c	/^coverage_init(void)$/;"	f
coverage_log	.\lib\coverage.c	/^coverage_log(void)$/;"	f
coverage_mutex	.\lib\coverage.c	/^static struct ovs_mutex coverage_mutex = OVS_MUTEX_INITIALIZER;$/;"	v	typeref:struct:ovs_mutex	file:
coverage_read	.\lib\coverage.c	/^coverage_read(struct svec *lines)$/;"	f	file:
coverage_run	.\lib\coverage.c	/^coverage_run(void)$/;"	f
coverage_run_time	.\lib\coverage.c	/^static long long int coverage_run_time = LLONG_MIN;$/;"	v	file:
coverage_unixctl_show	.\lib\coverage.c	/^coverage_unixctl_show(struct unixctl_conn *conn, int argc OVS_UNUSED,$/;"	f	file:
cpath_down	.\lib\bfd.c	/^    bool cpath_down;              \/* Concatenated Path Down. *\/$/;"	m	struct:bfd	file:
cpu	.\lib\timeval.c	/^    unsigned long long int cpu; \/* Total user+system CPU usage when sampled. *\/$/;"	m	struct:cpu_usage	file:
cpu_tracker	.\lib\timeval.c	/^struct cpu_tracker {$/;"	s	file:
cpu_usage	.\lib\timeval.c	/^    int cpu_usage;$/;"	m	struct:cpu_tracker	file:
cpu_usage	.\lib\timeval.c	/^struct cpu_usage {$/;"	s	file:
cputime	.\vswitchd\system-stats.c	/^    long long int cputime;      \/* ms of CPU used during 'uptime'. *\/$/;"	m	struct:process_info	file:
cputime	.\vswitchd\system-stats.c	/^    long long int cputime;      \/* ms of CPU used during 'uptime'. *\/$/;"	m	struct:raw_process_info	file:
cr	.\lib\dpif-netdev.c	/^    const struct cls_rule cr;   \/* In owning dp_netdev's 'cls'. *\/$/;"	m	struct:dp_netdev_flow	typeref:struct:dp_netdev_flow::cls_rule	file:
cr	.\ofproto\ofproto-provider.h	/^    const struct cls_rule cr;      \/* In owning ofproto's classifier. *\/$/;"	m	struct:rule	typeref:struct:rule::cls_rule
cr	.\ofproto\ofproto.c	/^    struct cls_rule cr;$/;"	m	struct:rule_criteria	typeref:struct:rule_criteria::cls_rule	file:
crashes	.\vswitchd\system-stats.c	/^    int crashes;                \/* # of crashes (usually 0). *\/$/;"	m	struct:process_info	file:
crc32Table	.\lib\crc32c.c	/^static const uint32_t crc32Table[256] = {$/;"	v	file:
crc32_u32	.\datapath\linux\compat\hash-x86.c	/^static inline u32 crc32_u32(u32 crc, u32 val)$/;"	f	file:
crc32c	.\lib\crc32c.c	/^crc32c(const uint8_t *data, size_t size)$/;"	f
create	.\datapath\vport.h	/^	struct vport *(*create)(const struct vport_parms *);$/;"	m	struct:vport_ops	typeref:struct:vport_ops::create
create	.\python\ovs\unixctl\client.py	/^    def create(path):$/;"	m	class:UnixctlClient
create	.\python\ovs\unixctl\server.py	/^    def create(path):$/;"	m	class:UnixctlClient
create	.\python\ovs\unixctl\server.py	/^    def create(path, version=None):$/;"	m	class:UnixctlServer
create_bond_device	.\xenserver\opt_xensource_libexec_InterfaceReconfigureBridge.py	/^def create_bond_device(pif):$/;"	f
create_dpif_netdev	.\lib\dpif-netdev.c	/^create_dpif_netdev(struct dp_netdev *dp)$/;"	f	file:
create_error	.\python\ovs\jsonrpc.py	/^    def create_error(error, id):$/;"	m	class:Message
create_notify	.\python\ovs\jsonrpc.py	/^    def create_notify(method, params):$/;"	m	class:Message
create_partition	.\lib\classifier.c	/^create_partition(struct cls_classifier *cls, struct cls_subtable *subtable,$/;"	f	file:
create_reply	.\python\ovs\jsonrpc.py	/^    def create_reply(result, id):$/;"	m	class:Message
create_request	.\python\ovs\jsonrpc.py	/^    def create_request(method, params):$/;"	m	class:Message
create_symbol	.\utilities\ovs-vsctl.c	/^create_symbol(struct ovsdb_symbol_table *symtab, const char *id, bool *newp)$/;"	f	file:
create_symbol	.\vtep\vtep-ctl.c	/^create_symbol(struct ovsdb_symbol_table *symtab, const char *id, bool *newp)$/;"	f	file:
created	.\lib\netdev-linux.c	/^    long long int created;      \/* Time queue was created, in msecs. *\/$/;"	m	struct:tc_queue	file:
created	.\lib\netdev.h	/^    long long int created;$/;"	m	struct:netdev_queue_stats
created	.\lib\ovsdb-data.h	/^    bool created;               \/* Already used to create row? *\/$/;"	m	struct:ovsdb_symbol
created	.\ofproto\netflow.c	/^    long long int created;        \/* Time flow was created since time out. *\/$/;"	m	struct:netflow_flow	file:
created	.\ofproto\ofproto-provider.h	/^    long long int created;      \/* Creation time. *\/$/;"	m	struct:ofgroup
created	.\ofproto\ofproto-provider.h	/^    long long int created;      \/* Time created, in msec. *\/$/;"	m	struct:ofport
created	.\ofproto\ofproto.c	/^    long long int created;      \/* Time created. *\/$/;"	m	struct:meter	file:
created	.\ovsdb\trigger.h	/^    long long int created;      \/* Time created. *\/$/;"	m	struct:ovsdb_trigger
creation_time	.\lib\rconn.c	/^    time_t creation_time;$/;"	m	struct:rconn	file:
creation_time	.\lib\reconnect.c	/^    long long int creation_time;$/;"	m	struct:reconnect	file:
creation_time	.\lib\reconnect.h	/^    long long int creation_time;     \/* Time reconnect_create() called. *\/$/;"	m	struct:reconnect_stats
criteria	.\utilities\ovs-ofctl.c	/^static struct sort_criterion *criteria;$/;"	v	typeref:struct:sort_criterion	file:
csSeqNo	.\tests\test-sflow.c	/^    uint32_t csSeqNo;$/;"	m	struct:sflow_xdr	file:
csum	.\lib\csum.c	/^csum(const void *data, size_t n)$/;"	f
csum	.\lib\netdev.h	/^    bool csum;$/;"	m	struct:netdev_tunnel_config
csum	.\tests\test-csum.c	/^    uint16_t csum;$/;"	m	struct:test_case	file:
csum_add16	.\lib\csum.c	/^csum_add16(uint32_t partial, ovs_be16 new)$/;"	f
csum_add32	.\lib\csum.c	/^csum_add32(uint32_t partial, ovs_be32 new)$/;"	f
csum_and_copy_to_user	.\datapath\linux\compat\include\net\checksum.h	17;"	d
csum_continue	.\lib\csum.c	/^csum_continue(uint32_t partial, const void *data_, size_t n)$/;"	f
csum_finish	.\lib\csum.c	/^csum_finish(uint32_t partial)$/;"	f
csum_replace2	.\datapath\linux\compat\include\net\checksum.h	/^static inline void csum_replace2(__sum16 *sum, __be16 from, __be16 to)$/;"	f
csum_replace4	.\datapath\linux\compat\include\net\checksum.h	/^static inline void csum_replace4(__sum16 *sum, __be32 from, __be32 to)$/;"	f
csum_unfold	.\datapath\linux\compat\include\net\checksum.h	/^static inline __wsum csum_unfold(__sum16 n)$/;"	f
ctx	.\lib\stream-ssl.c	/^static SSL_CTX *ctx;$/;"	v	file:
ctypes	.\python\compat\uuid.py	/^        import ctypes$/;"	i
ctypes	.\python\compat\uuid.py	/^    import ctypes, ctypes.util$/;"	i
ctz32	.\lib\util.h	/^ctz32(uint32_t n)$/;"	f
ctz64	.\lib\util.h	/^ctz64(uint64_t n)$/;"	f
cur_cfg	.\lib\vswitch-idl.h	/^	int64_t cur_cfg;$/;"	m	struct:ovsrec_open_vswitch
cur_queue	.\lib\netdev-linux.c	/^    size_t cur_queue;$/;"	m	struct:netdev_linux_queue_state	file:
curr	.\include\openflow\openflow-1.0.h	/^    ovs_be32 curr;          \/* Current features. *\/$/;"	m	struct:ofp10_phy_port
curr	.\include\openflow\openflow-1.1.h	/^    ovs_be32 curr;          \/* Current features. *\/$/;"	m	struct:ofp11_port
curr	.\include\openflow\openflow-1.4.h	/^    ovs_be32 curr;          \/* Current features. *\/$/;"	m	struct:ofp14_port_desc_prop_ethernet
curr	.\lib\ofp-util.h	/^    enum netdev_features curr;       \/* Current features. *\/$/;"	m	struct:ofputil_phy_port	typeref:enum:ofputil_phy_port::netdev_features
curr_speed	.\include\openflow\openflow-1.1.h	/^    ovs_be32 curr_speed;    \/* Current port bitrate in kbps. *\/$/;"	m	struct:ofp11_port
curr_speed	.\include\openflow\openflow-1.4.h	/^    ovs_be32 curr_speed;    \/* Current port bitrate in kbps. *\/$/;"	m	struct:ofp14_port_desc_prop_ethernet
curr_speed	.\lib\ofp-util.h	/^    uint32_t curr_speed;        \/* Current speed, in kbps. *\/$/;"	m	struct:ofputil_phy_port
current	.\lib\netdev-linux.c	/^    enum netdev_features current;    \/* Cached from ETHTOOL_GSET. *\/$/;"	m	struct:netdev_linux	typeref:enum:netdev_linux::netdev_features	file:
current_column	.\lib\table.h	/^    size_t current_column;$/;"	m	struct:table
d	.\lib\hindex.h	/^    struct hindex_node *d;$/;"	m	struct:hindex_node	typeref:struct:hindex_node::hindex_node
daemon	.\lib\daemon.c	/^VLOG_DEFINE_THIS_MODULE(daemon);$/;"	v
daemon	.\tests\appctl.py	/^import ovs.daemon$/;"	i
daemon	.\tests\test-daemon.py	/^import ovs.daemon$/;"	i
daemon	.\tests\test-jsonrpc.py	/^import ovs.daemon$/;"	i
daemon	.\tests\test-unixctl.py	/^import ovs.daemon$/;"	i
daemon_save_fd	.\lib\daemon.c	/^daemon_save_fd(int fd)$/;"	f
daemon_set_monitor	.\lib\daemon-unix.c	/^daemon_set_monitor(void)$/;"	f
daemon_unix	.\lib\daemon-unix.c	/^VLOG_DEFINE_THIS_MODULE(daemon_unix);$/;"	v
daemon_usage	.\lib\daemon-unix.c	/^daemon_usage(void)$/;"	f
daemon_usage	.\lib\daemon-windows.c	/^daemon_usage(void)$/;"	f
daemon_windows	.\lib\daemon-windows.c	/^VLOG_DEFINE_THIS_MODULE(daemon_windows);$/;"	v
daemonize	.\lib\daemon.c	/^daemonize(void)$/;"	f
daemonize	.\python\ovs\daemon.py	/^def daemonize():$/;"	f
daemonize_complete	.\lib\daemon-unix.c	/^daemonize_complete(void)$/;"	f
daemonize_complete	.\lib\daemon-windows.c	/^daemonize_complete(void)$/;"	f
daemonize_complete	.\python\ovs\daemon.py	/^def daemonize_complete():$/;"	f
daemonize_fd	.\lib\daemon-unix.c	/^static int daemonize_fd = -1;$/;"	v	file:
daemonize_post_detach	.\lib\daemon-unix.c	/^daemonize_post_detach(void)$/;"	f	file:
daemonize_start	.\lib\daemon-unix.c	/^daemonize_start(void)$/;"	f
daemonize_start	.\lib\daemon-windows.c	/^void daemonize_start(void)$/;"	f
daemonize_start	.\python\ovs\daemon.py	/^def daemonize_start():$/;"	f
daemonize_txn	.\vswitchd\bridge.c	/^static struct ovsdb_idl_txn *daemonize_txn;$/;"	v	typeref:struct:ovsdb_idl_txn	file:
data	.\datapath\linux\compat\include\net\vxlan.h	/^	void		 *data;$/;"	m	struct:vxlan_sock
data	.\include\openflow\openflow-1.0.h	/^    uint8_t data[0];        \/* Ethernet frame, halfway through 32-bit word,$/;"	m	struct:ofp10_packet_in
data	.\include\openflow\openflow-common.h	/^    uint8_t data[0];          \/* Variable-length data.  Interpreted based$/;"	m	struct:ofp_error_msg
data	.\lib\flow.c	/^    uint32_t *data;$/;"	m	struct:mf_ctx	file:
data	.\lib\hmapx.h	/^    void *data;$/;"	m	struct:hmapx_node
data	.\lib\netdev-bsd.c	/^    void *data;$/;"	m	struct:pcap_arg	file:
data	.\lib\ofp-actions.h	/^    uint8_t data[];$/;"	m	struct:ofpact_note
data	.\lib\sflow_api.h	/^    u_int32_t data[(SFL_MAX_DATAGRAM_SIZE + SFL_DATA_PAD) \/ sizeof(u_int32_t)];$/;"	m	struct:_SFLSampleCollector
data	.\lib\sha1.h	/^    uint32_t data[16];           \/* SHA data buffer *\/$/;"	m	struct:sha1_ctx
data	.\lib\shash.h	/^    void *data;$/;"	m	struct:shash_node
data	.\lib\simap.h	/^    unsigned int data;$/;"	m	struct:simap_node
data	.\ovsdb\ovsdb-client.c	/^    struct ovsdb_datum **data;$/;"	m	struct:dump_table_aux	typeref:struct:dump_table_aux::ovsdb_datum	file:
data	.\python\ovs\db\types.py	/^import ovs.db.data$/;"	i
data	.\tests\test-csum.c	/^    char *data;$/;"	m	struct:test_case	file:
data	.\tests\test-ovsdb.py	/^from ovs.db import data$/;"	i
data	.\tests\test-sha1.c	/^    char *data;$/;"	m	struct:test_vector	file:
data	.\tests\test-stp.c	/^    void *data;$/;"	m	struct:bpdu	file:
dataReceived	.\python\ovstest\tcp.py	/^    def dataReceived(self, data):$/;"	m	class:TcpListenerConnection
dataReceived	.\python\ovstest\tcp.py	/^    def dataReceived(self, data):$/;"	m	class:TcpSenderConnection
data_pull	.\lib\flow.c	/^data_pull(void **datap, size_t *sizep, size_t size)$/;"	f	file:
data_try_pull	.\lib\flow.c	/^data_try_pull(void **datap, size_t *sizep, size_t size)$/;"	f	file:
database	.\lib\ovsdb-idl-provider.h	/^    const char *database;       \/* <db-name> for this database. *\/$/;"	m	struct:ovsdb_idl_class
datagramReceived	.\python\ovstest\udp.py	/^    def datagramReceived(self, data, (_1, _2)):$/;"	m	class:UdpListener
datagramReceived	.\python\ovstest\udp.py	/^    def datagramReceived(self, data, (host, port)):$/;"	m	class:UdpSender
datagram_version	.\lib\sflow.h	/^    u_int32_t datagram_version;      \/* (enum SFLDatagram_version) = VERSION5 = 5 *\/$/;"	m	struct:_SFLSample_datagram_hdr
datap	.\lib\sflow_api.h	/^    u_int32_t *datap; \/* packet fill pointer *\/$/;"	m	struct:_SFLSampleCollector
datap	.\tests\test-sflow.c	/^    ovs_be32 *datap;$/;"	m	struct:sflow_xdr	file:
datapath	.\datapath\datapath.h	/^struct datapath {$/;"	s
datapath_configure_bond	.\xenserver\opt_xensource_libexec_InterfaceReconfigureVswitch.py	/^def datapath_configure_bond(pif,slaves):$/;"	f
datapath_configure_tunnel	.\xenserver\opt_xensource_libexec_InterfaceReconfigureVswitch.py	/^def datapath_configure_tunnel(pif):$/;"	f
datapath_deconfigure_bond	.\xenserver\opt_xensource_libexec_InterfaceReconfigureVswitch.py	/^def datapath_deconfigure_bond(netdev):$/;"	f
datapath_deconfigure_ipdev	.\xenserver\opt_xensource_libexec_InterfaceReconfigureVswitch.py	/^def datapath_deconfigure_ipdev(interface):$/;"	f
datapath_deconfigure_physical	.\xenserver\opt_xensource_libexec_InterfaceReconfigureVswitch.py	/^def datapath_deconfigure_physical(netdev):$/;"	f
datapath_get_physical_pifs	.\xenserver\opt_xensource_libexec_InterfaceReconfigureVswitch.py	/^def datapath_get_physical_pifs(pif):$/;"	f
datapath_id	.\include\openflow\openflow-common.h	/^    ovs_be64 datapath_id;   \/* Datapath unique ID.  The lower 48-bits are for$/;"	m	struct:ofp_switch_features
datapath_id	.\lib\learning-switch.c	/^    unsigned long long int datapath_id;$/;"	m	struct:lswitch	file:
datapath_id	.\lib\ofp-util.h	/^    uint64_t datapath_id;       \/* Datapath unique ID. *\/$/;"	m	struct:ofputil_switch_features
datapath_id	.\lib\vswitch-idl.h	/^	char *datapath_id;$/;"	m	struct:ovsrec_bridge
datapath_id	.\ofproto\ofproto-provider.h	/^    uint64_t datapath_id;       \/* Datapath ID. *\/$/;"	m	struct:ofproto
datapath_modify_config	.\xenserver\opt_xensource_libexec_InterfaceReconfigureVswitch.py	/^def datapath_modify_config(commands):$/;"	f
datapath_policy	.\datapath\datapath.c	/^static const struct nla_policy datapath_policy[OVS_DP_ATTR_MAX + 1] = {$/;"	v	typeref:struct:nla_policy	file:
datapath_type	.\lib\vswitch-idl.h	/^	char *datapath_type;	\/* Always nonnull. *\/$/;"	m	struct:ovsrec_bridge
datetime	.\python\ovs\vlog.py	/^import datetime$/;"	i
datum	.\lib\ovsdb-data.c	/^    struct ovsdb_datum *datum;$/;"	m	struct:ovsdb_datum_sort_cbdata	typeref:struct:ovsdb_datum_sort_cbdata::ovsdb_datum	file:
db	.\ovsdb\execution.c	/^    struct ovsdb *db;$/;"	m	struct:ovsdb_execution	typeref:struct:ovsdb_execution::ovsdb	file:
db	.\ovsdb\file.c	/^    struct ovsdb *db;$/;"	m	struct:ovsdb_file	typeref:struct:ovsdb_file::ovsdb	file:
db	.\ovsdb\jsonrpc-server.c	/^    struct ovsdb *db;$/;"	m	struct:ovsdb_jsonrpc_monitor	typeref:struct:ovsdb_jsonrpc_monitor::ovsdb	file:
db	.\ovsdb\ovsdb-server.c	/^    struct ovsdb *db;$/;"	m	struct:db	typeref:struct:db::ovsdb	file:
db	.\ovsdb\ovsdb-server.c	/^struct db {$/;"	s	file:
db	.\ovsdb\transaction.c	/^    struct ovsdb *db;$/;"	m	struct:ovsdb_txn	typeref:struct:ovsdb_txn::ovsdb	file:
db	.\ovsdb\trigger.h	/^    struct ovsdb *db;           \/* Database on which trigger acts. *\/$/;"	m	struct:ovsdb_trigger	typeref:struct:ovsdb_trigger::ovsdb
db	.\python\ovs\db\data.py	/^import ovs.db.parser$/;"	i
db	.\python\ovs\db\data.py	/^import ovs.db.types$/;"	i
db	.\python\ovs\db\idl.py	/^import ovs.db.parser$/;"	i
db	.\python\ovs\db\idl.py	/^import ovs.db.schema$/;"	i
db	.\python\ovs\db\schema.py	/^import ovs.db.parser$/;"	i
db	.\python\ovs\db\types.py	/^import ovs.db.data$/;"	i
db	.\python\ovs\db\types.py	/^import ovs.db.parser$/;"	i
db	.\python\ovs\ovsuuid.py	/^import ovs.db.parser$/;"	i
db	.\tests\test-ovsdb.py	/^import ovs.db.idl$/;"	i
db	.\tests\test-ovsdb.py	/^import ovs.db.schema$/;"	i
db	.\utilities\ovs-vsctl.c	/^static const char *db;$/;"	v	file:
db	.\vtep\vtep-ctl.c	/^static const char *db;$/;"	v	file:
db	.\xenserver\opt_xensource_libexec_InterfaceReconfigure.py	/^def db():$/;"	f
db_init_from_cache	.\xenserver\opt_xensource_libexec_InterfaceReconfigure.py	/^def db_init_from_cache(cache):$/;"	f
db_init_from_xenapi	.\xenserver\opt_xensource_libexec_InterfaceReconfigure.py	/^def db_init_from_xenapi(session):$/;"	f
db_version	.\lib\vswitch-idl.h	/^	char *db_version;$/;"	m	struct:ovsrec_open_vswitch
dbg	.\python\ovs\vlog.py	/^    def dbg(self, message, **kwargs):$/;"	m	class:Vlog
dbg_is_enabled	.\python\ovs\vlog.py	/^    def dbg_is_enabled(self):$/;"	m	class:Vlog
dbg_rl	.\ofproto\tunnel.c	/^static struct vlog_rate_limit dbg_rl = VLOG_RATE_LIMIT_INIT(60, 60);$/;"	v	typeref:struct:vlog_rate_limit	file:
dbs	.\ovsdb\server.h	/^    struct shash dbs;      \/* Maps from a db name to a "struct ovsdb *". *\/$/;"	m	struct:ovsdb_server	typeref:struct:ovsdb_server::shash
deadline	.\lib\timeval.c	/^static long long int deadline = LLONG_MAX;$/;"	v	file:
deadline	.\python\ovs\reconnect.py	/^        def deadline(fsm):$/;"	m	class:Reconnect.Active
deadline	.\python\ovs\reconnect.py	/^        def deadline(fsm):$/;"	m	class:Reconnect.Backoff
deadline	.\python\ovs\reconnect.py	/^        def deadline(fsm):$/;"	m	class:Reconnect.ConnectInProgress
deadline	.\python\ovs\reconnect.py	/^        def deadline(fsm):$/;"	m	class:Reconnect.Idle
deadline	.\python\ovs\reconnect.py	/^        def deadline(fsm):$/;"	m	class:Reconnect.Listening
deadline	.\python\ovs\reconnect.py	/^        def deadline(fsm):$/;"	m	class:Reconnect.Reconnect
deadline	.\python\ovs\reconnect.py	/^        def deadline(fsm):$/;"	m	class:Reconnect.Void
dealloc	.\lib\netdev-provider.h	/^    void (*dealloc)(struct netdev *);$/;"	m	struct:netdev_class
dealloc	.\ofproto\ofproto-dpif.c	/^dealloc(struct ofproto *ofproto_)$/;"	f	file:
dealloc	.\ofproto\ofproto-provider.h	/^    void (*dealloc)(struct ofproto *ofproto);$/;"	m	struct:ofproto_class
dealloc_ofp_port	.\ofproto\ofproto.c	/^dealloc_ofp_port(struct ofproto *ofproto, ofp_port_t ofp_port)$/;"	f	file:
dec_ttl_cnt_ids_from_openflow	.\lib\ofp-actions.c	/^dec_ttl_cnt_ids_from_openflow(const struct nx_action_cnt_ids *nac_ids,$/;"	f	file:
dec_ttl_from_openflow	.\lib\ofp-actions.c	/^dec_ttl_from_openflow(struct ofpbuf *out, enum ofputil_action_code compat)$/;"	f	file:
decay_detect_time	.\lib\bfd.c	/^    long long int decay_detect_time; \/* Decay detection time. *\/$/;"	m	struct:bfd	file:
decay_min_rx	.\lib\bfd.c	/^    int decay_min_rx;             \/* min_rx is set to decay_min_rx when *\/$/;"	m	struct:bfd	file:
decay_rx_ctl	.\lib\bfd.c	/^    int decay_rx_ctl;             \/* Count bfd packets received within decay *\/$/;"	m	struct:bfd	file:
decay_rx_packets	.\lib\bfd.c	/^    uint64_t decay_rx_packets;    \/* Packets received by 'netdev'. *\/$/;"	m	struct:bfd	file:
decode_action_bits	.\lib\ofp-util.c	/^decode_action_bits(ovs_be32 of_actions,$/;"	f	file:
decode_nxast_action	.\lib\ofp-actions.c	/^decode_nxast_action(const union ofp_action *a, enum ofputil_action_code *code)$/;"	f	file:
decode_openflow10_action	.\lib\ofp-actions.c	/^decode_openflow10_action(const union ofp_action *a,$/;"	f	file:
decode_openflow11_action	.\lib\ofp-actions.c	/^decode_openflow11_action(const union ofp_action *a,$/;"	f	file:
decode_openflow11_instruction	.\lib\ofp-actions.c	/^decode_openflow11_instruction(const struct ofp11_instruction *inst,$/;"	f	file:
decode_openflow11_instructions	.\lib\ofp-actions.c	/^decode_openflow11_instructions(const struct ofp11_instruction insts[],$/;"	f	file:
deconfigure_bridge	.\xenserver\opt_xensource_libexec_InterfaceReconfigureVswitch.py	/^def deconfigure_bridge(pif):$/;"	f
default	.\python\ovs\db\data.py	/^    def default(type_):$/;"	m	class:Atom
default	.\python\ovs\db\data.py	/^    def default(type_):$/;"	m	class:Datum
default	.\python\ovs\db\types.py	/^    def default(self):$/;"	m	class:BaseType
default_atom	.\python\ovs\db\types.py	/^    def default_atom(self):$/;"	m	class:AtomicType
default_db	.\ovsdb\ovsdb-tool.c	/^default_db(void)$/;"	f	file:
default_db	.\utilities\ovs-vsctl.c	/^default_db(void)$/;"	f	file:
default_db	.\vtep\vtep-ctl.c	/^default_db(void)$/;"	f	file:
default_ea	.\vswitchd\bridge.c	/^    uint8_t default_ea[ETH_ADDR_LEN]; \/* Default MAC. *\/$/;"	m	struct:bridge	file:
default_flows	.\lib\learning-switch.c	/^    const struct ofputil_flow_mod *default_flows;$/;"	m	struct:lswitch	typeref:struct:lswitch::ofputil_flow_mod	file:
default_flows	.\lib\learning-switch.h	/^    const struct ofputil_flow_mod *default_flows;$/;"	m	struct:lswitch_config	typeref:struct:lswitch_config::ofputil_flow_mod
default_flows	.\tests\test-controller.c	/^static struct ofputil_flow_mod *default_flows;$/;"	v	typeref:struct:ofputil_flow_mod	file:
default_install__	.\lib\netdev-linux.c	/^default_install__(struct netdev *netdev_)$/;"	f	file:
default_pattern	.\lib\vlog.c	/^    bool default_pattern;       \/* Whether current pattern is the default. *\/$/;"	m	struct:facility	file:
default_queue	.\lib\learning-switch.c	/^    uint32_t default_queue;     \/* Default OpenFlow queue, or UINT32_MAX. *\/$/;"	m	struct:lswitch	file:
default_queue	.\lib\learning-switch.h	/^    uint32_t default_queue;$/;"	m	struct:lswitch_config
default_queue	.\tests\test-controller.c	/^static uint32_t default_queue = UINT32_MAX;$/;"	v	file:
default_schema	.\ovsdb\ovsdb-tool.c	/^default_schema(void)$/;"	f	file:
default_tc_install	.\lib\netdev-linux.c	/^default_tc_install(struct netdev *netdev,$/;"	f	file:
default_tc_load	.\lib\netdev-linux.c	/^default_tc_load(struct netdev *netdev, struct ofpbuf *nlmsg OVS_UNUSED)$/;"	f	file:
define_genl_family	.\lib\netlink-socket.c	/^define_genl_family(uint16_t id, const char *name)$/;"	f	file:
del	.\ofproto\ofproto-dpif.c	/^del(const char *type, const char *name)$/;"	f	file:
del	.\ofproto\ofproto-provider.h	/^    int (*del)(const char *type, const char *name);$/;"	m	struct:ofproto_class
del_bridge	.\utilities\ovs-vsctl.c	/^del_bridge(struct vsctl_context *ctx, struct vsctl_bridge *br)$/;"	f	file:
del_cached_bridge	.\utilities\ovs-vsctl.c	/^del_cached_bridge(struct vsctl_context *ctx, struct vsctl_bridge *br)$/;"	f	file:
del_cached_iface	.\utilities\ovs-vsctl.c	/^del_cached_iface(struct vsctl_context *ctx, struct vsctl_iface *iface)$/;"	f	file:
del_cached_ls_binding	.\vtep\vtep-ctl.c	/^del_cached_ls_binding(struct vtep_ctl_port *port, const char *vlan)$/;"	f	file:
del_cached_lswitch	.\vtep\vtep-ctl.c	/^del_cached_lswitch(struct vtep_ctl_context *ctx, struct vtep_ctl_lswitch *ls)$/;"	f	file:
del_cached_port	.\utilities\ovs-vsctl.c	/^del_cached_port(struct vsctl_context *ctx, struct vsctl_port *port)$/;"	f	file:
del_cached_port	.\vtep\vtep-ctl.c	/^del_cached_port(struct vtep_ctl_context *ctx, struct vtep_ctl_port *port)$/;"	f	file:
del_cached_pswitch	.\vtep\vtep-ctl.c	/^del_cached_pswitch(struct vtep_ctl_context *ctx, struct vtep_ctl_pswitch *ps)$/;"	f	file:
del_lswitch	.\vtep\vtep-ctl.c	/^del_lswitch(struct vtep_ctl_context *ctx, struct vtep_ctl_lswitch *ls)$/;"	f	file:
del_mcast_entry	.\vtep\vtep-ctl.c	/^del_mcast_entry(struct vtep_ctl_context *ctx,$/;"	f	file:
del_ploc_from_mcast_mac	.\vtep\vtep-ctl.c	/^del_ploc_from_mcast_mac(struct vtep_ctl_mcast_mac *mcast_mac,$/;"	f	file:
del_port	.\utilities\ovs-vsctl.c	/^del_port(struct vsctl_context *ctx, struct vsctl_port *port)$/;"	f	file:
del_port	.\vtep\vtep-ctl.c	/^del_port(struct vtep_ctl_context *ctx, struct vtep_ctl_port *port)$/;"	f	file:
del_pswitch	.\vtep\vtep-ctl.c	/^del_pswitch(struct vtep_ctl_context *ctx, struct vtep_ctl_pswitch *ps)$/;"	f	file:
del_ucast_entry	.\vtep\vtep-ctl.c	/^del_ucast_entry(struct vtep_ctl_context *ctx, bool local)$/;"	f	file:
del_work	.\datapath\linux\compat\include\net\vxlan.h	/^	struct work_struct del_work;$/;"	m	struct:vxlan_sock	typeref:struct:vxlan_sock::work_struct
delay_expires	.\ofproto\bond.c	/^    long long delay_expires;    \/* Time after which 'enabled' may change. *\/$/;"	m	struct:bond_slave	file:
delete	.\python\ovs\db\idl.py	/^    def delete(self):$/;"	m	class:Row
deleteController	.\xenserver\usr_lib_xsconsole_plugins-base_XSFeatureVSwitch.py	/^    def deleteController(self):$/;"	m	class:VSwitchControllerDialogue
delete_controllers	.\utilities\ovs-vsctl.c	/^delete_controllers(struct ovsrec_controller **controllers,$/;"	f	file:
delete_garbage_row	.\ovsdb\transaction.c	/^delete_garbage_row(struct ovsdb_txn *txn, struct ovsdb_txn_row *txn_row)$/;"	f	file:
delete_group	.\ofproto\ofproto.c	/^delete_group(struct ofproto *ofproto, uint32_t group_id)$/;"	f	file:
delete_managers	.\utilities\ovs-vsctl.c	/^delete_managers(const struct vsctl_context *ctx)$/;"	f	file:
delete_managers	.\vtep\vtep-ctl.c	/^delete_managers(const struct vtep_ctl_context *ctx)$/;"	f	file:
delete_queue	.\lib\netdev-provider.h	/^    int (*delete_queue)(struct netdev *netdev, unsigned int queue_id);$/;"	m	struct:netdev_class
delete_row_cb	.\ovsdb\execution.c	/^delete_row_cb(const struct ovsdb_row *row, void *dr_)$/;"	f	file:
delete_row_cbdata	.\ovsdb\execution.c	/^struct delete_row_cbdata {$/;"	s	file:
delete_row_refs	.\ovsdb\transaction.c	/^delete_row_refs(struct ovsdb_txn *txn, const struct ovsdb_row *row,$/;"	f	file:
delimiters	.\lib\odp-util.c	/^static const char *delimiters = ", \\t\\r\\n";$/;"	v	file:
demand	.\lib\cfm.c	/^    bool demand;           \/* Demand mode. *\/$/;"	m	struct:cfm	file:
demand	.\lib\cfm.h	/^    bool demand;                \/* Run in demand mode. *\/$/;"	m	struct:cfm_settings
demand_rx_bfd_time	.\lib\bfd.c	/^    long long int demand_rx_bfd_time;$/;"	m	struct:bfd	file:
demand_rx_ccm_t	.\lib\cfm.c	/^    struct timer demand_rx_ccm_t;$/;"	m	struct:cfm	typeref:struct:cfm::timer	file:
depth	.\lib\fat-rwlock.c	/^    unsigned int depth;$/;"	m	struct:fat_rwlock_slot	file:
depth	.\lib\json.c	/^    int depth;$/;"	m	struct:json_serializer	file:
depth	.\lib\sflow.h	/^    u_int32_t depth;$/;"	m	struct:_SFLLabelStack
dequeue_packet	.\ofproto\pinsched.c	/^dequeue_packet(struct pinsched *ps, struct pinqueue *q)$/;"	f	file:
desc	.\lib\ofp-util.h	/^    struct ofputil_phy_port desc;$/;"	m	struct:ofputil_port_status	typeref:struct:ofputil_port_status::ofputil_phy_port
describe_fd	.\lib\socket-util.c	/^describe_fd(int fd)$/;"	f
describe_sockaddr	.\lib\socket-util.c	/^describe_sockaddr(struct ds *string, int fd,$/;"	f	file:
description	.\lib\vtep-idl.h	/^	char *description;	\/* Always nonnull. *\/$/;"	m	struct:vteprec_logical_router
description	.\lib\vtep-idl.h	/^	char *description;	\/* Always nonnull. *\/$/;"	m	struct:vteprec_logical_switch
description	.\lib\vtep-idl.h	/^	char *description;	\/* Always nonnull. *\/$/;"	m	struct:vteprec_physical_port
description	.\lib\vtep-idl.h	/^	char *description;	\/* Always nonnull. *\/$/;"	m	struct:vteprec_physical_switch
description	.\tests\test-jsonrpc.py	/^                                      description=group_description)$/;"	v
designated_bridge	.\lib\stp.c	/^    stp_identifier designated_bridge; \/* 8.5.5.6. *\/$/;"	m	struct:stp_port	file:
designated_cost	.\lib\stp.c	/^    int designated_cost;            \/* 8.5.5.5: Path cost to root on port. *\/$/;"	m	struct:stp_port	file:
designated_port	.\lib\stp.c	/^    int designated_port;            \/* 8.5.5.7: Port to send config msgs on. *\/$/;"	m	struct:stp_port	file:
designated_root	.\lib\stp.c	/^    stp_identifier designated_root; \/* 8.5.3.1: Bridge believed to be root. *\/$/;"	m	struct:stp	file:
designated_root	.\lib\stp.c	/^    stp_identifier designated_root; \/* 8.5.5.4. *\/$/;"	m	struct:stp_port	file:
designated_root	.\ofproto\ofproto.h	/^    stp_identifier designated_root;$/;"	m	struct:ofproto_stp_status
destroy	.\datapath\vport.h	/^	void (*destroy)(struct vport *);$/;"	m	struct:vport_ops
destroy	.\lib\dpif-provider.h	/^    int (*destroy)(struct dpif *dpif);$/;"	m	struct:dpif_class
destroy	.\ovsdb\ovsdb.h	/^    void (*destroy)(struct ovsdb_replica *);$/;"	m	struct:ovsdb_replica_class
destroy_bond_device	.\xenserver\opt_xensource_libexec_InterfaceReconfigureBridge.py	/^def destroy_bond_device(pif):$/;"	f
destroy_bridge	.\xenserver\opt_xensource_libexec_InterfaceReconfigureBridge.py	/^    def destroy_bridge(pif):$/;"	f	function:bring_down_interface
destroy_classifier	.\tests\test-classifier.c	/^destroy_classifier(struct classifier *cls)$/;"	f	file:
destroy_dp_rcu	.\datapath\datapath.c	/^static void destroy_dp_rcu(struct rcu_head *rcu)$/;"	f	file:
destroy_rule_executes	.\ofproto\ofproto.c	/^destroy_rule_executes(struct ofproto *ofproto)$/;"	f	file:
destroy_subtable	.\lib\classifier.c	/^destroy_subtable(struct cls_classifier *cls, struct cls_subtable *subtable)$/;"	f	file:
destroy_tap	.\lib\netdev-bsd.c	/^destroy_tap(int fd, const char *name)$/;"	f	file:
destroy_vlan	.\xenserver\opt_xensource_libexec_InterfaceReconfigureBridge.py	/^    def destroy_vlan(pif):$/;"	f	function:bring_down_interface
destroyed	.\lib\dpif-netdev.c	/^    atomic_flag destroyed;$/;"	m	struct:dp_netdev	file:
destruct	.\lib\netdev-provider.h	/^    void (*destruct)(struct netdev *);$/;"	m	struct:netdev_class
destruct	.\ofproto\ofproto-dpif.c	/^destruct(struct ofproto *ofproto_)$/;"	f	file:
destruct	.\ofproto\ofproto-provider.h	/^    void (*destruct)(struct ofproto *ofproto);$/;"	m	struct:ofproto_class
destructor	.\lib\ovs-thread.c	/^    void (*destructor)(void *); \/* Called at thread exit. *\/$/;"	m	struct:ovsthread_key	file:
destructor_func	.\lib\ovs-thread.c	/^typedef void destructor_func(void *);$/;"	t	file:
detach	.\lib\daemon-unix.c	/^bool detach;                    \/* Was --detach specified? *\/$/;"	v
detach	.\lib\daemon-windows.c	/^bool detach;                 \/* Was --detach specified? *\/$/;"	v
detach_process	.\lib\daemon-windows.c	/^detach_process(int argc, char *argv[])$/;"	f	file:
detached	.\lib\daemon-unix.c	/^static bool detached;           \/* Have we already detached? *\/$/;"	v	file:
detached	.\lib\daemon-windows.c	/^static bool detached;        \/* Running as the child process. *\/$/;"	v	file:
details	.\lib\ovsdb-error.c	/^    char *details;              \/* String for "details" member. *\/$/;"	m	struct:ovsdb_error	file:
detect_time	.\lib\bfd.c	/^    long long int detect_time;    \/* RFC 5880 6.8.4 Detection time. *\/$/;"	m	struct:bfd	file:
determine_changes	.\ovsdb\transaction.c	/^determine_changes(struct ovsdb_txn *txn, struct ovsdb_txn_row *txn_row)$/;"	f	file:
dev	.\datapath\vport-netdev.h	/^	struct net_device *dev;$/;"	m	struct:netdev_vport	typeref:struct:netdev_vport::net_device
dev	.\ofproto\ofproto-dpif-xlate.c	/^        } dev;$/;"	m	union:xc_entry::__anon136	typeref:struct:xc_entry::__anon136::__anon137	file:
dev_disable_lro	.\datapath\linux\compat\dev-openvswitch.c	/^void dev_disable_lro(struct net_device *dev) { }$/;"	f
dev_disable_lro	.\datapath\linux\compat\dev-openvswitch.c	/^void dev_disable_lro(struct net_device *dev)$/;"	f
dev_get_by_index_rcu	.\datapath\linux\compat\include\linux\netdevice.h	/^static inline struct net_device *dev_get_by_index_rcu(struct net *net, int ifindex)$/;"	f
dev_queue_xmit	.\datapath\linux\compat\gso.c	66;"	d	file:
dev_queue_xmit	.\datapath\linux\compat\include\linux\netdevice.h	117;"	d
dev_supports_vlan_tx	.\datapath\linux\compat\gso.c	/^static bool dev_supports_vlan_tx(struct net_device *dev)$/;"	f	file:
dev_table	.\datapath\vport.c	/^static struct hlist_head *dev_table;$/;"	v	typeref:struct:hlist_head	file:
device	.\datapath\datapath.c	/^DEFINE_COMPAT_PNET_REG_FUNC(device);$/;"	v
device	.\lib\lockfile.c	/^    dev_t device;$/;"	m	struct:lockfile	file:
dgramSeqNo	.\tests\test-sflow.c	/^    uint32_t dgramSeqNo;$/;"	m	struct:sflow_xdr	file:
dhcp_header	.\lib\dhcp.h	/^struct dhcp_header {$/;"	s
diag	.\lib\bfd.c	/^    enum diag diag;               \/* bfd.LocalDiag. *\/$/;"	m	struct:bfd	typeref:enum:bfd::diag	file:
diag	.\lib\bfd.c	/^enum diag {$/;"	g	file:
die_if_error	.\tests\test-ovsdb.c	/^die_if_error(char *error)$/;"	f	file:
die_if_error	.\utilities\ovs-vsctl.c	/^die_if_error(char *error)$/;"	f	file:
die_if_error	.\vtep\vtep-ctl.c	/^die_if_error(char *error)$/;"	f	file:
diff_stats	.\tests\test-reconnect.c	/^diff_stats(const struct reconnect_stats *old,$/;"	f	file:
diff_stats	.\tests\test-reconnect.py	/^def diff_stats(old, new, delta):$/;"	f
digest	.\lib\sha1.h	/^    uint32_t digest[5];          \/* Message digest. *\/$/;"	m	struct:sha1_ctx
dir_name	.\lib\util.c	/^dir_name(const char *file_name)$/;"	f
direction	.\lib\sflow.h	/^    u_int32_t direction;   \/* enum SFLExtended_url_direction *\/$/;"	m	struct:_SFLExtended_url
dirs	.\python\ovs\daemon.py	/^import ovs.dirs$/;"	i
dirs	.\python\ovs\unixctl\server.py	/^import ovs.dirs$/;"	i
dirs	.\python\ovs\vlog.py	/^import ovs.dirs$/;"	i
disable	.\python\ovs\reconnect.py	/^    def disable(self, now):$/;"	m	class:Reconnect
disc	.\lib\bfd.c	/^    uint32_t disc;                \/* bfd.LocalDiscr. Key in 'all_bfds' hmap. *\/$/;"	m	struct:bfd	file:
discards	.\lib\sflow.h	/^    u_int32_t discards;$/;"	m	struct:_SFLVlan_counters
disconnected	.\python\ovs\reconnect.py	/^    def disconnected(self, now, error):$/;"	m	class:Reconnect
dist_check_SCRIPTS	.\tests\automake.mk	/^dist_check_SCRIPTS = tests\/flowgen.pl$/;"	m
dist_extras	.\datapath\Modules.mk	/^dist_extras = $(foreach module,$(dist_modules),$($(module)_extras))$/;"	m
dist_headers	.\datapath\Modules.mk	/^dist_headers = $(foreach module,$(dist_modules),$($(module)_headers))$/;"	m
dist_modules	.\datapath\Modules.mk	/^dist_modules = $(both_modules)	# Modules to distribute$/;"	m
dist_noinst_SCRIPTS	.\ofproto\automake.mk	/^dist_noinst_SCRIPTS = ofproto\/ipfix-gen-entities$/;"	m
dist_sources	.\datapath\Modules.mk	/^dist_sources = $(foreach module,$(dist_modules),$($(module)_sources))$/;"	m
div_double	.\ovsdb\mutation.c	/^div_double(double *x, double y)$/;"	f	file:
div_int	.\ovsdb\mutation.c	/^div_int(int64_t *x, int64_t y)$/;"	f	file:
div_mutation	.\ovsdb\mutation.c	/^static const struct ovsdb_scalar_mutation div_mutation = {$/;"	v	typeref:struct:ovsdb_scalar_mutation	file:
div_mutation	.\ovsdb\mutation.c	/^static const struct ovsdb_scalar_mutation div_mutation;$/;"	v	typeref:struct:ovsdb_scalar_mutation	file:
dl_addr	.\include\openflow\openflow-common.h	/^    uint8_t dl_addr[OFP_ETH_ALEN];  \/* Ethernet address. *\/$/;"	m	struct:ofp_action_dl_addr
dl_addr	.\lib\ofp-actions.c	/^    struct ofp_action_dl_addr dl_addr;$/;"	m	union:ofp_action	typeref:struct:ofp_action::ofp_action_dl_addr	file:
dl_dst	.\include\openflow\openflow-1.0.h	/^    uint8_t dl_dst[OFP_ETH_ALEN]; \/* Ethernet destination address. *\/$/;"	m	struct:ofp10_match
dl_dst	.\include\openflow\openflow-1.1.h	/^    uint8_t dl_dst[OFP_ETH_ALEN]; \/* Ethernet destination address. *\/$/;"	m	struct:ofp11_match
dl_dst	.\lib\flow.h	/^    uint8_t dl_dst[6];          \/* Ethernet destination address. *\/$/;"	m	struct:flow
dl_dst_mask	.\include\openflow\openflow-1.1.h	/^    uint8_t dl_dst_mask[OFP_ETH_ALEN]; \/* Ethernet destination address mask. *\/$/;"	m	struct:ofp11_match
dl_dst_values	.\tests\test-classifier.c	/^static uint8_t dl_dst_values[][6] = { { 0x4a, 0x27, 0x71, 0xae, 0x64, 0xc1 },$/;"	v	file:
dl_src	.\include\openflow\openflow-1.0.h	/^    uint8_t dl_src[OFP_ETH_ALEN]; \/* Ethernet source address. *\/$/;"	m	struct:ofp10_match
dl_src	.\include\openflow\openflow-1.1.h	/^    uint8_t dl_src[OFP_ETH_ALEN]; \/* Ethernet source address. *\/$/;"	m	struct:ofp11_match
dl_src	.\lib\flow.h	/^    uint8_t dl_src[6];          \/* Ethernet source address. *\/$/;"	m	struct:flow
dl_src_mask	.\include\openflow\openflow-1.1.h	/^    uint8_t dl_src_mask[OFP_ETH_ALEN]; \/* Ethernet source address mask.  *\/$/;"	m	struct:ofp11_match
dl_src_values	.\tests\test-classifier.c	/^static uint8_t dl_src_values[][6] = { { 0x00, 0x02, 0xe3, 0x0f, 0x80, 0xa4 },$/;"	v	file:
dl_type	.\include\openflow\openflow-1.0.h	/^    ovs_be16 dl_type;          \/* Ethernet frame type. *\/$/;"	m	struct:ofp10_match
dl_type	.\include\openflow\openflow-1.1.h	/^    ovs_be16 dl_type;          \/* Ethernet frame type. *\/$/;"	m	struct:ofp11_match
dl_type	.\lib\flow.h	/^    ovs_be16 dl_type;           \/* Ethernet frame type. *\/$/;"	m	struct:flow
dl_type	.\lib\ofp-parse.c	/^    uint16_t dl_type;$/;"	m	struct:protocol	file:
dl_type_is_ip_any	.\lib\packets.h	/^static inline bool dl_type_is_ip_any(ovs_be16 dl_type)$/;"	f
dl_type_values	.\tests\test-classifier.c	/^static ovs_be16 dl_type_values[]$/;"	v	file:
dl_vlan	.\include\openflow\openflow-1.0.h	/^    ovs_be16 dl_vlan;          \/* Input VLAN. *\/$/;"	m	struct:ofp10_match
dl_vlan	.\include\openflow\openflow-1.1.h	/^    ovs_be16 dl_vlan;          \/* Input VLAN id. *\/$/;"	m	struct:ofp11_match
dl_vlan_pcp	.\include\openflow\openflow-1.0.h	/^    uint8_t dl_vlan_pcp;       \/* Input VLAN priority. *\/$/;"	m	struct:ofp10_match
dl_vlan_pcp	.\include\openflow\openflow-1.1.h	/^    uint8_t dl_vlan_pcp;       \/* Input VLAN priority. *\/$/;"	m	struct:ofp11_match
do_activity	.\tests\test-reconnect.c	/^do_activity(int argc OVS_UNUSED, char *argv[] OVS_UNUSED)$/;"	f	file:
do_activity	.\tests\test-reconnect.py	/^def do_activity(_):$/;"	f
do_advance	.\tests\test-reconnect.c	/^do_advance(int argc OVS_UNUSED, char *argv[])$/;"	f	file:
do_advance	.\tests\test-reconnect.py	/^def do_advance(arg):$/;"	f
do_ca_cert_bootstrap	.\lib\stream-ssl.c	/^do_ca_cert_bootstrap(struct stream *stream)$/;"	f	file:
do_compact	.\ovsdb\ovsdb-tool.c	/^do_compact(int argc, char *argv[])$/;"	f	file:
do_compare_rows	.\tests\test-ovsdb.c	/^do_compare_rows(int argc, char *argv[])$/;"	f	file:
do_connect_failed	.\tests\test-reconnect.c	/^do_connect_failed(int argc OVS_UNUSED, char *argv[])$/;"	f	file:
do_connect_failed	.\tests\test-reconnect.py	/^def do_connect_failed(arg):$/;"	f
do_connected	.\tests\test-reconnect.c	/^do_connected(int argc OVS_UNUSED, char *argv[] OVS_UNUSED)$/;"	f	file:
do_connected	.\tests\test-reconnect.py	/^def do_connected(_):$/;"	f
do_connecting	.\tests\test-reconnect.c	/^do_connecting(int argc OVS_UNUSED, char *argv[] OVS_UNUSED)$/;"	f	file:
do_connecting	.\tests\test-reconnect.py	/^def do_connecting(_):$/;"	f
do_convert	.\ovsdb\ovsdb-tool.c	/^do_convert(int argc, char *argv[])$/;"	f	file:
do_create	.\ovsdb\ovsdb-tool.c	/^do_create(int argc, char *argv[])$/;"	f	file:
do_db_cksum	.\ovsdb\ovsdb-tool.c	/^do_db_cksum(int argc OVS_UNUSED, char *argv[])$/;"	f	file:
do_db_version	.\ovsdb\ovsdb-tool.c	/^do_db_version(int argc, char *argv[])$/;"	f	file:
do_default_atoms	.\tests\test-ovsdb.c	/^do_default_atoms(int argc OVS_UNUSED, char *argv[] OVS_UNUSED)$/;"	f	file:
do_default_atoms	.\tests\test-ovsdb.py	/^def do_default_atoms():$/;"	f
do_default_data	.\tests\test-ovsdb.c	/^do_default_data(int argc OVS_UNUSED, char *argv[] OVS_UNUSED)$/;"	f	file:
do_default_data	.\tests\test-ovsdb.py	/^def do_default_data():$/;"	f
do_direct_tests	.\python\ovstest\tests.py	/^def do_direct_tests(node1, node2, bandwidth, duration, ps):$/;"	f
do_disable	.\tests\test-reconnect.c	/^do_disable(int argc OVS_UNUSED, char *argv[] OVS_UNUSED)$/;"	f	file:
do_disable	.\tests\test-reconnect.py	/^def do_disable(_):$/;"	f
do_disconnected	.\tests\test-reconnect.c	/^do_disconnected(int argc OVS_UNUSED, char *argv[])$/;"	f	file:
do_disconnected	.\tests\test-reconnect.py	/^def do_disconnected(arg):$/;"	f
do_dump	.\ovsdb\ovsdb-client.c	/^do_dump(struct jsonrpc *rpc, const char *database,$/;"	f	file:
do_enable	.\tests\test-reconnect.c	/^do_enable(int argc OVS_UNUSED, char *argv[] OVS_UNUSED)$/;"	f	file:
do_enable	.\tests\test-reconnect.py	/^def do_enable(_):$/;"	f
do_evaluate_conditions	.\tests\test-ovsdb.c	/^do_evaluate_conditions(int argc OVS_UNUSED, char *argv[])$/;"	f	file:
do_execute	.\tests\test-ovsdb.c	/^do_execute(int argc OVS_UNUSED, char *argv[])$/;"	f	file:
do_execute_actions	.\datapath\actions.c	/^static int do_execute_actions(struct datapath *dp, struct sk_buff *skb,$/;"	f	file:
do_execute_mutations	.\tests\test-ovsdb.c	/^do_execute_mutations(int argc OVS_UNUSED, char *argv[])$/;"	f	file:
do_force_reconnect	.\tests\test-reconnect.c	/^do_force_reconnect(int argc OVS_UNUSED, char *argv[] OVS_UNUSED)$/;"	f	file:
do_force_reconnect	.\tests\test-reconnect.py	/^def do_force_reconnect(_):$/;"	f
do_fork	.\tests\test-lockfile.c	/^do_fork(void)$/;"	f	file:
do_get_ifindex	.\lib\netdev-linux.c	/^do_get_ifindex(const char *netdev_name)$/;"	f	file:
do_get_schema	.\ovsdb\ovsdb-client.c	/^do_get_schema(struct jsonrpc *rpc, const char *database,$/;"	f	file:
do_get_schema_version	.\ovsdb\ovsdb-client.c	/^do_get_schema_version(struct jsonrpc *rpc, const char *database,$/;"	f	file:
do_help	.\ovsdb\ovsdb-client.c	/^do_help(struct jsonrpc *rpc OVS_UNUSED, const char *database OVS_UNUSED,$/;"	f	file:
do_help	.\ovsdb\ovsdb-tool.c	/^do_help(int argc OVS_UNUSED, char *argv[] OVS_UNUSED)$/;"	f	file:
do_help	.\tests\test-jsonrpc.c	/^do_help(int argc OVS_UNUSED, char *argv[] OVS_UNUSED)$/;"	f	file:
do_help	.\tests\test-ovsdb.c	/^do_help(int argc OVS_UNUSED, char *argv[] OVS_UNUSED)$/;"	f	file:
do_idl	.\tests\test-ovsdb.c	/^do_idl(int argc, char *argv[])$/;"	f	file:
do_idl	.\tests\test-ovsdb.py	/^def do_idl(schema_file, remote, *commands):$/;"	f
do_init	.\lib\uuid.c	/^do_init(void)$/;"	f	file:
do_init_time	.\lib\timeval.c	/^do_init_time(void)$/;"	f	file:
do_l3_tests	.\python\ovstest\tests.py	/^def do_l3_tests(node1, node2, bandwidth, duration, ps, type):$/;"	f
do_list_columns	.\ovsdb\ovsdb-client.c	/^do_list_columns(struct jsonrpc *rpc, const char *database,$/;"	f	file:
do_list_dbs	.\ovsdb\ovsdb-client.c	/^do_list_dbs(struct jsonrpc *rpc, const char *database OVS_UNUSED,$/;"	f	file:
do_list_tables	.\ovsdb\ovsdb-client.c	/^do_list_tables(struct jsonrpc *rpc, const char *database,$/;"	f	file:
do_listen	.\tests\test-jsonrpc.c	/^do_listen(int argc OVS_UNUSED, char *argv[])$/;"	f	file:
do_listen	.\tests\test-jsonrpc.py	/^def do_listen(name):$/;"	f
do_listen_error	.\tests\test-reconnect.c	/^do_listen_error(int argc OVS_UNUSED, char *argv[])$/;"	f	file:
do_listen_error	.\tests\test-reconnect.py	/^def do_listen_error(arg):$/;"	f
do_listening	.\tests\test-reconnect.c	/^do_listening(int argc OVS_UNUSED, char *argv[] OVS_UNUSED)$/;"	f	file:
do_listening	.\tests\test-reconnect.py	/^def do_listening(_):$/;"	f
do_log_io	.\tests\test-ovsdb.c	/^do_log_io(int argc, char *argv[])$/;"	f	file:
do_lookup_genl_family	.\lib\netlink-socket.c	/^do_lookup_genl_family(const char *name, struct nlattr **attrs,$/;"	f	file:
do_monitor	.\ovsdb\ovsdb-client.c	/^do_monitor(struct jsonrpc *rpc, const char *database,$/;"	f	file:
do_needs_conversion	.\ovsdb\ovsdb-tool.c	/^do_needs_conversion(int argc, char *argv[])$/;"	f	file:
do_notify	.\tests\test-jsonrpc.c	/^do_notify(int argc OVS_UNUSED, char *argv[])$/;"	f	file:
do_notify	.\tests\test-jsonrpc.py	/^def do_notify(name, method, params_string):$/;"	f
do_open	.\lib\dpif.c	/^do_open(const char *name, const char *type, bool create, struct dpif **dpifp)$/;"	f	file:
do_output	.\datapath\actions.c	/^static int do_output(struct datapath *dp, struct sk_buff *skb, int out_port)$/;"	f	file:
do_parse_atom_strings	.\tests\test-ovsdb.c	/^do_parse_atom_strings(int argc, char *argv[])$/;"	f	file:
do_parse_atomic_type	.\tests\test-ovsdb.c	/^do_parse_atomic_type(int argc OVS_UNUSED, char *argv[])$/;"	f	file:
do_parse_atomic_type	.\tests\test-ovsdb.py	/^def do_parse_atomic_type(type_string):$/;"	f
do_parse_atoms	.\tests\test-ovsdb.c	/^do_parse_atoms(int argc, char *argv[])$/;"	f	file:
do_parse_atoms	.\tests\test-ovsdb.py	/^def do_parse_atoms(type_string, *atom_strings):$/;"	f
do_parse_base_type	.\tests\test-ovsdb.c	/^do_parse_base_type(int argc OVS_UNUSED, char *argv[])$/;"	f	file:
do_parse_base_type	.\tests\test-ovsdb.py	/^def do_parse_base_type(type_string):$/;"	f
do_parse_column	.\tests\test-ovsdb.c	/^do_parse_column(int argc OVS_UNUSED, char *argv[])$/;"	f	file:
do_parse_column	.\tests\test-ovsdb.py	/^def do_parse_column(name, column_string):$/;"	f
do_parse_conditions	.\tests\test-ovsdb.c	/^do_parse_conditions(int argc, char *argv[])$/;"	f	file:
do_parse_data	.\tests\test-ovsdb.c	/^do_parse_data(int argc, char *argv[])$/;"	f	file:
do_parse_data	.\tests\test-ovsdb.py	/^def do_parse_data(type_string, *data_strings):$/;"	f
do_parse_data__	.\tests\test-ovsdb.c	/^do_parse_data__(int argc, char *argv[],$/;"	f	file:
do_parse_data_strings	.\tests\test-ovsdb.c	/^do_parse_data_strings(int argc, char *argv[])$/;"	f	file:
do_parse_mutations	.\tests\test-ovsdb.c	/^do_parse_mutations(int argc, char *argv[])$/;"	f	file:
do_parse_rows	.\tests\test-ovsdb.c	/^do_parse_rows(int argc, char *argv[])$/;"	f	file:
do_parse_schema	.\tests\test-ovsdb.c	/^do_parse_schema(int argc OVS_UNUSED, char *argv[])$/;"	f	file:
do_parse_schema	.\tests\test-ovsdb.py	/^def do_parse_schema(schema_string):$/;"	f
do_parse_table	.\tests\test-ovsdb.c	/^do_parse_table(int argc OVS_UNUSED, char *argv[])$/;"	f	file:
do_parse_table	.\tests\test-ovsdb.py	/^def do_parse_table(name, table_string, default_is_root_string='false'):$/;"	f
do_parse_type	.\tests\test-ovsdb.c	/^do_parse_type(int argc OVS_UNUSED, char *argv[])$/;"	f	file:
do_parse_type	.\tests\test-ovsdb.py	/^def do_parse_type(type_string):$/;"	f
do_query	.\ovsdb\ovsdb-tool.c	/^do_query(int argc, char *argv[])$/;"	f	file:
do_query	.\tests\test-ovsdb.c	/^do_query(int argc OVS_UNUSED, char *argv[])$/;"	f	file:
do_query_cb	.\tests\test-ovsdb.c	/^do_query_cb(const struct ovsdb_row *row, void *cbdata_)$/;"	f	file:
do_query_cbdata	.\tests\test-ovsdb.c	/^struct do_query_cbdata {$/;"	s	file:
do_query_distinct	.\tests\test-ovsdb.c	/^do_query_distinct(int argc OVS_UNUSED, char *argv[])$/;"	f	file:
do_query_distinct_class	.\tests\test-ovsdb.c	/^struct do_query_distinct_class {$/;"	s	file:
do_query_distinct_row	.\tests\test-ovsdb.c	/^struct do_query_distinct_row {$/;"	s	file:
do_recv	.\lib\vconn.c	/^do_recv(struct vconn *vconn, struct ofpbuf **msgp)$/;"	f	file:
do_request	.\tests\test-jsonrpc.c	/^do_request(int argc OVS_UNUSED, char *argv[])$/;"	f	file:
do_request	.\tests\test-jsonrpc.py	/^def do_request(name, method, params_string):$/;"	f
do_run	.\tests\test-reconnect.c	/^do_run(int argc, char *argv[])$/;"	f	file:
do_run	.\tests\test-reconnect.py	/^def do_run(arg):$/;"	f
do_schema_cksum	.\ovsdb\ovsdb-tool.c	/^do_schema_cksum(int argc, char *argv[])$/;"	f	file:
do_schema_version	.\ovsdb\ovsdb-tool.c	/^do_schema_version(int argc, char *argv[])$/;"	f	file:
do_send	.\lib\vconn.c	/^do_send(struct vconn *vconn, struct ofpbuf *msg)$/;"	f	file:
do_send_packet_ins	.\ofproto\connmgr.c	/^do_send_packet_ins(struct ofconn *ofconn, struct list *txq)$/;"	f	file:
do_set_addr	.\lib\netdev-bsd.c	/^do_set_addr(struct netdev *netdev,$/;"	f	file:
do_set_addr	.\lib\netdev-linux.c	/^do_set_addr(struct netdev *netdev,$/;"	f	file:
do_set_max_tries	.\tests\test-reconnect.c	/^do_set_max_tries(int argc OVS_UNUSED, char *argv[])$/;"	f	file:
do_set_max_tries	.\tests\test-reconnect.py	/^def do_set_max_tries(arg):$/;"	f
do_set_passive	.\tests\test-reconnect.c	/^do_set_passive(int argc OVS_UNUSED, char *argv[] OVS_UNUSED)$/;"	f	file:
do_set_passive	.\tests\test-reconnect.py	/^def do_set_passive(_):$/;"	f
do_set_pattern	.\lib\vlog.c	/^do_set_pattern(enum vlog_facility facility, const char *pattern)$/;"	f	file:
do_setup	.\datapath\vport-internal_dev.c	/^static void do_setup(struct net_device *netdev)$/;"	f	file:
do_show_log	.\ovsdb\ovsdb-tool.c	/^do_show_log(int argc, char *argv[])$/;"	f	file:
do_sort_atoms	.\tests\test-ovsdb.c	/^do_sort_atoms(int argc OVS_UNUSED, char *argv[])$/;"	f	file:
do_sort_atoms	.\tests\test-ovsdb.py	/^def do_sort_atoms(type_string, atom_strings):$/;"	f
do_ssl_init	.\lib\stream-ssl.c	/^do_ssl_init(void)$/;"	f	file:
do_tcp_tests	.\python\ovstest\tests.py	/^def do_tcp_tests(receiver, sender, duration):$/;"	f
do_timeout	.\tests\test-reconnect.c	/^do_timeout(int argc OVS_UNUSED, char *argv[] OVS_UNUSED)$/;"	f	file:
do_timeout	.\tests\test-reconnect.py	/^def do_timeout(_):$/;"	f
do_transact	.\ovsdb\ovsdb-client.c	/^do_transact(struct jsonrpc *rpc, const char *database OVS_UNUSED,$/;"	f	file:
do_transact	.\ovsdb\ovsdb-tool.c	/^do_transact(int argc, char *argv[])$/;"	f	file:
do_transact	.\tests\test-ovsdb.c	/^do_transact(int argc, char *argv[])$/;"	f	file:
do_transact_abort	.\tests\test-ovsdb.c	/^do_transact_abort(int argc OVS_UNUSED, char *argv[] OVS_UNUSED)$/;"	f	file:
do_transact_commit	.\tests\test-ovsdb.c	/^do_transact_commit(int argc OVS_UNUSED, char *argv[] OVS_UNUSED)$/;"	f	file:
do_transact_db	.\tests\test-ovsdb.c	/^static struct ovsdb *do_transact_db;$/;"	v	typeref:struct:ovsdb	file:
do_transact_delete	.\tests\test-ovsdb.c	/^do_transact_delete(int argc OVS_UNUSED, char *argv[] OVS_UNUSED)$/;"	f	file:
do_transact_find_row	.\tests\test-ovsdb.c	/^do_transact_find_row(const char *uuid_string)$/;"	f	file:
do_transact_get_integer	.\tests\test-ovsdb.c	/^do_transact_get_integer(const struct ovsdb_row *row, const char *column_name)$/;"	f	file:
do_transact_insert	.\tests\test-ovsdb.c	/^do_transact_insert(int argc OVS_UNUSED, char *argv[] OVS_UNUSED)$/;"	f	file:
do_transact_modify	.\tests\test-ovsdb.c	/^do_transact_modify(int argc OVS_UNUSED, char *argv[] OVS_UNUSED)$/;"	f	file:
do_transact_print	.\tests\test-ovsdb.c	/^do_transact_print(int argc OVS_UNUSED, char *argv[] OVS_UNUSED)$/;"	f	file:
do_transact_set_i_j	.\tests\test-ovsdb.c	/^do_transact_set_i_j(struct ovsdb_row *row,$/;"	f	file:
do_transact_set_integer	.\tests\test-ovsdb.c	/^do_transact_set_integer(struct ovsdb_row *row, const char *column_name,$/;"	f	file:
do_transact_table	.\tests\test-ovsdb.c	/^static struct ovsdb_table *do_transact_table;$/;"	v	typeref:struct:ovsdb_table	file:
do_transact_txn	.\tests\test-ovsdb.c	/^static struct ovsdb_txn *do_transact_txn;$/;"	v	typeref:struct:ovsdb_txn	file:
do_trigger	.\tests\test-ovsdb.c	/^do_trigger(int argc OVS_UNUSED, char *argv[])$/;"	f	file:
do_trigger_dump	.\tests\test-ovsdb.c	/^do_trigger_dump(struct test_trigger *t, long long int now, const char *title)$/;"	f	file:
do_udp_tests	.\python\ovstest\tests.py	/^def do_udp_tests(receiver, sender, tbwidth, duration, port_sizes):$/;"	f
do_unlink_files	.\lib\fatal-signal.c	/^do_unlink_files(void)$/;"	f	file:
do_vlan_ioctl	.\lib\vlandev.c	/^do_vlan_ioctl(const char *netdev_name, struct vlan_ioctl_args *via,$/;"	f	file:
do_vlan_tests	.\python\ovstest\tests.py	/^def do_vlan_tests(node1, node2, bandwidth, duration, ps, tag):$/;"	f
do_vsctl	.\utilities\ovs-vsctl.c	/^do_vsctl(const char *args, struct vsctl_command *commands, size_t n_commands,$/;"	f	file:
do_vtep_ctl	.\vtep\vtep-ctl.c	/^do_vtep_ctl(const char *args, struct vtep_ctl_command *commands,$/;"	f	file:
do_winsock_start	.\lib\stream.c	/^do_winsock_start(void)$/;"	f	file:
do_xlate_actions	.\ofproto\ofproto-dpif-xlate.c	/^do_xlate_actions(const struct ofpact *ofpacts, size_t ofpacts_len,$/;"	f	file:
doc	.\utilities\ovs-dev.py	/^def doc():$/;"	f
done	.\lib\json.c	/^    bool done;$/;"	m	struct:json_parser	file:
done	.\lib\ovs-thread.h	/^    atomic_bool done;$/;"	m	struct:ovsthread_once
dont_fragment	.\lib\netdev.h	/^    bool dont_fragment;$/;"	m	struct:netdev_tunnel_config
dot12HCInHighPriorityOctets	.\lib\sflow.h	/^    u_int64_t dot12HCInHighPriorityOctets;$/;"	m	struct:_SFLVg_counters
dot12HCInNormPriorityOctets	.\lib\sflow.h	/^    u_int64_t dot12HCInNormPriorityOctets;$/;"	m	struct:_SFLVg_counters
dot12HCOutHighPriorityOctets	.\lib\sflow.h	/^    u_int64_t dot12HCOutHighPriorityOctets;$/;"	m	struct:_SFLVg_counters
dot12InDataErrors	.\lib\sflow.h	/^    u_int32_t dot12InDataErrors;$/;"	m	struct:_SFLVg_counters
dot12InHighPriorityFrames	.\lib\sflow.h	/^    u_int32_t dot12InHighPriorityFrames;$/;"	m	struct:_SFLVg_counters
dot12InHighPriorityOctets	.\lib\sflow.h	/^    u_int64_t dot12InHighPriorityOctets;$/;"	m	struct:_SFLVg_counters
dot12InIPMErrors	.\lib\sflow.h	/^    u_int32_t dot12InIPMErrors;$/;"	m	struct:_SFLVg_counters
dot12InNormPriorityFrames	.\lib\sflow.h	/^    u_int32_t dot12InNormPriorityFrames;$/;"	m	struct:_SFLVg_counters
dot12InNormPriorityOctets	.\lib\sflow.h	/^    u_int64_t dot12InNormPriorityOctets;$/;"	m	struct:_SFLVg_counters
dot12InNullAddressedFrames	.\lib\sflow.h	/^    u_int32_t dot12InNullAddressedFrames;$/;"	m	struct:_SFLVg_counters
dot12InOversizeFrameErrors	.\lib\sflow.h	/^    u_int32_t dot12InOversizeFrameErrors;$/;"	m	struct:_SFLVg_counters
dot12OutHighPriorityFrames	.\lib\sflow.h	/^    u_int32_t dot12OutHighPriorityFrames;$/;"	m	struct:_SFLVg_counters
dot12OutHighPriorityOctets	.\lib\sflow.h	/^    u_int64_t dot12OutHighPriorityOctets;$/;"	m	struct:_SFLVg_counters
dot12TransitionIntoTrainings	.\lib\sflow.h	/^    u_int32_t dot12TransitionIntoTrainings;$/;"	m	struct:_SFLVg_counters
dot3StatsAlignmentErrors	.\lib\sflow.h	/^    u_int32_t dot3StatsAlignmentErrors;$/;"	m	struct:_SFLEthernet_counters
dot3StatsCarrierSenseErrors	.\lib\sflow.h	/^    u_int32_t dot3StatsCarrierSenseErrors;$/;"	m	struct:_SFLEthernet_counters
dot3StatsDeferredTransmissions	.\lib\sflow.h	/^    u_int32_t dot3StatsDeferredTransmissions;$/;"	m	struct:_SFLEthernet_counters
dot3StatsExcessiveCollisions	.\lib\sflow.h	/^    u_int32_t dot3StatsExcessiveCollisions;$/;"	m	struct:_SFLEthernet_counters
dot3StatsFCSErrors	.\lib\sflow.h	/^    u_int32_t dot3StatsFCSErrors;$/;"	m	struct:_SFLEthernet_counters
dot3StatsFrameTooLongs	.\lib\sflow.h	/^    u_int32_t dot3StatsFrameTooLongs;$/;"	m	struct:_SFLEthernet_counters
dot3StatsInternalMacReceiveErrors	.\lib\sflow.h	/^    u_int32_t dot3StatsInternalMacReceiveErrors;$/;"	m	struct:_SFLEthernet_counters
dot3StatsInternalMacTransmitErrors	.\lib\sflow.h	/^    u_int32_t dot3StatsInternalMacTransmitErrors;$/;"	m	struct:_SFLEthernet_counters
dot3StatsLateCollisions	.\lib\sflow.h	/^    u_int32_t dot3StatsLateCollisions;$/;"	m	struct:_SFLEthernet_counters
dot3StatsMultipleCollisionFrames	.\lib\sflow.h	/^    u_int32_t dot3StatsMultipleCollisionFrames;$/;"	m	struct:_SFLEthernet_counters
dot3StatsSQETestErrors	.\lib\sflow.h	/^    u_int32_t dot3StatsSQETestErrors;$/;"	m	struct:_SFLEthernet_counters
dot3StatsSingleCollisionFrames	.\lib\sflow.h	/^    u_int32_t dot3StatsSingleCollisionFrames;$/;"	m	struct:_SFLEthernet_counters
dot3StatsSymbolErrors	.\lib\sflow.h	/^    u_int32_t dot3StatsSymbolErrors;$/;"	m	struct:_SFLEthernet_counters
dot5StatsACErrors	.\lib\sflow.h	/^    u_int32_t dot5StatsACErrors;$/;"	m	struct:_SFLTokenring_counters
dot5StatsAbortTransErrors	.\lib\sflow.h	/^    u_int32_t dot5StatsAbortTransErrors;$/;"	m	struct:_SFLTokenring_counters
dot5StatsBurstErrors	.\lib\sflow.h	/^    u_int32_t dot5StatsBurstErrors;$/;"	m	struct:_SFLTokenring_counters
dot5StatsFrameCopiedErrors	.\lib\sflow.h	/^    u_int32_t dot5StatsFrameCopiedErrors;$/;"	m	struct:_SFLTokenring_counters
dot5StatsFreqErrors	.\lib\sflow.h	/^    u_int32_t dot5StatsFreqErrors;$/;"	m	struct:_SFLTokenring_counters
dot5StatsHardErrors	.\lib\sflow.h	/^    u_int32_t dot5StatsHardErrors;$/;"	m	struct:_SFLTokenring_counters
dot5StatsInternalErrors	.\lib\sflow.h	/^    u_int32_t dot5StatsInternalErrors;$/;"	m	struct:_SFLTokenring_counters
dot5StatsLineErrors	.\lib\sflow.h	/^    u_int32_t dot5StatsLineErrors;$/;"	m	struct:_SFLTokenring_counters
dot5StatsLobeWires	.\lib\sflow.h	/^    u_int32_t dot5StatsLobeWires;$/;"	m	struct:_SFLTokenring_counters
dot5StatsLostFrameErrors	.\lib\sflow.h	/^    u_int32_t dot5StatsLostFrameErrors;$/;"	m	struct:_SFLTokenring_counters
dot5StatsReceiveCongestions	.\lib\sflow.h	/^    u_int32_t dot5StatsReceiveCongestions;$/;"	m	struct:_SFLTokenring_counters
dot5StatsRecoverys	.\lib\sflow.h	/^    u_int32_t dot5StatsRecoverys;$/;"	m	struct:_SFLTokenring_counters
dot5StatsRemoves	.\lib\sflow.h	/^    u_int32_t dot5StatsRemoves;$/;"	m	struct:_SFLTokenring_counters
dot5StatsSignalLoss	.\lib\sflow.h	/^    u_int32_t dot5StatsSignalLoss;$/;"	m	struct:_SFLTokenring_counters
dot5StatsSingles	.\lib\sflow.h	/^    u_int32_t dot5StatsSingles;$/;"	m	struct:_SFLTokenring_counters
dot5StatsSoftErrors	.\lib\sflow.h	/^    u_int32_t dot5StatsSoftErrors;$/;"	m	struct:_SFLTokenring_counters
dot5StatsTokenErrors	.\lib\sflow.h	/^    u_int32_t dot5StatsTokenErrors;$/;"	m	struct:_SFLTokenring_counters
dot5StatsTransmitBeacons	.\lib\sflow.h	/^    u_int32_t dot5StatsTransmitBeacons;$/;"	m	struct:_SFLTokenring_counters
down_delay	.\ofproto\bond.h	/^    int down_delay;             \/* ms before disabling a down slave. *\/$/;"	m	struct:bond_settings
downdelay	.\ofproto\bond.c	/^    int updelay, downdelay;     \/* Delay before slave goes up\/down, in ms. *\/$/;"	m	struct:bond	file:
dp	.\datapath\vport.h	/^	struct datapath	*dp;$/;"	m	struct:vport	typeref:struct:vport::datapath
dp	.\datapath\vport.h	/^	struct datapath *dp;$/;"	m	struct:vport_parms	typeref:struct:vport_parms::datapath
dp	.\lib\dpif-netdev.c	/^    struct dp_netdev *dp;$/;"	m	struct:dp_netdev_execute_aux	typeref:struct:dp_netdev_execute_aux::dp_netdev	file:
dp	.\lib\dpif-netdev.c	/^    struct dp_netdev *dp;$/;"	m	struct:dpif_netdev	typeref:struct:dpif_netdev::dp_netdev	file:
dp	.\lib\dpif-netdev.c	/^    struct dp_netdev *dp;$/;"	m	struct:pmd_thread	typeref:struct:pmd_thread::dp_netdev	file:
dp_blacklist_provider	.\lib\dpif.c	/^dp_blacklist_provider(const char *type)$/;"	f
dp_cb	.\datapath\linux\compat\gso.h	/^	struct ovs_skb_cb dp_cb;$/;"	m	struct:ovs_gso_cb	typeref:struct:ovs_gso_cb::ovs_skb_cb
dp_class_lookup	.\lib\dpif.c	/^dp_class_lookup(const char *type)$/;"	f	file:
dp_class_unref	.\lib\dpif.c	/^dp_class_unref(struct registered_dpif_class *rc)$/;"	f	file:
dp_cleanup	.\datapath\datapath.c	/^module_exit(dp_cleanup);$/;"	v
dp_cleanup	.\datapath\datapath.c	/^static void dp_cleanup(void)$/;"	f	file:
dp_datapath_genl_family	.\datapath\datapath.c	/^static struct genl_family dp_datapath_genl_family = {$/;"	v	typeref:struct:genl_family	file:
dp_datapath_genl_family	.\datapath\datapath.c	/^static struct genl_family dp_datapath_genl_family;$/;"	v	typeref:struct:genl_family	file:
dp_datapath_genl_ops	.\datapath\datapath.c	/^static struct genl_ops dp_datapath_genl_ops[] = {$/;"	v	typeref:struct:genl_ops	file:
dp_desc	.\include\openflow\openflow-common.h	/^    char dp_desc[DESC_STR_LEN];        \/* Human readable description of$/;"	m	struct:ofp_desc_stats
dp_desc	.\ofproto\ofproto-provider.h	/^    char *dp_desc;              \/* Datapath description (NULL for default). *\/$/;"	m	struct:ofproto
dp_detach_port_notify	.\datapath\dp_notify.c	/^static void dp_detach_port_notify(struct vport *vport)$/;"	f	file:
dp_device_event	.\datapath\dp_notify.c	/^static int dp_device_event(struct notifier_block *unused, unsigned long event,$/;"	f	file:
dp_enumerate_names	.\lib\dpif.c	/^dp_enumerate_names(const char *type, struct sset *names)$/;"	f
dp_enumerate_types	.\lib\dpif.c	/^dp_enumerate_types(struct sset *types)$/;"	f
dp_flow_genl_family	.\datapath\datapath.c	/^static struct genl_family dp_flow_genl_family = {$/;"	v	typeref:struct:genl_family	file:
dp_flow_genl_family	.\datapath\datapath.c	/^static struct genl_family dp_flow_genl_family;$/;"	v	typeref:struct:genl_family	file:
dp_flow_genl_ops	.\datapath\datapath.c	/^static struct genl_ops dp_flow_genl_ops[] = {$/;"	v	typeref:struct:genl_ops	file:
dp_genl_families	.\datapath\datapath.c	/^static struct genl_family *dp_genl_families[] = {$/;"	v	typeref:struct:genl_family	file:
dp_hash	.\lib\flow.h	/^    uint32_t dp_hash;           \/* Datapath computed hash value. The exact$/;"	m	struct:flow
dp_hash	.\lib\packets.h	/^    uint32_t dp_hash;           \/* hash value computed by the recirculation$/;"	m	struct:pkt_metadata
dp_hash_node	.\datapath\vport.h	/^	struct hlist_node dp_hash_node;$/;"	m	struct:vport	typeref:struct:vport::hlist_node
dp_ifindex	.\include\linux\openvswitch.h	/^	int dp_ifindex;$/;"	m	struct:ovs_header
dp_ifindex	.\lib\dpif-linux.c	/^    int dp_ifindex;$/;"	m	struct:dpif_linux	file:
dp_ifindex	.\lib\dpif-linux.c	/^    int dp_ifindex;$/;"	m	struct:dpif_linux_dp	file:
dp_ifindex	.\lib\dpif-linux.c	/^    int dp_ifindex;$/;"	m	struct:dpif_linux_flow	file:
dp_ifindex	.\lib\dpif-linux.h	/^    int dp_ifindex;$/;"	m	struct:dpif_linux_vport
dp_init	.\datapath\datapath.c	/^module_init(dp_init);$/;"	v
dp_init	.\datapath\datapath.c	/^static int __init dp_init(void)$/;"	f	file:
dp_initialize	.\lib\dpif.c	/^dp_initialize(void)$/;"	f	file:
dp_netdev	.\lib\dpif-netdev.c	/^struct dp_netdev {$/;"	s	file:
dp_netdev_actions	.\lib\dpif-netdev.c	/^struct dp_netdev_actions {$/;"	s	file:
dp_netdev_actions_create	.\lib\dpif-netdev.c	/^dp_netdev_actions_create(const struct nlattr *actions, size_t size)$/;"	f
dp_netdev_actions_free	.\lib\dpif-netdev.c	/^dp_netdev_actions_free(struct dp_netdev_actions *actions)$/;"	f	file:
dp_netdev_count_packet	.\lib\dpif-netdev.c	/^dp_netdev_count_packet(struct dp_netdev *dp, enum dp_stat_type type)$/;"	f	file:
dp_netdev_execute_actions	.\lib\dpif-netdev.c	/^dp_netdev_execute_actions(struct dp_netdev *dp, const struct miniflow *key,$/;"	f	file:
dp_netdev_execute_aux	.\lib\dpif-netdev.c	/^struct dp_netdev_execute_aux {$/;"	s	file:
dp_netdev_flow	.\lib\dpif-netdev.c	/^struct dp_netdev_flow {$/;"	s	file:
dp_netdev_flow_cast	.\lib\dpif-netdev.c	/^dp_netdev_flow_cast(const struct cls_rule *cr)$/;"	f	file:
dp_netdev_flow_flush	.\lib\dpif-netdev.c	/^dp_netdev_flow_flush(struct dp_netdev *dp)$/;"	f	file:
dp_netdev_flow_free	.\lib\dpif-netdev.c	/^dp_netdev_flow_free(struct dp_netdev_flow *flow)$/;"	f	file:
dp_netdev_flow_get_actions	.\lib\dpif-netdev.c	/^dp_netdev_flow_get_actions(const struct dp_netdev_flow *flow)$/;"	f
dp_netdev_flow_iter	.\lib\dpif-netdev.c	/^struct dp_netdev_flow_iter {$/;"	s	file:
dp_netdev_flow_state	.\lib\dpif-netdev.c	/^struct dp_netdev_flow_state {$/;"	s	file:
dp_netdev_flow_stats	.\lib\dpif-netdev.c	/^struct dp_netdev_flow_stats {$/;"	s	file:
dp_netdev_flow_stats_new_cb	.\lib\dpif-netdev.c	/^dp_netdev_flow_stats_new_cb(void)$/;"	f	file:
dp_netdev_flow_used	.\lib\dpif-netdev.c	/^dp_netdev_flow_used(struct dp_netdev_flow *netdev_flow,$/;"	f	file:
dp_netdev_mutex	.\lib\dpif-netdev.c	/^    OVS_REQUIRES(dp_netdev_mutex);$/;"	v
dp_netdev_mutex	.\lib\dpif-netdev.c	/^static struct ovs_mutex dp_netdev_mutex = OVS_MUTEX_INITIALIZER;$/;"	v	typeref:struct:ovs_mutex	file:
dp_netdev_mutex	.\lib\dpif-netdev.c	/^static struct shash dp_netdevs OVS_GUARDED_BY(dp_netdev_mutex)$/;"	v	typeref:struct:OVS_GUARDED_BY	file:
dp_netdev_output_userspace	.\lib\dpif-netdev.c	/^dp_netdev_output_userspace(struct dp_netdev *dp, struct ofpbuf *packet,$/;"	f	file:
dp_netdev_port	.\lib\dpif-netdev.c	/^struct dp_netdev_port {$/;"	s	file:
dp_netdev_port_state	.\lib\dpif-netdev.c	/^struct dp_netdev_port_state {$/;"	s	file:
dp_netdev_process_rxq_port	.\lib\dpif-netdev.c	/^dp_netdev_process_rxq_port(struct dp_netdev *dp,$/;"	f	file:
dp_netdev_queue	.\lib\dpif-netdev.c	/^struct dp_netdev_queue {$/;"	s	file:
dp_netdev_reload_pmd_threads	.\lib\dpif-netdev.c	/^dp_netdev_reload_pmd_threads(struct dp_netdev *dp)$/;"	f	file:
dp_netdev_set_pmd_threads	.\lib\dpif-netdev.c	/^dp_netdev_set_pmd_threads(struct dp_netdev *dp, int n)$/;"	f	file:
dp_netdev_stats	.\lib\dpif-netdev.c	/^struct dp_netdev_stats {$/;"	s	file:
dp_netdev_stats_new_cb	.\lib\dpif-netdev.c	/^dp_netdev_stats_new_cb(void)$/;"	f	file:
dp_netdev_unref	.\lib\dpif-netdev.c	/^dp_netdev_unref(struct dp_netdev *dp)$/;"	f	file:
dp_netdev_upcall	.\lib\dpif-netdev.c	/^struct dp_netdev_upcall {$/;"	s	file:
dp_notify_work	.\datapath\datapath.h	/^	struct work_struct dp_notify_work;$/;"	m	struct:ovs_net	typeref:struct:ovs_net::work_struct
dp_packet_genl_family	.\datapath\datapath.c	/^static struct genl_family dp_packet_genl_family = {$/;"	v	typeref:struct:genl_family	file:
dp_packet_genl_family	.\datapath\datapath.c	/^static struct genl_family dp_packet_genl_family;$/;"	v	typeref:struct:genl_family	file:
dp_packet_genl_ops	.\datapath\datapath.c	/^static struct genl_ops dp_packet_genl_ops[] = {$/;"	v	typeref:struct:genl_ops	file:
dp_packet_pad	.\lib\dpif-netdev.h	/^static inline void dp_packet_pad(struct ofpbuf *b)$/;"	f
dp_parse_name	.\lib\dpif.c	/^dp_parse_name(const char *datapath_name_, char **name, char **type)$/;"	f
dp_register_genl	.\datapath\datapath.c	/^static int dp_register_genl(void)$/;"	f	file:
dp_register_provider	.\lib\dpif.c	/^dp_register_provider(const struct dpif_class *new_class)$/;"	f
dp_register_provider__	.\lib\dpif.c	/^dp_register_provider__(const struct dpif_class *new_class)$/;"	f	file:
dp_stat_type	.\lib\dpif-netdev.c	/^enum dp_stat_type {$/;"	g	file:
dp_stats_percpu	.\datapath\datapath.h	/^struct dp_stats_percpu {$/;"	s
dp_unregister_genl	.\datapath\datapath.c	/^static void dp_unregister_genl(int n_families)$/;"	f	file:
dp_unregister_provider	.\lib\dpif.c	/^dp_unregister_provider(const char *type)$/;"	f
dp_unregister_provider__	.\lib\dpif.c	/^dp_unregister_provider__(const char *type)$/;"	f	file:
dp_upcall_info	.\datapath\datapath.h	/^struct dp_upcall_info {$/;"	s
dp_vport_genl_family	.\datapath\datapath.c	/^struct genl_family dp_vport_genl_family = {$/;"	v	typeref:struct:genl_family
dp_vport_genl_ops	.\datapath\datapath.c	/^static struct genl_ops dp_vport_genl_ops[] = {$/;"	v	typeref:struct:genl_ops	file:
dpctl_add_dp	.\utilities\ovs-dpctl.c	/^dpctl_add_dp(int argc OVS_UNUSED, char *argv[])$/;"	f	file:
dpctl_add_flow	.\utilities\ovs-dpctl.c	/^dpctl_add_flow(int argc, char *argv[])$/;"	f	file:
dpctl_add_if	.\utilities\ovs-dpctl.c	/^dpctl_add_if(int argc OVS_UNUSED, char *argv[])$/;"	f	file:
dpctl_del_dp	.\utilities\ovs-dpctl.c	/^dpctl_del_dp(int argc OVS_UNUSED, char *argv[])$/;"	f	file:
dpctl_del_flow	.\utilities\ovs-dpctl.c	/^dpctl_del_flow(int argc, char *argv[])$/;"	f	file:
dpctl_del_flows	.\utilities\ovs-dpctl.c	/^dpctl_del_flows(int argc, char *argv[])$/;"	f	file:
dpctl_del_if	.\utilities\ovs-dpctl.c	/^dpctl_del_if(int argc OVS_UNUSED, char *argv[])$/;"	f	file:
dpctl_dump_dps	.\utilities\ovs-dpctl.c	/^dpctl_dump_dps(int argc OVS_UNUSED, char *argv[] OVS_UNUSED)$/;"	f	file:
dpctl_dump_flows	.\utilities\ovs-dpctl.c	/^dpctl_dump_flows(int argc, char *argv[])$/;"	f	file:
dpctl_help	.\utilities\ovs-dpctl.c	/^dpctl_help(int argc OVS_UNUSED, char *argv[] OVS_UNUSED)$/;"	f	file:
dpctl_mod_flow	.\utilities\ovs-dpctl.c	/^dpctl_mod_flow(int argc OVS_UNUSED, char *argv[])$/;"	f	file:
dpctl_normalize_actions	.\utilities\ovs-dpctl.c	/^dpctl_normalize_actions(int argc, char *argv[])$/;"	f	file:
dpctl_parse_actions	.\utilities\ovs-dpctl.c	/^dpctl_parse_actions(int argc, char *argv[])$/;"	f	file:
dpctl_put_flow	.\utilities\ovs-dpctl.c	/^dpctl_put_flow(int argc, char *argv[], enum dpif_flow_put_flags flags)$/;"	f	file:
dpctl_set_if	.\utilities\ovs-dpctl.c	/^dpctl_set_if(int argc, char *argv[])$/;"	f	file:
dpctl_show	.\utilities\ovs-dpctl.c	/^dpctl_show(int argc, char *argv[])$/;"	f	file:
dpdk	.\lib\netdev-dpdk.c	/^VLOG_DEFINE_THIS_MODULE(dpdk);$/;"	v
dpdk_class_init	.\lib\netdev-dpdk.c	/^dpdk_class_init(void)$/;"	f	file:
dpdk_do_tx_copy	.\lib\netdev-dpdk.c	/^dpdk_do_tx_copy(struct netdev *netdev, char *buf, int size)$/;"	f	file:
dpdk_init	.\lib\netdev-dpdk.c	/^dpdk_init(int argc, char **argv)$/;"	f
dpdk_init	.\lib\netdev-dpdk.h	/^dpdk_init(int arg1 OVS_UNUSED, char **arg2 OVS_UNUSED)$/;"	f
dpdk_mp	.\lib\netdev-dpdk.c	/^    struct dpdk_mp *dpdk_mp;$/;"	m	struct:netdev_dpdk	typeref:struct:netdev_dpdk::dpdk_mp	file:
dpdk_mp	.\lib\netdev-dpdk.c	/^struct dpdk_mp {$/;"	s	file:
dpdk_mp_put	.\lib\netdev-dpdk.c	/^dpdk_mp_put(struct dpdk_mp *dmp)$/;"	f	file:
dpdk_mutex	.\lib\netdev-dpdk.c	/^static struct list dpdk_list OVS_GUARDED_BY(dpdk_mutex)$/;"	v	typeref:struct:OVS_GUARDED_BY	file:
dpdk_mutex	.\lib\netdev-dpdk.c	/^static struct list dpdk_mp_list OVS_GUARDED_BY(dpdk_mutex)$/;"	v	typeref:struct:OVS_GUARDED_BY	file:
dpdk_mutex	.\lib\netdev-dpdk.c	/^static struct ovs_mutex dpdk_mutex = OVS_MUTEX_INITIALIZER;$/;"	v	typeref:struct:ovs_mutex	file:
dpdk_queue_flush	.\lib\netdev-dpdk.c	/^dpdk_queue_flush(struct netdev_dpdk *dev, int qid)$/;"	f	file:
dpdk_queue_pkt	.\lib\netdev-dpdk.c	/^dpdk_queue_pkt(struct netdev_dpdk *dev, int qid,$/;"	f	file:
dpdk_rte_mzalloc	.\lib\netdev-dpdk.c	/^dpdk_rte_mzalloc(size_t sz)$/;"	f	file:
dpdk_tx_queue	.\lib\netdev-dpdk.c	/^struct dpdk_tx_queue {$/;"	s	file:
dpdk_watchdog	.\lib\netdev-dpdk.c	/^dpdk_watchdog(void *dummy OVS_UNUSED)$/;"	f	file:
dpid_from_hash	.\vswitchd\bridge.c	/^dpid_from_hash(const void *data, size_t n)$/;"	f	file:
dpid_from_string	.\lib\packets.c	/^dpid_from_string(const char *s, uint64_t *dpidp)$/;"	f
dpif	.\lib\dpif-linux.c	/^    struct dpif dpif;$/;"	m	struct:dpif_linux	typeref:struct:dpif_linux::dpif	file:
dpif	.\lib\dpif-netdev.c	/^    struct dpif dpif;$/;"	m	struct:dpif_netdev	typeref:struct:dpif_netdev::dpif	file:
dpif	.\lib\dpif-provider.h	/^struct dpif {$/;"	s
dpif	.\lib\dpif.c	/^    struct dpif *dpif;$/;"	m	struct:dpif_execute_helper_aux	typeref:struct:dpif_execute_helper_aux::dpif	file:
dpif	.\lib\dpif.c	/^VLOG_DEFINE_THIS_MODULE(dpif);$/;"	v
dpif	.\lib\dpif.h	/^    const struct dpif *dpif;$/;"	m	struct:dpif_flow_dump	typeref:struct:dpif_flow_dump::dpif
dpif	.\lib\dpif.h	/^    const struct dpif *dpif;$/;"	m	struct:dpif_port_dump	typeref:struct:dpif_port_dump::dpif
dpif	.\ofproto\ofproto-dpif-upcall.c	/^    struct dpif *dpif;                 \/* Datapath handle. *\/$/;"	m	struct:udpif	typeref:struct:udpif::dpif	file:
dpif	.\ofproto\ofproto-dpif-xlate.c	/^    struct dpif *dpif;            \/* Datapath interface. *\/$/;"	m	struct:xbridge	typeref:struct:xbridge::dpif	file:
dpif	.\ofproto\ofproto-dpif.c	/^    struct dpif *dpif;$/;"	m	struct:dpif_backer	typeref:struct:dpif_backer::dpif	file:
dpif_assert_class	.\lib\dpif-provider.h	/^static inline void dpif_assert_class(const struct dpif *dpif,$/;"	f
dpif_backer	.\ofproto\ofproto-dpif.c	/^struct dpif_backer {$/;"	s	file:
dpif_base_name	.\lib\dpif.c	/^dpif_base_name(const struct dpif *dpif)$/;"	f
dpif_blacklist	.\lib\dpif.c	/^static struct sset dpif_blacklist = SSET_INITIALIZER(&dpif_blacklist);$/;"	v	typeref:struct:sset	file:
dpif_channel	.\lib\dpif-linux.c	/^struct dpif_channel {$/;"	s	file:
dpif_class	.\lib\dpif-provider.h	/^    const struct dpif_class *dpif_class;$/;"	m	struct:dpif	typeref:struct:dpif::dpif_class
dpif_class	.\lib\dpif-provider.h	/^struct dpif_class {$/;"	s
dpif_class	.\lib\dpif.c	/^    const struct dpif_class *dpif_class;$/;"	m	struct:registered_dpif_class	typeref:struct:registered_dpif_class::dpif_class	file:
dpif_classes	.\lib\dpif.c	/^static struct shash dpif_classes = SHASH_INITIALIZER(&dpif_classes);$/;"	v	typeref:struct:shash	file:
dpif_close	.\lib\dpif.c	/^dpif_close(struct dpif *dpif)$/;"	f
dpif_completion	.\ofproto\ofproto-dpif.c	/^struct dpif_completion {$/;"	s	file:
dpif_create	.\lib\dpif.c	/^dpif_create(const char *name, const char *type, struct dpif **dpifp)$/;"	f
dpif_create_and_open	.\lib\dpif.c	/^dpif_create_and_open(const char *name, const char *type, struct dpif **dpifp)$/;"	f
dpif_delete	.\lib\dpif.c	/^dpif_delete(struct dpif *dpif)$/;"	f
dpif_destroy	.\lib\dpif.c	/^COVERAGE_DEFINE(dpif_destroy);$/;"	v
dpif_dp_stats	.\lib\dpif.h	/^struct dpif_dp_stats {$/;"	s
dpif_dummy_change_port_number	.\lib\dpif-netdev.c	/^dpif_dummy_change_port_number(struct unixctl_conn *conn, int argc OVS_UNUSED,$/;"	f	file:
dpif_dummy_register	.\lib\dpif-netdev.c	/^dpif_dummy_register(bool override)$/;"	f
dpif_dummy_register__	.\lib\dpif-netdev.c	/^dpif_dummy_register__(const char *type)$/;"	f	file:
dpif_execute	.\lib\dpif.c	/^COVERAGE_DEFINE(dpif_execute);$/;"	v
dpif_execute	.\lib\dpif.c	/^dpif_execute(struct dpif *dpif, struct dpif_execute *execute)$/;"	f
dpif_execute	.\lib\dpif.h	/^struct dpif_execute {$/;"	s
dpif_execute_helper_aux	.\lib\dpif.c	/^struct dpif_execute_helper_aux {$/;"	s	file:
dpif_execute_helper_cb	.\lib\dpif.c	/^dpif_execute_helper_cb(void *aux_, struct ofpbuf *packet,$/;"	f	file:
dpif_execute_with_help	.\lib\dpif.c	/^COVERAGE_DEFINE(dpif_execute_with_help);$/;"	v
dpif_execute_with_help	.\lib\dpif.c	/^dpif_execute_with_help(struct dpif *dpif, struct dpif_execute *execute)$/;"	f	file:
dpif_flow_del	.\lib\dpif.c	/^COVERAGE_DEFINE(dpif_flow_del);$/;"	v
dpif_flow_del	.\lib\dpif.c	/^dpif_flow_del(struct dpif *dpif,$/;"	f
dpif_flow_del	.\lib\dpif.h	/^struct dpif_flow_del {$/;"	s
dpif_flow_del__	.\lib\dpif.c	/^dpif_flow_del__(struct dpif *dpif, struct dpif_flow_del *del)$/;"	f	file:
dpif_flow_dump	.\lib\dpif.h	/^struct dpif_flow_dump {$/;"	s
dpif_flow_dump_done	.\lib\dpif.c	/^dpif_flow_dump_done(struct dpif_flow_dump *dump)$/;"	f
dpif_flow_dump_next	.\lib\dpif.c	/^dpif_flow_dump_next(struct dpif_flow_dump *dump, void *state,$/;"	f
dpif_flow_dump_next_may_destroy_keys	.\lib\dpif.c	/^dpif_flow_dump_next_may_destroy_keys(struct dpif_flow_dump *dump, void *state)$/;"	f
dpif_flow_dump_start	.\lib\dpif.c	/^dpif_flow_dump_start(struct dpif_flow_dump *dump, const struct dpif *dpif)$/;"	f
dpif_flow_dump_state_init	.\lib\dpif.c	/^dpif_flow_dump_state_init(const struct dpif *dpif, void **statep)$/;"	f
dpif_flow_dump_state_uninit	.\lib\dpif.c	/^dpif_flow_dump_state_uninit(const struct dpif *dpif, void *state)$/;"	f
dpif_flow_flush	.\lib\dpif.c	/^COVERAGE_DEFINE(dpif_flow_flush);$/;"	v
dpif_flow_flush	.\lib\dpif.c	/^dpif_flow_flush(struct dpif *dpif)$/;"	f
dpif_flow_get	.\lib\dpif.c	/^COVERAGE_DEFINE(dpif_flow_get);$/;"	v
dpif_flow_get	.\lib\dpif.c	/^dpif_flow_get(const struct dpif *dpif,$/;"	f
dpif_flow_put	.\lib\dpif.c	/^COVERAGE_DEFINE(dpif_flow_put);$/;"	v
dpif_flow_put	.\lib\dpif.c	/^dpif_flow_put(struct dpif *dpif, enum dpif_flow_put_flags flags,$/;"	f
dpif_flow_put	.\lib\dpif.h	/^struct dpif_flow_put {$/;"	s
dpif_flow_put__	.\lib\dpif.c	/^dpif_flow_put__(struct dpif *dpif, const struct dpif_flow_put *put)$/;"	f	file:
dpif_flow_put_flags	.\lib\dpif.h	/^enum dpif_flow_put_flags {$/;"	g
dpif_flow_stats	.\lib\dpif.h	/^struct dpif_flow_stats {$/;"	s
dpif_flow_stats_extract	.\lib\dpif.c	/^dpif_flow_stats_extract(const struct flow *flow, const struct ofpbuf *packet,$/;"	f
dpif_flow_stats_format	.\lib\dpif.c	/^dpif_flow_stats_format(const struct dpif_flow_stats *stats, struct ds *s)$/;"	f
dpif_get_dp_stats	.\lib\dpif.c	/^dpif_get_dp_stats(const struct dpif *dpif, struct dpif_dp_stats *stats)$/;"	f
dpif_get_netflow_ids	.\lib\dpif.c	/^dpif_get_netflow_ids(const struct dpif *dpif,$/;"	f
dpif_handler	.\lib\dpif-linux.c	/^struct dpif_handler {$/;"	s	file:
dpif_handlers_set	.\lib\dpif.c	/^dpif_handlers_set(struct dpif *dpif, uint32_t n_handlers)$/;"	f
dpif_init	.\lib\dpif.c	/^dpif_init(struct dpif *dpif, const struct dpif_class *dpif_class,$/;"	f
dpif_ipfix	.\ofproto\ofproto-dpif-ipfix.c	/^struct dpif_ipfix {$/;"	s	file:
dpif_ipfix_bridge_exporter	.\ofproto\ofproto-dpif-ipfix.c	/^struct dpif_ipfix_bridge_exporter {$/;"	s	file:
dpif_ipfix_bridge_exporter_clear	.\ofproto\ofproto-dpif-ipfix.c	/^dpif_ipfix_bridge_exporter_clear(struct dpif_ipfix_bridge_exporter *exporter)$/;"	f	file:
dpif_ipfix_bridge_exporter_destroy	.\ofproto\ofproto-dpif-ipfix.c	/^dpif_ipfix_bridge_exporter_destroy(struct dpif_ipfix_bridge_exporter *exporter)$/;"	f	file:
dpif_ipfix_bridge_exporter_init	.\ofproto\ofproto-dpif-ipfix.c	/^dpif_ipfix_bridge_exporter_init(struct dpif_ipfix_bridge_exporter *exporter)$/;"	f	file:
dpif_ipfix_bridge_exporter_set_options	.\ofproto\ofproto-dpif-ipfix.c	/^dpif_ipfix_bridge_exporter_set_options($/;"	f	file:
dpif_ipfix_cache_expire	.\ofproto\ofproto-dpif-ipfix.c	/^dpif_ipfix_cache_expire(struct dpif_ipfix_exporter *exporter,$/;"	f	file:
dpif_ipfix_cache_expire_now	.\ofproto\ofproto-dpif-ipfix.c	/^dpif_ipfix_cache_expire_now(struct dpif_ipfix_exporter *exporter,$/;"	f	file:
dpif_ipfix_create	.\ofproto\ofproto-dpif-ipfix.c	/^dpif_ipfix_create(void)$/;"	f
dpif_ipfix_exporter	.\ofproto\ofproto-dpif-ipfix.c	/^struct dpif_ipfix_exporter {$/;"	s	file:
dpif_ipfix_exporter_clear	.\ofproto\ofproto-dpif-ipfix.c	/^dpif_ipfix_exporter_clear(struct dpif_ipfix_exporter *exporter)$/;"	f	file:
dpif_ipfix_exporter_destroy	.\ofproto\ofproto-dpif-ipfix.c	/^dpif_ipfix_exporter_destroy(struct dpif_ipfix_exporter *exporter)$/;"	f	file:
dpif_ipfix_exporter_init	.\ofproto\ofproto-dpif-ipfix.c	/^dpif_ipfix_exporter_init(struct dpif_ipfix_exporter *exporter)$/;"	f	file:
dpif_ipfix_exporter_set_options	.\ofproto\ofproto-dpif-ipfix.c	/^dpif_ipfix_exporter_set_options(struct dpif_ipfix_exporter *exporter,$/;"	f	file:
dpif_ipfix_flow_exporter	.\ofproto\ofproto-dpif-ipfix.c	/^struct dpif_ipfix_flow_exporter {$/;"	s	file:
dpif_ipfix_flow_exporter_clear	.\ofproto\ofproto-dpif-ipfix.c	/^dpif_ipfix_flow_exporter_clear(struct dpif_ipfix_flow_exporter *exporter)$/;"	f	file:
dpif_ipfix_flow_exporter_destroy	.\ofproto\ofproto-dpif-ipfix.c	/^dpif_ipfix_flow_exporter_destroy(struct dpif_ipfix_flow_exporter *exporter)$/;"	f	file:
dpif_ipfix_flow_exporter_init	.\ofproto\ofproto-dpif-ipfix.c	/^dpif_ipfix_flow_exporter_init(struct dpif_ipfix_flow_exporter *exporter)$/;"	f	file:
dpif_ipfix_flow_exporter_map_node	.\ofproto\ofproto-dpif-ipfix.c	/^struct dpif_ipfix_flow_exporter_map_node {$/;"	s	file:
dpif_ipfix_flow_exporter_set_options	.\ofproto\ofproto-dpif-ipfix.c	/^dpif_ipfix_flow_exporter_set_options($/;"	f	file:
dpif_ipfix_ref	.\ofproto\ofproto-dpif-ipfix.c	/^dpif_ipfix_ref(const struct dpif_ipfix *di_)$/;"	f
dpif_ipfix_sample	.\ofproto\ofproto-dpif-ipfix.c	/^dpif_ipfix_sample(struct dpif_ipfix_exporter *exporter,$/;"	f	file:
dpif_linux	.\lib\dpif-linux.c	/^VLOG_DEFINE_THIS_MODULE(dpif_linux);$/;"	v
dpif_linux	.\lib\dpif-linux.c	/^struct dpif_linux {$/;"	s	file:
dpif_linux_cast	.\lib\dpif-linux.c	/^dpif_linux_cast(const struct dpif *dpif)$/;"	f	file:
dpif_linux_class	.\lib\dpif-linux.c	/^const struct dpif_class dpif_linux_class = {$/;"	v	typeref:struct:dpif_class
dpif_linux_close	.\lib\dpif-linux.c	/^dpif_linux_close(struct dpif *dpif_)$/;"	f	file:
dpif_linux_destroy	.\lib\dpif-linux.c	/^dpif_linux_destroy(struct dpif *dpif_)$/;"	f	file:
dpif_linux_dp	.\lib\dpif-linux.c	/^struct dpif_linux_dp {$/;"	s	file:
dpif_linux_dp_dump_start	.\lib\dpif-linux.c	/^dpif_linux_dp_dump_start(struct nl_dump *dump)$/;"	f	file:
dpif_linux_dp_from_ofpbuf	.\lib\dpif-linux.c	/^dpif_linux_dp_from_ofpbuf(struct dpif_linux_dp *dp, const struct ofpbuf *buf)$/;"	f	file:
dpif_linux_dp_get	.\lib\dpif-linux.c	/^dpif_linux_dp_get(const struct dpif *dpif_, struct dpif_linux_dp *reply,$/;"	f	file:
dpif_linux_dp_init	.\lib\dpif-linux.c	/^dpif_linux_dp_init(struct dpif_linux_dp *dp)$/;"	f	file:
dpif_linux_dp_to_ofpbuf	.\lib\dpif-linux.c	/^dpif_linux_dp_to_ofpbuf(const struct dpif_linux_dp *dp, struct ofpbuf *buf)$/;"	f	file:
dpif_linux_dp_transact	.\lib\dpif-linux.c	/^dpif_linux_dp_transact(const struct dpif_linux_dp *request,$/;"	f	file:
dpif_linux_encode_execute	.\lib\dpif-linux.c	/^dpif_linux_encode_execute(int dp_ifindex, const struct dpif_execute *d_exec,$/;"	f	file:
dpif_linux_enumerate	.\lib\dpif-linux.c	/^dpif_linux_enumerate(struct sset *all_dps)$/;"	f	file:
dpif_linux_execute	.\lib\dpif-linux.c	/^dpif_linux_execute(struct dpif *dpif_, struct dpif_execute *execute)$/;"	f	file:
dpif_linux_execute__	.\lib\dpif-linux.c	/^dpif_linux_execute__(int dp_ifindex, const struct dpif_execute *execute)$/;"	f	file:
dpif_linux_flow	.\lib\dpif-linux.c	/^struct dpif_linux_flow {$/;"	s	file:
dpif_linux_flow_del	.\lib\dpif-linux.c	/^dpif_linux_flow_del(struct dpif *dpif_, const struct dpif_flow_del *del)$/;"	f	file:
dpif_linux_flow_dump_done	.\lib\dpif-linux.c	/^dpif_linux_flow_dump_done(const struct dpif *dpif OVS_UNUSED, void *iter_)$/;"	f	file:
dpif_linux_flow_dump_next	.\lib\dpif-linux.c	/^dpif_linux_flow_dump_next(const struct dpif *dpif_, void *iter_, void *state_,$/;"	f	file:
dpif_linux_flow_dump_next_may_destroy_keys	.\lib\dpif-linux.c	/^dpif_linux_flow_dump_next_may_destroy_keys(void *state_)$/;"	f	file:
dpif_linux_flow_dump_start	.\lib\dpif-linux.c	/^dpif_linux_flow_dump_start(const struct dpif *dpif_, void **iterp)$/;"	f	file:
dpif_linux_flow_dump_state_init	.\lib\dpif-linux.c	/^dpif_linux_flow_dump_state_init(void **statep)$/;"	f	file:
dpif_linux_flow_dump_state_uninit	.\lib\dpif-linux.c	/^dpif_linux_flow_dump_state_uninit(void *state_)$/;"	f	file:
dpif_linux_flow_flush	.\lib\dpif-linux.c	/^dpif_linux_flow_flush(struct dpif *dpif_)$/;"	f	file:
dpif_linux_flow_from_ofpbuf	.\lib\dpif-linux.c	/^dpif_linux_flow_from_ofpbuf(struct dpif_linux_flow *flow,$/;"	f	file:
dpif_linux_flow_get	.\lib\dpif-linux.c	/^dpif_linux_flow_get(const struct dpif *dpif_,$/;"	f	file:
dpif_linux_flow_get__	.\lib\dpif-linux.c	/^dpif_linux_flow_get__(const struct dpif_linux *dpif,$/;"	f	file:
dpif_linux_flow_get_stats	.\lib\dpif-linux.c	/^dpif_linux_flow_get_stats(const struct dpif_linux_flow *flow,$/;"	f	file:
dpif_linux_flow_init	.\lib\dpif-linux.c	/^dpif_linux_flow_init(struct dpif_linux_flow *flow)$/;"	f	file:
dpif_linux_flow_iter	.\lib\dpif-linux.c	/^struct dpif_linux_flow_iter {$/;"	s	file:
dpif_linux_flow_put	.\lib\dpif-linux.c	/^dpif_linux_flow_put(struct dpif *dpif_, const struct dpif_flow_put *put)$/;"	f	file:
dpif_linux_flow_state	.\lib\dpif-linux.c	/^struct dpif_linux_flow_state {$/;"	s	file:
dpif_linux_flow_to_ofpbuf	.\lib\dpif-linux.c	/^dpif_linux_flow_to_ofpbuf(const struct dpif_linux_flow *flow,$/;"	f	file:
dpif_linux_flow_transact	.\lib\dpif-linux.c	/^dpif_linux_flow_transact(struct dpif_linux_flow *request,$/;"	f	file:
dpif_linux_get_stats	.\lib\dpif-linux.c	/^dpif_linux_get_stats(const struct dpif *dpif_, struct dpif_dp_stats *stats)$/;"	f	file:
dpif_linux_handlers_set	.\lib\dpif-linux.c	/^dpif_linux_handlers_set(struct dpif *dpif_, uint32_t n_handlers)$/;"	f	file:
dpif_linux_init	.\lib\dpif-linux.c	/^dpif_linux_init(void)$/;"	f	file:
dpif_linux_init_flow_del	.\lib\dpif-linux.c	/^dpif_linux_init_flow_del(struct dpif_linux *dpif, const struct dpif_flow_del *del,$/;"	f	file:
dpif_linux_init_flow_put	.\lib\dpif-linux.c	/^dpif_linux_init_flow_put(struct dpif_linux *dpif, const struct dpif_flow_put *put,$/;"	f	file:
dpif_linux_is_internal_device	.\lib\dpif-linux.c	/^dpif_linux_is_internal_device(const char *name)$/;"	f
dpif_linux_open	.\lib\dpif-linux.c	/^dpif_linux_open(const struct dpif_class *class OVS_UNUSED, const char *name,$/;"	f	file:
dpif_linux_operate	.\lib\dpif-linux.c	/^dpif_linux_operate(struct dpif *dpif_, struct dpif_op **ops, size_t n_ops)$/;"	f	file:
dpif_linux_operate__	.\lib\dpif-linux.c	/^dpif_linux_operate__(struct dpif_linux *dpif, struct dpif_op **ops, size_t n_ops)$/;"	f	file:
dpif_linux_port_add	.\lib\dpif-linux.c	/^dpif_linux_port_add(struct dpif *dpif_, struct netdev *netdev,$/;"	f	file:
dpif_linux_port_del	.\lib\dpif-linux.c	/^dpif_linux_port_del(struct dpif *dpif_, odp_port_t port_no)$/;"	f	file:
dpif_linux_port_dump_done	.\lib\dpif-linux.c	/^dpif_linux_port_dump_done(const struct dpif *dpif_ OVS_UNUSED, void *state_)$/;"	f	file:
dpif_linux_port_dump_next	.\lib\dpif-linux.c	/^dpif_linux_port_dump_next(const struct dpif *dpif_, void *state_,$/;"	f	file:
dpif_linux_port_dump_next__	.\lib\dpif-linux.c	/^dpif_linux_port_dump_next__(const struct dpif_linux *dpif, struct nl_dump *dump,$/;"	f	file:
dpif_linux_port_dump_start	.\lib\dpif-linux.c	/^dpif_linux_port_dump_start(const struct dpif *dpif_, void **statep)$/;"	f	file:
dpif_linux_port_dump_start__	.\lib\dpif-linux.c	/^dpif_linux_port_dump_start__(const struct dpif_linux *dpif,$/;"	f	file:
dpif_linux_port_get_pid	.\lib\dpif-linux.c	/^dpif_linux_port_get_pid(const struct dpif *dpif_, odp_port_t port_no,$/;"	f	file:
dpif_linux_port_poll	.\lib\dpif-linux.c	/^dpif_linux_port_poll(const struct dpif *dpif_, char **devnamep)$/;"	f	file:
dpif_linux_port_poll_wait	.\lib\dpif-linux.c	/^dpif_linux_port_poll_wait(const struct dpif *dpif_)$/;"	f	file:
dpif_linux_port_query__	.\lib\dpif-linux.c	/^dpif_linux_port_query__(const struct dpif_linux *dpif, odp_port_t port_no,$/;"	f	file:
dpif_linux_port_query_by_name	.\lib\dpif-linux.c	/^dpif_linux_port_query_by_name(const struct dpif *dpif_, const char *devname,$/;"	f	file:
dpif_linux_port_query_by_number	.\lib\dpif-linux.c	/^dpif_linux_port_query_by_number(const struct dpif *dpif_, odp_port_t port_no,$/;"	f	file:
dpif_linux_port_state	.\lib\dpif-linux.c	/^struct dpif_linux_port_state {$/;"	s	file:
dpif_linux_queue_to_priority	.\lib\dpif-linux.c	/^dpif_linux_queue_to_priority(const struct dpif *dpif OVS_UNUSED,$/;"	f	file:
dpif_linux_recv	.\lib\dpif-linux.c	/^dpif_linux_recv(struct dpif *dpif_, uint32_t handler_id,$/;"	f	file:
dpif_linux_recv_purge	.\lib\dpif-linux.c	/^dpif_linux_recv_purge(struct dpif *dpif_)$/;"	f	file:
dpif_linux_recv_set	.\lib\dpif-linux.c	/^dpif_linux_recv_set(struct dpif *dpif_, bool enable)$/;"	f	file:
dpif_linux_recv_wait	.\lib\dpif-linux.c	/^dpif_linux_recv_wait(struct dpif *dpif_, uint32_t handler_id)$/;"	f	file:
dpif_linux_run	.\lib\dpif-linux.c	/^dpif_linux_run(struct dpif *dpif_)$/;"	f	file:
dpif_linux_vport	.\lib\dpif-linux.h	/^struct dpif_linux_vport {$/;"	s
dpif_linux_vport_from_ofpbuf	.\lib\dpif-linux.c	/^dpif_linux_vport_from_ofpbuf(struct dpif_linux_vport *vport,$/;"	f	file:
dpif_linux_vport_get	.\lib\dpif-linux.c	/^dpif_linux_vport_get(const char *name, struct dpif_linux_vport *reply,$/;"	f
dpif_linux_vport_init	.\lib\dpif-linux.c	/^dpif_linux_vport_init(struct dpif_linux_vport *vport)$/;"	f
dpif_linux_vport_to_ofpbuf	.\lib\dpif-linux.c	/^dpif_linux_vport_to_ofpbuf(const struct dpif_linux_vport *vport,$/;"	f	file:
dpif_linux_vport_transact	.\lib\dpif-linux.c	/^dpif_linux_vport_transact(const struct dpif_linux_vport *request,$/;"	f
dpif_mutex	.\lib\dpif.c	/^static struct ovs_mutex dpif_mutex = OVS_MUTEX_INITIALIZER;$/;"	v	typeref:struct:ovs_mutex	file:
dpif_name	.\lib\dpif.c	/^dpif_name(const struct dpif *dpif)$/;"	f
dpif_netdev	.\lib\dpif-netdev.c	/^VLOG_DEFINE_THIS_MODULE(dpif_netdev);$/;"	v
dpif_netdev	.\lib\dpif-netdev.c	/^struct dpif_netdev {$/;"	s	file:
dpif_netdev_cast	.\lib\dpif-netdev.c	/^dpif_netdev_cast(const struct dpif *dpif)$/;"	f	file:
dpif_netdev_class	.\lib\dpif-netdev.c	/^const struct dpif_class dpif_netdev_class = {$/;"	v	typeref:struct:dpif_class
dpif_netdev_class_is_dummy	.\lib\dpif-netdev.c	/^dpif_netdev_class_is_dummy(const struct dpif_class *class)$/;"	f	file:
dpif_netdev_close	.\lib\dpif-netdev.c	/^dpif_netdev_close(struct dpif *dpif)$/;"	f	file:
dpif_netdev_destroy	.\lib\dpif-netdev.c	/^dpif_netdev_destroy(struct dpif *dpif)$/;"	f	file:
dpif_netdev_enumerate	.\lib\dpif-netdev.c	/^dpif_netdev_enumerate(struct sset *all_dps)$/;"	f	file:
dpif_netdev_execute	.\lib\dpif-netdev.c	/^dpif_netdev_execute(struct dpif *dpif, struct dpif_execute *execute)$/;"	f	file:
dpif_netdev_flow_del	.\lib\dpif-netdev.c	/^dpif_netdev_flow_del(struct dpif *dpif, const struct dpif_flow_del *del)$/;"	f	file:
dpif_netdev_flow_dump_done	.\lib\dpif-netdev.c	/^dpif_netdev_flow_dump_done(const struct dpif *dpif OVS_UNUSED, void *iter_)$/;"	f	file:
dpif_netdev_flow_dump_next	.\lib\dpif-netdev.c	/^dpif_netdev_flow_dump_next(const struct dpif *dpif, void *iter_, void *state_,$/;"	f	file:
dpif_netdev_flow_dump_start	.\lib\dpif-netdev.c	/^dpif_netdev_flow_dump_start(const struct dpif *dpif OVS_UNUSED, void **iterp)$/;"	f	file:
dpif_netdev_flow_dump_state_init	.\lib\dpif-netdev.c	/^dpif_netdev_flow_dump_state_init(void **statep)$/;"	f	file:
dpif_netdev_flow_dump_state_uninit	.\lib\dpif-netdev.c	/^dpif_netdev_flow_dump_state_uninit(void *state_)$/;"	f	file:
dpif_netdev_flow_flush	.\lib\dpif-netdev.c	/^dpif_netdev_flow_flush(struct dpif *dpif)$/;"	f	file:
dpif_netdev_flow_from_nlattrs	.\lib\dpif-netdev.c	/^dpif_netdev_flow_from_nlattrs(const struct nlattr *key, uint32_t key_len,$/;"	f	file:
dpif_netdev_flow_get	.\lib\dpif-netdev.c	/^dpif_netdev_flow_get(const struct dpif *dpif,$/;"	f	file:
dpif_netdev_flow_put	.\lib\dpif-netdev.c	/^dpif_netdev_flow_put(struct dpif *dpif, const struct dpif_flow_put *put)$/;"	f	file:
dpif_netdev_get_stats	.\lib\dpif-netdev.c	/^dpif_netdev_get_stats(const struct dpif *dpif, struct dpif_dp_stats *stats)$/;"	f	file:
dpif_netdev_handlers_set	.\lib\dpif-netdev.c	/^dpif_netdev_handlers_set(struct dpif *dpif, uint32_t n_handlers)$/;"	f	file:
dpif_netdev_mask_from_nlattrs	.\lib\dpif-netdev.c	/^dpif_netdev_mask_from_nlattrs(const struct nlattr *key, uint32_t key_len,$/;"	f	file:
dpif_netdev_open	.\lib\dpif-netdev.c	/^dpif_netdev_open(const struct dpif_class *class, const char *name,$/;"	f	file:
dpif_netdev_port_add	.\lib\dpif-netdev.c	/^dpif_netdev_port_add(struct dpif *dpif, struct netdev *netdev,$/;"	f	file:
dpif_netdev_port_del	.\lib\dpif-netdev.c	/^dpif_netdev_port_del(struct dpif *dpif, odp_port_t port_no)$/;"	f	file:
dpif_netdev_port_dump_done	.\lib\dpif-netdev.c	/^dpif_netdev_port_dump_done(const struct dpif *dpif OVS_UNUSED, void *state_)$/;"	f	file:
dpif_netdev_port_dump_next	.\lib\dpif-netdev.c	/^dpif_netdev_port_dump_next(const struct dpif *dpif, void *state_,$/;"	f	file:
dpif_netdev_port_dump_start	.\lib\dpif-netdev.c	/^dpif_netdev_port_dump_start(const struct dpif *dpif OVS_UNUSED, void **statep)$/;"	f	file:
dpif_netdev_port_open_type	.\lib\dpif-netdev.c	/^dpif_netdev_port_open_type(const struct dpif_class *class, const char *type)$/;"	f	file:
dpif_netdev_port_poll	.\lib\dpif-netdev.c	/^dpif_netdev_port_poll(const struct dpif *dpif_, char **devnamep OVS_UNUSED)$/;"	f	file:
dpif_netdev_port_poll_wait	.\lib\dpif-netdev.c	/^dpif_netdev_port_poll_wait(const struct dpif *dpif_)$/;"	f	file:
dpif_netdev_port_query_by_name	.\lib\dpif-netdev.c	/^dpif_netdev_port_query_by_name(const struct dpif *dpif, const char *devname,$/;"	f	file:
dpif_netdev_port_query_by_number	.\lib\dpif-netdev.c	/^dpif_netdev_port_query_by_number(const struct dpif *dpif, odp_port_t port_no,$/;"	f	file:
dpif_netdev_queue_to_priority	.\lib\dpif-netdev.c	/^dpif_netdev_queue_to_priority(const struct dpif *dpif OVS_UNUSED,$/;"	f	file:
dpif_netdev_recv	.\lib\dpif-netdev.c	/^dpif_netdev_recv(struct dpif *dpif, uint32_t handler_id,$/;"	f	file:
dpif_netdev_recv_purge	.\lib\dpif-netdev.c	/^dpif_netdev_recv_purge(struct dpif *dpif)$/;"	f	file:
dpif_netdev_recv_set	.\lib\dpif-netdev.c	/^dpif_netdev_recv_set(struct dpif *dpif, bool enable)$/;"	f	file:
dpif_netdev_recv_wait	.\lib\dpif-netdev.c	/^dpif_netdev_recv_wait(struct dpif *dpif, uint32_t handler_id)$/;"	f	file:
dpif_netdev_run	.\lib\dpif-netdev.c	/^dpif_netdev_run(struct dpif *dpif)$/;"	f	file:
dpif_netdev_wait	.\lib\dpif-netdev.c	/^dpif_netdev_wait(struct dpif *dpif)$/;"	f	file:
dpif_normalize_type	.\lib\dpif.c	/^dpif_normalize_type(const char *type)$/;"	f
dpif_op	.\lib\dpif.h	/^struct dpif_op {$/;"	s
dpif_op_type	.\lib\dpif.h	/^enum dpif_op_type {$/;"	g
dpif_open	.\lib\dpif.c	/^dpif_open(const char *name, const char *type, struct dpif **dpifp)$/;"	f
dpif_operate	.\lib\dpif.c	/^dpif_operate(struct dpif *dpif, struct dpif_op **ops, size_t n_ops)$/;"	f
dpif_port	.\lib\dpif.h	/^struct dpif_port {$/;"	s
dpif_port	.\lib\netdev-vport.c	/^    const char *dpif_port;$/;"	m	struct:vport_class	file:
dpif_port_add	.\lib\dpif.c	/^COVERAGE_DEFINE(dpif_port_add);$/;"	v
dpif_port_add	.\lib\dpif.c	/^dpif_port_add(struct dpif *dpif, struct netdev *netdev, odp_port_t *port_nop)$/;"	f
dpif_port_clone	.\lib\dpif.c	/^dpif_port_clone(struct dpif_port *dst, const struct dpif_port *src)$/;"	f
dpif_port_del	.\lib\dpif.c	/^COVERAGE_DEFINE(dpif_port_del);$/;"	v
dpif_port_del	.\lib\dpif.c	/^dpif_port_del(struct dpif *dpif, odp_port_t port_no)$/;"	f
dpif_port_destroy	.\lib\dpif.c	/^dpif_port_destroy(struct dpif_port *dpif_port)$/;"	f
dpif_port_dump	.\lib\dpif.h	/^struct dpif_port_dump {$/;"	s
dpif_port_dump_done	.\lib\dpif.c	/^dpif_port_dump_done(struct dpif_port_dump *dump)$/;"	f
dpif_port_dump_next	.\lib\dpif.c	/^dpif_port_dump_next(struct dpif_port_dump *dump, struct dpif_port *port)$/;"	f
dpif_port_dump_start	.\lib\dpif.c	/^dpif_port_dump_start(struct dpif_port_dump *dump, const struct dpif *dpif)$/;"	f
dpif_port_exists	.\lib\dpif.c	/^dpif_port_exists(const struct dpif *dpif, const char *devname)$/;"	f
dpif_port_get_name	.\lib\dpif.c	/^dpif_port_get_name(struct dpif *dpif, odp_port_t port_no,$/;"	f
dpif_port_get_pid	.\lib\dpif.c	/^dpif_port_get_pid(const struct dpif *dpif, odp_port_t port_no, uint32_t hash)$/;"	f
dpif_port_open_type	.\lib\dpif.c	/^dpif_port_open_type(const char *datapath_type, const char *port_type)$/;"	f
dpif_port_poll	.\lib\dpif.c	/^dpif_port_poll(const struct dpif *dpif, char **devnamep)$/;"	f
dpif_port_poll_wait	.\lib\dpif.c	/^dpif_port_poll_wait(const struct dpif *dpif)$/;"	f
dpif_port_query_by_name	.\lib\dpif.c	/^dpif_port_query_by_name(const struct dpif *dpif, const char *devname,$/;"	f
dpif_port_query_by_number	.\lib\dpif.c	/^dpif_port_query_by_number(const struct dpif *dpif, odp_port_t port_no,$/;"	f
dpif_purge	.\lib\dpif.c	/^COVERAGE_DEFINE(dpif_purge);$/;"	v
dpif_queue_to_priority	.\lib\dpif.c	/^dpif_queue_to_priority(const struct dpif *dpif, uint32_t queue_id,$/;"	f
dpif_recv	.\lib\dpif.c	/^dpif_recv(struct dpif *dpif, uint32_t handler_id, struct dpif_upcall *upcall,$/;"	f
dpif_recv_purge	.\lib\dpif.c	/^dpif_recv_purge(struct dpif *dpif)$/;"	f
dpif_recv_set	.\lib\dpif.c	/^dpif_recv_set(struct dpif *dpif, bool enable)$/;"	f
dpif_recv_wait	.\lib\dpif.c	/^dpif_recv_wait(struct dpif *dpif, uint32_t handler_id)$/;"	f
dpif_run	.\lib\dpif.c	/^dpif_run(struct dpif *dpif)$/;"	f
dpif_sflow	.\ofproto\ofproto-dpif-sflow.c	/^struct dpif_sflow {$/;"	s	file:
dpif_sflow_create	.\ofproto\ofproto-dpif-sflow.c	/^dpif_sflow_create(void)$/;"	f
dpif_sflow_port	.\ofproto\ofproto-dpif-sflow.c	/^struct dpif_sflow_port {$/;"	s	file:
dpif_sflow_ref	.\ofproto\ofproto-dpif-sflow.c	/^dpif_sflow_ref(const struct dpif_sflow *ds_)$/;"	f
dpif_show_backer	.\ofproto\ofproto-dpif.c	/^dpif_show_backer(const struct dpif_backer *backer, struct ds *ds)$/;"	f	file:
dpif_type	.\lib\dpif.c	/^dpif_type(const struct dpif *dpif)$/;"	f
dpif_uninit	.\lib\dpif.c	/^dpif_uninit(struct dpif *dpif, bool close)$/;"	f
dpif_upcall	.\lib\dpif.h	/^struct dpif_upcall {$/;"	s
dpif_upcall	.\ofproto\ofproto-dpif-upcall.c	/^    struct dpif_upcall dpif_upcall; \/* As returned by dpif_recv() *\/$/;"	m	struct:upcall	typeref:struct:upcall::dpif_upcall	file:
dpif_upcall_type	.\lib\dpif.h	/^enum dpif_upcall_type {$/;"	g
dpif_upcall_type_to_string	.\lib\dpif.c	/^dpif_upcall_type_to_string(enum dpif_upcall_type type)$/;"	f
dpif_wait	.\lib\dpif.c	/^dpif_wait(struct dpif *dpif)$/;"	f
dpmsg_rl	.\lib\dpif.c	/^static struct vlog_rate_limit dpmsg_rl = VLOG_RATE_LIMIT_INIT(600, 600);$/;"	v	typeref:struct:vlog_rate_limit	file:
dps	.\datapath\datapath.h	/^	struct list_head dps;$/;"	m	struct:ovs_net	typeref:struct:ovs_net::list_head
drain_fd	.\lib\socket-util.c	/^drain_fd(int fd, size_t n_packets)$/;"	f
drain_rcvbuf	.\lib\socket-util.c	/^drain_rcvbuf(int fd)$/;"	f
dropEvents	.\tests\test-sflow.c	/^    uint32_t dropEvents;$/;"	m	struct:sflow_xdr	file:
drop_frags_rule	.\ofproto\ofproto-dpif.c	/^    struct rule_dpif *drop_frags_rule; \/* Used in OFPC_FRAG_DROP mode. *\/$/;"	m	struct:ofproto_dpif	typeref:struct:ofproto_dpif::rule_dpif	file:
drop_packet	.\ofproto\pinsched.c	/^drop_packet(struct pinsched *ps)$/;"	f	file:
drops	.\lib\sflow.h	/^    u_int32_t drops;                \/* Number of times a packet was dropped due to$/;"	m	struct:_SFLFlow_sample
drops	.\lib\sflow.h	/^    u_int32_t drops;                \/* Number of times a packet was dropped due to$/;"	m	struct:_SFLFlow_sample_expanded
drvinfo	.\lib\netdev-linux.c	/^    struct ethtool_drvinfo drvinfo;  \/* Cached from ETHTOOL_GDRVINFO. *\/$/;"	m	struct:netdev_linux	typeref:struct:netdev_linux::ethtool_drvinfo	file:
dry_run	.\lib\ovsdb-idl.c	/^    bool dry_run;$/;"	m	struct:ovsdb_idl_txn	file:
dry_run	.\utilities\ovs-vsctl.c	/^static bool dry_run;$/;"	v	file:
dry_run	.\vtep\vtep-ctl.c	/^static bool dry_run;$/;"	v	file:
ds	.\lib\dynamic-string.h	/^struct ds {$/;"	s
ds	.\lib\json.c	/^    struct ds *ds;$/;"	m	struct:json_serializer	typeref:struct:json_serializer::ds	file:
ds	.\vswitchd\bridge.c	/^    struct ds *ds;$/;"	m	struct:qos_unixctl_show_cbdata	typeref:struct:qos_unixctl_show_cbdata::ds	file:
dsClass	.\tests\test-sflow.c	/^    uint32_t dsClass;$/;"	m	struct:sflow_xdr	file:
dsIndex	.\tests\test-sflow.c	/^    uint32_t dsIndex;$/;"	m	struct:sflow_xdr	file:
ds_chomp	.\lib\dynamic-string.c	/^ds_chomp(struct ds *ds, int c)$/;"	f
ds_class	.\lib\sflow.h	/^    u_int32_t ds_class;             \/* EXPANDED *\/$/;"	m	struct:_SFLFlow_sample_expanded
ds_class	.\lib\sflow.h	/^    u_int32_t ds_class;           \/* EXPANDED *\/$/;"	m	struct:_SFLCounters_sample_expanded
ds_class	.\lib\sflow_api.h	/^    u_int32_t ds_class;$/;"	m	struct:_SFLDataSource_instance
ds_clear	.\lib\dynamic-string.c	/^ds_clear(struct ds *ds)$/;"	f
ds_cstr	.\lib\dynamic-string.c	/^ds_cstr(struct ds *ds)$/;"	f
ds_cstr_ro	.\lib\dynamic-string.c	/^ds_cstr_ro(const struct ds *ds)$/;"	f
ds_destroy	.\lib\dynamic-string.c	/^ds_destroy(struct ds *ds)$/;"	f
ds_get_line	.\lib\dynamic-string.c	/^ds_get_line(struct ds *ds, FILE *file)$/;"	f
ds_get_preprocessed_line	.\lib\dynamic-string.c	/^ds_get_preprocessed_line(struct ds *ds, FILE *file, int *line_numberp)$/;"	f
ds_get_test_line	.\lib\dynamic-string.c	/^ds_get_test_line(struct ds *ds, FILE *file)$/;"	f
ds_index	.\lib\sflow.h	/^    u_int32_t ds_index;             \/* EXPANDED *\/$/;"	m	struct:_SFLFlow_sample_expanded
ds_index	.\lib\sflow.h	/^    u_int32_t ds_index;           \/* EXPANDED *\/$/;"	m	struct:_SFLCounters_sample_expanded
ds_index	.\lib\sflow_api.h	/^    u_int32_t ds_index;$/;"	m	struct:_SFLDataSource_instance
ds_init	.\lib\dynamic-string.c	/^ds_init(struct ds *ds)$/;"	f
ds_instance	.\lib\sflow_api.h	/^    u_int32_t ds_instance;$/;"	m	struct:_SFLDataSource_instance
ds_last	.\lib\dynamic-string.c	/^ds_last(const struct ds *ds)$/;"	f
ds_put_and_free_cstr	.\lib\dynamic-string.c	/^ds_put_and_free_cstr(struct ds *ds, char *s)$/;"	f
ds_put_buffer	.\lib\dynamic-string.c	/^ds_put_buffer(struct ds *ds, const char *s, size_t n)$/;"	f
ds_put_cfm_fault	.\lib\cfm.c	/^ds_put_cfm_fault(struct ds *ds, int fault)$/;"	f	file:
ds_put_char	.\lib\dynamic-string.h	/^ds_put_char(struct ds *ds, char c)$/;"	f
ds_put_char__	.\lib\dynamic-string.c	/^ds_put_char__(struct ds *ds, char c)$/;"	f
ds_put_char_multiple	.\lib\dynamic-string.c	/^ds_put_char_multiple(struct ds *ds, char c, size_t n)$/;"	f
ds_put_cstr	.\lib\dynamic-string.c	/^ds_put_cstr(struct ds *ds, const char *s)$/;"	f
ds_put_format	.\lib\dynamic-string.c	/^ds_put_format(struct ds *ds, const char *format, ...)$/;"	f
ds_put_format_valist	.\lib\dynamic-string.c	/^ds_put_format_valist(struct ds *ds, const char *format, va_list args_)$/;"	f
ds_put_hex_dump	.\lib\dynamic-string.c	/^ds_put_hex_dump(struct ds *ds, const void *buf_, size_t size,$/;"	f
ds_put_lacp_state	.\lib\lacp.c	/^ds_put_lacp_state(struct ds *ds, uint8_t state)$/;"	f	file:
ds_put_printable	.\lib\dynamic-string.c	/^ds_put_printable(struct ds *ds, const char *s, size_t n)$/;"	f
ds_put_strftime_msec	.\lib\dynamic-string.c	/^ds_put_strftime_msec(struct ds *ds, const char *template, long long int when,$/;"	f
ds_put_uninit	.\lib\dynamic-string.c	/^ds_put_uninit(struct ds *ds, size_t n)$/;"	f
ds_put_utf8	.\lib\dynamic-string.c	/^ds_put_utf8(struct ds *ds, int uc)$/;"	f
ds_reserve	.\lib\dynamic-string.c	/^ds_reserve(struct ds *ds, size_t min_length)$/;"	f
ds_steal_cstr	.\lib\dynamic-string.c	/^ds_steal_cstr(struct ds *ds)$/;"	f
ds_swap	.\lib\dynamic-string.c	/^ds_swap(struct ds *a, struct ds *b)$/;"	f
ds_truncate	.\lib\dynamic-string.c	/^ds_truncate(struct ds *ds, size_t new_length)$/;"	f
dscp	.\lib\jsonrpc.c	/^    uint8_t dscp;$/;"	m	struct:jsonrpc_session	file:
dscp	.\lib\ofp-actions.h	/^    uint8_t dscp;               \/* DSCP in high 6 bits, rest ignored. *\/$/;"	m	struct:ofpact_dscp
dscp	.\lib\rconn.c	/^    uint8_t dscp;$/;"	m	struct:rconn	file:
dscp	.\lib\vswitch-idl.h	/^	int64_t *dscp;$/;"	m	struct:ovsrec_queue
dscp	.\ofproto\connmgr.c	/^    uint8_t dscp;               \/* DSCP Value for controller connection *\/$/;"	m	struct:ofservice	file:
dscp	.\ofproto\ofproto-dpif-xlate.c	/^    uint8_t dscp;               \/* DSCP bits to mark outgoing traffic with. *\/$/;"	m	struct:skb_priority_to_dscp	file:
dscp	.\ofproto\ofproto.h	/^    uint8_t dscp;               \/* DSCP bits (e.g. [0, 63]). *\/$/;"	m	struct:ofproto_port_queue
dscp	.\ofproto\ofproto.h	/^    uint8_t dscp;               \/* DSCP value for controller connection. *\/$/;"	m	struct:ofproto_controller
dscp	.\ovsdb\jsonrpc-server.c	/^    uint8_t dscp;$/;"	m	struct:ovsdb_jsonrpc_remote	file:
dscp	.\ovsdb\jsonrpc-server.h	/^    int dscp;                   \/* Dscp value for manager connections *\/$/;"	m	struct:ovsdb_jsonrpc_options
dscp_from_skb_priority	.\ofproto\ofproto-dpif-xlate.c	/^dscp_from_skb_priority(const struct xport *xport, uint32_t skb_priority,$/;"	f	file:
dsi	.\lib\sflow_api.h	/^    SFLDataSource_instance dsi;$/;"	m	struct:_SFLPoller
dsi	.\lib\sflow_api.h	/^    SFLDataSource_instance dsi;$/;"	m	struct:_SFLSampler
dsi	.\ofproto\ofproto-dpif-sflow.c	/^    SFLDataSource_instance dsi; \/* sFlow library's notion of port number. *\/$/;"	m	struct:dpif_sflow_port	file:
dst	.\datapath\flow.h	/^				__be32 dst;	\/* IP destination address. *\/$/;"	m	struct:sw_flow_key::__anon5::__anon6::__anon7
dst	.\datapath\flow.h	/^				struct in6_addr dst;	\/* IPv6 destination address. *\/$/;"	m	struct:sw_flow_key::__anon5::__anon9::__anon10	typeref:struct:sw_flow_key::__anon5::__anon9::__anon10::in6_addr
dst	.\datapath\flow.h	/^		__be16 dst;		\/* TCP\/UDP\/SCTP destination port. *\/$/;"	m	struct:sw_flow_key::__anon4
dst	.\datapath\flow.h	/^		u8     dst[ETH_ALEN];	\/* Ethernet destination address. *\/$/;"	m	struct:sw_flow_key::__anon2
dst	.\datapath\linux\compat\include\net\flow_keys.h	/^	__be32 dst;$/;"	m	struct:flow_keys
dst	.\include\openflow\nicira-ext.h	/^    ovs_be32 dst;                   \/* Destination register. *\/$/;"	m	struct:nx_action_reg_load
dst	.\include\openflow\nicira-ext.h	/^    ovs_be32 dst;                   \/* Destination register. *\/$/;"	m	struct:nx_action_reg_move
dst	.\include\openflow\nicira-ext.h	/^    ovs_be32 dst;               \/* Destination. *\/$/;"	m	struct:nx_action_bundle
dst	.\include\openflow\nicira-ext.h	/^    ovs_be32 dst;               \/* Destination. *\/$/;"	m	struct:nx_action_multipath
dst	.\include\openflow\openflow-1.2.h	/^    ovs_be32 dst;                   \/* OXM TLV header *\/$/;"	m	struct:ofp12_action_set_field
dst	.\lib\ofp-actions.h	/^    struct mf_subfield dst;   \/* NX_LEARN_DST_MATCH, NX_LEARN_DST_LOAD only. *\/$/;"	m	struct:ofpact_learn_spec	typeref:struct:ofpact_learn_spec::mf_subfield
dst	.\lib\ofp-actions.h	/^    struct mf_subfield dst;$/;"	m	struct:ofpact_bundle	typeref:struct:ofpact_bundle::mf_subfield
dst	.\lib\ofp-actions.h	/^    struct mf_subfield dst;$/;"	m	struct:ofpact_multipath	typeref:struct:ofpact_multipath::mf_subfield
dst	.\lib\ofp-actions.h	/^    struct mf_subfield dst;$/;"	m	struct:ofpact_reg_load	typeref:struct:ofpact_reg_load::mf_subfield
dst	.\lib\ofp-actions.h	/^    struct mf_subfield dst;$/;"	m	struct:ofpact_reg_move	typeref:struct:ofpact_reg_move::mf_subfield
dst	.\lib\ovsdb-idl.c	/^    struct ovsdb_idl_row *dst;  \/* Destination row. *\/$/;"	m	struct:ovsdb_idl_arc	typeref:struct:ovsdb_idl_arc::ovsdb_idl_row	file:
dst	.\lib\sflow.h	/^    SFLAddress dst;    \/* Destination address *\/$/;"	m	struct:_SFLExtended_nat
dst_addr	.\lib\netflow.h	/^    ovs_be32 dst_addr;             \/* Destination IP address. *\/$/;"	m	struct:netflow_v5_record
dst_arcs	.\lib\ovsdb-idl-provider.h	/^    struct list dst_arcs;       \/* Backward arcs (ovsdb_idl_arc.dst_node). *\/$/;"	m	struct:ovsdb_idl_row	typeref:struct:ovsdb_idl_row::list
dst_as	.\lib\netflow.h	/^    ovs_be16 dst_as;               \/* Destination AS ID.  Set to 0. *\/$/;"	m	struct:netflow_v5_record
dst_as_path	.\lib\sflow.h	/^    SFLExtended_as_path_segment *dst_as_path; \/* list of seqs or sets *\/$/;"	m	struct:_SFLExtended_gateway
dst_as_path_segments	.\lib\sflow.h	/^    u_int32_t dst_as_path_segments;           \/* number of segments in path *\/$/;"	m	struct:_SFLExtended_gateway
dst_charset	.\lib\sflow.h	/^    u_int32_t dst_charset;$/;"	m	struct:_SFLExtended_user
dst_get_neighbour_noref	.\datapath\linux\compat\include\net\dst.h	10;"	d
dst_ip	.\lib\sflow.h	/^    SFLIPv4   dst_ip;      \/* Destination IP Address *\/$/;"	m	struct:_SFLSampled_ipv4
dst_ip	.\lib\sflow.h	/^    SFLIPv6   dst_ip;       \/* Destination IP Address *\/$/;"	m	struct:_SFLSampled_ipv6
dst_ip	.\lib\vtep-idl.h	/^	char *dst_ip;	\/* Always nonnull. *\/$/;"	m	struct:vteprec_physical_locator
dst_mac	.\lib\sflow.h	/^    u_int8_t dst_mac[8];$/;"	m	struct:_SFLSampled_ethernet
dst_mask	.\lib\netflow.h	/^    uint8_t  dst_mask;             \/* Destination mask bits.  Set to 0. *\/$/;"	m	struct:netflow_v5_record
dst_mask	.\lib\sflow.h	/^    u_int32_t dst_mask;               \/* Destination address prefix mask bits *\/$/;"	m	struct:_SFLExtended_router
dst_mirrors	.\ofproto\ofproto-dpif-mirror.c	/^    mirror_mask_t dst_mirrors;  \/* Mirrors triggered when packet sent. *\/$/;"	m	struct:mbundle	file:
dst_node	.\lib\ovsdb-idl.c	/^    struct list dst_node;       \/* In dst->dst_arcs list. *\/$/;"	m	struct:ovsdb_idl_arc	typeref:struct:ovsdb_idl_arc::list	file:
dst_node	.\ovsdb\row.h	/^    struct list dst_node;       \/* In destination row's dst_refs list. *\/$/;"	m	struct:ovsdb_weak_ref	typeref:struct:ovsdb_weak_ref::list
dst_ofs	.\include\openflow\nicira-ext.h	/^    ovs_be16 dst_ofs;               \/* Starting bit offset in destination. *\/$/;"	m	struct:nx_action_reg_move
dst_port	.\datapath\vport-lisp.c	/^	__be16 dst_port;$/;"	m	struct:lisp_port	file:
dst_port	.\lib\netdev.h	/^    ovs_be16 dst_port;$/;"	m	struct:netdev_tunnel_config
dst_port	.\lib\netflow.h	/^    ovs_be16 dst_port;$/;"	m	struct:netflow_v5_record
dst_port	.\lib\sflow.h	/^    u_int32_t dst_port;     \/* TCP\/UDP destination port number or equivalent *\/$/;"	m	struct:_SFLSampled_ipv6
dst_port	.\lib\sflow.h	/^    u_int32_t dst_port;    \/* TCP\/UDP destination port number or equivalent *\/$/;"	m	struct:_SFLSampled_ipv4
dst_priority	.\lib\sflow.h	/^    u_int32_t dst_priority;   \/* The 802.1p priority *\/$/;"	m	struct:_SFLExtended_switch
dst_refs	.\ovsdb\row.h	/^    struct list dst_refs;       \/* Weak references to this row. *\/$/;"	m	struct:ovsdb_row	typeref:struct:ovsdb_row::list
dst_type	.\lib\ofp-actions.h	/^    int dst_type;             \/* One of NX_LEARN_DST_*. *\/$/;"	m	struct:ofpact_learn_spec
dst_user	.\lib\sflow.h	/^    SFLString dst_user;$/;"	m	struct:_SFLExtended_user
dst_vlan	.\lib\sflow.h	/^    u_int32_t dst_vlan;       \/* The 802.1Q VLAN id of outgoing frame *\/$/;"	m	struct:_SFLExtended_switch
dsts	.\ofproto\ofproto-dpif-mirror.c	/^    struct hmapx dsts;          \/* Contains "struct mbundle*"s. *\/$/;"	m	struct:mirror	typeref:struct:mirror::hmapx	file:
dsts	.\ofproto\ofproto.h	/^    void **dsts;                \/* A set of registered ofbundle handles. *\/$/;"	m	struct:ofproto_mirror_settings
dummy	.\lib\ovsdb-idl.c	/^    struct uuid dummy;          \/* Dummy UUID used locally. *\/$/;"	m	struct:ovsdb_idl_txn_insert	typeref:struct:ovsdb_idl_txn_insert::uuid	file:
dummy_class	.\lib\netdev-dummy.c	/^static const struct netdev_class dummy_class = {$/;"	v	typeref:struct:netdev_class	file:
dummy_enable	.\lib\dummy.c	/^dummy_enable(bool override)$/;"	f
dummy_list_mutex	.\lib\netdev-dummy.c	/^static struct list dummy_list OVS_GUARDED_BY(dummy_list_mutex)$/;"	v	typeref:struct:OVS_GUARDED_BY	file:
dummy_list_mutex	.\lib\netdev-dummy.c	/^static struct ovs_mutex dummy_list_mutex = OVS_MUTEX_INITIALIZER;$/;"	v	typeref:struct:ovs_mutex	file:
dummy_packet_conn	.\lib\netdev-dummy.c	/^struct dummy_packet_conn {$/;"	s	file:
dummy_packet_conn_close	.\lib\netdev-dummy.c	/^dummy_packet_conn_close(struct dummy_packet_conn *conn)$/;"	f	file:
dummy_packet_conn_get_config	.\lib\netdev-dummy.c	/^dummy_packet_conn_get_config(struct dummy_packet_conn *conn, struct smap *args)$/;"	f	file:
dummy_packet_conn_init	.\lib\netdev-dummy.c	/^dummy_packet_conn_init(struct dummy_packet_conn *conn)$/;"	f	file:
dummy_packet_conn_send	.\lib\netdev-dummy.c	/^dummy_packet_conn_send(struct dummy_packet_conn *conn,$/;"	f	file:
dummy_packet_conn_set_config	.\lib\netdev-dummy.c	/^dummy_packet_conn_set_config(struct dummy_packet_conn *conn,$/;"	f	file:
dummy_packet_conn_type	.\lib\netdev-dummy.c	/^enum dummy_packet_conn_type {$/;"	g	file:
dummy_packet_conn_wait	.\lib\netdev-dummy.c	/^dummy_packet_conn_wait(struct dummy_packet_conn *conn)$/;"	f	file:
dummy_packet_pconn	.\lib\netdev-dummy.c	/^struct dummy_packet_pconn {$/;"	s	file:
dummy_packet_rconn	.\lib\netdev-dummy.c	/^struct dummy_packet_rconn {$/;"	s	file:
dummy_packet_stream	.\lib\netdev-dummy.c	/^struct dummy_packet_stream {$/;"	s	file:
dummy_packet_stream_close	.\lib\netdev-dummy.c	/^dummy_packet_stream_close(struct dummy_packet_stream *s)$/;"	f	file:
dummy_packet_stream_create	.\lib\netdev-dummy.c	/^dummy_packet_stream_create(struct stream *stream)$/;"	f	file:
dummy_packet_stream_init	.\lib\netdev-dummy.c	/^dummy_packet_stream_init(struct dummy_packet_stream *s, struct stream *stream)$/;"	f	file:
dummy_packet_stream_run	.\lib\netdev-dummy.c	/^dummy_packet_stream_run(struct netdev_dummy *dev, struct dummy_packet_stream *s)$/;"	f	file:
dummy_packet_stream_send	.\lib\netdev-dummy.c	/^dummy_packet_stream_send(struct dummy_packet_stream *s, const void *buffer, size_t size)$/;"	f	file:
dummy_packet_stream_wait	.\lib\netdev-dummy.c	/^dummy_packet_stream_wait(struct dummy_packet_stream *s)$/;"	f	file:
dump	.\lib\dpif-linux.c	/^    struct nl_dump dump;$/;"	m	struct:dpif_linux_flow_iter	typeref:struct:dpif_linux_flow_iter::nl_dump	file:
dump	.\lib\dpif-linux.c	/^    struct nl_dump dump;$/;"	m	struct:dpif_linux_port_state	typeref:struct:dpif_linux_port_state::nl_dump	file:
dump	.\lib\netdev-linux.c	/^    struct nl_dump dump;$/;"	m	struct:queue_dump_state	typeref:struct:queue_dump_state::nl_dump	file:
dump	.\ofproto\ofproto-dpif-upcall.c	/^    struct dpif_flow_dump dump;        \/* DPIF flow dump state. *\/$/;"	m	struct:udpif	typeref:struct:udpif::dpif_flow_dump	file:
dump	.\tests\test-stp.c	/^dump(struct test_case *tc)$/;"	f	file:
dump_bridge_tree	.\tests\test-stp.c	/^dump_bridge_tree(struct test_case *tc, struct bridge *b, int level)$/;"	f	file:
dump_duration	.\ofproto\ofproto-dpif-upcall.c	/^    long long int dump_duration;       \/* Duration of the last flow dump. *\/$/;"	m	struct:udpif	file:
dump_lan_tree	.\tests\test-stp.c	/^dump_lan_tree(struct test_case *tc, struct lan *lan, int level)$/;"	f	file:
dump_op	.\ofproto\ofproto-dpif-upcall.c	/^struct dump_op {$/;"	s	file:
dump_op_init	.\ofproto\ofproto-dpif-upcall.c	/^dump_op_init(struct dump_op *op, const struct nlattr *key, size_t key_len,$/;"	f	file:
dump_queue_stats	.\lib\netdev-provider.h	/^    int (*dump_queue_stats)(const struct netdev *netdev,$/;"	m	struct:netdev_class
dump_seq	.\ofproto\ofproto-dpif-upcall.c	/^    struct seq *dump_seq;              \/* Increments each dump iteration. *\/$/;"	m	struct:udpif	typeref:struct:udpif::seq	file:
dump_seq	.\ofproto\ofproto-dpif.c	/^    uint64_t dump_seq; \/* Last read of udpif_dump_seq(). *\/$/;"	m	struct:ofproto_dpif	file:
dump_stats_transaction	.\utilities\ovs-ofctl.c	/^dump_stats_transaction(struct vconn *vconn, struct ofpbuf *request)$/;"	f	file:
dump_table	.\ovsdb\ovsdb-client.c	/^dump_table(const struct ovsdb_table_schema *ts, struct json_array *rows)$/;"	f	file:
dump_table_aux	.\ovsdb\ovsdb-client.c	/^struct dump_table_aux {$/;"	s	file:
dump_transaction	.\utilities\ovs-ofctl.c	/^dump_transaction(struct vconn *vconn, struct ofpbuf *request)$/;"	f	file:
dump_trivial_stats_transaction	.\utilities\ovs-ofctl.c	/^dump_trivial_stats_transaction(const char *vconn_name, enum ofpraw raw)$/;"	f	file:
dump_trivial_transaction	.\utilities\ovs-ofctl.c	/^dump_trivial_transaction(const char *vconn_name, enum ofpraw raw)$/;"	f	file:
dup_mirrors	.\ofproto\ofproto-dpif-mirror.c	/^    mirror_mask_t dup_mirrors;  \/* Bitmap of mirrors with the same output. *\/$/;"	m	struct:mirror	file:
duplex	.\lib\vswitch-idl.h	/^	char *duplex;$/;"	m	struct:ovsrec_interface
duplicate_index_row	.\ovsdb\transaction.c	/^duplicate_index_row(const struct ovsdb_column_set *index,$/;"	f	file:
duplicate_index_row__	.\ovsdb\transaction.c	/^duplicate_index_row__(const struct ovsdb_column_set *index,$/;"	f	file:
durable	.\ovsdb\execution.c	/^    bool durable;$/;"	m	struct:ovsdb_execution	file:
duration_nsec	.\include\openflow\nicira-ext.h	/^    ovs_be32 duration_nsec;   \/* Time flow has been alive in nanoseconds$/;"	m	struct:nx_flow_stats
duration_nsec	.\include\openflow\nicira-ext.h	/^    ovs_be32 duration_nsec;   \/* Time flow was alive in nanoseconds beyond$/;"	m	struct:nx_flow_removed
duration_nsec	.\include\openflow\openflow-1.0.h	/^    ovs_be32 duration_nsec;   \/* Time flow has been alive in nanoseconds$/;"	m	struct:ofp10_flow_stats
duration_nsec	.\include\openflow\openflow-1.0.h	/^    ovs_be32 duration_nsec;   \/* Time flow was alive in nanoseconds beyond$/;"	m	struct:ofp10_flow_removed
duration_nsec	.\include\openflow\openflow-1.1.h	/^    ovs_be32 duration_nsec;    \/* Time flow has been alive in nanoseconds beyond$/;"	m	struct:ofp11_flow_stats
duration_nsec	.\include\openflow\openflow-1.1.h	/^    ovs_be32 duration_nsec;   \/* Time flow was alive in nanoseconds beyond$/;"	m	struct:ofp11_flow_removed
duration_nsec	.\include\openflow\openflow-1.2.h	/^    ovs_be32 duration_nsec;   \/* Time flow was alive in nanoseconds beyond$/;"	m	struct:ofp12_flow_removed
duration_nsec	.\include\openflow\openflow-1.3.h	/^    ovs_be32  duration_nsec;     \/* Time meter has been alive in nanoseconds$/;"	m	struct:ofp13_action_self_learning::ofp13_meter_stats
duration_nsec	.\include\openflow\openflow-1.3.h	/^    ovs_be32 duration_nsec;   \/* Time group has been alive in nanoseconds$/;"	m	struct:ofp13_action_self_learning::ofp13_group_stats
duration_nsec	.\include\openflow\openflow-1.3.h	/^    ovs_be32 duration_nsec;   \/* Time port has been alive in nanoseconds$/;"	m	struct:ofp13_action_self_learning::ofp13_port_stats
duration_nsec	.\include\openflow\openflow-1.3.h	/^    ovs_be32 duration_nsec;   \/* Time queue has been alive in nanoseconds$/;"	m	struct:ofp13_action_self_learning::ofp13_queue_stats
duration_nsec	.\include\openflow\openflow-1.4.h	/^    ovs_be32 duration_nsec;  \/* Time port has been alive in nanoseconds beyond$/;"	m	struct:ofp14_port_stats
duration_nsec	.\lib\ofp-util.h	/^    uint32_t duration_nsec;$/;"	m	struct:ofputil_flow_removed
duration_nsec	.\lib\ofp-util.h	/^    uint32_t duration_nsec;$/;"	m	struct:ofputil_flow_stats
duration_nsec	.\lib\ofp-util.h	/^    uint32_t duration_nsec;$/;"	m	struct:ofputil_group_stats
duration_nsec	.\lib\ofp-util.h	/^    uint32_t duration_nsec;$/;"	m	struct:ofputil_meter_stats
duration_nsec	.\lib\ofp-util.h	/^    uint32_t duration_nsec;$/;"	m	struct:ofputil_port_stats
duration_nsec	.\lib\ofp-util.h	/^    uint32_t duration_nsec;$/;"	m	struct:ofputil_queue_stats
duration_sec	.\include\openflow\nicira-ext.h	/^    ovs_be32 duration_sec;    \/* Time flow has been alive in seconds. *\/$/;"	m	struct:nx_flow_stats
duration_sec	.\include\openflow\nicira-ext.h	/^    ovs_be32 duration_sec;    \/* Time flow was alive in seconds. *\/$/;"	m	struct:nx_flow_removed
duration_sec	.\include\openflow\openflow-1.0.h	/^    ovs_be32 duration_sec;    \/* Time flow has been alive in seconds. *\/$/;"	m	struct:ofp10_flow_stats
duration_sec	.\include\openflow\openflow-1.0.h	/^    ovs_be32 duration_sec;    \/* Time flow was alive in seconds. *\/$/;"	m	struct:ofp10_flow_removed
duration_sec	.\include\openflow\openflow-1.1.h	/^    ovs_be32 duration_sec;     \/* Time flow has been alive in seconds. *\/$/;"	m	struct:ofp11_flow_stats
duration_sec	.\include\openflow\openflow-1.1.h	/^    ovs_be32 duration_sec;    \/* Time flow was alive in seconds. *\/$/;"	m	struct:ofp11_flow_removed
duration_sec	.\include\openflow\openflow-1.2.h	/^    ovs_be32 duration_sec;    \/* Time flow was alive in seconds. *\/$/;"	m	struct:ofp12_flow_removed
duration_sec	.\include\openflow\openflow-1.3.h	/^    ovs_be32  duration_sec;      \/* Time meter has been alive in seconds. *\/$/;"	m	struct:ofp13_action_self_learning::ofp13_meter_stats
duration_sec	.\include\openflow\openflow-1.3.h	/^    ovs_be32 duration_sec;    \/* Time group has been alive in seconds. *\/$/;"	m	struct:ofp13_action_self_learning::ofp13_group_stats
duration_sec	.\include\openflow\openflow-1.3.h	/^    ovs_be32 duration_sec;    \/* Time port has been alive in seconds. *\/$/;"	m	struct:ofp13_action_self_learning::ofp13_port_stats
duration_sec	.\include\openflow\openflow-1.3.h	/^    ovs_be32 duration_sec;    \/* Time queue has been alive in seconds. *\/$/;"	m	struct:ofp13_action_self_learning::ofp13_queue_stats
duration_sec	.\include\openflow\openflow-1.4.h	/^    ovs_be32 duration_sec;   \/* Time port has been alive in seconds. *\/$/;"	m	struct:ofp14_port_stats
duration_sec	.\lib\ofp-util.h	/^    uint32_t duration_sec;      \/* UINT32_MAX if unknown. *\/$/;"	m	struct:ofputil_group_stats
duration_sec	.\lib\ofp-util.h	/^    uint32_t duration_sec;      \/* UINT32_MAX if unknown. *\/$/;"	m	struct:ofputil_port_stats
duration_sec	.\lib\ofp-util.h	/^    uint32_t duration_sec;$/;"	m	struct:ofputil_flow_removed
duration_sec	.\lib\ofp-util.h	/^    uint32_t duration_sec;$/;"	m	struct:ofputil_flow_stats
duration_sec	.\lib\ofp-util.h	/^    uint32_t duration_sec;$/;"	m	struct:ofputil_meter_stats
duration_sec	.\lib\ofp-util.h	/^    uint32_t duration_sec;$/;"	m	struct:ofputil_queue_stats
ea	.\vswitchd\bridge.c	/^    uint8_t ea[ETH_ADDR_LEN];   \/* Bridge Ethernet Address. *\/$/;"	m	struct:bridge	file:
echo	.\lib\packets.h	/^        } echo;$/;"	m	union:icmp_header::__anon87	typeref:struct:icmp_header::__anon87::__anon88
ecn	.\lib\ofp-actions.h	/^    uint8_t ecn;               \/* ECN in low 2 bits, rest ignored. *\/$/;"	m	struct:ofpact_ecn
edges	.\lib\classifier.c	/^    struct trie_node *edges[2]; \/* Both NULL if leaf. *\/$/;"	m	struct:trie_node	typeref:struct:trie_node::trie_node	file:
egress_iface	.\lib\netdev-vport.c	/^    char egress_iface[IFNAMSIZ];$/;"	m	struct:netdev_vport	file:
elapsed_msec	.\ovsdb\execution.c	/^    long long int elapsed_msec;$/;"	m	struct:ovsdb_execution	file:
elapsed_remainder	.\lib\stp.c	/^    int elapsed_remainder;          \/* Left-over msecs from last stp_tick(). *\/$/;"	m	struct:stp	file:
element	.\tests\test-heap.c	/^struct element {$/;"	s	file:
element	.\tests\test-hindex.c	/^struct element {$/;"	s	file:
element	.\tests\test-hmap.c	/^struct element {$/;"	s	file:
element	.\tests\test-list.c	/^struct element {$/;"	s	file:
element_from_heap_node	.\tests\test-heap.c	/^element_from_heap_node(const struct heap_node *node)$/;"	f	file:
element_size	.\datapath\linux\compat\include\linux\flex_array.h	/^			int element_size;$/;"	m	struct:flex_array::__anon12::__anon13
elements	.\datapath\linux\compat\flex_array.c	/^	char elements[FLEX_ARRAY_PART_SIZE];$/;"	m	struct:flex_array_part	file:
elements	.\lib\sflow.h	/^    SFLCounters_sample_element *elements;$/;"	m	struct:_SFLCounters_sample
elements	.\lib\sflow.h	/^    SFLCounters_sample_element *elements;$/;"	m	struct:_SFLCounters_sample_expanded
elements	.\lib\sflow.h	/^    SFLFlow_sample_element *elements;$/;"	m	struct:_SFLFlow_sample
elements	.\lib\sflow.h	/^    SFLFlow_sample_element *elements;$/;"	m	struct:_SFLFlow_sample_expanded
elements_fit_in_base	.\datapath\linux\compat\flex_array.c	/^static inline int elements_fit_in_base(struct flex_array *fa)$/;"	f	file:
elems	.\lib\json.h	/^    struct json **elems;$/;"	m	struct:json_array	typeref:struct:json_array::json
elems_per_part	.\datapath\linux\compat\include\linux\flex_array.h	/^			int elems_per_part;$/;"	m	struct:flex_array::__anon12::__anon13
emer	.\python\ovs\vlog.py	/^    def emer(self, message, **kwargs):$/;"	m	class:Vlog
emer_is_enabled	.\python\ovs\vlog.py	/^    def emer_is_enabled(self):$/;"	m	class:Vlog
empty	.\lib\packets.h	/^            ovs_be16 empty;$/;"	m	struct:icmp_header::__anon87::__anon89
enable	.\ofproto\ofproto.h	/^    bool enable;$/;"	m	struct:ofproto_port_stp_settings
enable	.\python\ovs\reconnect.py	/^    def enable(self, now):$/;"	m	class:Reconnect
enable_async_messages	.\lib\vswitch-idl.h	/^	bool *enable_async_messages;$/;"	m	struct:ovsrec_controller
enable_async_msgs	.\ofproto\connmgr.c	/^    bool enable_async_msgs;     \/* Initially enable async messages? *\/$/;"	m	struct:ofconn	file:
enable_async_msgs	.\ofproto\connmgr.c	/^    bool enable_async_msgs;     \/* Initially enable async messages? *\/$/;"	m	struct:ofservice	file:
enable_async_msgs	.\ofproto\ofproto.h	/^    bool enable_async_msgs;     \/* Initially enable asynchronous messages? *\/$/;"	m	struct:ofproto_controller
enable_lacp	.\vswitchd\bridge.c	/^enable_lacp(struct port *port, bool *activep)$/;"	f	file:
enable_megaflows	.\ofproto\ofproto-dpif-upcall.c	/^static atomic_bool enable_megaflows = ATOMIC_VAR_INIT(true);$/;"	v	file:
enable_recirc	.\ofproto\ofproto-dpif-xlate.c	/^    bool enable_recirc;$/;"	m	struct:xbridge	file:
enable_recirc	.\ofproto\ofproto-dpif.c	/^    bool enable_recirc;   \/* True if the datapath supports recirculation *\/$/;"	m	struct:dpif_backer	file:
enable_slave	.\ofproto\bond.c	/^enable_slave(struct unixctl_conn *conn, const char *argv[], bool enable)$/;"	f	file:
enable_system_stats	.\vswitchd\bridge.c	/^enable_system_stats(const struct ovsrec_open_vswitch *cfg)$/;"	f	file:
enabled	.\ofproto\bond.c	/^    bool enabled;               \/* May be chosen for flows? *\/$/;"	m	struct:bond_slave	file:
enabled	.\ofproto\ofproto.h	/^    bool enabled;               \/* If false, ignore other members. *\/$/;"	m	struct:ofproto_port_stp_stats
enabled	.\ofproto\ofproto.h	/^    bool enabled;               \/* If false, ignore other members. *\/$/;"	m	struct:ofproto_port_stp_status
enabled	.\ofproto\ofproto.h	/^    bool enabled;               \/* If false, ignore other members. *\/$/;"	m	struct:ofproto_stp_status
enabled	.\tests\test-bundle.c	/^    bool enabled;$/;"	m	struct:slave	file:
enabled	.\vswitchd\system-stats.c	/^static bool enabled;$/;"	v	file:
encapsulation_type	.\lib\vtep-idl.h	/^	char *encapsulation_type;	\/* Always nonnull. *\/$/;"	m	struct:vteprec_physical_locator
encode_action_bits	.\lib\ofp-util.c	/^encode_action_bits(enum ofputil_action_bitmap ofputil_actions,$/;"	f	file:
end	.\datapath\flow.h	/^	unsigned short int end;$/;"	m	struct:sw_flow_key_range
end	.\lib\classifier.c	/^    uint8_t end;$/;"	m	struct:range	file:
end	.\lib\flow.c	/^    uint32_t * const end;$/;"	m	struct:mf_ctx	file:
end_section	.\python\compat\argparse.py	/^    def end_section(self):$/;"	m	class:HelpFormatter
engine_id	.\lib\netflow.h	/^    uint8_t  engine_id;            \/* Engine id. *\/$/;"	m	struct:netflow_v5_header
engine_id	.\lib\vswitch-idl.h	/^	int64_t *engine_id;$/;"	m	struct:ovsrec_netflow
engine_id	.\ofproto\netflow.c	/^    uint8_t engine_id;            \/* Value of engine_id to use. *\/$/;"	m	struct:netflow	file:
engine_id	.\ofproto\netflow.h	/^    uint8_t engine_id;$/;"	m	struct:netflow_options
engine_type	.\lib\netflow.h	/^    uint8_t  engine_type;          \/* Engine type. *\/$/;"	m	struct:netflow_v5_header
engine_type	.\lib\vswitch-idl.h	/^	int64_t *engine_type;$/;"	m	struct:ovsrec_netflow
engine_type	.\ofproto\netflow.c	/^    uint8_t engine_type;          \/* Value of engine_type to use. *\/$/;"	m	struct:netflow	file:
engine_type	.\ofproto\netflow.h	/^    uint8_t engine_type;$/;"	m	struct:netflow_options
english_list_delimiter	.\lib\util.c	/^english_list_delimiter(size_t index, size_t total)$/;"	f
enqueue	.\lib\ofp-actions.c	/^    struct ofp10_action_enqueue enqueue;$/;"	m	union:ofp_action	typeref:struct:ofp_action::ofp10_action_enqueue	file:
enqueue_from_openflow10	.\lib\ofp-actions.c	/^enqueue_from_openflow10(const struct ofp10_action_enqueue *oae,$/;"	f	file:
entries	.\ofproto\bond.c	/^    struct list entries;        \/* 'struct bond_entry's assigned here. *\/$/;"	m	struct:bond_slave	typeref:struct:bond_slave::list	file:
entries	.\ofproto\ofproto-dpif-xlate.c	/^    struct ofpbuf entries;$/;"	m	struct:xlate_cache	typeref:struct:xlate_cache::ofpbuf	file:
entropy	.\lib\entropy.c	/^VLOG_DEFINE_THIS_MODULE(entropy);$/;"	v
enum_	.\lib\ovsdb-types.h	/^    struct ovsdb_datum *enum_;$/;"	m	struct:ovsdb_base_type	typeref:struct:ovsdb_base_type::ovsdb_datum
enumerate	.\lib\dpif-provider.h	/^    int (*enumerate)(struct sset *all_dps);$/;"	m	struct:dpif_class
enumerate_names	.\ofproto\ofproto-dpif.c	/^enumerate_names(const char *type, struct sset *names)$/;"	f	file:
enumerate_names	.\ofproto\ofproto-provider.h	/^    int (*enumerate_names)(const char *type, struct sset *names);$/;"	m	struct:ofproto_class
enumerate_types	.\ofproto\ofproto-dpif.c	/^enumerate_types(struct sset *types)$/;"	f	file:
enumerate_types	.\ofproto\ofproto-provider.h	/^    void (*enumerate_types)(struct sset *types);$/;"	m	struct:ofproto_class
env	.\tests\test-sflow.c	/^    jmp_buf env;$/;"	m	struct:sflow_xdr	file:
env	.\utilities\ovs-dev.py	/^def env():$/;"	f
epoll_events	.\lib\dpif-linux.c	/^    struct epoll_event *epoll_events;$/;"	m	struct:dpif_handler	typeref:struct:dpif_handler::epoll_event	file:
epoll_fd	.\lib\dpif-linux.c	/^    int epoll_fd;                 \/* epoll fd that includes channel socks. *\/$/;"	m	struct:dpif_handler	file:
equal	.\ovsdb\execution.c	/^    bool *equal;$/;"	m	struct:wait_auxdata	file:
equal_pathnames	.\vswitchd\bridge.c	/^equal_pathnames(const char *a, const char *b, size_t b_stoplen)$/;"	f	file:
err	.\python\ovs\vlog.py	/^    def err(self, message, **kwargs):$/;"	m	class:Vlog
err	.\tests\test-stp.c	/^err(const char *message, ...)$/;"	f	file:
err_handler	.\datapath\linux\compat\include\net\gre.h	/^	int (*err_handler)(struct sk_buff *skb, u32 info,$/;"	m	struct:gre_cisco_protocol
err_is_enabled	.\python\ovs\vlog.py	/^    def err_is_enabled(self):$/;"	m	class:Vlog
err_stats	.\datapath\vport.h	/^	struct vport_err_stats err_stats;$/;"	m	struct:vport	typeref:struct:vport::vport_err_stats
errline	.\tests\test-sflow.c	/^    int errline;$/;"	m	struct:sflow_xdr	file:
errno	.\python\ovs\daemon.py	/^import errno$/;"	i
errno	.\python\ovs\jsonrpc.py	/^import errno$/;"	i
errno	.\python\ovs\poller.py	/^import errno$/;"	i
errno	.\python\ovs\socket_util.py	/^import errno$/;"	i
errno	.\python\ovs\stream.py	/^import errno$/;"	i
errno	.\python\ovs\unixctl\client.py	/^import errno$/;"	i
errno	.\python\ovs\unixctl\server.py	/^import errno$/;"	i
errno	.\tests\test-jsonrpc.py	/^import errno$/;"	i
errno	.\tests\test-reconnect.py	/^import errno$/;"	i
errno_	.\lib\ovsdb-error.c	/^    int errno_;                 \/* Unix errno value, 0 if none. *\/$/;"	m	struct:ovsdb_error	file:
error	.\lib\dpif.c	/^    int error;$/;"	m	struct:dpif_execute_helper_aux	file:
error	.\lib\dpif.h	/^    int error;$/;"	m	struct:dpif_op
error	.\lib\dpif.h	/^    int error;$/;"	m	struct:dpif_port_dump
error	.\lib\json.c	/^    char *error;                \/* Error message, if any, null if none yet. *\/$/;"	m	struct:json_parser	file:
error	.\lib\jsonrpc.h	/^    struct json *error;         \/* Error reply only. *\/$/;"	m	struct:jsonrpc_msg	typeref:struct:jsonrpc_msg::json
error	.\lib\netdev.h	/^    int error;$/;"	m	struct:netdev_queue_dump
error	.\lib\netlink-protocol.h	/^        int error;$/;"	m	struct:nlmsgerr
error	.\lib\netlink-socket.h	/^    int error;                  \/* Positive errno value, 0 if no error. *\/$/;"	m	struct:nl_transaction
error	.\lib\ovsdb-idl.c	/^    char *error;$/;"	m	struct:ovsdb_idl_txn	file:
error	.\lib\ovsdb-parser.h	/^    struct ovsdb_error *error;  \/* Error signaled, if any. *\/$/;"	m	struct:ovsdb_parser	typeref:struct:ovsdb_parser::ovsdb_error
error	.\lib\stream-provider.h	/^    int error;$/;"	m	struct:stream
error	.\lib\vconn-provider.h	/^    int error;$/;"	m	struct:vconn
error	.\ofproto\ofproto.c	/^    enum ofperr error;                  \/* 0 if no error. *\/$/;"	m	struct:ofoperation	typeref:enum:ofoperation::ofperr	file:
error	.\ofproto\ofproto.h	/^    int error;$/;"	m	struct:ofproto_port_dump
error	.\ovsdb\execution.c	/^    struct ovsdb_error **error;$/;"	m	struct:mutate_row_cbdata	typeref:struct:mutate_row_cbdata::ovsdb_error	file:
error	.\ovsdb\log.c	/^    int error;$/;"	m	struct:ovsdb_log_read_cbdata	file:
error	.\python\compat\argparse.py	/^    def error(self, message):$/;"	m	class:ArgumentParser
error	.\python\ovs\db\data.py	/^from ovs.db import error$/;"	i
error	.\python\ovs\db\idl.py	/^from ovs.db import error$/;"	i
error	.\python\ovs\db\parser.py	/^from ovs.db import error$/;"	i
error	.\python\ovs\db\schema.py	/^from ovs.db import error$/;"	i
error	.\python\ovs\db\types.py	/^from ovs.db import error$/;"	i
error	.\python\ovs\jsonrpc.py	/^    def error(self, error):$/;"	m	class:Connection
error	.\python\ovs\ovsuuid.py	/^from ovs.db import error$/;"	i
error	.\tests\test-ovsdb.py	/^from ovs.db import error$/;"	i
errorFn	.\lib\sflow_api.h	/^    errorFn_t errorFn;$/;"	m	struct:_SFLAgent
errorFn_t	.\lib\sflow_api.h	/^typedef void (*errorFn_t)(void *magic,                \/* callback to log error message *\/$/;"	t
error_count	.\lib\stp.c	/^    int error_count;                \/* Number of bad BPDUs received. *\/$/;"	m	struct:stp_port	file:
error_count	.\ofproto\ofproto.h	/^    int error_count;            \/* Number of bad BPDUs received. *\/$/;"	m	struct:ofproto_port_stp_stats
error_from_string	.\tests\test-reconnect.c	/^error_from_string(const char *s)$/;"	f	file:
error_from_string	.\tests\test-reconnect.py	/^def error_from_string(s):$/;"	f
error_rl	.\lib\dpif-linux.c	/^static struct vlog_rate_limit error_rl = VLOG_RATE_LIMIT_INIT(9999, 5);$/;"	v	typeref:struct:vlog_rate_limit	file:
error_rl	.\lib\dpif.c	/^static struct vlog_rate_limit error_rl = VLOG_RATE_LIMIT_INIT(60, 5);$/;"	v	typeref:struct:vlog_rate_limit	file:
escape	.\xenserver\opt_xensource_libexec_InterfaceReconfigureVswitch.py	/^    def escape(match):$/;"	f	function:vsctl_escape
escapeCString	.\python\ovs\db\data.py	/^def escapeCString(src):$/;"	f
escapeCString	.\python\ovs\db\types.py	/^def escapeCString(src):$/;"	f
escapes	.\python\ovs\json.py	/^escapes = {ord('"'): u"\\\\\\"",$/;"	v
eth	.\datapath\flow.h	/^	} eth;$/;"	m	struct:sw_flow_key	typeref:struct:sw_flow_key::__anon2
eth_addr_bitand	.\lib\packets.c	/^eth_addr_bitand(const uint8_t src[ETH_ADDR_LEN],$/;"	f
eth_addr_ccm	.\lib\cfm.c	/^static const uint8_t eth_addr_ccm[6] = { 0x01, 0x80, 0xC2, 0x00, 0x00, 0x30 };$/;"	v	file:
eth_addr_ccm_x	.\lib\cfm.c	/^static const uint8_t eth_addr_ccm_x[6] = {$/;"	v	file:
eth_addr_compare_3way	.\lib\packets.h	/^static inline int eth_addr_compare_3way(const uint8_t a[ETH_ADDR_LEN],$/;"	f
eth_addr_equal_except	.\lib\packets.h	/^static inline bool eth_addr_equal_except(const uint8_t a[ETH_ADDR_LEN],$/;"	f
eth_addr_equals	.\lib\packets.h	/^static inline bool eth_addr_equals(const uint8_t a[ETH_ADDR_LEN],$/;"	f
eth_addr_from_string	.\lib\packets.c	/^eth_addr_from_string(const char *s, uint8_t ea[ETH_ADDR_LEN])$/;"	f
eth_addr_from_uint64	.\lib\packets.h	/^static inline void eth_addr_from_uint64(uint64_t x, uint8_t ea[ETH_ADDR_LEN])$/;"	f
eth_addr_is_broadcast	.\lib\packets.h	/^static inline bool eth_addr_is_broadcast(const uint8_t ea[6])$/;"	f
eth_addr_is_local	.\lib\packets.h	/^static inline bool eth_addr_is_local(const uint8_t ea[6])$/;"	f
eth_addr_is_multicast	.\lib\packets.h	/^static inline bool eth_addr_is_multicast(const uint8_t ea[6])$/;"	f
eth_addr_is_reserved	.\lib\packets.c	/^eth_addr_is_reserved(const uint8_t ea[ETH_ADDR_LEN])$/;"	f
eth_addr_is_zero	.\lib\packets.h	/^static inline bool eth_addr_is_zero(const uint8_t ea[6])$/;"	f
eth_addr_mark_random	.\lib\packets.h	/^static inline void eth_addr_mark_random(uint8_t ea[ETH_ADDR_LEN])$/;"	f
eth_addr_nicira_random	.\lib\packets.h	/^static inline void eth_addr_nicira_random(uint8_t ea[ETH_ADDR_LEN])$/;"	f
eth_addr_random	.\lib\packets.h	/^static inline void eth_addr_random(uint8_t ea[ETH_ADDR_LEN])$/;"	f
eth_addr_to_uint64	.\lib\packets.h	/^static inline uint64_t eth_addr_to_uint64(const uint8_t ea[ETH_ADDR_LEN])$/;"	f
eth_addr_vlan_to_uint64	.\lib\packets.h	/^static inline uint64_t eth_addr_vlan_to_uint64(const uint8_t ea[ETH_ADDR_LEN],$/;"	f
eth_compose	.\lib\packets.c	/^eth_compose(struct ofpbuf *b, const uint8_t eth_dst[ETH_ADDR_LEN],$/;"	f
eth_dst	.\include\linux\openvswitch.h	/^	__u8	 eth_dst[ETH_ALEN];$/;"	m	struct:ovs_key_ethernet
eth_format_masked	.\lib\packets.c	/^eth_format_masked(const uint8_t eth[ETH_ADDR_LEN],$/;"	f
eth_from_hex	.\lib\packets.c	/^eth_from_hex(const char *hex, struct ofpbuf **packetp)$/;"	f
eth_from_packet_or_flow	.\lib\netdev-dummy.c	/^eth_from_packet_or_flow(const char *s)$/;"	f	file:
eth_hw_addr_random	.\datapath\linux\compat\include\linux\etherdevice.h	/^static inline void eth_hw_addr_random(struct net_device *dev)$/;"	f
eth_len	.\lib\sflow.h	/^    u_int32_t eth_len;       \/* The length of the MAC packet excluding$/;"	m	struct:_SFLSampled_ethernet
eth_mac_addr	.\datapath\linux\compat\include\linux\etherdevice.h	/^static inline int eth_mac_addr(struct net_device *dev, void *p)$/;"	f
eth_mac_addr	.\datapath\linux\compat\include\linux\etherdevice.h	22;"	d
eth_mask_is_exact	.\lib\packets.h	/^static inline int eth_mask_is_exact(const uint8_t ea[ETH_ADDR_LEN])$/;"	f
eth_pop_vlan	.\lib\packets.c	/^eth_pop_vlan(struct ofpbuf *packet)$/;"	f
eth_push_vlan	.\lib\packets.c	/^eth_push_vlan(struct ofpbuf *packet, ovs_be16 tpid, ovs_be16 tci)$/;"	f
eth_src	.\include\linux\openvswitch.h	/^	__u8	 eth_src[ETH_ALEN];$/;"	m	struct:ovs_key_ethernet
eth_type	.\lib\sflow.h	/^    u_int32_t eth_type;$/;"	m	struct:_SFLSampled_ethernet
eth_type_mpls	.\lib\packets.h	/^static inline bool eth_type_mpls(ovs_be16 eth_type)$/;"	f
ether_addr_copy	.\datapath\linux\compat\include\linux\etherdevice.h	/^static inline void ether_addr_copy(u8 *dst, const u8 *src)$/;"	f
ether_addr_error	.\lib\netdev-linux.c	/^    int ether_addr_error;       \/* Cached error code from set\/get etheraddr. *\/$/;"	m	struct:netdev_linux	file:
etheraddr	.\lib\netdev-bsd.c	/^    uint8_t etheraddr[ETH_ADDR_LEN];$/;"	m	struct:netdev_bsd	file:
etheraddr	.\lib\netdev-linux.c	/^    uint8_t etheraddr[ETH_ADDR_LEN];$/;"	m	struct:netdev_linux	file:
etheraddr	.\lib\netdev-vport.c	/^    uint8_t etheraddr[ETH_ADDR_LEN];$/;"	m	struct:netdev_vport	file:
ethernet	.\lib\sflow.h	/^    SFLEthernet_counters ethernet;$/;"	m	union:_SFLCounters_type
ethernet	.\lib\sflow.h	/^    SFLSampled_ethernet ethernet;$/;"	m	union:_SFLFlow_type
ethertype	.\include\openflow\nicira-ext.h	/^    ovs_be16 ethertype;             \/* Ethertype *\/$/;"	m	struct:nx_action_pop_mpls
ethertype	.\include\openflow\nicira-ext.h	/^    ovs_be16 ethertype;             \/* Ethertype *\/$/;"	m	struct:nx_action_push_mpls
ethertype	.\include\openflow\openflow-1.1.h	/^    ovs_be16 ethertype;               \/* Ethertype *\/$/;"	m	struct:ofp11_action_pop_mpls
ethertype	.\include\openflow\openflow-1.1.h	/^    ovs_be16 ethertype;               \/* Ethertype *\/$/;"	m	struct:ofp11_action_push
ethertype	.\lib\ofp-actions.h	/^    ovs_be16 ethertype;$/;"	m	struct:ofpact_pop_mpls
ethertype	.\lib\ofp-actions.h	/^    ovs_be16 ethertype;$/;"	m	struct:ofpact_push_mpls
ethtool_settings	.\xenserver\opt_xensource_libexec_InterfaceReconfigure.py	/^def ethtool_settings(oc, defaults = {}):$/;"	f
evaluate_relop	.\utilities\ovs-vsctl.c	/^evaluate_relop(const struct ovsdb_datum *a, const struct ovsdb_datum *b,$/;"	f	file:
evaluate_relop	.\vtep\vtep-ctl.c	/^evaluate_relop(const struct ovsdb_datum *a, const struct ovsdb_datum *b,$/;"	f	file:
event	.\include\openflow\nicira-ext.h	/^    ovs_be16 event;             \/* NXFME_ABBREV. *\/$/;"	m	struct:nx_flow_update_abbrev
event	.\include\openflow\nicira-ext.h	/^    ovs_be16 event;             \/* One of NXFME_*. *\/$/;"	m	struct:nx_flow_update_full
event	.\include\openflow\nicira-ext.h	/^    ovs_be16 event;             \/* One of NXFME_*. *\/$/;"	m	struct:nx_flow_update_header
event	.\lib\ofp-util.h	/^    enum nx_flow_update_event event;$/;"	m	struct:ofputil_flow_update	typeref:enum:ofputil_flow_update::nx_flow_update_event
event_offset	.\lib\dpif-linux.c	/^    int event_offset;             \/* Offset into 'epoll_events'. *\/$/;"	m	struct:dpif_handler	file:
eventlet	.\python\ovs\poller.py	/^    import eventlet.patcher$/;"	i
eviction_fields	.\ofproto\ofproto-provider.h	/^    struct mf_subfield *eviction_fields;$/;"	m	struct:oftable	typeref:struct:oftable::mf_subfield
eviction_group	.\ofproto\ofproto.c	/^struct eviction_group {$/;"	s	file:
eviction_group_id_basis	.\ofproto\ofproto-provider.h	/^    uint32_t eviction_group_id_basis;$/;"	m	struct:oftable
eviction_group_priority	.\ofproto\ofproto.c	/^eviction_group_priority(size_t n_rules)$/;"	f	file:
eviction_group_timer	.\ofproto\ofproto-provider.h	/^    long long int eviction_group_timer; \/* For rate limited reheapification. *\/$/;"	m	struct:ofproto
eviction_groups_by_id	.\ofproto\ofproto-provider.h	/^    struct hmap eviction_groups_by_id;$/;"	m	struct:oftable	typeref:struct:oftable::hmap
eviction_groups_by_size	.\ofproto\ofproto-provider.h	/^    struct heap eviction_groups_by_size;$/;"	m	struct:oftable	typeref:struct:oftable::heap
example	.\tests\test-ovsdb.c	/^    struct ovsdb_row *example;$/;"	m	struct:do_query_distinct_class	typeref:struct:do_query_distinct_class::ovsdb_row	file:
exception	.\python\ovs\vlog.py	/^    def exception(self, message):$/;"	m	class:Vlog
exceptions	.\python\ovstest\rpcserver.py	/^import exceptions$/;"	i
exceptions	.\python\ovstest\util.py	/^import exceptions$/;"	i
exceptions	.\python\ovstest\vswitch.py	/^import exceptions$/;"	i
execute	.\lib\dpif-provider.h	/^    int (*execute)(struct dpif *dpif, struct dpif_execute *execute);$/;"	m	struct:dpif_class
execute	.\lib\dpif.h	/^        struct dpif_execute execute;$/;"	m	union:dpif_op::__anon45	typeref:struct:dpif_op::__anon45::dpif_execute
execute_ab	.\lib\bundle.c	/^execute_ab(const struct ofpact_bundle *bundle,$/;"	f	file:
execute_cancel	.\ovsdb\jsonrpc-server.c	/^execute_cancel(struct ovsdb_jsonrpc_session *s, struct jsonrpc_msg *request)$/;"	f	file:
execute_controller_action	.\ofproto\ofproto-dpif-xlate.c	/^execute_controller_action(struct xlate_ctx *ctx, int len,$/;"	f	file:
execute_hash	.\datapath\actions.c	/^static void execute_hash(struct sk_buff *skb, const struct nlattr *attr)$/;"	f	file:
execute_hrw	.\lib\bundle.c	/^execute_hrw(const struct ofpact_bundle *bundle,$/;"	f	file:
execute_recirc	.\datapath\actions.c	/^static int execute_recirc(struct datapath *dp, struct sk_buff *skb,$/;"	f	file:
execute_set_action	.\datapath\actions.c	/^static int execute_set_action(struct sk_buff *skb,$/;"	f	file:
execute_transaction	.\ovsdb\jsonrpc-server.c	/^execute_transaction(struct ovsdb_jsonrpc_session *s, struct ovsdb *db,$/;"	f	file:
exit	.\datapath\linux\compat\include\net\net_namespace.h	/^	void (*exit)(struct net *net);$/;"	m	struct:rpl_pernet_operations
exit	.\ofproto\ofproto-dpif-xlate.c	/^    bool exit;                  \/* No further actions should be processed. *\/$/;"	m	struct:xlate_ctx	file:
exit	.\python\compat\argparse.py	/^    def exit(self, status=0, message=None):$/;"	m	class:ArgumentParser
exit_latch	.\lib\dpif-netdev.c	/^    struct latch exit_latch;$/;"	m	struct:dp_netdev	typeref:struct:dp_netdev::latch	file:
exit_latch	.\ofproto\ofproto-dpif-upcall.c	/^    struct latch exit_latch;           \/* Tells child threads to exit. *\/$/;"	m	struct:udpif	typeref:struct:udpif::latch	file:
exited	.\lib\process.c	/^    bool exited;$/;"	m	struct:process	file:
exiting	.\tests\test-unixctl.py	/^exiting = False$/;"	v
exp_type	.\include\openflow\openflow-1.2.h	/^    ovs_be32 exp_type;        \/* Experimenter defined. *\/$/;"	m	struct:ofp12_experimenter_stats_header
exp_type	.\include\openflow\openflow-1.3.h	/^    ovs_be32    exp_type;     \/* Experimenter defined. *\/$/;"	m	struct:ofp13_action_self_learning::ofp13_table_feature_prop_experimenter
exp_type	.\include\openflow\openflow-1.4.h	/^    ovs_be32        exp_type;      \/* Experimenter defined. *\/$/;"	m	struct:ofp14_async_config_prop_experimenter
exp_type	.\include\openflow\openflow-1.4.h	/^    ovs_be32        exp_type;     \/* Experimenter defined. *\/$/;"	m	struct:ofp14_role_prop_experimenter
expected	.\ovsdb\execution.c	/^    struct ovsdb_row_hash *expected;$/;"	m	struct:wait_auxdata	typeref:struct:wait_auxdata::ovsdb_row_hash	file:
experimenter	.\include\openflow\openflow-1.1.h	/^    ovs_be32 experimenter;      \/* Experimenter ID which takes the same form$/;"	m	struct:ofp11_instruction_experimenter
experimenter	.\include\openflow\openflow-1.2.h	/^    ovs_be32 experimenter;    \/* Experimenter ID which takes the same form$/;"	m	struct:ofp12_experimenter_stats_header
experimenter	.\include\openflow\openflow-1.2.h	/^    ovs_be32 experimenter; \/* Experimenter ID which takes the same$/;"	m	struct:ofp12_oxm_experimenter_header
experimenter	.\include\openflow\openflow-1.3.h	/^    ovs_be32    experimenter; \/* Experimenter ID which takes the same form as$/;"	m	struct:ofp13_action_self_learning::ofp13_meter_band_experimenter
experimenter	.\include\openflow\openflow-1.3.h	/^    ovs_be32    experimenter; \/* Experimenter ID which takes the same form$/;"	m	struct:ofp13_action_self_learning::ofp13_table_feature_prop_experimenter
experimenter	.\include\openflow\openflow-1.4.h	/^    ovs_be32        experimenter;  \/* Experimenter ID which takes the same$/;"	m	struct:ofp14_async_config_prop_experimenter
experimenter	.\include\openflow\openflow-1.4.h	/^    ovs_be32        experimenter; \/* Experimenter ID which takes the same$/;"	m	struct:ofp14_role_prop_experimenter
expires	.\lib\mac-learning.h	/^    time_t expires;             \/* Expiration time. *\/$/;"	m	struct:mac_entry
exporter	.\ofproto\ofproto-dpif-ipfix.c	/^    struct dpif_ipfix_exporter exporter;$/;"	m	struct:dpif_ipfix_bridge_exporter	typeref:struct:dpif_ipfix_bridge_exporter::dpif_ipfix_exporter	file:
exporter	.\ofproto\ofproto-dpif-ipfix.c	/^    struct dpif_ipfix_exporter exporter;$/;"	m	struct:dpif_ipfix_flow_exporter	typeref:struct:dpif_ipfix_flow_exporter::dpif_ipfix_exporter	file:
exporter	.\ofproto\ofproto-dpif-ipfix.c	/^    struct dpif_ipfix_flow_exporter exporter;$/;"	m	struct:dpif_ipfix_flow_exporter_map_node	typeref:struct:dpif_ipfix_flow_exporter_map_node::dpif_ipfix_flow_exporter	file:
extended	.\lib\cfm.c	/^    atomic_bool extended;      \/* Extended mode. *\/$/;"	m	struct:cfm	file:
extended	.\lib\cfm.h	/^    bool extended;              \/* Run in extended mode. *\/$/;"	m	struct:cfm_settings
external_ids	.\lib\vswitch-idl.h	/^	struct smap external_ids;$/;"	m	struct:ovsrec_bridge	typeref:struct:ovsrec_bridge::smap
external_ids	.\lib\vswitch-idl.h	/^	struct smap external_ids;$/;"	m	struct:ovsrec_controller	typeref:struct:ovsrec_controller::smap
external_ids	.\lib\vswitch-idl.h	/^	struct smap external_ids;$/;"	m	struct:ovsrec_flow_sample_collector_set	typeref:struct:ovsrec_flow_sample_collector_set::smap
external_ids	.\lib\vswitch-idl.h	/^	struct smap external_ids;$/;"	m	struct:ovsrec_flow_table	typeref:struct:ovsrec_flow_table::smap
external_ids	.\lib\vswitch-idl.h	/^	struct smap external_ids;$/;"	m	struct:ovsrec_interface	typeref:struct:ovsrec_interface::smap
external_ids	.\lib\vswitch-idl.h	/^	struct smap external_ids;$/;"	m	struct:ovsrec_ipfix	typeref:struct:ovsrec_ipfix::smap
external_ids	.\lib\vswitch-idl.h	/^	struct smap external_ids;$/;"	m	struct:ovsrec_manager	typeref:struct:ovsrec_manager::smap
external_ids	.\lib\vswitch-idl.h	/^	struct smap external_ids;$/;"	m	struct:ovsrec_mirror	typeref:struct:ovsrec_mirror::smap
external_ids	.\lib\vswitch-idl.h	/^	struct smap external_ids;$/;"	m	struct:ovsrec_netflow	typeref:struct:ovsrec_netflow::smap
external_ids	.\lib\vswitch-idl.h	/^	struct smap external_ids;$/;"	m	struct:ovsrec_open_vswitch	typeref:struct:ovsrec_open_vswitch::smap
external_ids	.\lib\vswitch-idl.h	/^	struct smap external_ids;$/;"	m	struct:ovsrec_port	typeref:struct:ovsrec_port::smap
external_ids	.\lib\vswitch-idl.h	/^	struct smap external_ids;$/;"	m	struct:ovsrec_qos	typeref:struct:ovsrec_qos::smap
external_ids	.\lib\vswitch-idl.h	/^	struct smap external_ids;$/;"	m	struct:ovsrec_queue	typeref:struct:ovsrec_queue::smap
external_ids	.\lib\vswitch-idl.h	/^	struct smap external_ids;$/;"	m	struct:ovsrec_sflow	typeref:struct:ovsrec_sflow::smap
external_ids	.\lib\vswitch-idl.h	/^	struct smap external_ids;$/;"	m	struct:ovsrec_ssl	typeref:struct:ovsrec_ssl::smap
extra_in_band_remotes	.\ofproto\connmgr.c	/^    struct sockaddr_in *extra_in_band_remotes;$/;"	m	struct:connmgr	typeref:struct:connmgr::sockaddr_in	file:
extra_multiple	.\lib\ofp-msgs.c	/^    unsigned int extra_multiple;$/;"	m	struct:raw_info	file:
extra_name	.\lib\meta-flow.h	/^    const char *extra_name;     \/* Alternate name, e.g. "dl_type", or NULL. *\/$/;"	m	struct:mf_field
f1	.\lib\sha1.c	/^f1(uint32_t x, uint32_t y, uint32_t z)$/;"	f	file:
f2	.\lib\sha1.c	/^f2(uint32_t x, uint32_t y, uint32_t z)$/;"	f	file:
f3	.\lib\sha1.c	/^f3(uint32_t x, uint32_t y, uint32_t z)$/;"	f	file:
f4	.\lib\sha1.c	/^f4(uint32_t x, uint32_t y, uint32_t z)$/;"	f	file:
fa_element_to_part_nr	.\datapath\linux\compat\flex_array.c	/^static int fa_element_to_part_nr(struct flex_array *fa,$/;"	f	file:
facilities	.\lib\vlog.c	/^static struct facility facilities[VLF_N_FACILITIES] = {$/;"	v	typeref:struct:facility	file:
facility	.\lib\vlog.c	/^struct facility {$/;"	s	file:
factorial	.\tests\test-classifier.c	/^factorial(int n_items)$/;"	f	file:
factorial	.\tests\test-heap.c	/^factorial(int n_items)$/;"	f	file:
fail_mode	.\lib\vswitch-idl.h	/^	char *fail_mode;$/;"	m	struct:ovsrec_bridge
fail_mode	.\ofproto\connmgr.c	/^    enum ofproto_fail_mode fail_mode;$/;"	m	struct:connmgr	typeref:enum:connmgr::ofproto_fail_mode	file:
fail_open	.\ofproto\connmgr.c	/^    struct fail_open *fail_open;$/;"	m	struct:connmgr	typeref:struct:connmgr::fail_open	file:
fail_open	.\ofproto\fail-open.c	/^VLOG_DEFINE_THIS_MODULE(fail_open);$/;"	v
fail_open	.\ofproto\fail-open.c	/^struct fail_open {$/;"	s	file:
fail_open	.\ofproto\ofproto-dpif-xlate.h	/^    bool fail_open;             \/* Initial rule is fail open? *\/$/;"	m	struct:xlate_out
fail_open_create	.\ofproto\fail-open.c	/^fail_open_create(struct ofproto *ofproto, struct connmgr *mgr)$/;"	f
fail_open_is_active	.\ofproto\fail-open.c	/^fail_open_is_active(const struct fail_open *fo)$/;"	f
fail_open_run	.\ofproto\fail-open.c	/^fail_open_run(struct fail_open *fo)$/;"	f
fail_open_wait	.\ofproto\fail-open.c	/^fail_open_wait(struct fail_open *fo)$/;"	f
fake_bridge	.\lib\vswitch-idl.h	/^	bool fake_bridge;$/;"	m	struct:ovsrec_port
fake_iface	.\ofproto\bond.h	/^    bool fake_iface;            \/* Update fake stats for netdev 'name'? *\/$/;"	m	struct:bond_settings
fake_pvconn	.\tests\test-vconn.c	/^struct fake_pvconn {$/;"	s	file:
fallback_ab	.\lib\lacp.c	/^    bool fallback_ab; \/* True if fallback to active-backup on LACP failure. *\/$/;"	m	struct:lacp	file:
fallback_ab_cfg	.\lib\lacp.h	/^    bool fallback_ab_cfg;             \/* Fallback to BM_SLB on LACP failure. *\/$/;"	m	struct:lacp_settings
fallback_dpid	.\ofproto\ofproto-provider.h	/^    uint64_t fallback_dpid;     \/* Datapath ID if no better choice found. *\/$/;"	m	struct:ofproto
false	.\datapath\linux\compat\include\linux\stddef.h	/^	false   = 0,$/;"	e	enum:__anon14
family_list	.\datapath\linux\compat\include\net\genetlink.h	/^	struct list_head        family_list;    \/* private *\/$/;"	m	struct:rpl_genl_family	typeref:struct:rpl_genl_family::list_head
family_policy	.\lib\netlink-socket.c	/^static const struct nl_policy family_policy[CTRL_ATTR_MAX + 1] = {$/;"	v	typeref:struct:nl_policy	file:
fast	.\lib\lacp.c	/^    bool fast;               \/* True if using fast probe interval. *\/$/;"	m	struct:lacp	file:
fast	.\lib\lacp.h	/^    bool fast;                        \/* Fast or slow probe interval. *\/$/;"	m	struct:lacp_settings
fast_hash_ops	.\datapath\linux\compat\include\linux\hash.h	/^struct fast_hash_ops {$/;"	s
fat_rwlock	.\lib\fat-rwlock.h	/^struct OVS_LOCKABLE fat_rwlock {$/;"	s
fat_rwlock_destroy	.\lib\fat-rwlock.c	/^fat_rwlock_destroy(struct fat_rwlock *rwlock)$/;"	f
fat_rwlock_get_slot__	.\lib\fat-rwlock.c	/^fat_rwlock_get_slot__(struct fat_rwlock *rwlock)$/;"	f	file:
fat_rwlock_init	.\lib\fat-rwlock.c	/^fat_rwlock_init(struct fat_rwlock *rwlock)$/;"	f
fat_rwlock_slot	.\lib\fat-rwlock.c	/^struct fat_rwlock_slot {$/;"	s	file:
fatal_ignore_sigpipe	.\lib\fatal-signal.c	/^fatal_ignore_sigpipe(void)$/;"	f
fatal_signal	.\lib\fatal-signal.c	/^VLOG_DEFINE_THIS_MODULE(fatal_signal);$/;"	v
fatal_signal	.\python\ovs\daemon.py	/^import ovs.fatal_signal$/;"	i
fatal_signal	.\python\ovs\socket_util.py	/^import ovs.fatal_signal$/;"	i
fatal_signal_add_file_to_unlink	.\lib\fatal-signal.c	/^fatal_signal_add_file_to_unlink(const char *file)$/;"	f
fatal_signal_add_hook	.\lib\fatal-signal.c	/^fatal_signal_add_hook(void (*hook_cb)(void *aux), void (*cancel_cb)(void *aux),$/;"	f
fatal_signal_fork	.\lib\fatal-signal.c	/^fatal_signal_fork(void)$/;"	f
fatal_signal_handler	.\lib\fatal-signal.c	/^fatal_signal_handler(int sig_nr)$/;"	f
fatal_signal_init	.\lib\fatal-signal.c	/^fatal_signal_init(void)$/;"	f
fatal_signal_remove_file_to_unlink	.\lib\fatal-signal.c	/^fatal_signal_remove_file_to_unlink(const char *file)$/;"	f
fatal_signal_run	.\lib\fatal-signal.c	/^fatal_signal_run(void)$/;"	f
fatal_signal_unlink_file_now	.\lib\fatal-signal.c	/^fatal_signal_unlink_file_now(const char *file)$/;"	f
fatal_signal_wait	.\lib\fatal-signal.c	/^fatal_signal_wait(void)$/;"	f
fatal_signals	.\lib\fatal-signal.c	/^static const int fatal_signals[] = { SIGTERM };$/;"	v	file:
fatal_signals	.\lib\fatal-signal.c	/^static const int fatal_signals[] = { SIGTERM, SIGINT, SIGHUP, SIGALRM };$/;"	v	file:
fault	.\lib\cfm.c	/^    enum cfm_fault_reason fault;  \/* Connectivity fault status. *\/$/;"	m	struct:cfm	typeref:enum:cfm::cfm_fault_reason	file:
fault_override	.\lib\cfm.c	/^    int fault_override;    \/* Manual override of 'fault' status.$/;"	m	struct:cfm	file:
fault_timer	.\lib\cfm.c	/^    struct timer fault_timer; \/* Check for faults when expired. *\/$/;"	m	struct:cfm	typeref:struct:cfm::timer	file:
faults	.\ofproto\ofproto.h	/^    enum cfm_fault_reason faults;$/;"	m	struct:ofproto_cfm_status	typeref:enum:ofproto_cfm_status::cfm_fault_reason
fcntl	.\python\ovs\daemon.py	/^import fcntl$/;"	i
fcntl	.\python\ovstest\util.py	/^import fcntl$/;"	i
fd	.\lib\async-append-aio.c	/^    int fd;$/;"	m	struct:async_append	file:
fd	.\lib\lockfile.c	/^    int fd;$/;"	m	struct:lockfile	file:
fd	.\lib\netdev-bsd.c	/^    int fd;$/;"	m	struct:netdev_bsd	file:
fd	.\lib\netdev-bsd.c	/^    int fd;$/;"	m	struct:netdev_rxq_bsd	file:
fd	.\lib\netdev-linux.c	/^    int fd;$/;"	m	struct:netdev_rxq_linux	file:
fd	.\lib\netlink-socket.c	/^    int fd;$/;"	m	struct:nl_sock	file:
fd	.\lib\stream-fd-unix.c	/^    int fd;$/;"	m	struct:fd_pstream	file:
fd	.\lib\stream-fd-unix.c	/^    int fd;$/;"	m	struct:stream_fd	file:
fd	.\lib\stream-fd-windows.c	/^    int fd;$/;"	m	struct:fd_pstream	file:
fd	.\lib\stream-fd-windows.c	/^    int fd;$/;"	m	struct:stream_fd	file:
fd	.\lib\stream-ssl.c	/^    int fd;$/;"	m	struct:pssl_pstream	file:
fd	.\lib\stream-ssl.c	/^    int fd;$/;"	m	struct:ssl_stream	file:
fd_close	.\lib\stream-fd-unix.c	/^fd_close(struct stream *stream)$/;"	f	file:
fd_close	.\lib\stream-fd-windows.c	/^fd_close(struct stream *stream)$/;"	f	file:
fd_connect	.\lib\stream-fd-unix.c	/^fd_connect(struct stream *stream)$/;"	f	file:
fd_connect	.\lib\stream-fd-windows.c	/^fd_connect(struct stream *stream)$/;"	f	file:
fd_pstream	.\lib\stream-fd-unix.c	/^struct fd_pstream$/;"	s	file:
fd_pstream	.\lib\stream-fd-windows.c	/^struct fd_pstream$/;"	s	file:
fd_pstream_cast	.\lib\stream-fd-unix.c	/^fd_pstream_cast(struct pstream *pstream)$/;"	f	file:
fd_pstream_cast	.\lib\stream-fd-windows.c	/^fd_pstream_cast(struct pstream *pstream)$/;"	f	file:
fd_pstream_class	.\lib\stream-fd-unix.c	/^static const struct pstream_class fd_pstream_class = {$/;"	v	typeref:struct:pstream_class	file:
fd_pstream_class	.\lib\stream-fd-unix.c	/^static const struct pstream_class fd_pstream_class;$/;"	v	typeref:struct:pstream_class	file:
fd_pstream_class	.\lib\stream-fd-windows.c	/^static const struct pstream_class fd_pstream_class = {$/;"	v	typeref:struct:pstream_class	file:
fd_pstream_class	.\lib\stream-fd-windows.c	/^static const struct pstream_class fd_pstream_class;$/;"	v	typeref:struct:pstream_class	file:
fd_recv	.\lib\stream-fd-unix.c	/^fd_recv(struct stream *stream, void *buffer, size_t n)$/;"	f	file:
fd_recv	.\lib\stream-fd-windows.c	/^fd_recv(struct stream *stream, void *buffer, size_t n)$/;"	f	file:
fd_send	.\lib\stream-fd-unix.c	/^fd_send(struct stream *stream, const void *buffer, size_t n)$/;"	f	file:
fd_send	.\lib\stream-fd-windows.c	/^fd_send(struct stream *stream, const void *buffer, size_t n)$/;"	f	file:
fd_wait	.\lib\stream-fd-unix.c	/^fd_wait(struct stream *stream, enum stream_wait_type wait)$/;"	f	file:
fd_wait	.\lib\stream-fd-windows.c	/^fd_wait(struct stream *stream, enum stream_wait_type wait)$/;"	f	file:
fd_wait	.\python\ovs\poller.py	/^    def fd_wait(self, fd, events):$/;"	m	class:Poller
fdb_needs_flush	.\lib\stp.c	/^    bool fdb_needs_flush;          \/* MAC learning tables needs flushing. *\/$/;"	m	struct:stp	file:
fds	.\lib\latch.h	/^    int fds[2];$/;"	m	struct:latch
fds	.\lib\process.c	/^static int fds[2];$/;"	v	file:
fds	.\ofproto\collectors.c	/^    int *fds;                     \/* Sockets. *\/$/;"	m	struct:collectors	file:
feed	.\python\ovs\json.py	/^    def feed(self, s):$/;"	m	class:Parser
fetch_braces	.\lib\vlog.c	/^fetch_braces(const char *p, const char *def, char *out, size_t out_size)$/;"	f	file:
fetch_dbs	.\ovsdb\ovsdb-client.c	/^fetch_dbs(struct jsonrpc *rpc, struct svec *dbs)$/;"	f	file:
fetch_ofputil_phy_port	.\utilities\ovs-ofctl.c	/^fetch_ofputil_phy_port(const char *vconn_name, const char *port_name,$/;"	f	file:
fetch_port_by_features	.\utilities\ovs-ofctl.c	/^fetch_port_by_features(struct vconn *vconn,$/;"	f	file:
fetch_port_by_stats	.\utilities\ovs-ofctl.c	/^fetch_port_by_stats(struct vconn *vconn,$/;"	f	file:
fetch_schema	.\ovsdb\ovsdb-client.c	/^fetch_schema(struct jsonrpc *rpc, const char *database)$/;"	f	file:
fetch_switch_config	.\utilities\ovs-ofctl.c	/^fetch_switch_config(struct vconn *vconn, struct ofp_switch_config *config_)$/;"	f	file:
field	.\include\openflow\nicira-ext.h	/^    ovs_be32 field;                 \/* The field used for push or pop. *\/$/;"	m	struct:nx_action_stack
field	.\lib\classifier.c	/^    const struct mf_field *field; \/* Trie field, or NULL. *\/$/;"	m	struct:cls_trie	typeref:struct:cls_trie::mf_field	file:
field	.\lib\meta-flow.h	/^    const struct mf_field *field;$/;"	m	struct:mf_subfield	typeref:struct:mf_subfield::mf_field
field	.\lib\ofp-actions.h	/^    const struct mf_field *field;$/;"	m	struct:ofpact_set_field	typeref:struct:ofpact_set_field::mf_field
field	.\utilities\ovs-ofctl.c	/^    const struct mf_field *field; \/* NULL means to sort by priority. *\/$/;"	m	struct:sort_criterion	typeref:struct:sort_criterion::mf_field	file:
fields	.\include\openflow\nicira-ext.h	/^    ovs_be16 fields;            \/* One of NX_HASH_FIELDS_*. *\/$/;"	m	struct:nx_action_bundle
fields	.\include\openflow\nicira-ext.h	/^    ovs_be16 fields;            \/* One of NX_HASH_FIELDS_*. *\/$/;"	m	struct:nx_action_multipath
fields	.\lib\ofp-actions.h	/^    enum nx_hash_fields fields;$/;"	m	struct:ofpact_bundle	typeref:enum:ofpact_bundle::nx_hash_fields
fields	.\lib\ofp-actions.h	/^    enum nx_hash_fields fields;$/;"	m	struct:ofpact_multipath	typeref:enum:ofpact_multipath::nx_hash_fields
fields	.\ovsdb\row.h	/^    struct ovsdb_datum fields[];$/;"	m	struct:ovsdb_row	typeref:struct:ovsdb_row::ovsdb_datum
fields	.\python\compat\uuid.py	/^    fields = property(get_fields)$/;"	v	class:UUID
file	.\lib\dhcp.h	/^    char file[128];             \/* Boot file name. *\/$/;"	m	struct:dhcp_header
file	.\ovsdb\log.c	/^    struct ovsdb_log *file;$/;"	m	struct:ovsdb_log_read_cbdata	typeref:struct:ovsdb_log_read_cbdata::ovsdb_log	file:
file	.\ovsdb\ovsdb-server.c	/^    struct ovsdb_file *file;$/;"	m	struct:db	typeref:struct:db::ovsdb_file	file:
file_name	.\lib\stream-ssl.c	/^    char *file_name;            \/* Configured file name, if any. *\/$/;"	m	struct:ssl_config_file	file:
file_name	.\ovsdb\file.c	/^    char *file_name;$/;"	m	struct:ovsdb_file	file:
file_name	.\tests\test-stp.c	/^static const char *file_name;$/;"	v	file:
filename	.\ovsdb\ovsdb-server.c	/^    char *filename;$/;"	m	struct:db	file:
filep_pidfile	.\lib\daemon-windows.c	/^static FILE *filep_pidfile;    \/* File pointer to access the pidfile. *\/$/;"	v	file:
files	.\lib\fatal-signal.c	/^static struct sset files = SSET_INITIALIZER(&files);$/;"	v	typeref:struct:sset	file:
filter_tnl_flags	.\datapath\vport-gre.c	/^static __be16 filter_tnl_flags(__be16 flags)$/;"	f	file:
fin	.\ofproto\ofproto-dpif-xlate.c	/^        } fin;$/;"	m	union:xc_entry::__anon136	typeref:struct:xc_entry::__anon136::__anon143	file:
fin_hard_timeout	.\include\openflow\nicira-ext.h	/^    ovs_be16 fin_hard_timeout;  \/* Hard timeout after FIN, if nonzero. *\/$/;"	m	struct:nx_action_learn
fin_hard_timeout	.\include\openflow\nicira-ext.h	/^    ovs_be16 fin_hard_timeout;  \/* New hard timeout, if nonzero. *\/$/;"	m	struct:nx_action_fin_timeout
fin_hard_timeout	.\lib\ofp-actions.h	/^    uint16_t fin_hard_timeout;  \/* Hard timeout after FIN, if nonzero. *\/$/;"	m	struct:ofpact_learn
fin_hard_timeout	.\lib\ofp-actions.h	/^    uint16_t fin_hard_timeout;$/;"	m	struct:ofpact_fin_timeout
fin_idle_timeout	.\include\openflow\nicira-ext.h	/^    ovs_be16 fin_idle_timeout;  \/* Idle timeout after FIN, if nonzero. *\/$/;"	m	struct:nx_action_learn
fin_idle_timeout	.\include\openflow\nicira-ext.h	/^    ovs_be16 fin_idle_timeout;  \/* New idle timeout, if nonzero. *\/$/;"	m	struct:nx_action_fin_timeout
fin_idle_timeout	.\lib\ofp-actions.h	/^    uint16_t fin_idle_timeout;  \/* Idle timeout after FIN, if nonzero. *\/$/;"	m	struct:ofpact_learn
fin_idle_timeout	.\lib\ofp-actions.h	/^    uint16_t fin_idle_timeout;$/;"	m	struct:ofpact_fin_timeout
fin_timeout	.\lib\ofp-actions.c	/^    struct nx_action_fin_timeout fin_timeout;$/;"	m	union:ofp_action	typeref:struct:ofp_action::nx_action_fin_timeout	file:
fin_timeout_from_openflow	.\lib\ofp-actions.c	/^fin_timeout_from_openflow(const struct nx_action_fin_timeout *naft,$/;"	f	file:
find_bridge	.\utilities\ovs-vsctl.c	/^find_bridge(struct vsctl_context *ctx, const char *name, bool must_exist)$/;"	f	file:
find_bucket	.\datapath\flow_table.c	/^static struct hlist_head *find_bucket(struct table_instance *ti, u32 hash)$/;"	f	file:
find_command	.\utilities\ovs-vsctl.c	/^find_command(const char *name)$/;"	f	file:
find_command	.\vtep\vtep-ctl.c	/^find_command(const char *name)$/;"	f	file:
find_controller_by_target	.\ofproto\connmgr.c	/^find_controller_by_target(struct connmgr *mgr, const char *target)$/;"	f	file:
find_db	.\ovsdb\ovsdb-server.c	/^find_db(const struct shash *all_dbs, const char *db_name)$/;"	f	file:
find_equal	.\lib\classifier.c	/^find_equal(struct cls_subtable *subtable, const struct miniflow *flow,$/;"	f	file:
find_file	.\build-aux\sodepends.pl	/^sub find_file {$/;"	s
find_genl_family_by_id	.\lib\netlink-socket.c	/^find_genl_family_by_id(uint16_t id)$/;"	f	file:
find_iface	.\utilities\ovs-vsctl.c	/^find_iface(struct vsctl_context *ctx, const char *name, bool must_exist)$/;"	f	file:
find_local_hw_addr	.\vswitchd\bridge.c	/^find_local_hw_addr(const struct bridge *br, uint8_t ea[ETH_ADDR_LEN],$/;"	f	file:
find_lswitch	.\vtep\vtep-ctl.c	/^find_lswitch(struct vtep_ctl_context *ctx, const char *name, bool must_exist)$/;"	f	file:
find_match	.\lib\classifier.c	/^find_match(const struct cls_subtable *subtable, const struct flow *flow,$/;"	f	file:
find_match_miniflow	.\lib\classifier.c	/^find_match_miniflow(const struct cls_subtable *subtable,$/;"	f	file:
find_match_wc	.\lib\classifier.c	/^find_match_wc(const struct cls_subtable *subtable, const struct flow *flow,$/;"	f	file:
find_min_mtu	.\ofproto\ofproto.c	/^find_min_mtu(struct ofproto *p)$/;"	f	file:
find_option	.\utilities\ovs-vsctl.c	/^find_option(const char *name, struct option *options, size_t n_options)$/;"	f	file:
find_option	.\vtep\vtep-ctl.c	/^find_option(const char *name, struct option *options, size_t n_options)$/;"	f	file:
find_or_make_txn_row	.\ovsdb\transaction.c	/^find_or_make_txn_row(struct ovsdb_txn *txn, const struct ovsdb_table *table,$/;"	f	file:
find_partition	.\lib\classifier.c	/^find_partition(const struct cls_classifier *cls, ovs_be64 metadata,$/;"	f	file:
find_ploc	.\vtep\vtep-ctl.c	/^find_ploc(struct vtep_ctl_context *ctx, const char *encap,$/;"	f	file:
find_poll_node	.\lib\poll-loop.c	/^find_poll_node(struct poll_loop *loop, int fd, uint32_t wevent)$/;"	f	file:
find_port	.\utilities\ovs-vsctl.c	/^find_port(struct vsctl_context *ctx, const char *name, bool must_exist)$/;"	f	file:
find_port	.\vtep\vtep-ctl.c	/^find_port(struct vtep_ctl_context *ctx, const char *ps_name,$/;"	f	file:
find_pswitch	.\vtep\vtep-ctl.c	/^find_pswitch(struct vtep_ctl_context *ctx, const char *name, bool must_exist)$/;"	f	file:
find_real_bridge	.\utilities\ovs-vsctl.c	/^find_real_bridge(struct vsctl_context *ctx, const char *name, bool must_exist)$/;"	f	file:
find_route	.\datapath\compat.h	/^static inline struct rtable *find_route(struct net *net,$/;"	f
find_subtable	.\lib\classifier.c	/^find_subtable(const struct cls_classifier *cls, const struct minimask *mask)$/;"	f	file:
find_txn_row	.\ovsdb\transaction.c	/^find_txn_row(const struct ovsdb_table *table, const struct uuid *uuid)$/;"	f	file:
find_vlan_bridge	.\utilities\ovs-vsctl.c	/^find_vlan_bridge(struct vsctl_bridge *parent, int vlan)$/;"	f	file:
finish	.\python\ovs\db\parser.py	/^    def finish(self):$/;"	m	class:Parser
finish	.\python\ovs\json.py	/^    def finish(self):$/;"	m	class:Parser
finish_queue_dump	.\lib\netdev-linux.c	/^finish_queue_dump(struct queue_dump_state *state)$/;"	f	file:
first_changed_port	.\lib\stp.c	/^    struct stp_port *first_changed_port;$/;"	m	struct:stp	typeref:struct:stp::stp_port	file:
first_dropped	.\lib\vlog.h	/^    time_t first_dropped;       \/* Time first message was dropped. *\/$/;"	m	struct:vlog_rate_limit
first_matching_table	.\ofproto\ofproto.c	/^first_matching_table(const struct ofproto *ofproto, uint8_t table_id)$/;"	f	file:
first_op	.\ofproto\connmgr.c	/^    long long int first_op, last_op; \/* Range of times for unreported ops. *\/$/;"	m	struct:ofconn	file:
fix_segment	.\datapath\linux\compat\gso.h	/^	void (*fix_segment)(struct sk_buff *);$/;"	m	struct:ovs_gso_cb
fix_sflow_action	.\ofproto\ofproto-dpif-xlate.c	/^fix_sflow_action(struct xlate_ctx *ctx)$/;"	f	file:
flag	.\include\windows\getopt.h	/^	int *flag;$/;"	m	struct:option
flag	.\lib\ofp-util.c	/^    enum ofputil_flow_mod_flags flag;$/;"	m	struct:ofputil_flow_mod_flag	typeref:enum:ofputil_flow_mod_flag::ofputil_flow_mod_flags	file:
flags	.\datapath\flow.h	/^		__be16 flags;		\/* TCP flags. *\/$/;"	m	struct:sw_flow_key::__anon4
flags	.\datapath\linux\compat\include\net\gre.h	/^	__be16 flags;$/;"	m	struct:gre_base_hdr
flags	.\datapath\linux\compat\include\net\ip_tunnels.h	/^	__be16 flags;$/;"	m	struct:tnl_ptk_info
flags	.\include\openflow\nicira-ext.h	/^    ovs_be16 flags;               \/* One of OFPFF_*. *\/$/;"	m	struct:nx_flow_mod
flags	.\include\openflow\nicira-ext.h	/^    ovs_be16 flags;             \/* Either 0 or OFPFF_SEND_FLOW_REM. *\/$/;"	m	struct:nx_action_learn
flags	.\include\openflow\nicira-ext.h	/^    ovs_be16 flags;             \/* NXFMF_*. *\/$/;"	m	struct:nx_flow_monitor_request
flags	.\include\openflow\openflow-1.0.h	/^    ovs_be16 flags;               \/* One of OFPFF_*. *\/$/;"	m	struct:ofp10_flow_mod
flags	.\include\openflow\openflow-1.0.h	/^    ovs_be16 flags;             \/* Requests: always 0.$/;"	m	struct:ofp10_stats_msg
flags	.\include\openflow\openflow-1.1.h	/^    ovs_be16 flags;              \/* One of OFPFF_*. *\/$/;"	m	struct:ofp11_flow_mod
flags	.\include\openflow\openflow-1.1.h	/^    ovs_be16 flags;             \/* OFPSF_REQ_* flags (none yet defined). *\/$/;"	m	struct:ofp11_stats_msg
flags	.\include\openflow\openflow-1.1.h	/^    ovs_be16 flags;            \/* OF 1.3: Set of OFPFF*. *\/$/;"	m	struct:ofp11_flow_stats
flags	.\include\openflow\openflow-1.3.h	/^    ovs_be16          flags;        \/* Set of OFPMC_* that apply. *\/$/;"	m	struct:ofp13_action_self_learning::ofp13_meter_config
flags	.\include\openflow\openflow-1.3.h	/^    ovs_be16          flags;        \/* Set of OFPMF_*. *\/$/;"	m	struct:ofp13_action_self_learning::ofp13_meter_mod
flags	.\include\openflow\openflow-1.4.h	/^    ovs_be16 flags;         \/* Bitmap of OFPBF_* flags. *\/$/;"	m	struct:ofp14_bundle_ctrl_msg
flags	.\include\openflow\openflow-1.4.h	/^    ovs_be32         flags;   \/* Bitmap of OFPTMPEF14_* flags *\/$/;"	m	struct:ofp14_table_mod_prop_eviction
flags	.\include\openflow\openflow-common.h	/^    ovs_be16 flags;             \/* OFPC_* flags. *\/$/;"	m	struct:ofp_switch_config
flags	.\lib\bfd.c	/^    enum flags flags;             \/* Flags sent on messages. *\/$/;"	m	struct:bfd	typeref:enum:bfd::flags	file:
flags	.\lib\bfd.c	/^    uint8_t flags;        \/* 2bit State field followed by flags. *\/$/;"	m	struct:msg	file:
flags	.\lib\bfd.c	/^enum flags {$/;"	g	file:
flags	.\lib\dhcp.h	/^    ovs_be16 flags;             \/* DHCP_FLAGS_*. *\/$/;"	m	struct:dhcp_header
flags	.\lib\dpif.h	/^    enum dpif_flow_put_flags flags; \/* DPIF_FP_*. *\/$/;"	m	struct:dpif_flow_put	typeref:enum:dpif_flow_put::dpif_flow_put_flags
flags	.\lib\json.c	/^    int flags;$/;"	m	struct:json_parser	file:
flags	.\lib\json.c	/^    int flags;$/;"	m	struct:json_serializer	file:
flags	.\lib\netdev-dpdk.c	/^    enum netdev_flags flags;$/;"	m	struct:netdev_dpdk	typeref:enum:netdev_dpdk::netdev_flags	file:
flags	.\lib\ofp-actions.h	/^    enum ofputil_flow_mod_flags flags;$/;"	m	struct:ofpact_learn	typeref:enum:ofpact_learn::ofputil_flow_mod_flags
flags	.\lib\ofp-util.h	/^    enum nx_flow_monitor_flags flags;$/;"	m	struct:ofputil_flow_monitor_request	typeref:enum:ofputil_flow_monitor_request::nx_flow_monitor_flags
flags	.\lib\ofp-util.h	/^    enum ofputil_flow_mod_flags flags;$/;"	m	struct:ofputil_flow_mod	typeref:enum:ofputil_flow_mod::ofputil_flow_mod_flags
flags	.\lib\ofp-util.h	/^    enum ofputil_flow_mod_flags flags;$/;"	m	struct:ofputil_flow_stats	typeref:enum:ofputil_flow_stats::ofputil_flow_mod_flags
flags	.\lib\ofp-util.h	/^    uint16_t            flags;$/;"	m	struct:ofputil_bundle_add_msg
flags	.\lib\ofp-util.h	/^    uint16_t    flags;$/;"	m	struct:ofputil_bundle_ctrl_msg
flags	.\lib\ofp-util.h	/^    uint16_t flags;$/;"	m	struct:ofputil_meter_config
flags	.\lib\packets.h	/^    uint16_t flags;$/;"	m	struct:flow_tnl
flags	.\ofproto\bundles.c	/^    uint16_t          flags;$/;"	m	struct:ofp_bundle	file:
flags	.\ofproto\connmgr.h	/^    enum nx_flow_monitor_flags flags;$/;"	m	struct:ofmonitor	typeref:enum:ofmonitor::nx_flow_monitor_flags
flags	.\ofproto\ofproto-provider.h	/^    enum oftable_flags flags;$/;"	m	struct:oftable	typeref:enum:oftable::oftable_flags
flags	.\ofproto\ofproto.c	/^    enum ofputil_flow_mod_flags flags;  \/* Rule's old flags. *\/$/;"	m	struct:ofoperation	typeref:enum:ofoperation::ofputil_flow_mod_flags	file:
flags	.\ofproto\ofproto.c	/^    uint16_t flags;             \/* Meter flags. *\/$/;"	m	struct:meter	file:
flags	.\utilities\ovs-ofctl.c	/^    uint16_t flags;$/;"	m	struct:fte_version	file:
flap_count	.\lib\bfd.c	/^    uint64_t flap_count;          \/* Counts bfd forwarding flaps. *\/$/;"	m	struct:bfd	file:
flap_count	.\lib\cfm.c	/^    uint64_t flap_count;       \/* Count the flaps since boot. *\/$/;"	m	struct:cfm	file:
flap_count	.\ofproto\ofproto.h	/^    uint64_t flap_count;$/;"	m	struct:ofproto_cfm_status
flex_array	.\datapath\linux\compat\include\linux\flex_array.h	/^struct flex_array {$/;"	s
flex_array_alloc	.\datapath\linux\compat\flex_array.c	/^struct flex_array *flex_array_alloc(int element_size, unsigned int total,$/;"	f
flex_array_clear	.\datapath\linux\compat\flex_array.c	/^int flex_array_clear(struct flex_array *fa, unsigned int element_nr)$/;"	f
flex_array_free	.\datapath\linux\compat\flex_array.c	/^void flex_array_free(struct flex_array *fa)$/;"	f
flex_array_free_parts	.\datapath\linux\compat\flex_array.c	/^void flex_array_free_parts(struct flex_array *fa)$/;"	f
flex_array_get	.\datapath\linux\compat\flex_array.c	/^void *flex_array_get(struct flex_array *fa, unsigned int element_nr)$/;"	f
flex_array_get_ptr	.\datapath\linux\compat\flex_array.c	/^void *flex_array_get_ptr(struct flex_array *fa, unsigned int element_nr)$/;"	f
flex_array_part	.\datapath\linux\compat\flex_array.c	/^struct flex_array_part {$/;"	s	file:
flex_array_prealloc	.\datapath\linux\compat\flex_array.c	/^int flex_array_prealloc(struct flex_array *fa, unsigned int start,$/;"	f
flex_array_put	.\datapath\linux\compat\flex_array.c	/^int flex_array_put(struct flex_array *fa, unsigned int element_nr, void *src,$/;"	f
flex_array_put_ptr	.\datapath\linux\compat\include\linux\flex_array.h	81;"	d
flex_array_shrink	.\datapath\linux\compat\flex_array.c	/^int flex_array_shrink(struct flex_array *fa)$/;"	f
float_down	.\lib\heap.c	/^float_down(struct heap *heap, size_t i)$/;"	f	file:
float_to_int	.\python\ovs\db\parser.py	/^def float_to_int(x):$/;"	f
float_up	.\lib\heap.c	/^float_up(struct heap *heap, size_t i)$/;"	f	file:
float_up_or_down	.\lib\heap.c	/^float_up_or_down(struct heap *heap, size_t i)$/;"	f	file:
flood_packets	.\ofproto\ofproto-dpif-xlate.c	/^flood_packets(struct xlate_ctx *ctx, bool all)$/;"	f	file:
flood_vlans	.\lib\mac-learning.h	/^    unsigned long *flood_vlans; \/* Bitmap of learning disabled VLANs. *\/$/;"	m	struct:mac_learning
flood_vlans	.\lib\vswitch-idl.h	/^	int64_t *flood_vlans;$/;"	m	struct:ovsrec_bridge
floodable	.\ofproto\ofproto-dpif-xlate.c	/^    bool floodable;                \/* No port has OFPUTIL_PC_NO_FLOOD set? *\/$/;"	m	struct:xbundle	file:
floodable	.\ofproto\ofproto-dpif.c	/^    bool floodable;          \/* True if no port has OFPUTIL_PC_NO_FLOOD set. *\/$/;"	m	struct:ofbundle	file:
flow	.\datapath\datapath.h	/^	struct sw_flow		*flow;$/;"	m	struct:ovs_skb_cb	typeref:struct:ovs_skb_cb::sw_flow
flow	.\lib\classifier.c	/^    struct miniflow flow;       \/* Matching rule. Mask is in the subtable. *\/$/;"	m	struct:cls_match	typeref:struct:cls_match::miniflow	file:
flow	.\lib\dpif-linux.c	/^    struct dpif_linux_flow flow;$/;"	m	struct:dpif_linux_flow_state	typeref:struct:dpif_linux_flow_state::dpif_linux_flow	file:
flow	.\lib\dpif-netdev.c	/^    const struct flow flow;      \/* The flow that created this entry. *\/$/;"	m	struct:dp_netdev_flow	typeref:struct:dp_netdev_flow::flow	file:
flow	.\lib\flow.h	/^struct flow {$/;"	s
flow	.\lib\match.h	/^    struct flow flow;$/;"	m	struct:match	typeref:struct:match::flow
flow	.\lib\match.h	/^    struct miniflow flow;$/;"	m	struct:minimatch	typeref:struct:minimatch::miniflow
flow	.\ofproto\ofproto-dpif-upcall.c	/^    struct flow flow;$/;"	m	struct:flow_miss	typeref:struct:flow_miss::flow	file:
flow	.\ofproto\ofproto-dpif-xlate.c	/^            struct flow *flow;$/;"	m	struct:xc_entry::__anon136::__anon138	typeref:struct:xc_entry::__anon136::__anon138::flow	file:
flow	.\ofproto\ofproto-dpif-xlate.c	/^            struct flow *flow;$/;"	m	struct:xc_entry::__anon136::__anon140	typeref:struct:xc_entry::__anon136::__anon140::flow	file:
flow	.\ofproto\ofproto-dpif-xlate.c	/^            struct flow *flow;$/;"	m	struct:xc_entry::__anon136::__anon142	typeref:struct:xc_entry::__anon136::__anon142::flow	file:
flow	.\ofproto\ofproto-dpif-xlate.h	/^    struct flow flow;$/;"	m	struct:xlate_in	typeref:struct:xlate_in::flow
flow	.\ofproto\ofproto-dpif.c	/^    struct flow flow;$/;"	m	struct:trace_ctx	typeref:struct:trace_ctx::flow	file:
flow	.\utilities\ovs-dpctl.c	/^    struct flow flow;$/;"	m	struct:actions_for_flow	typeref:struct:actions_for_flow::flow	file:
flowSampleSeqNo	.\lib\sflow_api.h	/^    u_int32_t flowSampleSeqNo;$/;"	m	struct:_SFLSampler
flowType	.\lib\sflow.h	/^    SFLFlow_type flowType;$/;"	m	struct:_SFLFlow_sample_element
flow_be32ofs	.\lib\meta-flow.h	/^    int flow_be32ofs;  \/* Field's be32 offset in "struct flow", if prefix tree$/;"	m	struct:mf_field
flow_cache	.\datapath\flow_table.c	/^static struct kmem_cache *flow_cache;$/;"	v	typeref:struct:kmem_cache	file:
flow_cmp_masked_key	.\datapath\flow_table.c	/^static bool flow_cmp_masked_key(const struct sw_flow *flow,$/;"	f	file:
flow_compose	.\lib\flow.c	/^flow_compose(struct ofpbuf *b, const struct flow *flow)$/;"	f
flow_compose_l4	.\lib\flow.c	/^flow_compose_l4(struct ofpbuf *b, const struct flow *flow)$/;"	f	file:
flow_cookie	.\ofproto\ofproto.c	/^    ovs_be64 flow_cookie;               \/* Rule's old flow cookie. *\/$/;"	m	struct:ofoperation	file:
flow_count	.\include\openflow\openflow-1.3.h	/^    ovs_be32  flow_count;        \/* Number of flows bound to meter. *\/$/;"	m	struct:ofp13_action_self_learning::ofp13_meter_stats
flow_count	.\include\openflow\openflow-common.h	/^    ovs_be32 flow_count;      \/* Number of flows. *\/$/;"	m	struct:ofp_aggregate_stats_reply
flow_count	.\lib\ofp-util.h	/^    uint32_t flow_count;$/;"	m	struct:ofputil_aggregate_stats
flow_count	.\lib\ofp-util.h	/^    uint32_t flow_count;$/;"	m	struct:ofputil_meter_stats
flow_count	.\tests\test-bundle.c	/^    size_t flow_count;$/;"	m	struct:slave	file:
flow_count_common_mpls_labels	.\lib\flow.c	/^flow_count_common_mpls_labels(const struct flow *a, int an,$/;"	f
flow_count_mpls_labels	.\lib\flow.c	/^flow_count_mpls_labels(const struct flow *flow, struct flow_wildcards *wc)$/;"	f
flow_del	.\lib\dpif-provider.h	/^    int (*flow_del)(struct dpif *dpif, const struct dpif_flow_del *del);$/;"	m	struct:dpif_class
flow_del	.\lib\dpif.h	/^        struct dpif_flow_del flow_del;$/;"	m	union:dpif_op::__anon45	typeref:struct:dpif_op::__anon45::dpif_flow_del
flow_dump_done	.\lib\dpif-provider.h	/^    int (*flow_dump_done)(const struct dpif *dpif, void *iter);$/;"	m	struct:dpif_class
flow_dump_next	.\lib\dpif-provider.h	/^    int (*flow_dump_next)(const struct dpif *dpif, void *iter, void *state,$/;"	m	struct:dpif_class
flow_dump_next_may_destroy_keys	.\lib\dpif-provider.h	/^    bool (*flow_dump_next_may_destroy_keys)(void *state);$/;"	m	struct:dpif_class
flow_dump_start	.\lib\dpif-provider.h	/^    int (*flow_dump_start)(const struct dpif *dpif, void **iterp);$/;"	m	struct:dpif_class
flow_dump_state_init	.\lib\dpif-provider.h	/^    void (*flow_dump_state_init)(void **statep);$/;"	m	struct:dpif_class
flow_dump_state_uninit	.\lib\dpif-provider.h	/^    void (*flow_dump_state_uninit)(void *statep);$/;"	m	struct:dpif_class
flow_end_timestamp_usec	.\ofproto\ofproto-dpif-ipfix.c	/^    uint64_t flow_end_timestamp_usec;$/;"	m	struct:ipfix_flow_cache_entry	file:
flow_equal_except	.\lib\flow.c	/^flow_equal_except(const struct flow *a, const struct flow *b,$/;"	f
flow_exporter_map	.\ofproto\ofproto-dpif-ipfix.c	/^    struct hmap flow_exporter_map;  \/* dpif_ipfix_flow_exporter_map_node. *\/$/;"	m	struct:dpif_ipfix	typeref:struct:dpif_ipfix::hmap	file:
flow_extract	.\lib\flow.c	/^COVERAGE_DEFINE(flow_extract);$/;"	v
flow_extract	.\lib\flow.c	/^flow_extract(struct ofpbuf *packet, const struct pkt_metadata *md,$/;"	f
flow_flush	.\lib\dpif-provider.h	/^    int (*flow_flush)(struct dpif *dpif);$/;"	m	struct:dpif_class
flow_format	.\lib\flow.c	/^flow_format(struct ds *ds, const struct flow *flow)$/;"	f
flow_free	.\datapath\flow_table.c	/^static void flow_free(struct sw_flow *flow)$/;"	f	file:
flow_get	.\lib\dpif-provider.h	/^    int (*flow_get)(const struct dpif *dpif,$/;"	m	struct:dpif_class
flow_get_metadata	.\lib\flow.c	/^flow_get_metadata(const struct flow *flow, struct flow_metadata *fmd)$/;"	f
flow_has_vlan	.\lib\ofp-actions.h	/^    bool flow_has_vlan;         \/* VLAN present at action validation time? *\/$/;"	m	struct:ofpact_vlan_pcp
flow_has_vlan	.\lib\ofp-actions.h	/^    bool flow_has_vlan;         \/* VLAN present at action validation time? *\/$/;"	m	struct:ofpact_vlan_vid
flow_has_vlan	.\lib\ofp-actions.h	/^    bool flow_has_vlan;   \/* VLAN present at action validation time. *\/$/;"	m	struct:ofpact_set_field
flow_hash	.\datapath\flow_table.c	/^static u32 flow_hash(const struct sw_flow_key *key, int key_start,$/;"	f	file:
flow_hash_5tuple	.\lib\flow.c	/^flow_hash_5tuple(const struct flow *flow, uint32_t basis)$/;"	f
flow_hash_fields	.\lib\flow.c	/^flow_hash_fields(const struct flow *flow, enum nx_hash_fields fields,$/;"	f
flow_hash_fields_to_str	.\lib\flow.c	/^flow_hash_fields_to_str(enum nx_hash_fields fields)$/;"	f
flow_hash_fields_valid	.\lib\flow.c	/^flow_hash_fields_valid(enum nx_hash_fields fields)$/;"	f
flow_hash_in_minimask	.\lib\classifier.c	/^flow_hash_in_minimask(const struct flow *flow, const struct minimask *mask,$/;"	f	file:
flow_hash_in_minimask_range	.\lib\classifier.c	/^flow_hash_in_minimask_range(const struct flow *flow,$/;"	f	file:
flow_hash_in_wildcards	.\lib\flow.c	/^flow_hash_in_wildcards(const struct flow *flow,$/;"	f
flow_hash_symmetric_l4	.\lib\flow.c	/^flow_hash_symmetric_l4(const struct flow *flow, uint32_t basis)$/;"	f
flow_in_port	.\lib\packets.h	/^union flow_in_port {$/;"	u
flow_ip_proto	.\lib\ofp-actions.h	/^    uint8_t  flow_ip_proto;     \/* IP proto from corresponding match, or 0 *\/$/;"	m	struct:ofpact_l4_port
flow_key	.\ofproto\ofproto-dpif-ipfix.c	/^    struct ipfix_flow_key flow_key;$/;"	m	struct:ipfix_flow_cache_entry	typeref:struct:ipfix_flow_cache_entry::ipfix_flow_key	file:
flow_key_map_node	.\ofproto\ofproto-dpif-ipfix.c	/^    struct hmap_node flow_key_map_node;$/;"	m	struct:ipfix_flow_cache_entry	typeref:struct:ipfix_flow_cache_entry::hmap_node	file:
flow_key_msg_part	.\ofproto\ofproto-dpif-ipfix.c	/^    uint64_t flow_key_msg_part[DIV_ROUND_UP(MAX_FLOW_KEY_LEN, 8)];$/;"	m	struct:ipfix_flow_key	file:
flow_key_msg_part_size	.\ofproto\ofproto-dpif-ipfix.c	/^    size_t flow_key_msg_part_size;$/;"	m	struct:ipfix_flow_key	file:
flow_key_start	.\datapath\flow_table.c	/^static int flow_key_start(const struct sw_flow_key *key)$/;"	f	file:
flow_keys	.\datapath\linux\compat\include\net\flow_keys.h	/^struct flow_keys {$/;"	s
flow_limit	.\lib\vswitch-idl.h	/^	int64_t *flow_limit;$/;"	m	struct:ovsrec_flow_table
flow_limit	.\ofproto\ofproto-dpif-upcall.c	/^    atomic_uint flow_limit;            \/* Datapath flow hard limit. *\/$/;"	m	struct:udpif	file:
flow_lookup	.\datapath\flow_table.c	/^static struct sw_flow *flow_lookup(struct flow_table *tbl,$/;"	f	file:
flow_mask_find	.\datapath\flow_table.c	/^static struct sw_flow_mask *flow_mask_find(const struct flow_table *tbl,$/;"	f	file:
flow_mask_hash_fields	.\lib\flow.c	/^flow_mask_hash_fields(const struct flow *flow, struct flow_wildcards *wc,$/;"	f
flow_mask_insert	.\datapath\flow_table.c	/^static int flow_mask_insert(struct flow_table *tbl, struct sw_flow *flow,$/;"	f	file:
flow_mask_remove	.\datapath\flow_table.c	/^static void flow_mask_remove(struct flow_table *tbl, struct sw_flow_mask *mask)$/;"	f	file:
flow_message_log_level	.\lib\dpif.c	/^flow_message_log_level(int error)$/;"	f	file:
flow_miss	.\ofproto\ofproto-dpif-upcall.c	/^    struct flow_miss *flow_miss;    \/* This upcall's flow_miss. *\/$/;"	m	struct:upcall	typeref:struct:upcall::flow_miss	file:
flow_miss	.\ofproto\ofproto-dpif-upcall.c	/^struct flow_miss {$/;"	s	file:
flow_miss_find	.\ofproto\ofproto-dpif-upcall.c	/^flow_miss_find(struct hmap *todo, const struct ofproto_dpif *ofproto,$/;"	f	file:
flow_mod_init	.\ofproto\ofproto.c	/^flow_mod_init(struct ofputil_flow_mod *fm,$/;"	f	file:
flow_mutex	.\lib\dpif-netdev.c	/^    struct ovs_mutex flow_mutex;$/;"	m	struct:dp_netdev	typeref:struct:dp_netdev::ovs_mutex	file:
flow_policy	.\datapath\datapath.c	/^static const struct nla_policy flow_policy[OVS_FLOW_ATTR_MAX + 1] = {$/;"	v	typeref:struct:nla_policy	file:
flow_pop_mpls	.\lib\flow.c	/^flow_pop_mpls(struct flow *flow, int n, ovs_be16 eth_type,$/;"	f
flow_print	.\lib\flow.c	/^flow_print(FILE *stream, const struct flow *flow)$/;"	f
flow_push_mpls	.\lib\flow.c	/^flow_push_mpls(struct flow *flow, int n, ovs_be16 mpls_eth_type,$/;"	f
flow_put	.\lib\dpif-provider.h	/^    int (*flow_put)(struct dpif *dpif, const struct dpif_flow_put *put);$/;"	m	struct:dpif_class
flow_put	.\lib\dpif.h	/^        struct dpif_flow_put flow_put;$/;"	m	union:dpif_op::__anon45	typeref:struct:dpif_op::__anon45::dpif_flow_put
flow_random_hash_fields	.\lib\flow.c	/^flow_random_hash_fields(struct flow *flow)$/;"	f
flow_removed_mask	.\include\openflow\nicira-ext.h	/^    ovs_be32 flow_removed_mask[2]; \/* Bitmasks of OFPPR_* values. *\/$/;"	m	struct:nx_async_config
flow_removed_mask	.\include\openflow\openflow-1.3.h	/^    ovs_be32 flow_removed_mask[2];\/* Bitmasks of OFPRR_* values. *\/$/;"	m	struct:ofp13_action_self_learning::ofp13_async_config
flow_restore_wait	.\ofproto\ofproto.c	/^static bool flow_restore_wait = true;$/;"	v	file:
flow_sample	.\lib\odp-util.h	/^    } flow_sample;$/;"	m	union:user_action_cookie	typeref:struct:user_action_cookie::__anon71
flow_segment_u32s	.\lib\flow.c	/^const uint8_t flow_segment_u32s[4] = {$/;"	v
flow_segments	.\lib\classifier.c	/^    uint8_t flow_segments[CLS_MAX_INDICES]; \/* Flow segment boundaries to use$/;"	m	struct:cls_classifier	file:
flow_seq	.\lib\netflow.h	/^    ovs_be32 flow_seq;             \/* Number of flows since sending$/;"	m	struct:netflow_v5_header
flow_set_dl_vlan	.\lib\flow.c	/^flow_set_dl_vlan(struct flow *flow, ovs_be16 vid)$/;"	f
flow_set_mpls_bos	.\lib\flow.c	/^flow_set_mpls_bos(struct flow *flow, int idx, uint8_t bos)$/;"	f
flow_set_mpls_label	.\lib\flow.c	/^flow_set_mpls_label(struct flow *flow, int idx, ovs_be32 label)$/;"	f
flow_set_mpls_lse	.\lib\flow.c	/^flow_set_mpls_lse(struct flow *flow, int idx, ovs_be32 lse)$/;"	f
flow_set_mpls_lse_ttl	.\lib\packets.h	/^flow_set_mpls_lse_ttl(ovs_be32 *mpls_lse, uint8_t ttl)$/;"	f
flow_set_mpls_tc	.\lib\flow.c	/^flow_set_mpls_tc(struct flow *flow, int idx, uint8_t tc)$/;"	f
flow_set_mpls_ttl	.\lib\flow.c	/^flow_set_mpls_ttl(struct flow *flow, int idx, uint8_t ttl)$/;"	f
flow_set_vlan_pcp	.\lib\flow.c	/^flow_set_vlan_pcp(struct flow *flow, uint8_t pcp)$/;"	f
flow_set_vlan_vid	.\lib\flow.c	/^flow_set_vlan_vid(struct flow *flow, ovs_be16 vid)$/;"	f
flow_start_timestamp_usec	.\ofproto\ofproto-dpif-ipfix.c	/^    uint64_t flow_start_timestamp_usec;$/;"	m	struct:ipfix_flow_cache_entry	file:
flow_stats	.\datapath\flow.h	/^struct flow_stats {$/;"	s
flow_stats_ds	.\ofproto\ofproto.c	/^flow_stats_ds(struct rule *rule, struct ds *results)$/;"	f	file:
flow_table	.\datapath\flow_table.h	/^struct flow_table {$/;"	s
flow_table_copy_flows	.\datapath\flow_table.c	/^static void flow_table_copy_flows(struct table_instance *old,$/;"	f	file:
flow_tbl_destroy_rcu_cb	.\datapath\flow_table.c	/^static void flow_tbl_destroy_rcu_cb(struct rcu_head *rcu)$/;"	f	file:
flow_tnl	.\lib\packets.h	/^struct flow_tnl {$/;"	s
flow_to_string	.\lib\flow.c	/^flow_to_string(const struct flow *flow)$/;"	f
flow_tun_flag_to_string	.\lib\flow.c	/^flow_tun_flag_to_string(uint32_t flags)$/;"	f
flow_unwildcard_tp_ports	.\lib\flow.c	/^flow_unwildcard_tp_ports(const struct flow *flow, struct flow_wildcards *wc)$/;"	f
flow_wildcards_and	.\lib\flow.c	/^flow_wildcards_and(struct flow_wildcards *dst,$/;"	f
flow_wildcards_clear_non_packet_fields	.\lib\flow.c	/^flow_wildcards_clear_non_packet_fields(struct flow_wildcards *wc)$/;"	f
flow_wildcards_equal	.\lib\flow.c	/^flow_wildcards_equal(const struct flow_wildcards *a,$/;"	f
flow_wildcards_fold_minimask	.\lib\classifier.c	/^flow_wildcards_fold_minimask(struct flow_wildcards *wc,$/;"	f	file:
flow_wildcards_fold_minimask_range	.\lib\classifier.c	/^flow_wildcards_fold_minimask_range(struct flow_wildcards *wc,$/;"	f	file:
flow_wildcards_has_extra	.\lib\flow.c	/^flow_wildcards_has_extra(const struct flow_wildcards *a,$/;"	f
flow_wildcards_hash	.\lib\flow.c	/^flow_wildcards_hash(const struct flow_wildcards *wc, uint32_t basis)$/;"	f
flow_wildcards_init_catchall	.\lib\flow.c	/^flow_wildcards_init_catchall(struct flow_wildcards *wc)$/;"	f
flow_wildcards_is_catchall	.\lib\flow.c	/^flow_wildcards_is_catchall(const struct flow_wildcards *wc)$/;"	f
flow_wildcards_or	.\lib\flow.c	/^flow_wildcards_or(struct flow_wildcards *dst,$/;"	f
flow_wildcards_set_reg_mask	.\lib\flow.c	/^flow_wildcards_set_reg_mask(struct flow_wildcards *wc, int idx, uint32_t mask)$/;"	f
flow_zero_wildcards	.\lib\flow.c	/^flow_zero_wildcards(struct flow *flow, const struct flow_wildcards *wildcards)$/;"	f
flows	.\ofproto\netflow.c	/^    struct hmap flows;            \/* Contains 'netflow_flows'. *\/$/;"	m	struct:netflow	typeref:struct:netflow::hmap	file:
flush	.\ofproto\ofproto-dpif.c	/^flush(struct ofproto *ofproto_)$/;"	f	file:
flush	.\ofproto\ofproto-provider.h	/^    void (*flush)(struct ofproto *ofproto);$/;"	m	struct:ofproto_class
flush_help_string	.\tests\ovstest.c	/^flush_help_string(struct ds *ds)$/;"	f	file:
flushed_cbsets	.\lib\ovs-rcu.c	/^static struct guarded_list flushed_cbsets;$/;"	v	typeref:struct:guarded_list	file:
flushed_cbsets_seq	.\lib\ovs-rcu.c	/^static struct seq *flushed_cbsets_seq;$/;"	v	typeref:struct:seq	file:
fm	.\ofproto\ofproto-dpif-xlate.c	/^            struct ofputil_flow_mod *fm;$/;"	m	struct:xc_entry::__anon136::__anon141	typeref:struct:xc_entry::__anon136::__anon141::ofputil_flow_mod	file:
fmd	.\lib\ofp-util.h	/^    struct flow_metadata fmd;$/;"	m	struct:ofputil_packet_in	typeref:struct:ofputil_packet_in::flow_metadata
follow_symlinks	.\lib\util.c	/^follow_symlinks(const char *filename)$/;"	f
for_each_possible_cpu	.\datapath\linux\compat\include\linux\cpumask.h	8;"	d
for_each_txn_row	.\ovsdb\transaction.c	/^for_each_txn_row(struct ovsdb_txn *txn,$/;"	f	file:
forbid_forking	.\lib\ovs-thread.c	/^forbid_forking(const char *reason)$/;"	f
force_reconnect	.\python\ovs\db\idl.py	/^    def force_reconnect(self):$/;"	m	class:Idl
force_reconnect	.\python\ovs\jsonrpc.py	/^    def force_reconnect(self):$/;"	m	class:Session
force_reconnect	.\python\ovs\reconnect.py	/^    def force_reconnect(self, now):$/;"	m	class:Reconnect
force_status_commit	.\vswitchd\bridge.c	/^static bool force_status_commit = true;$/;"	v	file:
fork	.\python\ovs\fatal_signal.py	/^def fork():$/;"	f
fork_and_clean_up	.\lib\daemon-unix.c	/^fork_and_clean_up(void)$/;"	f	file:
fork_and_wait_for_startup	.\lib\daemon-unix.c	/^fork_and_wait_for_startup(int *fdp)$/;"	f	file:
fork_notify_startup	.\lib\daemon-unix.c	/^fork_notify_startup(int fd)$/;"	f	file:
format	.\include\openflow\nicira-ext.h	/^    ovs_be32 format;            \/* One of NXFF_*. *\/$/;"	m	struct:nx_set_flow_format
format	.\include\openflow\nicira-ext.h	/^    ovs_be32 format;            \/* One of NXPIF_*. *\/$/;"	m	struct:nx_set_packet_in_format
format	.\lib\table.h	/^    enum table_format format;   \/* TF_*. *\/$/;"	m	struct:table_style	typeref:enum:table_style::table_format
format	.\python\compat\argparse.py	/^        def format(tuple_size):$/;"	f	function:HelpFormatter._metavar_formatter
format_be16_masked	.\lib\match.c	/^format_be16_masked(struct ds *s, const char *name,$/;"	f	file:
format_be32_masked	.\lib\match.c	/^format_be32_masked(struct ds *s, const char *name,$/;"	f	file:
format_be64_masked	.\lib\match.c	/^format_be64_masked(struct ds *s, const char *name,$/;"	f	file:
format_eth_masked	.\lib\match.c	/^format_eth_masked(struct ds *s, const char *name, const uint8_t eth[6],$/;"	f	file:
format_flags	.\lib\flow.c	/^format_flags(struct ds *ds, const char *(*bit_to_string)(uint32_t),$/;"	f
format_flags_masked	.\lib\flow.c	/^format_flags_masked(struct ds *ds, const char *name,$/;"	f
format_flow_tunnel	.\lib\match.c	/^format_flow_tunnel(struct ds *s, const struct match *match)$/;"	f	file:
format_generic_odp_action	.\lib\odp-util.c	/^format_generic_odp_action(struct ds *ds, const struct nlattr *a)$/;"	f	file:
format_generic_odp_key	.\lib\odp-util.c	/^format_generic_odp_key(const struct nlattr *a, struct ds *ds)$/;"	f	file:
format_help	.\python\compat\argparse.py	/^        def format_help(self):$/;"	m	class:HelpFormatter._Section
format_help	.\python\compat\argparse.py	/^    def format_help(self):$/;"	m	class:ArgumentParser
format_help	.\python\compat\argparse.py	/^    def format_help(self):$/;"	m	class:HelpFormatter
format_ip_netmask	.\lib\match.c	/^format_ip_netmask(struct ds *s, const char *name, ovs_be32 ip,$/;"	f	file:
format_ipv6_addr	.\lib\packets.c	/^format_ipv6_addr(char *addr_str, const struct in6_addr *addr)$/;"	f
format_ipv6_netmask	.\lib\match.c	/^format_ipv6_netmask(struct ds *s, const char *name,$/;"	f	file:
format_log_message	.\lib\vlog.c	/^format_log_message(const struct vlog_module *module, enum vlog_level level,$/;"	f	file:
format_mpls	.\lib\odp-util.c	/^format_mpls(struct ds *ds, const struct ovs_key_mpls *mpls_key,$/;"	f	file:
format_mpls_lse	.\lib\odp-util.c	/^format_mpls_lse(struct ds *ds, ovs_be32 mpls_lse)$/;"	f	file:
format_nxm_field_name	.\lib\nx-match.c	/^format_nxm_field_name(struct ds *s, uint32_t header)$/;"	f	file:
format_odp_action	.\lib\odp-util.c	/^format_odp_action(struct ds *ds, const struct nlattr *a)$/;"	f	file:
format_odp_actions	.\lib\odp-util.c	/^format_odp_actions(struct ds *ds, const struct nlattr *actions,$/;"	f
format_odp_hash_action	.\lib\odp-util.c	/^format_odp_hash_action(struct ds *ds, const struct ovs_action_hash *hash_act)$/;"	f	file:
format_odp_key_attr	.\lib\odp-util.c	/^format_odp_key_attr(const struct nlattr *a, const struct nlattr *ma,$/;"	f	file:
format_odp_recirc_action	.\lib\odp-util.c	/^format_odp_recirc_action(struct ds *ds, uint32_t recirc_id)$/;"	f	file:
format_odp_sample_action	.\lib\odp-util.c	/^format_odp_sample_action(struct ds *ds, const struct nlattr *attr)$/;"	f	file:
format_odp_userspace_action	.\lib\odp-util.c	/^format_odp_userspace_action(struct ds *ds, const struct nlattr *attr)$/;"	f	file:
format_uint32_masked	.\lib\match.c	/^format_uint32_masked(struct ds *s, const char *name,$/;"	f	file:
format_usage	.\python\compat\argparse.py	/^    def format_usage(self):$/;"	m	class:ArgumentParser
format_version	.\python\compat\argparse.py	/^    def format_version(self):$/;"	m	class:ArgumentParser
format_vlan_tci	.\lib\odp-util.c	/^format_vlan_tci(struct ds *ds, ovs_be16 vlan_tci)$/;"	f	file:
forward_bpdu	.\ofproto\ofproto-dpif-xlate.c	/^    bool forward_bpdu;            \/* Bridge forwards STP BPDUs? *\/$/;"	m	struct:xbridge	file:
forward_bpdu	.\ofproto\ofproto-provider.h	/^    bool forward_bpdu;          \/* Option to allow forwarding of BPDU frames$/;"	m	struct:ofproto
forward_bpdu_changed	.\ofproto\ofproto-dpif.c	/^forward_bpdu_changed(struct ofproto *ofproto_)$/;"	f	file:
forward_bpdu_changed	.\ofproto\ofproto-provider.h	/^    void (*forward_bpdu_changed)(struct ofproto *ofproto);$/;"	m	struct:ofproto_class
forward_delay	.\lib\stp.c	/^    int forward_delay;              \/* 8.5.3.6: Delay between state changes. *\/$/;"	m	struct:stp	file:
forward_delay_timer	.\lib\stp.c	/^    struct stp_timer forward_delay_timer; \/* 8.5.6.2: State change timer. *\/$/;"	m	struct:stp_port	typeref:struct:stp_port::stp_timer	file:
forwarding_if_rx	.\lib\bfd.c	/^    bool forwarding_if_rx;$/;"	m	struct:bfd	file:
forwarding_if_rx_detect_time	.\lib\bfd.c	/^    long long int forwarding_if_rx_detect_time;$/;"	m	struct:bfd	file:
forwarding_override	.\lib\bfd.c	/^    int forwarding_override;      \/* Manual override of 'forwarding' status. *\/$/;"	m	struct:bfd	file:
fpv_accept	.\tests\test-vconn.c	/^fpv_accept(struct fake_pvconn *fpv)$/;"	f	file:
fpv_close	.\tests\test-vconn.c	/^fpv_close(struct fake_pvconn *fpv)$/;"	f	file:
fpv_create	.\tests\test-vconn.c	/^fpv_create(const char *type, struct fake_pvconn *fpv)$/;"	f	file:
fpv_destroy	.\tests\test-vconn.c	/^fpv_destroy(struct fake_pvconn *fpv)$/;"	f	file:
frag	.\datapath\flow.h	/^		u8     frag;		\/* One of OVS_FRAG_TYPE_*. *\/$/;"	m	struct:sw_flow_key::__anon3
frag	.\lib\packets.h	/^        } frag;$/;"	m	union:icmp_header::__anon87	typeref:struct:icmp_header::__anon87::__anon89
frag	.\ofproto\ofproto-dpif-xlate.c	/^    enum ofp_config_flags frag;   \/* Fragmentation handling. *\/$/;"	m	struct:xbridge	typeref:enum:xbridge::ofp_config_flags	file:
frag_handling	.\lib\meta-flow.c	/^struct frag_handling {$/;"	s	file:
frag_handling	.\ofproto\ofproto-provider.h	/^    enum ofp_config_flags frag_handling; \/* One of OFPC_*.  *\/$/;"	m	struct:ofproto	typeref:enum:ofproto::ofp_config_flags
frame	.\lib\ofpbuf.h	/^    void *frame;                \/* Packet frame start, or NULL. *\/$/;"	m	struct:ofpbuf
frame_length	.\lib\sflow.h	/^    u_int32_t frame_length;               \/* Original length of packet before sampling *\/$/;"	m	struct:_SFLSampled_header
frames	.\lib\backtrace.h	/^    uintptr_t frames[BACKTRACE_MAX_FRAMES];$/;"	m	struct:backtrace
freeFn	.\lib\sflow_api.h	/^    freeFn_t freeFn;$/;"	m	struct:_SFLAgent
freeFn_t	.\lib\sflow_api.h	/^typedef int (*freeFn_t)(void *magic,                  \/* callback to free space on heap *\/$/;"	t
free_buckets	.\datapath\flow_table.c	/^static void free_buckets(struct flex_array *buckets)$/;"	f	file:
free_cacheline	.\lib\util.c	/^free_cacheline(void *p)$/;"	f
free_data	.\lib\ovsdb-data.c	/^free_data(enum ovsdb_atomic_type type,$/;"	f	file:
free_dpdk_buf	.\lib\netdev-dpdk.c	/^free_dpdk_buf(struct ofpbuf *b)$/;"	f
free_dpdk_buf	.\lib\netdev-dpdk.h	/^free_dpdk_buf(struct ofpbuf *buf OVS_UNUSED)$/;"	f
free_key_value	.\lib\ovsdb-data.c	/^free_key_value(const struct ovsdb_type *type,$/;"	f	file:
free_monitor_row_data	.\ovsdb\jsonrpc-server.c	/^free_monitor_row_data(const struct ovsdb_jsonrpc_monitor_table *mt,$/;"	f	file:
free_poll_loop	.\lib\poll-loop.c	/^free_poll_loop(void *loop_)$/;"	f	file:
free_poll_nodes	.\lib\poll-loop.c	/^free_poll_nodes(struct poll_loop *loop)$/;"	f	file:
free_port_rcu	.\datapath\vport-netdev.c	/^static void free_port_rcu(struct rcu_head *rcu)$/;"	f	file:
free_registered_recs	.\vswitchd\bridge.c	/^free_registered_recs(void)$/;"	f	file:
free_rule	.\tests\test-classifier.c	/^free_rule(struct test_rule *rule)$/;"	f	file:
free_short_name	.\python\ovs\socket_util.py	/^def free_short_name(short_name):$/;"	f
free_slot	.\lib\fat-rwlock.c	/^free_slot(struct fat_rwlock_slot *slot)$/;"	f	file:
free_sockaddr_un	.\lib\socket-util.c	/^free_sockaddr_un(int dirfd, const char *linkname)$/;"	f	file:
free_vport_rcu	.\datapath\vport.c	/^static void free_vport_rcu(struct rcu_head *rcu)$/;"	f	file:
from_file	.\python\ovs\json.py	/^def from_file(name):$/;"	f
from_json	.\python\ovs\db\data.py	/^    def from_json(base, json, symtab=None):$/;"	m	class:Atom
from_json	.\python\ovs\db\data.py	/^    def from_json(type_, json, symtab=None):$/;"	m	class:Datum
from_json	.\python\ovs\db\schema.py	/^    def from_json(json):$/;"	m	class:DbSchema
from_json	.\python\ovs\db\schema.py	/^    def from_json(json):$/;"	m	class:IdlSchema
from_json	.\python\ovs\db\schema.py	/^    def from_json(json, name):$/;"	m	class:ColumnSchema
from_json	.\python\ovs\db\schema.py	/^    def from_json(json, name):$/;"	m	class:TableSchema
from_json	.\python\ovs\db\types.py	/^    def from_json(json):$/;"	m	class:AtomicType
from_json	.\python\ovs\db\types.py	/^    def from_json(json):$/;"	m	class:BaseType
from_json	.\python\ovs\db\types.py	/^    def from_json(json):$/;"	m	class:Type
from_json	.\python\ovs\jsonrpc.py	/^    def from_json(json):$/;"	m	class:Message
from_json	.\python\ovs\ovsuuid.py	/^def from_json(json, symtab=None):$/;"	f
from_python	.\python\ovs\db\data.py	/^    def from_python(base, value):$/;"	m	class:Atom
from_python	.\python\ovs\db\data.py	/^    def from_python(type_, value, row_to_uuid):$/;"	m	class:Datum
from_stream	.\python\ovs\json.py	/^def from_stream(stream):$/;"	f
from_string	.\python\ovs\db\types.py	/^    def from_string(s):$/;"	m	class:AtomicType
from_string	.\python\ovs\json.py	/^def from_string(s):$/;"	f
from_string	.\python\ovs\ovsuuid.py	/^def from_string(s):$/;"	f
fsSeqNo	.\tests\test-sflow.c	/^    uint32_t fsSeqNo;$/;"	m	struct:sflow_xdr	file:
fseeko	.\lib\stdio.c	/^fseeko(FILE *stream, off_t offset, int whence)$/;"	f
fsync	.\include\windows\unistd.h	19;"	d
fsync_parent_dir	.\lib\socket-util.c	/^fsync_parent_dir(const char *file_name)$/;"	f
fte	.\utilities\ovs-ofctl.c	/^struct fte {$/;"	s	file:
fte_free	.\utilities\ovs-ofctl.c	/^fte_free(struct fte *fte)$/;"	f	file:
fte_free_all	.\utilities\ovs-ofctl.c	/^fte_free_all(struct classifier *cls)$/;"	f	file:
fte_from_cls_rule	.\utilities\ovs-ofctl.c	/^fte_from_cls_rule(const struct cls_rule *cls_rule)$/;"	f	file:
fte_insert	.\utilities\ovs-ofctl.c	/^fte_insert(struct classifier *cls, const struct match *match,$/;"	f	file:
fte_make_flow_mod	.\utilities\ovs-ofctl.c	/^fte_make_flow_mod(const struct fte *fte, int index, uint16_t command,$/;"	f	file:
fte_version	.\utilities\ovs-ofctl.c	/^struct fte_version {$/;"	s	file:
fte_version_equals	.\utilities\ovs-ofctl.c	/^fte_version_equals(const struct fte_version *a, const struct fte_version *b)$/;"	f	file:
fte_version_format	.\utilities\ovs-ofctl.c	/^fte_version_format(const struct fte *fte, int index, struct ds *s)$/;"	f	file:
fte_version_free	.\utilities\ovs-ofctl.c	/^fte_version_free(struct fte_version *version)$/;"	f	file:
ftruncate	.\lib\util.c	/^ftruncate(int fd, off_t length)$/;"	f
full_name	.\lib\dpif-provider.h	/^    char *full_name;$/;"	m	struct:dpif
full_pri	.\tests\test-heap.c	/^    uint32_t full_pri;$/;"	m	struct:element	file:
func_append	.\build-aux\ltmain.sh	/^func_append ()$/;"	f
func_append_quoted	.\build-aux\ltmain.sh	/^func_append_quoted ()$/;"	f
func_arith	.\build-aux\ltmain.sh	/^func_arith ()$/;"	f
func_basename	.\build-aux\ltmain.sh	/^func_basename ()$/;"	f
func_check_version_match	.\build-aux\ltmain.sh	/^func_check_version_match ()$/;"	f
func_config	.\build-aux\ltmain.sh	/^func_config ()$/;"	f
func_convert_core_file_wine_to_w32	.\build-aux\ltmain.sh	/^func_convert_core_file_wine_to_w32 ()$/;"	f
func_convert_core_msys_to_w32	.\build-aux\ltmain.sh	/^func_convert_core_msys_to_w32 ()$/;"	f
func_convert_core_path_wine_to_w32	.\build-aux\ltmain.sh	/^func_convert_core_path_wine_to_w32 ()$/;"	f
func_convert_file_check	.\build-aux\ltmain.sh	/^func_convert_file_check ()$/;"	f
func_convert_file_cygwin_to_w32	.\build-aux\ltmain.sh	/^func_convert_file_cygwin_to_w32 ()$/;"	f
func_convert_file_msys_to_cygwin	.\build-aux\ltmain.sh	/^func_convert_file_msys_to_cygwin ()$/;"	f
func_convert_file_msys_to_w32	.\build-aux\ltmain.sh	/^func_convert_file_msys_to_w32 ()$/;"	f
func_convert_file_nix_to_cygwin	.\build-aux\ltmain.sh	/^func_convert_file_nix_to_cygwin ()$/;"	f
func_convert_file_nix_to_w32	.\build-aux\ltmain.sh	/^func_convert_file_nix_to_w32 ()$/;"	f
func_convert_file_noop	.\build-aux\ltmain.sh	/^func_convert_file_noop ()$/;"	f
func_convert_path_check	.\build-aux\ltmain.sh	/^func_convert_path_check ()$/;"	f
func_convert_path_cygwin_to_w32	.\build-aux\ltmain.sh	/^func_convert_path_cygwin_to_w32 ()$/;"	f
func_convert_path_front_back_pathsep	.\build-aux\ltmain.sh	/^func_convert_path_front_back_pathsep ()$/;"	f
func_convert_path_msys_to_cygwin	.\build-aux\ltmain.sh	/^func_convert_path_msys_to_cygwin ()$/;"	f
func_convert_path_msys_to_w32	.\build-aux\ltmain.sh	/^func_convert_path_msys_to_w32 ()$/;"	f
func_convert_path_nix_to_cygwin	.\build-aux\ltmain.sh	/^func_convert_path_nix_to_cygwin ()$/;"	f
func_convert_path_nix_to_w32	.\build-aux\ltmain.sh	/^func_convert_path_nix_to_w32 ()$/;"	f
func_convert_path_noop	.\build-aux\ltmain.sh	/^func_convert_path_noop ()$/;"	f
func_cygming_dll_for_implib	.\build-aux\ltmain.sh	/^func_cygming_dll_for_implib ()$/;"	f
func_cygming_dll_for_implib_fallback	.\build-aux\ltmain.sh	/^func_cygming_dll_for_implib_fallback ()$/;"	f
func_cygming_dll_for_implib_fallback_core	.\build-aux\ltmain.sh	/^func_cygming_dll_for_implib_fallback_core ()$/;"	f
func_cygming_gnu_implib_p	.\build-aux\ltmain.sh	/^func_cygming_gnu_implib_p ()$/;"	f
func_cygming_ms_implib_p	.\build-aux\ltmain.sh	/^func_cygming_ms_implib_p ()$/;"	f
func_cygpath	.\build-aux\ltmain.sh	/^func_cygpath ()$/;"	f
func_dirname	.\build-aux\ltmain.sh	/^func_dirname ()$/;"	f
func_dirname_and_basename	.\build-aux\ltmain.sh	/^func_dirname_and_basename ()$/;"	f
func_echo	.\build-aux\ltmain.sh	/^func_echo ()$/;"	f
func_echo_all	.\build-aux\ltmain.sh	/^func_echo_all ()$/;"	f
func_emit_cwrapperexe_src	.\build-aux\ltmain.sh	/^func_emit_cwrapperexe_src ()$/;"	f
func_emit_wrapper	.\build-aux\ltmain.sh	/^func_emit_wrapper ()$/;"	f
func_enable_tag	.\build-aux\ltmain.sh	/^func_enable_tag ()$/;"	f
func_error	.\build-aux\ltmain.sh	/^func_error ()$/;"	f
func_exec_program	.\build-aux\ltmain.sh	/^func_exec_program ()$/;"	f
func_exec_program_core	.\build-aux\ltmain.sh	/^func_exec_program_core ()$/;"	f
func_execute_cmds	.\build-aux\ltmain.sh	/^func_execute_cmds ()$/;"	f
func_extract_an_archive	.\build-aux\ltmain.sh	/^func_extract_an_archive ()$/;"	f
func_extract_archives	.\build-aux\ltmain.sh	/^func_extract_archives ()$/;"	f
func_fallback_echo	.\build-aux\ltmain.sh	/^func_fallback_echo ()$/;"	f
func_fatal_configuration	.\build-aux\ltmain.sh	/^func_fatal_configuration ()$/;"	f
func_fatal_error	.\build-aux\ltmain.sh	/^func_fatal_error ()$/;"	f
func_fatal_help	.\build-aux\ltmain.sh	/^func_fatal_help ()$/;"	f
func_features	.\build-aux\ltmain.sh	/^func_features ()$/;"	f
func_generate_dlsyms	.\build-aux\ltmain.sh	/^func_generate_dlsyms ()$/;"	f
func_grep	.\build-aux\ltmain.sh	/^func_grep ()$/;"	f
func_help	.\build-aux\ltmain.sh	/^func_help ()$/;"	f
func_infer_tag	.\build-aux\ltmain.sh	/^func_infer_tag ()$/;"	f
func_init_to_host_path_cmd	.\build-aux\ltmain.sh	/^func_init_to_host_path_cmd ()$/;"	f
func_lalib_p	.\build-aux\ltmain.sh	/^func_lalib_p ()$/;"	f
func_lalib_unsafe_p	.\build-aux\ltmain.sh	/^func_lalib_unsafe_p ()$/;"	f
func_len	.\build-aux\ltmain.sh	/^func_len ()$/;"	f
func_lo2o	.\build-aux\ltmain.sh	/^func_lo2o ()$/;"	f
func_lt_dump_args	.\build-aux\ltmain.sh	/^func_lt_dump_args ()$/;"	f
func_ltwrapper_executable_p	.\build-aux\ltmain.sh	/^func_ltwrapper_executable_p ()$/;"	f
func_ltwrapper_p	.\build-aux\ltmain.sh	/^func_ltwrapper_p ()$/;"	f
func_ltwrapper_script_p	.\build-aux\ltmain.sh	/^func_ltwrapper_script_p ()$/;"	f
func_ltwrapper_scriptname	.\build-aux\ltmain.sh	/^func_ltwrapper_scriptname ()$/;"	f
func_missing_arg	.\build-aux\ltmain.sh	/^func_missing_arg ()$/;"	f
func_mkdir_p	.\build-aux\ltmain.sh	/^func_mkdir_p ()$/;"	f
func_mktempdir	.\build-aux\ltmain.sh	/^func_mktempdir ()$/;"	f
func_mode_compile	.\build-aux\ltmain.sh	/^func_mode_compile ()$/;"	f
func_mode_execute	.\build-aux\ltmain.sh	/^func_mode_execute ()$/;"	f
func_mode_finish	.\build-aux\ltmain.sh	/^func_mode_finish ()$/;"	f
func_mode_help	.\build-aux\ltmain.sh	/^func_mode_help ()$/;"	f
func_mode_install	.\build-aux\ltmain.sh	/^func_mode_install ()$/;"	f
func_mode_link	.\build-aux\ltmain.sh	/^func_mode_link ()$/;"	f
func_mode_uninstall	.\build-aux\ltmain.sh	/^func_mode_uninstall ()$/;"	f
func_normal_abspath	.\build-aux\ltmain.sh	/^func_normal_abspath ()$/;"	f
func_parse_lt_options	.\build-aux\ltmain.sh	/^func_parse_lt_options ()$/;"	f
func_quote_for_eval	.\build-aux\ltmain.sh	/^func_quote_for_eval ()$/;"	f
func_quote_for_expand	.\build-aux\ltmain.sh	/^func_quote_for_expand ()$/;"	f
func_relative_path	.\build-aux\ltmain.sh	/^func_relative_path ()$/;"	f
func_replace_sysroot	.\build-aux\ltmain.sh	/^func_replace_sysroot ()$/;"	f
func_resolve_sysroot	.\build-aux\ltmain.sh	/^func_resolve_sysroot ()$/;"	f
func_show_eval	.\build-aux\ltmain.sh	/^func_show_eval ()$/;"	f
func_show_eval_locale	.\build-aux\ltmain.sh	/^func_show_eval_locale ()$/;"	f
func_source	.\build-aux\ltmain.sh	/^func_source ()$/;"	f
func_split_long_opt	.\build-aux\ltmain.sh	/^func_split_long_opt ()$/;"	f
func_split_short_opt	.\build-aux\ltmain.sh	/^func_split_short_opt ()$/;"	f
func_stripname	.\build-aux\ltmain.sh	/^func_stripname ()$/;"	f
func_to_host_file	.\build-aux\ltmain.sh	/^func_to_host_file ()$/;"	f
func_to_host_path	.\build-aux\ltmain.sh	/^func_to_host_path ()$/;"	f
func_to_tool_file	.\build-aux\ltmain.sh	/^func_to_tool_file ()$/;"	f
func_tr_sh	.\build-aux\ltmain.sh	/^func_tr_sh ()$/;"	f
func_usage	.\build-aux\ltmain.sh	/^func_usage ()$/;"	f
func_verbose	.\build-aux\ltmain.sh	/^func_verbose ()$/;"	f
func_version	.\build-aux\ltmain.sh	/^func_version ()$/;"	f
func_warning	.\build-aux\ltmain.sh	/^func_warning ()$/;"	f
func_win32_import_lib_p	.\build-aux\ltmain.sh	/^func_win32_import_lib_p ()$/;"	f
func_win32_libid	.\build-aux\ltmain.sh	/^func_win32_libid ()$/;"	f
func_write_libtool_object	.\build-aux\ltmain.sh	/^func_write_libtool_object ()$/;"	f
func_xform	.\build-aux\ltmain.sh	/^func_xform ()$/;"	f
function	.\lib\ovs-rcu.c	/^    void (*function)(void *aux);$/;"	m	struct:ovsrcu_cb	file:
function	.\ovsdb\condition.h	/^    enum ovsdb_function function;$/;"	m	struct:ovsdb_clause	typeref:enum:ovsdb_clause::ovsdb_function
function	.\tests\test-lockfile.c	/^    void (*function)(void);$/;"	m	struct:test	file:
fwd_delay	.\ofproto\ofproto.h	/^    uint16_t fwd_delay;$/;"	m	struct:ofproto_stp_settings
gateway	.\lib\packets.h	/^        ovs_16aligned_be32 gateway;$/;"	m	union:icmp_header::__anon87
gateway	.\lib\sflow.h	/^    SFLExtended_gateway gateway;$/;"	m	union:_SFLFlow_type
gatewayEncodingLength	.\lib\sflow_receiver.c	/^inline static u_int32_t gatewayEncodingLength(SFLExtended_gateway *gw) {$/;"	f	file:
gcd	.\lib\getopt_long.c	/^gcd(int a, int b)$/;"	f	file:
generate_all_wildcard_mask	.\lib\odp-util.c	/^generate_all_wildcard_mask(struct ofpbuf *ofp, const struct nlattr *key)$/;"	f	file:
generate_discriminator	.\lib\bfd.c	/^generate_discriminator(void)$/;"	f	file:
generation_id	.\include\openflow\openflow-1.2.h	/^    ovs_be64 generation_id;   \/* Master Election Generation Id *\/$/;"	m	struct:ofp12_role_request
generation_id	.\include\openflow\openflow-1.4.h	/^    ovs_be64 generation_id;     \/* Master Election Generation Id *\/$/;"	m	struct:ofp14_role_status
generation_id	.\lib\ofp-util.h	/^    uint64_t generation_id;$/;"	m	struct:ofputil_role_request
generation_id	.\lib\ofp-util.h	/^    uint64_t generation_id;$/;"	m	struct:ofputil_role_status
generic	.\lib\sflow.h	/^    SFLIf_counters generic;$/;"	m	union:_SFLCounters_type
genl_families	.\lib\netlink-socket.c	/^static struct hmap genl_families = HMAP_INITIALIZER(&genl_families);$/;"	v	typeref:struct:hmap	file:
genl_family	.\datapath\linux\compat\include\net\genetlink.h	46;"	d
genl_family	.\lib\netlink-socket.c	/^struct genl_family {$/;"	s	file:
genl_family_to_name	.\lib\netlink-socket.c	/^genl_family_to_name(uint16_t id)$/;"	f	file:
genl_notify	.\datapath\linux\compat\genetlink-openvswitch.c	6;"	d	file:
genl_notify	.\datapath\linux\compat\include\net\genetlink.h	47;"	d
genl_register_family	.\datapath\linux\compat\include\net\genetlink.h	90;"	d
genl_set_err	.\datapath\linux\compat\include\net\genetlink.h	/^static inline int genl_set_err(struct genl_family *family, struct net *net,$/;"	f
genl_set_err	.\datapath\linux\compat\include\net\genetlink.h	66;"	d
genl_unregister_family	.\datapath\linux\compat\include\net\genetlink.h	64;"	d
genlmsg_multicast_netns	.\datapath\linux\compat\include\net\genetlink.h	/^static inline int genlmsg_multicast_netns(struct genl_family *family,$/;"	f
genlmsg_multicast_netns	.\datapath\linux\compat\include\net\genetlink.h	78;"	d
genlmsg_new_unicast	.\datapath\linux\compat\include\net\genetlink.h	/^static inline struct sk_buff *genlmsg_new_unicast(size_t payload,$/;"	f
genlmsg_put	.\datapath\linux\compat\include\net\genetlink.h	58;"	d
genlmsghdr	.\lib\netlink-protocol.h	/^struct genlmsghdr {$/;"	s
get	.\python\ovs\db\data.py	/^    def get(self, key, default=None):$/;"	m	class:Datum
get	.\python\ovs\db\parser.py	/^    def get(self, name, types):$/;"	m	class:Parser
getController	.\xenserver\usr_lib_xsconsole_plugins-base_XSFeatureVSwitch.py	/^    def getController(self):$/;"	m	class:VSwitchControllerDialogue
getCountersFn	.\lib\sflow_api.h	/^    getCountersFn_t getCountersFn;$/;"	m	struct:_SFLPoller
getCountersFn_t	.\lib\sflow_api.h	/^typedef void (*getCountersFn_t)(void *magic,                   \/* callback to get counters *\/$/;"	t
getDOMImplementation	.\xenserver\opt_xensource_libexec_InterfaceReconfigure.py	/^from xml.dom.minidom import getDOMImplementation$/;"	i
getResults	.\python\ovstest\tcp.py	/^    def getResults(self):$/;"	m	class:TcpListenerFactory
getResults	.\python\ovstest\tcp.py	/^    def getResults(self):$/;"	m	class:TcpSenderFactory
getResults	.\python\ovstest\udp.py	/^    def getResults(self):$/;"	m	class:UdpListener
getResults	.\python\ovstest\udp.py	/^    def getResults(self):$/;"	m	class:UdpSender
getText	.\xenserver\opt_xensource_libexec_InterfaceReconfigure.py	/^    def getText(nodelist):$/;"	f	function:_str_from_xml
get_16aligned_be32	.\lib\unaligned.h	/^get_16aligned_be32(const ovs_16aligned_be32 *x)$/;"	f
get_16aligned_u32	.\lib\unaligned.h	/^get_16aligned_u32(const ovs_16aligned_u32 *x)$/;"	f
get_32aligned_be64	.\lib\unaligned.h	/^get_32aligned_be64(const ovs_32aligned_be64 *x)$/;"	f
get_32aligned_u64	.\lib\unaligned.h	/^get_32aligned_u64(const ovs_32aligned_u64 *x)$/;"	f
get_actions_for_flow	.\utilities\ovs-dpctl.c	/^get_actions_for_flow(struct hmap *actions_per_flow, const struct flow *flow)$/;"	f	file:
get_actions_from_instruction	.\lib\ofp-actions.c	/^get_actions_from_instruction(const struct ofp11_instruction *inst,$/;"	f	file:
get_all	.\tests\MockXenAPI.py	/^    def get_all(self):$/;"	m	class:Table
get_all_commands	.\ovsdb\ovsdb-client.c	/^static const struct ovsdb_client_command *get_all_commands(void)$/;"	f	file:
get_all_commands	.\ovsdb\ovsdb-tool.c	/^static const struct command *get_all_commands(void)$/;"	f	file:
get_all_commands	.\tests\test-jsonrpc.c	/^get_all_commands(void)$/;"	f	file:
get_all_commands	.\tests\test-ovsdb.c	/^get_all_commands(void)$/;"	f	file:
get_all_commands	.\tests\test-reconnect.c	/^get_all_commands(void)$/;"	f	file:
get_all_commands	.\utilities\ovs-benchmark.c	/^static const struct command *get_all_commands(void)$/;"	f	file:
get_all_commands	.\utilities\ovs-dpctl.c	/^static const struct command *get_all_commands(void)$/;"	f	file:
get_all_commands	.\utilities\ovs-ofctl.c	/^static const struct command *get_all_commands(void)$/;"	f	file:
get_all_commands	.\utilities\ovs-vsctl.c	/^static const struct vsctl_command_syntax *get_all_commands(void)$/;"	f	file:
get_all_commands	.\vtep\vtep-ctl.c	/^get_all_commands(void)$/;"	f	file:
get_all_pifs	.\xenserver\opt_xensource_libexec_InterfaceReconfigure.py	/^    def get_all_pifs(self):$/;"	m	class:DatabaseCache
get_all_records_where	.\tests\MockXenAPI.py	/^    def get_all_records_where(self, condition):$/;"	m	class:Table
get_allowed_ofp_versions	.\lib\ofp-version-opt.c	/^get_allowed_ofp_versions(void)$/;"	f
get_backlog	.\python\ovs\jsonrpc.py	/^    def get_backlog(self):$/;"	m	class:Connection
get_backlog	.\python\ovs\jsonrpc.py	/^    def get_backlog(self):$/;"	m	class:Session
get_be16	.\lib\learn.c	/^get_be16(const void **pp)$/;"	f	file:
get_be32	.\lib\learn.c	/^get_be32(const void **pp)$/;"	f	file:
get_bfd_status	.\ofproto\ofproto-dpif.c	/^get_bfd_status(struct ofport *ofport_, bool force, struct smap *smap)$/;"	f	file:
get_bfd_status	.\ofproto\ofproto-provider.h	/^    int (*get_bfd_status)(struct ofport *ofport, bool force, struct smap *smap);$/;"	m	struct:ofproto_class
get_bit_at	.\lib\classifier.c	/^get_bit_at(const uint32_t prefix, unsigned int ofs)$/;"	f	file:
get_bond_record	.\xenserver\opt_xensource_libexec_InterfaceReconfigure.py	/^    def get_bond_record(self, bond):$/;"	m	class:DatabaseCache
get_boot_time	.\vswitchd\system-stats.c	/^get_boot_time(void)$/;"	f	file:
get_by_uuid	.\tests\MockXenAPI.py	/^    def get_by_uuid(self, uuid):$/;"	m	class:Table
get_bytes	.\python\compat\uuid.py	/^    def get_bytes(self):$/;"	m	class:UUID
get_bytes_le	.\python\compat\uuid.py	/^    def get_bytes_le(self):$/;"	m	class:UUID
get_carrier	.\lib\netdev-provider.h	/^    int (*get_carrier)(const struct netdev *netdev, bool *carrier);$/;"	m	struct:netdev_class
get_carrier_resets	.\lib\netdev-provider.h	/^    long long int (*get_carrier_resets)(const struct netdev *netdev);$/;"	m	struct:netdev_class
get_cfm_status	.\ofproto\ofproto-dpif.c	/^get_cfm_status(const struct ofport *ofport_, bool force,$/;"	f	file:
get_cfm_status	.\ofproto\ofproto-provider.h	/^    int (*get_cfm_status)(const struct ofport *ofport, bool force,$/;"	m	struct:ofproto_class
get_clock_seq	.\python\compat\uuid.py	/^    def get_clock_seq(self):$/;"	m	class:UUID
get_clock_seq_hi_variant	.\python\compat\uuid.py	/^    def get_clock_seq_hi_variant(self):$/;"	m	class:UUID
get_clock_seq_low	.\python\compat\uuid.py	/^    def get_clock_seq_low(self):$/;"	m	class:UUID
get_column	.\utilities\ovs-vsctl.c	/^get_column(const struct vsctl_table_class *table, const char *column_name,$/;"	f	file:
get_column	.\vtep\vtep-ctl.c	/^get_column(const struct vtep_ctl_table_class *table, const char *column_name,$/;"	f	file:
get_config	.\lib\netdev-provider.h	/^    int (*get_config)(const struct netdev *netdev, struct smap *args);$/;"	m	struct:netdev_class
get_cpu_cores	.\vswitchd\system-stats.c	/^get_cpu_cores(struct smap *stats)$/;"	f	file:
get_cpu_tracker	.\lib\timeval.c	/^get_cpu_tracker(void)$/;"	f	file:
get_cpu_usage	.\lib\timeval.c	/^get_cpu_usage(void)$/;"	f
get_cwd	.\lib\util.c	/^get_cwd(void)$/;"	f
get_datagram_sizes	.\python\ovstest\util.py	/^def get_datagram_sizes(mtu1, mtu2):$/;"	f
get_datum	.\ovsdb\ovsdb-server.c	/^get_datum(struct ovsdb_row *row, const char *column_name,$/;"	f	file:
get_default	.\python\compat\argparse.py	/^    def get_default(self, dest):$/;"	m	class:_ActionsContainer
get_detach	.\lib\daemon.c	/^get_detach(void)$/;"	f
get_detach	.\python\ovs\daemon.py	/^def get_detach():$/;"	f
get_dp	.\datapath\datapath.c	/^static struct datapath *get_dp(struct net *net, int dp_ifindex)$/;"	f	file:
get_dp_netdev	.\lib\dpif-netdev.c	/^get_dp_netdev(const struct dpif *dpif)$/;"	f	file:
get_dp_stats	.\datapath\datapath.c	/^static void get_dp_stats(struct datapath *dp, struct ovs_dp_stats *stats,$/;"	f	file:
get_dpdev	.\datapath\vport-netdev.c	/^static struct net_device *get_dpdev(struct datapath *dp)$/;"	f	file:
get_dpif_flow_stats	.\lib\dpif-netdev.c	/^get_dpif_flow_stats(struct dp_netdev_flow *netdev_flow,$/;"	f	file:
get_dpifindex	.\datapath\datapath.c	/^static int get_dpifindex(struct datapath *dp)$/;"	f	file:
get_driver	.\python\ovstest\util.py	/^def get_driver(iface):$/;"	f
get_enabled_slave	.\ofproto\bond.c	/^get_enabled_slave(struct bond *bond)$/;"	f	file:
get_entropy	.\lib\entropy.c	/^get_entropy(void *buffer, size_t n)$/;"	f
get_entropy_or_die	.\lib\entropy.c	/^get_entropy_or_die(void *buffer, size_t n)$/;"	f
get_enum_type	.\python\ovs\db\types.py	/^    def get_enum_type(atomic_type):$/;"	m	class:BaseType
get_error	.\python\ovs\db\idl.py	/^    def get_error(self):$/;"	m	class:Transaction
get_etheraddr	.\lib\netdev-bsd.c	/^get_etheraddr(const char *netdev_name, uint8_t ea[ETH_ADDR_LEN])$/;"	f	file:
get_etheraddr	.\lib\netdev-linux.c	/^get_etheraddr(const char *netdev_name, uint8_t ea[ETH_ADDR_LEN])$/;"	f	file:
get_etheraddr	.\lib\netdev-provider.h	/^    int (*get_etheraddr)(const struct netdev *netdev, uint8_t mac[6]);$/;"	m	struct:netdev_class
get_exception_errno	.\python\ovs\socket_util.py	/^def get_exception_errno(e):$/;"	f
get_export_time_now	.\ofproto\ofproto-dpif-ipfix.c	/^get_export_time_now(uint64_t *export_time_usec, uint32_t *export_time_sec)$/;"	f	file:
get_external_id	.\utilities\ovs-vsctl.c	/^get_external_id(struct smap *smap, const char *prefix, const char *key,$/;"	f	file:
get_features	.\lib\netdev-provider.h	/^    int (*get_features)(const struct netdev *netdev,$/;"	m	struct:netdev_class
get_features	.\ofproto\ofproto-dpif.c	/^get_features(struct ofproto *ofproto_ OVS_UNUSED,$/;"	f	file:
get_features	.\ofproto\ofproto-provider.h	/^    void (*get_features)(struct ofproto *ofproto,$/;"	m	struct:ofproto_class
get_features_error	.\lib\netdev-linux.c	/^    int get_features_error;     \/* Cached error code from ETHTOOL_GSET. *\/$/;"	m	struct:netdev_linux	file:
get_fields	.\python\compat\uuid.py	/^    def get_fields(self):$/;"	m	class:UUID
get_filesys_stats	.\vswitchd\system-stats.c	/^get_filesys_stats(struct smap *stats OVS_UNUSED)$/;"	f	file:
get_flags	.\lib\netdev-bsd.c	/^get_flags(const struct netdev *netdev, int *flags)$/;"	f	file:
get_flags	.\lib\netdev-linux.c	/^get_flags(const struct netdev *dev, unsigned int *flags)$/;"	f	file:
get_hex	.\python\compat\uuid.py	/^    def get_hex(self):$/;"	m	class:UUID
get_idl_schema	.\python\ovs\db\idl.py	/^    def get_idl_schema(self):$/;"	m	class:SchemaHelper
get_ifindex	.\lib\netdev-bsd.c	/^get_ifindex(const struct netdev *netdev_, int *ifindexp)$/;"	f	file:
get_ifindex	.\lib\netdev-linux.c	/^get_ifindex(const struct netdev *netdev_, int *ifindexp)$/;"	f	file:
get_ifindex	.\lib\netdev-provider.h	/^    int (*get_ifindex)(const struct netdev *netdev);$/;"	m	struct:netdev_class
get_ifindex_error	.\lib\netdev-linux.c	/^    int get_ifindex_error;      \/* Cached error code from SIOCGIFINDEX. *\/$/;"	m	struct:netdev_linux	file:
get_in4	.\lib\netdev-provider.h	/^    int (*get_in4)(const struct netdev *netdev, struct in_addr *address,$/;"	m	struct:netdev_class
get_in6	.\lib\netdev-provider.h	/^    int (*get_in6)(const struct netdev *netdev, struct in6_addr *in6);$/;"	m	struct:netdev_class
get_increment_new_value	.\python\ovs\db\idl.py	/^    def get_increment_new_value(self):$/;"	m	class:Transaction
get_insert_uuid	.\python\ovs\db\idl.py	/^    def get_insert_uuid(self, uuid):$/;"	m	class:Transaction
get_int	.\tests\test-stp.c	/^get_int(int *intp)$/;"	f	file:
get_interface	.\python\ovstest\util.py	/^def get_interface(address):$/;"	f
get_interface_from_routing_decision	.\python\ovstest\util.py	/^def get_interface_from_routing_decision(ip):$/;"	f
get_interface_mtu	.\python\ovstest\util.py	/^def get_interface_mtu(iface):$/;"	f
get_last_connect_elapsed	.\python\ovs\reconnect.py	/^    def get_last_connect_elapsed(self, now):$/;"	m	class:Reconnect
get_last_disconnect_elapsed	.\python\ovs\reconnect.py	/^    def get_last_disconnect_elapsed(self, now):$/;"	m	class:Reconnect
get_level	.\python\ovs\vlog.py	/^def get_level(level_str):$/;"	f
get_levels	.\python\ovs\vlog.py	/^    def get_levels():$/;"	m	class:Vlog
get_lines	.\python\compat\argparse.py	/^                def get_lines(parts, indent, prefix=None):$/;"	f	function:HelpFormatter._format_usage
get_load_average	.\vswitchd\system-stats.c	/^get_load_average(struct smap *stats OVS_UNUSED)$/;"	f	file:
get_log_destination	.\xenserver\opt_xensource_libexec_InterfaceReconfigure.py	/^def get_log_destination():$/;"	f
get_management_pif	.\xenserver\opt_xensource_libexec_InterfaceReconfigure.py	/^    def get_management_pif(self):$/;"	m	class:DatabaseCache
get_max_backoff	.\python\ovs\reconnect.py	/^    def get_max_backoff(self):$/;"	m	class:Reconnect
get_max_fds	.\lib\process.c	/^get_max_fds(void)$/;"	f	file:
get_max_tries	.\python\ovs\reconnect.py	/^    def get_max_tries(self):$/;"	m	class:Reconnect
get_memory_stats	.\vswitchd\system-stats.c	/^get_memory_stats(struct smap *stats)$/;"	f	file:
get_memory_usage	.\ofproto\ofproto-provider.h	/^    void (*get_memory_usage)(const struct ofproto *ofproto,$/;"	m	struct:ofproto_class
get_min_backoff	.\python\ovs\reconnect.py	/^    def get_min_backoff(self):$/;"	m	class:Reconnect
get_mtime	.\lib\socket-util.c	/^get_mtime(const char *file_name, struct timespec *mtime)$/;"	f
get_mtu	.\lib\netdev-provider.h	/^    int (*get_mtu)(const struct netdev *netdev, int *mtup);$/;"	m	struct:netdev_class
get_name	.\datapath\vport.h	/^	const char *(*get_name)(const struct vport *);$/;"	m	struct:vport_ops
get_name	.\python\ovs\jsonrpc.py	/^    def get_name(self):$/;"	m	class:Session
get_name	.\python\ovs\reconnect.py	/^    def get_name(self):$/;"	m	class:Reconnect
get_netdev_tunnel_config	.\lib\netdev-vport.c	/^get_netdev_tunnel_config(const struct netdev *netdev)$/;"	f	file:
get_netflow_ids	.\ofproto\ofproto-dpif.c	/^get_netflow_ids(const struct ofproto *ofproto_,$/;"	f	file:
get_netflow_ids	.\ofproto\ofproto-provider.h	/^    void (*get_netflow_ids)(const struct ofproto *ofproto,$/;"	m	struct:ofproto_class
get_network_by_bridge	.\xenserver\opt_xensource_libexec_InterfaceReconfigure.py	/^    def get_network_by_bridge(self, bridge):$/;"	m	class:DatabaseCache
get_network_record	.\xenserver\opt_xensource_libexec_InterfaceReconfigure.py	/^    def get_network_record(self, network):$/;"	m	class:DatabaseCache
get_networks_with_bridge	.\xenserver\opt_xensource_libexec_InterfaceReconfigure.py	/^    def get_networks_with_bridge(self, bridge):$/;"	m	class:DatabaseCache
get_next_hop	.\lib\netdev-provider.h	/^    int (*get_next_hop)(const struct in_addr *host, struct in_addr *next_hop,$/;"	m	struct:netdev_class
get_node	.\python\compat\uuid.py	/^    def get_node(self):$/;"	m	class:UUID
get_null_fd	.\lib\daemon.c	/^get_null_fd(void)$/;"	f	file:
get_null_fd	.\python\ovs\socket_util.py	/^def get_null_fd():$/;"	f
get_ofp_port	.\ofproto\ofproto-dpif-xlate.c	/^get_ofp_port(const struct xbridge *xbridge, ofp_port_t ofp_port)$/;"	f	file:
get_ofp_port	.\ofproto\ofproto-dpif.c	/^get_ofp_port(const struct ofproto_dpif *ofproto, ofp_port_t ofp_port)$/;"	f	file:
get_ofprotos	.\ofproto\ofproto-dpif.c	/^get_ofprotos(struct shash *ofproto_shash)$/;"	f	file:
get_one_dp	.\utilities\ovs-dpctl.c	/^get_one_dp(void)$/;"	f	file:
get_optional	.\python\ovs\db\parser.py	/^    def get_optional(self, name, types, default=None):$/;"	m	class:Parser
get_options	.\datapath\vport.h	/^	int (*get_options)(const struct vport *, struct sk_buff *);$/;"	m	struct:vport_ops
get_page_size	.\vswitchd\system-stats.c	/^get_page_size(void)$/;"	f	file:
get_patch_config	.\lib\netdev-vport.c	/^get_patch_config(const struct netdev *dev_, struct smap *args)$/;"	f	file:
get_pif_by_bridge	.\xenserver\opt_xensource_libexec_InterfaceReconfigure.py	/^    def get_pif_by_bridge(self, bridge):$/;"	m	class:DatabaseCache
get_pif_by_uuid	.\xenserver\opt_xensource_libexec_InterfaceReconfigure.py	/^    def get_pif_by_uuid(self, uuid):$/;"	m	class:DatabaseCache
get_pif_record	.\xenserver\opt_xensource_libexec_InterfaceReconfigure.py	/^    def get_pif_record(self, pif):$/;"	m	class:DatabaseCache
get_pifs_by_device	.\xenserver\opt_xensource_libexec_InterfaceReconfigure.py	/^    def get_pifs_by_device(self, device):$/;"	m	class:DatabaseCache
get_pool_record	.\xenserver\opt_xensource_libexec_InterfaceReconfigure.py	/^    def get_pool_record(self):$/;"	m	class:DatabaseCache
get_port_number	.\utilities\ovs-dpctl.c	/^get_port_number(struct dpif *dpif, const char *name, odp_port_t *port)$/;"	f	file:
get_probe_interval	.\python\ovs\reconnect.py	/^    def get_probe_interval(self):$/;"	m	class:Reconnect
get_process_info	.\vswitchd\system-stats.c	/^get_process_info(pid_t pid, struct process_info *pinfo)$/;"	f	file:
get_process_stats	.\vswitchd\system-stats.c	/^get_process_stats(struct smap *stats)$/;"	f	file:
get_program_version	.\lib\util.c	/^get_program_version(void)$/;"	f
get_provider_meter_id	.\ofproto\ofproto.c	/^get_provider_meter_id(const struct ofproto *ofproto, uint32_t of_meter_id)$/;"	f	file:
get_qos	.\lib\netdev-provider.h	/^    int (*get_qos)(const struct netdev *netdev,$/;"	m	struct:netdev_class
get_qos_capabilities	.\lib\netdev-provider.h	/^    int (*get_qos_capabilities)(const struct netdev *netdev,$/;"	m	struct:netdev_class
get_qos_types	.\lib\netdev-provider.h	/^    int (*get_qos_types)(const struct netdev *netdev, struct sset *types);$/;"	m	struct:netdev_class
get_queue	.\lib\netdev-provider.h	/^    int (*get_queue)(const struct netdev *netdev,$/;"	m	struct:netdev_class
get_queue_id	.\lib\learning-switch.c	/^get_queue_id(const struct lswitch *sw, ofp_port_t in_port)$/;"	f	file:
get_queue_stats	.\lib\netdev-provider.h	/^    int (*get_queue_stats)(const struct netdev *netdev, unsigned int queue_id,$/;"	m	struct:netdev_class
get_raw_process_info	.\vswitchd\system-stats.c	/^get_raw_process_info(pid_t pid, struct raw_process_info *raw)$/;"	f	file:
get_received_bytes	.\python\ovs\jsonrpc.py	/^    def get_received_bytes(self):$/;"	m	class:Connection
get_recent_rusage	.\lib\timeval.c	/^get_recent_rusage(void)$/;"	f	file:
get_record	.\tests\MockXenAPI.py	/^    def get_record(self, record_ref):$/;"	m	class:Table
get_row	.\utilities\ovs-vsctl.c	/^get_row (struct vsctl_context *ctx,$/;"	f	file:
get_row	.\vtep\vtep-ctl.c	/^get_row (struct vtep_ctl_context *ctx,$/;"	f	file:
get_row_by_id	.\utilities\ovs-vsctl.c	/^get_row_by_id(struct vsctl_context *ctx, const struct vsctl_table_class *table,$/;"	f	file:
get_row_by_id	.\vtep\vtep-ctl.c	/^get_row_by_id(struct vtep_ctl_context *ctx, const struct vtep_ctl_table_class *table,$/;"	f	file:
get_seqno	.\python\ovs\jsonrpc.py	/^    def get_seqno(self):$/;"	m	class:Session
get_skb_priority	.\ofproto\ofproto-dpif-xlate.c	/^get_skb_priority(const struct xport *xport, uint32_t skb_priority)$/;"	f	file:
get_socket_rcvbuf	.\lib\socket-util.c	/^get_socket_rcvbuf(int sock)$/;"	f
get_src_port	.\datapath\vport-lisp.c	/^static u16 get_src_port(struct net *net, struct sk_buff *skb)$/;"	f	file:
get_stats	.\lib\dpif-provider.h	/^    int (*get_stats)(const struct dpif *dpif, struct dpif_dp_stats *stats);$/;"	m	struct:dpif_class
get_stats	.\lib\netdev-provider.h	/^    int (*get_stats)(const struct netdev *netdev, struct netdev_stats *);$/;"	m	struct:netdev_class
get_stats	.\lib\netdev-vport.c	/^get_stats(const struct netdev *netdev, struct netdev_stats *stats)$/;"	f	file:
get_stats	.\python\ovs\reconnect.py	/^    def get_stats(self, now):$/;"	m	class:Reconnect
get_stats_via_netlink	.\lib\netdev-linux.c	/^get_stats_via_netlink(const struct netdev *netdev_, struct netdev_stats *stats)$/;"	f	file:
get_stats_via_vport	.\lib\netdev-linux.c	/^get_stats_via_vport(const struct netdev *netdev_,$/;"	f	file:
get_stats_via_vport__	.\lib\netdev-linux.c	/^get_stats_via_vport__(const struct netdev *netdev, struct netdev_stats *stats)$/;"	f	file:
get_status	.\lib\netdev-provider.h	/^    int (*get_status)(const struct netdev *netdev, struct smap *smap);$/;"	m	struct:netdev_class
get_status	.\python\ovs\jsonrpc.py	/^    def get_status(self):$/;"	m	class:Connection
get_stp_port_stats	.\ofproto\ofproto-dpif.c	/^get_stp_port_stats(struct ofport *ofport_,$/;"	f	file:
get_stp_port_stats	.\ofproto\ofproto-provider.h	/^    int (*get_stp_port_stats)(struct ofport *ofport,$/;"	m	struct:ofproto_class
get_stp_port_status	.\ofproto\ofproto-dpif.c	/^get_stp_port_status(struct ofport *ofport_,$/;"	f	file:
get_stp_port_status	.\ofproto\ofproto-provider.h	/^    int (*get_stp_port_status)(struct ofport *ofport,$/;"	m	struct:ofproto_class
get_stp_status	.\ofproto\ofproto-dpif.c	/^get_stp_status(struct ofproto *ofproto_, struct ofproto_stp_status *s)$/;"	f	file:
get_stp_status	.\ofproto\ofproto-provider.h	/^    int (*get_stp_status)(struct ofproto *ofproto,$/;"	m	struct:ofproto_class
get_subfield	.\lib\learn.c	/^get_subfield(int n_bits, const void **p, struct mf_subfield *sf)$/;"	f	file:
get_subprogram_name	.\lib\util.c	/^get_subprogram_name(void)$/;"	f
get_table	.\utilities\ovs-vsctl.c	/^get_table(const char *table_name)$/;"	f	file:
get_table	.\vtep\vtep-ctl.c	/^get_table(const char *table_name)$/;"	f	file:
get_tables	.\ofproto\ofproto-dpif.c	/^get_tables(struct ofproto *ofproto_, struct ofp12_table_stats *ots)$/;"	f	file:
get_tables	.\ofproto\ofproto-provider.h	/^    void (*get_tables)(struct ofproto *ofproto, struct ofp12_table_stats *ots);$/;"	m	struct:ofproto_class
get_time	.\python\compat\uuid.py	/^    def get_time(self):$/;"	m	class:UUID
get_time_hi_version	.\python\compat\uuid.py	/^    def get_time_hi_version(self):$/;"	m	class:UUID
get_time_low	.\python\compat\uuid.py	/^    def get_time_low(self):$/;"	m	class:UUID
get_time_mid	.\python\compat\uuid.py	/^    def get_time_mid(self):$/;"	m	class:UUID
get_token	.\ofproto\pinsched.c	/^get_token(struct pinsched *ps)$/;"	f	file:
get_token	.\tests\test-stp.c	/^get_token(void)$/;"	f	file:
get_tunnel_config	.\lib\netdev-provider.h	/^        (*get_tunnel_config)(const struct netdev *netdev);$/;"	m	struct:netdev_class	typeref:struct:netdev_class::get_tunnel_config
get_tunnel_config	.\lib\netdev-vport.c	/^get_tunnel_config(const struct netdev *dev, struct smap *args)$/;"	f	file:
get_tx_packet	.\ofproto\pinsched.c	/^get_tx_packet(struct pinsched *ps)$/;"	f	file:
get_u32	.\lib\aes128.c	/^get_u32(const uint8_t *p)$/;"	f	file:
get_unaligned_be16	.\lib\unaligned.h	137;"	d
get_unaligned_be32	.\lib\unaligned.h	138;"	d
get_unaligned_be64	.\lib\unaligned.h	139;"	d
get_unaligned_u16	.\lib\unaligned.h	/^static inline uint16_t get_unaligned_u16(const uint16_t *p_)$/;"	f
get_unaligned_u32	.\lib\unaligned.h	/^static inline uint32_t get_unaligned_u32(const uint32_t *p_)$/;"	f
get_unaligned_u64	.\lib\unaligned.h	160;"	d
get_unaligned_u64__	.\lib\unaligned.h	/^static inline uint64_t get_unaligned_u64__(const uint64_t *p_)$/;"	f
get_unix_name_len	.\lib\socket-util.c	/^get_unix_name_len(socklen_t sun_len)$/;"	f
get_urn	.\python\compat\uuid.py	/^    def get_urn(self):$/;"	m	class:UUID
get_value	.\tests\test-classifier.c	/^get_value(unsigned int *x, unsigned n_values)$/;"	f	file:
get_variant	.\python\compat\uuid.py	/^    def get_variant(self):$/;"	m	class:UUID
get_version	.\python\compat\uuid.py	/^    def get_version(self):$/;"	m	class:UUID
get_vlan_record	.\xenserver\opt_xensource_libexec_InterfaceReconfigure.py	/^    def get_vlan_record(self, vlan):$/;"	m	class:DatabaseCache
get_vport_type	.\lib\dpif-linux.c	/^get_vport_type(const struct dpif_linux_vport *vport)$/;"	f	file:
getnode	.\python\compat\uuid.py	/^def getnode():$/;"	f
getopt	.\lib\getopt_long.c	/^getopt(nargc, nargv, options)$/;"	f
getopt	.\tests\test-json.py	/^import getopt$/;"	i
getopt	.\tests\test-ovsdb.py	/^import getopt$/;"	i
getopt_internal	.\lib\getopt_long.c	/^getopt_internal(int nargc, char **nargv, const char *options)$/;"	f	file:
getopt_long	.\lib\getopt_long.c	/^VLOG_DEFINE_THIS_MODULE(getopt_long);$/;"	v
getopt_long	.\lib\getopt_long.c	/^getopt_long(int nargc, char * const *nargv, const char *options,$/;"	f
getrusage	.\lib\getrusage-windows.c	/^getrusage(int who, struct rusage *usage)$/;"	f
getrusage_thread	.\lib\timeval.c	/^getrusage_thread(struct rusage *rusage OVS_UNUSED)$/;"	f	file:
getrusage_windows	.\lib\getrusage-windows.c	/^VLOG_DEFINE_THIS_MODULE(getrusage_windows);$/;"	v
getsockopt	.\lib\socket-util.h	107;"	d
getsockopt_int	.\lib\socket-util.c	/^getsockopt_int(int fd, int level, int option, const char *optname, int *valuep)$/;"	f	file:
ghost	.\ofproto\ofproto-dpif.c	/^    bool ghost;$/;"	m	struct:port_dump_state	file:
ghost_ports	.\ofproto\ofproto-dpif.c	/^    struct sset ghost_ports;       \/* Ports with no datapath port. *\/$/;"	m	struct:ofproto_dpif	typeref:struct:ofproto_dpif::sset	file:
giaddr	.\lib\dhcp.h	/^    ovs_be32 giaddr;            \/* Relay agent IP address. *\/$/;"	m	struct:dhcp_header
global_seqno	.\lib\ovs-rcu.c	/^static struct seq *global_seqno;$/;"	v	typeref:struct:seq	file:
gmtime_msec	.\lib\timeval.c	/^gmtime_msec(long long int now, struct tm_msec *result)$/;"	f
gmtime_r	.\lib\timeval.h	45;"	d
good_hash	.\tests\test-hindex.c	/^good_hash(int value)$/;"	f	file:
good_hash	.\tests\test-hmap.c	/^good_hash(int value)$/;"	f	file:
grat_arp_lock	.\lib\mac-learning.h	/^    time_t grat_arp_lock;       \/* Gratuitous ARP lock expiration time. *\/$/;"	m	struct:mac_entry
gre64_create	.\datapath\vport-gre.c	/^static struct vport *gre64_create(const struct vport_parms *parms)$/;"	f	file:
gre64_send	.\datapath\vport-gre.c	/^static int gre64_send(struct vport *vport, struct sk_buff *skb)$/;"	f	file:
gre64_tnl_destroy	.\datapath\vport-gre.c	/^static void gre64_tnl_destroy(struct vport *vport)$/;"	f	file:
gre64_vport	.\datapath\vport.h	/^	struct vport __rcu *gre64_vport;$/;"	m	struct:vport_net	typeref:struct:vport_net::__rcu
gre_add_protocol	.\datapath\linux\compat\gre.c	/^static int gre_add_protocol(const struct gre_protocol *proto, u8 version)$/;"	f	file:
gre_base_hdr	.\datapath\linux\compat\include\net\gre.h	/^struct gre_base_hdr {$/;"	s
gre_build_header	.\datapath\linux\compat\gre.c	/^void gre_build_header(struct sk_buff *skb, const struct tnl_ptk_info *tpi,$/;"	f
gre_build_header	.\datapath\linux\compat\include\net\gre.h	86;"	d
gre_cisco_proto	.\datapath\linux\compat\gre.c	/^static struct gre_cisco_protocol __rcu *gre_cisco_proto;$/;"	v	typeref:struct:__rcu	file:
gre_cisco_protocol	.\datapath\linux\compat\include\net\gre.h	/^struct gre_cisco_protocol {$/;"	s
gre_cisco_rcv	.\datapath\linux\compat\gre.c	/^static int gre_cisco_rcv(struct sk_buff *skb)$/;"	f	file:
gre_cisco_register	.\datapath\linux\compat\gre.c	/^int gre_cisco_register(struct gre_cisco_protocol *newp)$/;"	f
gre_cisco_register	.\datapath\linux\compat\include\net\gre.h	25;"	d
gre_cisco_unregister	.\datapath\linux\compat\gre.c	/^int gre_cisco_unregister(struct gre_cisco_protocol *proto)$/;"	f
gre_cisco_unregister	.\datapath\linux\compat\include\net\gre.h	28;"	d
gre_create	.\datapath\vport-gre.c	/^static struct vport *gre_create(const struct vport_parms *parms)$/;"	f	file:
gre_csum_fix	.\datapath\linux\compat\gre.c	/^static void gre_csum_fix(struct sk_buff *skb)$/;"	f	file:
gre_del_protocol	.\datapath\linux\compat\gre.c	/^static int gre_del_protocol(const struct gre_protocol *proto, u8 version)$/;"	f	file:
gre_err	.\datapath\vport-gre.c	/^static int gre_err(struct sk_buff *skb, u32 info,$/;"	f	file:
gre_exit	.\datapath\vport-gre.c	/^static void gre_exit(void)$/;"	f	file:
gre_flags_to_tnl_flags	.\datapath\linux\compat\include\net\gre.h	/^static inline __be16 gre_flags_to_tnl_flags(__be16 flags)$/;"	f
gre_get_name	.\datapath\vport-gre.c	/^static const char *gre_get_name(const struct vport *vport)$/;"	f	file:
gre_handle_offloads	.\datapath\linux\compat\gre.c	/^struct sk_buff *gre_handle_offloads(struct sk_buff *skb, bool gre_csum)$/;"	f
gre_handle_offloads	.\datapath\linux\compat\include\net\gre.h	116;"	d
gre_handle_offloads	.\datapath\linux\compat\include\net\gre.h	90;"	d
gre_init	.\datapath\vport-gre.c	/^static int gre_init(void)$/;"	f	file:
gre_ports	.\datapath\vport-gre.c	/^static int gre_ports;$/;"	v	file:
gre_protocol	.\datapath\linux\compat\gre.c	/^struct gre_protocol {$/;"	s	file:
gre_protocol	.\datapath\vport-gre.c	/^static struct gre_cisco_protocol gre_protocol = {$/;"	v	typeref:struct:gre_cisco_protocol	file:
gre_rcv	.\datapath\linux\compat\gre.c	/^static int gre_rcv(struct sk_buff *skb)$/;"	f	file:
gre_rcv	.\datapath\vport-gre.c	/^static int gre_rcv(struct sk_buff *skb,$/;"	f	file:
gre_send	.\datapath\vport-gre.c	/^static int gre_send(struct vport *vport, struct sk_buff *skb)$/;"	f	file:
gre_tnl_destroy	.\datapath\vport-gre.c	/^static void gre_tnl_destroy(struct vport *vport)$/;"	f	file:
gre_vport	.\datapath\vport.h	/^	struct vport __rcu *gre_vport;$/;"	m	struct:vport_net	typeref:struct:vport_net::__rcu
group	.\lib\ofp-actions.c	/^    struct ofp11_action_group group;$/;"	m	union:ofp_action	typeref:struct:ofp_action::ofp11_action_group	file:
group	.\ofproto\ofproto.c	/^    struct ofopgroup *group;    \/* Owning group. *\/$/;"	m	struct:ofoperation	typeref:struct:ofoperation::ofopgroup	file:
group	.\tests\test-jsonrpc.py	/^    group = parser.add_argument_group(title="Commands",$/;"	v
group_alloc	.\ofproto\ofproto-dpif.c	/^group_alloc(void)$/;"	f	file:
group_alloc	.\ofproto\ofproto-provider.h	/^    struct ofgroup *(*group_alloc)(void);$/;"	m	struct:ofproto_class	typeref:struct:ofproto_class::group_alloc
group_best_live_bucket	.\ofproto\ofproto-dpif-xlate.c	/^group_best_live_bucket(const struct xlate_ctx *ctx,$/;"	f	file:
group_construct	.\ofproto\ofproto-dpif.c	/^group_construct(struct ofgroup *group_)$/;"	f	file:
group_construct	.\ofproto\ofproto-provider.h	/^    enum ofperr (*group_construct)(struct ofgroup *);$/;"	m	struct:ofproto_class	typeref:enum:ofproto_class::group_construct
group_dealloc	.\ofproto\ofproto-dpif.c	/^group_dealloc(struct ofgroup *group_)$/;"	f	file:
group_dealloc	.\ofproto\ofproto-provider.h	/^    void (*group_dealloc)(struct ofgroup *);$/;"	m	struct:ofproto_class
group_destruct	.\ofproto\ofproto-dpif.c	/^group_destruct(struct ofgroup *group_)$/;"	f	file:
group_destruct	.\ofproto\ofproto-provider.h	/^    void (*group_destruct)(struct ofgroup *);$/;"	m	struct:ofproto_class
group_dpif	.\ofproto\ofproto-dpif.c	/^struct group_dpif {$/;"	s	file:
group_dpif	.\ofproto\ofproto-dpif.h	/^struct OVS_LOCKABLE group_dpif;$/;"	v	typeref:struct:OVS_LOCKABLE
group_dpif_cast	.\ofproto\ofproto-dpif.c	/^static struct group_dpif *group_dpif_cast(const struct ofgroup *group)$/;"	f	file:
group_dpif_get_buckets	.\ofproto\ofproto-dpif.c	/^group_dpif_get_buckets(const struct group_dpif *group,$/;"	f
group_dpif_get_type	.\ofproto\ofproto-dpif.c	/^group_dpif_get_type(const struct group_dpif *group)$/;"	f
group_first_live_bucket	.\ofproto\ofproto-dpif-xlate.c	/^group_first_live_bucket(const struct xlate_ctx *ctx,$/;"	f	file:
group_get_stats	.\ofproto\ofproto-dpif.c	/^group_get_stats(const struct ofgroup *group_, struct ofputil_group_stats *ogs)$/;"	f	file:
group_get_stats	.\ofproto\ofproto-provider.h	/^    enum ofperr (*group_get_stats)(const struct ofgroup *,$/;"	m	struct:ofproto_class	typeref:enum:ofproto_class::group_get_stats
group_id	.\include\openflow\openflow-1.1.h	/^    ovs_be32 group_id;                \/* Group identifier. *\/$/;"	m	struct:ofp11_action_group
group_id	.\include\openflow\openflow-1.1.h	/^    ovs_be32 group_id;            \/* Group identifier. *\/$/;"	m	struct:ofp11_group_mod
group_id	.\include\openflow\openflow-1.1.h	/^    ovs_be32 group_id;          \/* Group identifier. *\/$/;"	m	struct:ofp11_group_desc_stats
group_id	.\include\openflow\openflow-1.1.h	/^    ovs_be32 group_id;         \/* All groups if OFPG_ALL. *\/$/;"	m	struct:ofp11_group_stats_request
group_id	.\include\openflow\openflow-1.1.h	/^    ovs_be32 group_id;         \/* Group identifier. *\/$/;"	m	struct:ofp11_group_stats
group_id	.\lib\ofp-actions.h	/^    uint32_t group_id;$/;"	m	struct:ofpact_group
group_id	.\lib\ofp-util.h	/^    uint32_t group_id;            \/* Group identifier. *\/$/;"	m	struct:ofputil_group_mod
group_id	.\lib\ofp-util.h	/^    uint32_t group_id;          \/* Group identifier. *\/$/;"	m	struct:ofputil_group_desc
group_id	.\lib\ofp-util.h	/^    uint32_t group_id;    \/* Group identifier. *\/$/;"	m	struct:ofputil_group_stats
group_id	.\ofproto\ofproto-provider.h	/^    uint32_t group_id;$/;"	m	struct:ofgroup
group_is_alive	.\ofproto\ofproto-dpif-xlate.c	/^group_is_alive(const struct xlate_ctx *ctx, uint32_t group_id, int depth)$/;"	f	file:
group_modify	.\ofproto\ofproto-dpif.c	/^group_modify(struct ofgroup *group_, struct ofgroup *victim_)$/;"	f	file:
group_modify	.\ofproto\ofproto-provider.h	/^    enum ofperr (*group_modify)(struct ofgroup *, struct ofgroup *victim);$/;"	m	struct:ofproto_class	typeref:enum:ofproto_class::group_modify
group_node	.\ofproto\ofproto.c	/^    struct list group_node;     \/* In ofopgroup's "ops" list. *\/$/;"	m	struct:ofoperation	typeref:struct:ofoperation::list	file:
groups	.\lib\vswitch-idl.h	/^	char **groups;$/;"	m	struct:ovsrec_flow_table
groups	.\ofproto\ofproto.h	/^    struct mf_subfield *groups;$/;"	m	struct:ofproto_table_settings	typeref:struct:ofproto_table_settings::mf_subfield
groups_rwlock	.\ofproto\ofproto-provider.h	/^    struct ovs_rwlock groups_rwlock;$/;"	m	struct:ofproto	typeref:struct:ofproto::ovs_rwlock
gs	.\include\openflow\openflow-1.3.h	/^    struct ofp11_group_stats gs;$/;"	m	struct:ofp13_action_self_learning::ofp13_group_stats	typeref:struct:ofp13_action_self_learning::ofp13_group_stats::ofp11_group_stats
guarded_list	.\lib\guarded-list.h	/^struct guarded_list {$/;"	s
guarded_list_destroy	.\lib\guarded-list.c	/^guarded_list_destroy(struct guarded_list *list)$/;"	f
guarded_list_init	.\lib\guarded-list.c	/^guarded_list_init(struct guarded_list *list)$/;"	f
guarded_list_is_empty	.\lib\guarded-list.c	/^guarded_list_is_empty(const struct guarded_list *list)$/;"	f
guarded_list_pop_all	.\lib\guarded-list.c	/^guarded_list_pop_all(struct guarded_list *list, struct list *elements)$/;"	f
guarded_list_pop_front	.\lib\guarded-list.c	/^guarded_list_pop_front(struct guarded_list *list)$/;"	f
guarded_list_push_back	.\lib\guarded-list.c	/^guarded_list_push_back(struct guarded_list *list,$/;"	f
guess_netmask	.\lib\socket-util.c	/^guess_netmask(ovs_be32 ip_)$/;"	f
handle_add_meter	.\ofproto\ofproto.c	/^handle_add_meter(struct ofproto *ofproto, struct ofputil_meter_mod *mm)$/;"	f	file:
handle_args	.\python\ovs\daemon.py	/^def handle_args(args):$/;"	f
handle_args	.\python\ovs\vlog.py	/^def handle_args(args):$/;"	f
handle_barrier_request	.\ofproto\ofproto.c	/^handle_barrier_request(struct ofconn *ofconn, const struct ofp_header *oh)$/;"	f	file:
handle_bundle_add	.\ofproto\ofproto.c	/^handle_bundle_add(struct ofconn *ofconn, const struct ofp_header *oh)$/;"	f	file:
handle_bundle_control	.\ofproto\ofproto.c	/^handle_bundle_control(struct ofconn *ofconn, const struct ofp_header *oh)$/;"	f	file:
handle_desc_stats_request	.\ofproto\ofproto.c	/^handle_desc_stats_request(struct ofconn *ofconn,$/;"	f	file:
handle_echo_request	.\ofproto\ofproto.c	/^handle_echo_request(struct ofconn *ofconn, const struct ofp_header *oh)$/;"	f	file:
handle_features_request	.\ofproto\ofproto.c	/^handle_features_request(struct ofconn *ofconn, const struct ofp_header *oh)$/;"	f	file:
handle_get_config_request	.\ofproto\ofproto.c	/^handle_get_config_request(struct ofconn *ofconn, const struct ofp_header *oh)$/;"	f	file:
handle_group_desc_stats_request	.\ofproto\ofproto.c	/^handle_group_desc_stats_request(struct ofconn *ofconn,$/;"	f	file:
handle_group_features_stats_request	.\ofproto\ofproto.c	/^handle_group_features_stats_request(struct ofconn *ofconn,$/;"	f	file:
handle_group_mod	.\ofproto\ofproto.c	/^handle_group_mod(struct ofconn *ofconn, const struct ofp_header *oh)$/;"	f	file:
handle_group_request	.\ofproto\ofproto.c	/^handle_group_request(struct ofconn *ofconn,$/;"	f	file:
handle_group_stats_request	.\ofproto\ofproto.c	/^handle_group_stats_request(struct ofconn *ofconn,$/;"	f	file:
handle_meter_features_request	.\ofproto\ofproto.c	/^handle_meter_features_request(struct ofconn *ofconn,$/;"	f	file:
handle_meter_mod	.\ofproto\ofproto.c	/^handle_meter_mod(struct ofconn *ofconn, const struct ofp_header *oh)$/;"	f	file:
handle_meter_request	.\ofproto\ofproto.c	/^handle_meter_request(struct ofconn *ofconn, const struct ofp_header *request,$/;"	f	file:
handle_modify_meter	.\ofproto\ofproto.c	/^handle_modify_meter(struct ofproto *ofproto, struct ofputil_meter_mod *mm)$/;"	f	file:
handle_nxt_flow_mod_table_id	.\ofproto\ofproto.c	/^handle_nxt_flow_mod_table_id(struct ofconn *ofconn,$/;"	f	file:
handle_nxt_get_async_request	.\ofproto\ofproto.c	/^handle_nxt_get_async_request(struct ofconn *ofconn, const struct ofp_header *oh)$/;"	f	file:
handle_nxt_set_async_config	.\ofproto\ofproto.c	/^handle_nxt_set_async_config(struct ofconn *ofconn, const struct ofp_header *oh)$/;"	f	file:
handle_nxt_set_controller_id	.\ofproto\ofproto.c	/^handle_nxt_set_controller_id(struct ofconn *ofconn,$/;"	f	file:
handle_nxt_set_flow_format	.\ofproto\ofproto.c	/^handle_nxt_set_flow_format(struct ofconn *ofconn, const struct ofp_header *oh)$/;"	f	file:
handle_nxt_set_packet_in_format	.\ofproto\ofproto.c	/^handle_nxt_set_packet_in_format(struct ofconn *ofconn,$/;"	f	file:
handle_offloads	.\datapath\linux\compat\vxlan.c	/^static int handle_offloads(struct sk_buff *skb)$/;"	f	file:
handle_offloads	.\datapath\vport-lisp.c	/^static int handle_offloads(struct sk_buff *skb)$/;"	f	file:
handle_packet_out	.\ofproto\ofproto.c	/^handle_packet_out(struct ofconn *ofconn, const struct ofp_header *oh)$/;"	f	file:
handle_port_desc_stats_request	.\ofproto\ofproto.c	/^handle_port_desc_stats_request(struct ofconn *ofconn,$/;"	f	file:
handle_port_mod	.\ofproto\ofproto.c	/^handle_port_mod(struct ofconn *ofconn, const struct ofp_header *oh)$/;"	f	file:
handle_port_request	.\ofproto\ofproto.c	/^handle_port_request(struct ofconn *ofconn,$/;"	f	file:
handle_port_stats_request	.\ofproto\ofproto.c	/^handle_port_stats_request(struct ofconn *ofconn,$/;"	f	file:
handle_queue_get_config_request	.\ofproto\ofproto.c	/^handle_queue_get_config_request(struct ofconn *ofconn,$/;"	f	file:
handle_queue_stats_dump_cb	.\ofproto\ofproto.c	/^handle_queue_stats_dump_cb(uint32_t queue_id,$/;"	f	file:
handle_queue_stats_for_port	.\ofproto\ofproto.c	/^handle_queue_stats_for_port(struct ofport *port, uint32_t queue_id,$/;"	f	file:
handle_queue_stats_request	.\ofproto\ofproto.c	/^handle_queue_stats_request(struct ofconn *ofconn,$/;"	f	file:
handle_role_request	.\ofproto\ofproto.c	/^handle_role_request(struct ofconn *ofconn, const struct ofp_header *oh)$/;"	f	file:
handle_rpc	.\tests\test-jsonrpc.c	/^handle_rpc(struct jsonrpc *rpc, struct jsonrpc_msg *msg, bool *done)$/;"	f	file:
handle_rpc	.\tests\test-jsonrpc.py	/^def handle_rpc(rpc, msg):$/;"	f
handle_set_config	.\ofproto\ofproto.c	/^handle_set_config(struct ofconn *ofconn, const struct ofp_header *oh)$/;"	f	file:
handle_table_mod	.\ofproto\ofproto.c	/^handle_table_mod(struct ofconn *ofconn, const struct ofp_header *oh)$/;"	f	file:
handle_table_stats_request	.\ofproto\ofproto.c	/^handle_table_stats_request(struct ofconn *ofconn,$/;"	f	file:
handle_upcalls	.\ofproto\ofproto-dpif-upcall.c	/^handle_upcalls(struct handler *handler, struct hmap *misses,$/;"	f	file:
handler	.\datapath\linux\compat\gre.c	/^	int  (*handler)(struct sk_buff *skb);$/;"	m	struct:gre_protocol	file:
handler	.\datapath\linux\compat\include\net\gre.h	/^	int (*handler)(struct sk_buff *skb, const struct tnl_ptk_info *tpi);$/;"	m	struct:gre_cisco_protocol
handler	.\lib\command-line.h	/^    void (*handler)(int argc, char *argv[]);$/;"	m	struct:command
handler	.\ofproto\ofproto-dpif-upcall.c	/^struct handler {$/;"	s	file:
handler	.\ovsdb\ovsdb-client.c	/^    void (*handler)(struct jsonrpc *rpc, const char *database,$/;"	m	struct:ovsdb_client_command	file:
handler	.\tests\test-daemon.py	/^def handler(signum, _):$/;"	f
handler_id	.\ofproto\ofproto-dpif-upcall.c	/^    uint32_t handler_id;               \/* Handler id. *\/$/;"	m	struct:handler	file:
handler_queues	.\lib\dpif-netdev.c	/^    struct dp_netdev_queue *handler_queues;$/;"	m	struct:dp_netdev	typeref:struct:dp_netdev::dp_netdev_queue	file:
handlers	.\lib\dpif-linux.c	/^    struct dpif_handler *handlers;$/;"	m	struct:dpif_linux	typeref:struct:dpif_linux::dpif_handler	file:
handlers	.\ofproto\ofproto-dpif-upcall.c	/^    struct handler *handlers;          \/* Upcall handlers. *\/$/;"	m	struct:udpif	typeref:struct:udpif::handler	file:
handlers	.\python\ovs\vlog.py	/^import logging.handlers$/;"	i
handlers_set	.\lib\dpif-provider.h	/^    int (*handlers_set)(struct dpif *dpif, uint32_t n_handlers);$/;"	m	struct:dpif_class
hard	.\ofproto\ofproto-dpif-xlate.c	/^            uint16_t hard;$/;"	m	struct:xc_entry::__anon136::__anon143	file:
hard_age	.\include\openflow\nicira-ext.h	/^    ovs_be16 hard_age;        \/* Seconds since last modification, plus one. *\/$/;"	m	struct:nx_flow_stats
hard_age	.\lib\ofp-util.h	/^    int hard_age;               \/* Seconds since last change, -1 if unknown. *\/$/;"	m	struct:ofputil_flow_stats
hard_timeout	.\include\openflow\nicira-ext.h	/^    ovs_be16 hard_timeout;        \/* Max time before discarding (seconds). *\/$/;"	m	struct:nx_flow_mod
hard_timeout	.\include\openflow\nicira-ext.h	/^    ovs_be16 hard_timeout;      \/* Max time before discarding (seconds). *\/$/;"	m	struct:nx_action_learn
hard_timeout	.\include\openflow\nicira-ext.h	/^    ovs_be16 hard_timeout;      \/* Number of seconds before expiration. *\/$/;"	m	struct:nx_flow_update_full
hard_timeout	.\include\openflow\nicira-ext.h	/^    ovs_be16 hard_timeout;    \/* Number of seconds before expiration. *\/$/;"	m	struct:nx_flow_stats
hard_timeout	.\include\openflow\openflow-1.0.h	/^    ovs_be16 hard_timeout;        \/* Max time before discarding (seconds). *\/$/;"	m	struct:ofp10_flow_mod
hard_timeout	.\include\openflow\openflow-1.0.h	/^    ovs_be16 hard_timeout;    \/* Number of seconds before expiration. *\/$/;"	m	struct:ofp10_flow_stats
hard_timeout	.\include\openflow\openflow-1.1.h	/^    ovs_be16 hard_timeout;       \/* Max time before discarding (seconds). *\/$/;"	m	struct:ofp11_flow_mod
hard_timeout	.\include\openflow\openflow-1.1.h	/^    ovs_be16 hard_timeout;     \/* Number of seconds before expiration. *\/$/;"	m	struct:ofp11_flow_stats
hard_timeout	.\include\openflow\openflow-1.2.h	/^    ovs_be16 hard_timeout;    \/* Hard timeout from original flow mod. *\/$/;"	m	struct:ofp12_flow_removed
hard_timeout	.\lib\ofp-actions.h	/^    uint16_t hard_timeout;      \/* Max time before discarding (seconds). *\/$/;"	m	struct:ofpact_learn
hard_timeout	.\lib\ofp-util.h	/^    uint16_t hard_timeout;$/;"	m	struct:ofputil_flow_mod
hard_timeout	.\lib\ofp-util.h	/^    uint16_t hard_timeout;$/;"	m	struct:ofputil_flow_removed
hard_timeout	.\lib\ofp-util.h	/^    uint16_t hard_timeout;$/;"	m	struct:ofputil_flow_stats
hard_timeout	.\lib\ofp-util.h	/^    uint16_t hard_timeout;$/;"	m	struct:ofputil_flow_update
hard_timeout	.\ofproto\ofproto.c	/^    uint16_t hard_timeout;              \/* Rule's old hard timeout. *\/$/;"	m	struct:ofoperation	file:
hard_timeout	.\utilities\ovs-ofctl.c	/^    uint16_t hard_timeout;$/;"	m	struct:fte_version	file:
harmonize_features	.\datapath\linux\compat\netdevice.c	/^static netdev_features_t harmonize_features(struct sk_buff *skb,$/;"	f	file:
has_arg	.\include\windows\getopt.h	/^	int has_arg;$/;"	m	struct:option
has_bonded_bundles	.\ofproto\ofproto-dpif.c	/^    bool has_bonded_bundles;$/;"	m	struct:ofproto_dpif	file:
has_constraints	.\python\ovs\db\types.py	/^    def has_constraints(self):$/;"	m	class:BaseType
has_ever_connected	.\python\ovs\db\idl.py	/^    def has_ever_connected(self):$/;"	m	class:Idl
has_fin_timeout	.\ofproto\ofproto-dpif-xlate.h	/^    bool has_fin_timeout;       \/* Actions include NXAST_FIN_TIMEOUT? *\/$/;"	m	struct:xlate_out
has_in_band	.\ofproto\ofproto-dpif-xlate.c	/^    bool has_in_band;             \/* Bridge has in band control? *\/$/;"	m	struct:xbridge	file:
has_learn	.\ofproto\ofproto-dpif-xlate.h	/^    bool has_learn;             \/* Actions include NXAST_LEARN? *\/$/;"	m	struct:xlate_out
has_lock	.\lib\ovsdb-idl.c	/^    bool has_lock;              \/* Has db server told us we have the lock? *\/$/;"	m	struct:ovsdb_idl	file:
has_mirrors	.\ofproto\ofproto-dpif-mirror.c	/^    bool has_mirrors;$/;"	m	struct:mbridge	file:
has_normal	.\ofproto\ofproto-dpif-xlate.h	/^    bool has_normal;            \/* Actions output to OFPP_NORMAL? *\/$/;"	m	struct:xlate_out
has_port	.\ofproto\ofproto-dpif.c	/^    bool has_port;$/;"	m	struct:port_dump_state	file:
has_run	.\lib\netlink-notifier.c	/^    bool has_run;                \/* Guard for run and wait functions. *\/$/;"	m	struct:nln	file:
hash	.\datapath\flow.h	/^	u32 hash;$/;"	m	struct:sw_flow
hash	.\datapath\linux\compat\include\linux\hash.h	/^	u32 (*hash)(const void *data, u32 len, u32 seed);$/;"	m	struct:fast_hash_ops
hash	.\lib\hindex.h	/^    size_t hash;$/;"	m	struct:hindex_node
hash	.\lib\hmap.h	/^    size_t hash;                \/* Hash value. *\/$/;"	m	struct:hmap_node
hash	.\ofproto\bond.c	/^    struct bond_entry *hash;     \/* An array of BOND_BUCKETS elements. *\/$/;"	m	struct:bond	typeref:struct:bond::bond_entry	file:
hash2	.\datapath\linux\compat\include\linux\hash.h	/^	u32 (*hash2)(const u32 *data, u32 len, u32 seed);$/;"	m	struct:fast_hash_ops
hash_2words	.\lib\hash.h	/^static inline uint32_t hash_2words(uint32_t x, uint32_t y)$/;"	f
hash_3words	.\lib\hash.c	/^hash_3words(uint32_t a, uint32_t b, uint32_t c)$/;"	f
hash_alg	.\include\linux\openvswitch.h	/^	uint32_t  hash_alg;	\/* One of ovs_hash_alg. *\/$/;"	m	struct:ovs_action_hash
hash_alg	.\ofproto\ofproto-dpif-xlate.h	/^    uint8_t  hash_alg;   \/* !0 Compute hash for recirc before. *\/$/;"	m	struct:xlate_recirc
hash_atoms	.\lib\ovsdb-data.c	/^hash_atoms(enum ovsdb_atomic_type type, const union ovsdb_atom *atoms,$/;"	f	file:
hash_basis	.\include\linux\openvswitch.h	/^	uint32_t  hash_basis;$/;"	m	struct:ovs_action_hash
hash_basis	.\ofproto\ofproto-dpif-xlate.h	/^    uint32_t hash_basis;  \/* Compute hash for recirc before. *\/$/;"	m	struct:xlate_recirc
hash_boolean	.\lib\hash.h	/^static inline uint32_t hash_boolean(bool x, uint32_t basis)$/;"	f
hash_bucket	.\datapath\vport.c	/^static struct hlist_head *hash_bucket(struct net *net, const char *name)$/;"	f	file:
hash_bytes	.\lib\hash.c	/^hash_bytes(const void *p_, size_t n, uint32_t basis)$/;"	f
hash_cookie	.\ofproto\ofproto.c	/^hash_cookie(ovs_be64 cookie)$/;"	f	file:
hash_double	.\lib\hash.c	/^hash_double(double x, uint32_t basis)$/;"	f
hash_func	.\tests\test-hindex.c	/^typedef size_t hash_func(int value);$/;"	t	file:
hash_func	.\tests\test-hmap.c	/^typedef size_t hash_func(int value);$/;"	t	file:
hash_int	.\lib\hash.h	/^static inline uint32_t hash_int(uint32_t x, uint32_t basis)$/;"	f
hash_int_cb	.\tests\test-hash.c	/^hash_int_cb(uint32_t input)$/;"	f	file:
hash_mac	.\lib\packets.h	/^static inline uint32_t hash_mac(const uint8_t ea[ETH_ADDR_LEN],$/;"	f
hash_metadata	.\lib\classifier.c	/^hash_metadata(ovs_be64 metadata_)$/;"	f	file:
hash_mpid	.\lib\cfm.c	/^hash_mpid(uint64_t mpid)$/;"	f	file:
hash_name	.\lib\shash.c	/^hash_name(const char *name)$/;"	f	file:
hash_name	.\lib\simap.c	/^hash_name(const char *name, size_t length)$/;"	f	file:
hash_name	.\lib\sset.c	/^hash_name(const char *name)$/;"	f	file:
hash_name__	.\lib\sset.c	/^hash_name__(const char *name, size_t length)$/;"	f	file:
hash_node	.\datapath\flow.h	/^	struct hlist_node hash_node[2];$/;"	m	struct:sw_flow	typeref:struct:sw_flow::hlist_node
hash_node	.\datapath\vport.h	/^	struct hlist_node hash_node;$/;"	m	struct:vport	typeref:struct:vport::hlist_node
hash_nxt	.\lib\sflow_api.h	/^    struct _SFLSampler *hash_nxt;$/;"	m	struct:_SFLSampler	typeref:struct:_SFLSampler::_SFLSampler
hash_pointer	.\lib\hash.h	/^static inline uint32_t hash_pointer(const void *p, uint32_t basis)$/;"	f
hash_realdev_vid	.\ofproto\ofproto-dpif.c	/^hash_realdev_vid(ofp_port_t realdev_ofp_port, int vid)$/;"	f	file:
hash_rot	.\lib\hash.h	/^hash_rot(uint32_t x, int k)$/;"	f
hash_route_data	.\lib\route-table.c	/^hash_route_data(const struct route_data *rd)$/;"	f	file:
hash_seed	.\datapath\flow_table.h	/^	u32 hash_seed;$/;"	m	struct:table_instance
hash_string	.\lib\hash.h	/^static inline uint32_t hash_string(const char *s, uint32_t basis)$/;"	f
hash_uint64	.\lib\hash.h	/^static inline uint32_t hash_uint64(const uint64_t x)$/;"	f
hash_uint64_basis	.\lib\hash.h	/^static inline uint32_t hash_uint64_basis(const uint64_t x,$/;"	f
hash_words	.\lib\hash.c	/^hash_words(const uint32_t p[], size_t n_words, uint32_t basis)$/;"	f
hash_words_cb	.\tests\test-hash.c	/^hash_words_cb(uint32_t input)$/;"	f	file:
have_generation_id	.\lib\ofp-util.h	/^    bool have_generation_id;$/;"	m	struct:ofputil_role_request
hdrs	.\lib\ofp-msgs.c	/^    struct ofphdrs hdrs;        \/* Key. *\/$/;"	m	struct:raw_instance	typeref:struct:raw_instance::ofphdrs	file:
hdrs_len	.\lib\ofp-msgs.c	/^    unsigned int hdrs_len;      \/* ofphdrs_len(hdrs). *\/$/;"	m	struct:raw_instance	file:
hdrsize	.\datapath\linux\compat\include\net\genetlink.h	/^	unsigned int            hdrsize;$/;"	m	struct:rpl_genl_family
head	.\lib\byteq.h	/^    unsigned int head;          \/* Head of queue. *\/$/;"	m	struct:byteq
head	.\lib\stream-ssl.c	/^    uint8_t head[2];$/;"	m	struct:ssl_stream	file:
head_frag	.\datapath\linux\compat\skbuff-openvswitch.c	/^static inline bool head_frag(const struct sk_buff *skb)$/;"	f	file:
header	.\include\openflow\nicira-ext.h	/^    struct ofp_header header;$/;"	m	struct:nicira_header	typeref:struct:nicira_header::ofp_header
header	.\include\openflow\openflow-1.0.h	/^    struct ofp_header header;$/;"	m	struct:ofp10_stats_msg	typeref:struct:ofp10_stats_msg::ofp_header
header	.\include\openflow\openflow-1.1.h	/^    struct ofp_header header;$/;"	m	struct:ofp11_stats_msg	typeref:struct:ofp11_stats_msg::ofp_header
header	.\include\openflow\openflow-1.4.h	/^    struct ofp_header header;$/;"	m	struct:ofp14_async_config	typeref:struct:ofp14_async_config::ofp_header
header	.\include\openflow\openflow-common.h	/^    struct ofp_header header;   \/* Type OFPT_VENDOR or OFPT_EXPERIMENTER. *\/$/;"	m	struct:ofp_vendor_header	typeref:struct:ofp_vendor_header::ofp_header
header	.\lib\meta-flow.c	/^    uint32_t header;            \/* NXM or OXM header value. *\/$/;"	m	struct:nxm_field	file:
header	.\lib\ofp-actions.c	/^    struct ofp_action_header header;$/;"	m	union:ofp_action	typeref:struct:ofp_action::ofp_action_header	file:
header	.\lib\sflow.h	/^    SFLSampled_header header;$/;"	m	union:_SFLFlow_type
header	.\lib\vswitch-idl.h	/^	int64_t *header;$/;"	m	struct:ovsrec_sflow
header_	.\lib\vswitch-idl.h	/^	struct ovsdb_idl_row header_;$/;"	m	struct:ovsrec_bridge	typeref:struct:ovsrec_bridge::ovsdb_idl_row
header_	.\lib\vswitch-idl.h	/^	struct ovsdb_idl_row header_;$/;"	m	struct:ovsrec_controller	typeref:struct:ovsrec_controller::ovsdb_idl_row
header_	.\lib\vswitch-idl.h	/^	struct ovsdb_idl_row header_;$/;"	m	struct:ovsrec_flow_sample_collector_set	typeref:struct:ovsrec_flow_sample_collector_set::ovsdb_idl_row
header_	.\lib\vswitch-idl.h	/^	struct ovsdb_idl_row header_;$/;"	m	struct:ovsrec_flow_table	typeref:struct:ovsrec_flow_table::ovsdb_idl_row
header_	.\lib\vswitch-idl.h	/^	struct ovsdb_idl_row header_;$/;"	m	struct:ovsrec_interface	typeref:struct:ovsrec_interface::ovsdb_idl_row
header_	.\lib\vswitch-idl.h	/^	struct ovsdb_idl_row header_;$/;"	m	struct:ovsrec_ipfix	typeref:struct:ovsrec_ipfix::ovsdb_idl_row
header_	.\lib\vswitch-idl.h	/^	struct ovsdb_idl_row header_;$/;"	m	struct:ovsrec_manager	typeref:struct:ovsrec_manager::ovsdb_idl_row
header_	.\lib\vswitch-idl.h	/^	struct ovsdb_idl_row header_;$/;"	m	struct:ovsrec_mirror	typeref:struct:ovsrec_mirror::ovsdb_idl_row
header_	.\lib\vswitch-idl.h	/^	struct ovsdb_idl_row header_;$/;"	m	struct:ovsrec_netflow	typeref:struct:ovsrec_netflow::ovsdb_idl_row
header_	.\lib\vswitch-idl.h	/^	struct ovsdb_idl_row header_;$/;"	m	struct:ovsrec_open_vswitch	typeref:struct:ovsrec_open_vswitch::ovsdb_idl_row
header_	.\lib\vswitch-idl.h	/^	struct ovsdb_idl_row header_;$/;"	m	struct:ovsrec_port	typeref:struct:ovsrec_port::ovsdb_idl_row
header_	.\lib\vswitch-idl.h	/^	struct ovsdb_idl_row header_;$/;"	m	struct:ovsrec_qos	typeref:struct:ovsrec_qos::ovsdb_idl_row
header_	.\lib\vswitch-idl.h	/^	struct ovsdb_idl_row header_;$/;"	m	struct:ovsrec_queue	typeref:struct:ovsrec_queue::ovsdb_idl_row
header_	.\lib\vswitch-idl.h	/^	struct ovsdb_idl_row header_;$/;"	m	struct:ovsrec_sflow	typeref:struct:ovsrec_sflow::ovsdb_idl_row
header_	.\lib\vswitch-idl.h	/^	struct ovsdb_idl_row header_;$/;"	m	struct:ovsrec_ssl	typeref:struct:ovsrec_ssl::ovsdb_idl_row
header_	.\lib\vtep-idl.h	/^	struct ovsdb_idl_row header_;$/;"	m	struct:vteprec_arp_sources_local	typeref:struct:vteprec_arp_sources_local::ovsdb_idl_row
header_	.\lib\vtep-idl.h	/^	struct ovsdb_idl_row header_;$/;"	m	struct:vteprec_arp_sources_remote	typeref:struct:vteprec_arp_sources_remote::ovsdb_idl_row
header_	.\lib\vtep-idl.h	/^	struct ovsdb_idl_row header_;$/;"	m	struct:vteprec_global	typeref:struct:vteprec_global::ovsdb_idl_row
header_	.\lib\vtep-idl.h	/^	struct ovsdb_idl_row header_;$/;"	m	struct:vteprec_logical_binding_stats	typeref:struct:vteprec_logical_binding_stats::ovsdb_idl_row
header_	.\lib\vtep-idl.h	/^	struct ovsdb_idl_row header_;$/;"	m	struct:vteprec_logical_router	typeref:struct:vteprec_logical_router::ovsdb_idl_row
header_	.\lib\vtep-idl.h	/^	struct ovsdb_idl_row header_;$/;"	m	struct:vteprec_logical_switch	typeref:struct:vteprec_logical_switch::ovsdb_idl_row
header_	.\lib\vtep-idl.h	/^	struct ovsdb_idl_row header_;$/;"	m	struct:vteprec_manager	typeref:struct:vteprec_manager::ovsdb_idl_row
header_	.\lib\vtep-idl.h	/^	struct ovsdb_idl_row header_;$/;"	m	struct:vteprec_mcast_macs_local	typeref:struct:vteprec_mcast_macs_local::ovsdb_idl_row
header_	.\lib\vtep-idl.h	/^	struct ovsdb_idl_row header_;$/;"	m	struct:vteprec_mcast_macs_remote	typeref:struct:vteprec_mcast_macs_remote::ovsdb_idl_row
header_	.\lib\vtep-idl.h	/^	struct ovsdb_idl_row header_;$/;"	m	struct:vteprec_physical_locator	typeref:struct:vteprec_physical_locator::ovsdb_idl_row
header_	.\lib\vtep-idl.h	/^	struct ovsdb_idl_row header_;$/;"	m	struct:vteprec_physical_locator_set	typeref:struct:vteprec_physical_locator_set::ovsdb_idl_row
header_	.\lib\vtep-idl.h	/^	struct ovsdb_idl_row header_;$/;"	m	struct:vteprec_physical_port	typeref:struct:vteprec_physical_port::ovsdb_idl_row
header_	.\lib\vtep-idl.h	/^	struct ovsdb_idl_row header_;$/;"	m	struct:vteprec_physical_switch	typeref:struct:vteprec_physical_switch::ovsdb_idl_row
header_	.\lib\vtep-idl.h	/^	struct ovsdb_idl_row header_;$/;"	m	struct:vteprec_tunnel	typeref:struct:vteprec_tunnel::ovsdb_idl_row
header_	.\lib\vtep-idl.h	/^	struct ovsdb_idl_row header_;$/;"	m	struct:vteprec_ucast_macs_local	typeref:struct:vteprec_ucast_macs_local::ovsdb_idl_row
header_	.\lib\vtep-idl.h	/^	struct ovsdb_idl_row header_;$/;"	m	struct:vteprec_ucast_macs_remote	typeref:struct:vteprec_ucast_macs_remote::ovsdb_idl_row
header_	.\tests\idltest.h	/^	struct ovsdb_idl_row header_;$/;"	m	struct:idltest_link1	typeref:struct:idltest_link1::ovsdb_idl_row
header_	.\tests\idltest.h	/^	struct ovsdb_idl_row header_;$/;"	m	struct:idltest_link2	typeref:struct:idltest_link2::ovsdb_idl_row
header_	.\tests\idltest.h	/^	struct ovsdb_idl_row header_;$/;"	m	struct:idltest_simple	typeref:struct:idltest_simple::ovsdb_idl_row
header_bytes	.\lib\sflow.h	/^    u_int8_t *header_bytes;               \/* Header bytes *\/$/;"	m	struct:_SFLSampled_header
header_len	.\ofproto\ofproto.h	/^    uint32_t header_len;$/;"	m	struct:ofproto_sflow_options
header_length	.\lib\sflow.h	/^    u_int32_t header_length;              \/* length of sampled header bytes to follow *\/$/;"	m	struct:_SFLSampled_header
header_protocol	.\lib\sflow.h	/^    u_int32_t header_protocol;            \/* (enum SFLHeader_protocol) *\/$/;"	m	struct:_SFLSampled_header
heading	.\lib\table.c	/^    char *heading;$/;"	m	struct:column	file:
headings	.\lib\table.h	/^    bool headings;              \/* Include headings? *\/$/;"	m	struct:table_style
health	.\lib\cfm.c	/^    int health;               \/* Percentage of the number of CCM frames$/;"	m	struct:cfm	file:
health	.\ofproto\ofproto.h	/^    int health;$/;"	m	struct:ofproto_cfm_status
health_interval	.\lib\cfm.c	/^    int health_interval;      \/* Number of fault_intervals since health was$/;"	m	struct:cfm	file:
heap	.\lib\heap.h	/^struct heap {$/;"	s
heap_change	.\lib\heap.c	/^heap_change(struct heap *heap, struct heap_node *node, uint64_t priority)$/;"	f
heap_clear	.\lib\heap.c	/^heap_clear(struct heap *heap)$/;"	f
heap_count	.\lib\heap.h	/^heap_count(const struct heap *heap)$/;"	f
heap_destroy	.\lib\heap.c	/^heap_destroy(struct heap *heap)$/;"	f
heap_init	.\lib\heap.c	/^heap_init(struct heap *heap)$/;"	f
heap_insert	.\lib\heap.c	/^heap_insert(struct heap *heap, struct heap_node *node, uint64_t priority)$/;"	f
heap_is_empty	.\lib\heap.h	/^heap_is_empty(const struct heap *heap)$/;"	f
heap_is_leaf__	.\lib\heap.h	/^heap_is_leaf__(const struct heap *heap, size_t idx)$/;"	f
heap_left__	.\lib\heap.h	/^heap_left__(size_t idx)$/;"	f
heap_max	.\lib\heap.h	/^heap_max(const struct heap *heap)$/;"	f
heap_node	.\lib\heap.h	/^struct heap_node {$/;"	s
heap_node	.\ofproto\ofproto-dpif-monitor.c	/^    struct heap_node heap_node;       \/* In monitor_heap. *\/$/;"	m	struct:mport	typeref:struct:mport::heap_node	file:
heap_node	.\tests\test-heap.c	/^    struct heap_node heap_node;$/;"	m	struct:element	typeref:struct:element::heap_node	file:
heap_parent__	.\lib\heap.h	/^heap_parent__(size_t idx)$/;"	f
heap_pop	.\lib\heap.h	/^heap_pop(struct heap *heap)$/;"	f
heap_raw_change	.\lib\heap.h	/^heap_raw_change(struct heap_node *node, uint64_t priority)$/;"	f
heap_raw_insert	.\lib\heap.c	/^heap_raw_insert(struct heap *heap, struct heap_node *node, uint64_t priority)$/;"	f
heap_raw_remove	.\lib\heap.c	/^heap_raw_remove(struct heap *heap, struct heap_node *node)$/;"	f
heap_rebuild	.\lib\heap.c	/^heap_rebuild(struct heap *heap)$/;"	f
heap_remove	.\lib\heap.c	/^heap_remove(struct heap *heap, struct heap_node *node)$/;"	f
heap_right__	.\lib\heap.h	/^heap_right__(size_t idx)$/;"	f
heap_swap	.\lib\heap.c	/^heap_swap(struct heap *a, struct heap *b)$/;"	f
height	.\lib\json.c	/^    size_t height, allocated_height;$/;"	m	struct:json_parser	file:
hello_time	.\lib\stp.c	/^    int hello_time;                 \/* 8.5.3.5: Time between sending BPDUs. *\/$/;"	m	struct:stp	file:
hello_time	.\ofproto\ofproto.h	/^    uint16_t hello_time;$/;"	m	struct:ofproto_stp_settings
hello_timer	.\lib\stp.c	/^    struct stp_timer hello_timer;   \/* 8.5.4.1: Hello timer. *\/$/;"	m	struct:stp	typeref:struct:stp::stp_timer	file:
help	.\tests\ovstest.c	/^help(int argc OVS_UNUSED, char *argv[] OVS_UNUSED)$/;"	f	file:
help	.\tests\test-jsonrpc.py	/^                       help="Arguments to COMMAND.")$/;"	v
hex	.\python\compat\uuid.py	/^    hex = property(get_hex)$/;"	v	class:UUID
hex_to_uint8	.\tests\test-aes128.c	/^hex_to_uint8(const char *input, uint8_t *output, size_t n)$/;"	f	file:
hexit_value	.\lib\util.c	/^hexit_value(int c)$/;"	f
hexits_value	.\lib\util.c	/^hexits_value(const char *s, size_t n, bool *ok)$/;"	f
hfsc	.\lib\netdev-linux.c	/^struct hfsc {$/;"	s	file:
hfsc_class	.\lib\netdev-linux.c	/^struct hfsc_class {$/;"	s	file:
hfsc_class_cast__	.\lib\netdev-linux.c	/^hfsc_class_cast__(const struct tc_queue *queue)$/;"	f	file:
hfsc_class_delete	.\lib\netdev-linux.c	/^hfsc_class_delete(struct netdev *netdev, struct tc_queue *queue)$/;"	f	file:
hfsc_class_dump_stats	.\lib\netdev-linux.c	/^hfsc_class_dump_stats(const struct netdev *netdev OVS_UNUSED,$/;"	f	file:
hfsc_class_get	.\lib\netdev-linux.c	/^hfsc_class_get(const struct netdev *netdev OVS_UNUSED,$/;"	f	file:
hfsc_class_get_stats	.\lib\netdev-linux.c	/^hfsc_class_get_stats(const struct netdev *netdev, const struct tc_queue *queue,$/;"	f	file:
hfsc_class_set	.\lib\netdev-linux.c	/^hfsc_class_set(struct netdev *netdev, unsigned int queue_id,$/;"	f	file:
hfsc_get__	.\lib\netdev-linux.c	/^hfsc_get__(const struct netdev *netdev_)$/;"	f	file:
hfsc_install__	.\lib\netdev-linux.c	/^hfsc_install__(struct netdev *netdev_, uint32_t max_rate)$/;"	f	file:
hfsc_parse_class_details__	.\lib\netdev-linux.c	/^hfsc_parse_class_details__(struct netdev *netdev,$/;"	f	file:
hfsc_parse_qdisc_details__	.\lib\netdev-linux.c	/^hfsc_parse_qdisc_details__(struct netdev *netdev_, const struct smap *details,$/;"	f	file:
hfsc_parse_tca_options__	.\lib\netdev-linux.c	/^hfsc_parse_tca_options__(struct nlattr *nl_options, struct hfsc_class *class)$/;"	f	file:
hfsc_parse_tcmsg__	.\lib\netdev-linux.c	/^hfsc_parse_tcmsg__(struct ofpbuf *tcmsg, unsigned int *queue_id,$/;"	f	file:
hfsc_qdisc_get	.\lib\netdev-linux.c	/^hfsc_qdisc_get(const struct netdev *netdev, struct smap *details)$/;"	f	file:
hfsc_qdisc_set	.\lib\netdev-linux.c	/^hfsc_qdisc_set(struct netdev *netdev, const struct smap *details)$/;"	f	file:
hfsc_query_class__	.\lib\netdev-linux.c	/^hfsc_query_class__(const struct netdev *netdev, unsigned int handle,$/;"	f	file:
hfsc_setup_class__	.\lib\netdev-linux.c	/^hfsc_setup_class__(struct netdev *netdev, unsigned int handle,$/;"	f	file:
hfsc_setup_qdisc__	.\lib\netdev-linux.c	/^hfsc_setup_qdisc__(struct netdev * netdev)$/;"	f	file:
hfsc_tc_destroy	.\lib\netdev-linux.c	/^hfsc_tc_destroy(struct tc *tc)$/;"	f	file:
hfsc_tc_install	.\lib\netdev-linux.c	/^hfsc_tc_install(struct netdev *netdev, const struct smap *details)$/;"	f	file:
hfsc_tc_load	.\lib\netdev-linux.c	/^hfsc_tc_load(struct netdev *netdev, struct ofpbuf *nlmsg OVS_UNUSED)$/;"	f	file:
hfsc_update_queue__	.\lib\netdev-linux.c	/^hfsc_update_queue__(struct netdev *netdev, unsigned int queue_id,$/;"	f	file:
hi	.\include\openvswitch\types.h	/^        ovs_be16 hi, lo;$/;"	m	struct:__anon22
hi	.\include\openvswitch\types.h	/^        ovs_be32 hi, lo;$/;"	m	struct:__anon24
hi	.\include\openvswitch\types.h	/^        uint16_t hi, lo;$/;"	m	struct:__anon21
hi	.\include\openvswitch\types.h	/^        uint32_t hi, lo;$/;"	m	struct:__anon23
hindex	.\lib\hindex.h	/^struct hindex {$/;"	s
hindex_calc_mask	.\lib\hindex.c	/^hindex_calc_mask(size_t capacity)$/;"	f	file:
hindex_clear	.\lib\hindex.c	/^hindex_clear(struct hindex *hindex)$/;"	f
hindex_destroy	.\lib\hindex.c	/^hindex_destroy(struct hindex *hindex)$/;"	f
hindex_expand	.\lib\hindex.c	/^COVERAGE_DEFINE(hindex_expand);$/;"	v
hindex_expand	.\lib\hindex.c	/^hindex_expand(struct hindex *hindex)$/;"	f
hindex_first	.\lib\hindex.c	/^hindex_first(const struct hindex *hindex)$/;"	f
hindex_head_node	.\lib\hindex.c	/^hindex_head_node(const struct hindex *hindex, size_t hash)$/;"	f	file:
hindex_init	.\lib\hindex.c	/^hindex_init(struct hindex *hindex)$/;"	f
hindex_insert	.\lib\hindex.c	/^hindex_insert(struct hindex *hindex, struct hindex_node *node, size_t hash)$/;"	f
hindex_insert_fast	.\lib\hindex.c	/^hindex_insert_fast(struct hindex *hindex,$/;"	f
hindex_is_empty	.\lib\hindex.h	/^hindex_is_empty(const struct hindex *hindex)$/;"	f
hindex_moved	.\lib\hindex.c	/^hindex_moved(struct hindex *hindex)$/;"	f
hindex_next	.\lib\hindex.c	/^hindex_next(const struct hindex *hindex, const struct hindex_node *node)$/;"	f
hindex_next__	.\lib\hindex.c	/^hindex_next__(const struct hindex *hindex, size_t start)$/;"	f	file:
hindex_node	.\lib\hindex.h	/^struct hindex_node {$/;"	s
hindex_node_is_body	.\lib\hindex.c	/^hindex_node_is_body(const struct hindex_node *node)$/;"	f	file:
hindex_node_is_head	.\lib\hindex.c	/^hindex_node_is_head(const struct hindex_node *node)$/;"	f	file:
hindex_node_with_hash	.\lib\hindex.h	/^hindex_node_with_hash(const struct hindex *hindex, size_t hash)$/;"	f
hindex_pathological	.\lib\hindex.c	/^COVERAGE_DEFINE(hindex_pathological);$/;"	v
hindex_remove	.\lib\hindex.c	/^hindex_remove(struct hindex *hindex, struct hindex_node *node)$/;"	f
hindex_reserve	.\lib\hindex.c	/^COVERAGE_DEFINE(hindex_reserve);$/;"	v
hindex_reserve	.\lib\hindex.c	/^hindex_reserve(struct hindex *hindex, size_t n)$/;"	f
hindex_resize	.\lib\hindex.c	/^hindex_resize(struct hindex *hindex, size_t new_mask)$/;"	f	file:
hindex_shrink	.\lib\hindex.c	/^COVERAGE_DEFINE(hindex_shrink);$/;"	v
hindex_shrink	.\lib\hindex.c	/^hindex_shrink(struct hindex *hindex)$/;"	f
hindex_swap	.\lib\hindex.c	/^hindex_swap(struct hindex *a, struct hindex *b)$/;"	f
hlen	.\lib\dhcp.h	/^    uint8_t hlen;               \/* ETH_ADDR_LEN (typically). *\/$/;"	m	struct:dhcp_header
hlist	.\datapath\linux\compat\include\net\vxlan.h	/^	struct hlist_node hlist;$/;"	m	struct:vxlan_sock	typeref:struct:vxlan_sock::hlist_node
hlist_entry_safe	.\datapath\linux\compat\include\linux\list.h	7;"	d
hlist_first_rcu	.\datapath\linux\compat\include\linux\rculist.h	7;"	d
hlist_for_each_entry	.\datapath\linux\compat\include\linux\list.h	12;"	d
hlist_for_each_entry	.\datapath\linux\compat\include\linux\list.h	13;"	d
hlist_for_each_entry_rcu	.\datapath\linux\compat\include\linux\rculist.h	12;"	d
hlist_for_each_entry_rcu	.\datapath\linux\compat\include\linux\rculist.h	13;"	d
hlist_for_each_entry_safe	.\datapath\linux\compat\include\linux\list.h	18;"	d
hlist_for_each_entry_safe	.\datapath\linux\compat\include\linux\list.h	19;"	d
hlist_next_rcu	.\datapath\linux\compat\include\linux\rculist.h	8;"	d
hlist_pprev_rcu	.\datapath\linux\compat\include\linux\rculist.h	9;"	d
hmap	.\lib\hmap.c	/^VLOG_DEFINE_THIS_MODULE(hmap);$/;"	v
hmap	.\lib\hmap.h	/^struct hmap {$/;"	s
hmap_at_position	.\lib\hmap.c	/^hmap_at_position(const struct hmap *hmap,$/;"	f
hmap_capacity	.\lib\hmap.h	/^hmap_capacity(const struct hmap *hmap)$/;"	f
hmap_clear	.\lib\hmap.c	/^hmap_clear(struct hmap *hmap)$/;"	f
hmap_contains	.\lib\hmap.c	/^hmap_contains(const struct hmap *hmap, const struct hmap_node *node)$/;"	f
hmap_count	.\lib\hmap.h	/^hmap_count(const struct hmap *hmap)$/;"	f
hmap_destroy	.\lib\hmap.c	/^hmap_destroy(struct hmap *hmap)$/;"	f
hmap_expand	.\lib\hmap.c	/^COVERAGE_DEFINE(hmap_expand);$/;"	v
hmap_expand	.\lib\hmap.h	83;"	d
hmap_expand_at	.\lib\hmap.c	/^hmap_expand_at(struct hmap *hmap, const char *where)$/;"	f
hmap_first	.\lib\hmap.h	/^hmap_first(const struct hmap *hmap)$/;"	f
hmap_first_in_bucket	.\lib\hmap.h	/^hmap_first_in_bucket(const struct hmap *hmap, size_t hash)$/;"	f
hmap_first_with_hash	.\lib\hmap.h	/^hmap_first_with_hash(const struct hmap *hmap, size_t hash)$/;"	f
hmap_init	.\lib\hmap.c	/^hmap_init(struct hmap *hmap)$/;"	f
hmap_insert	.\lib\hmap.h	95;"	d
hmap_insert_at	.\lib\hmap.h	/^hmap_insert_at(struct hmap *hmap, struct hmap_node *node, size_t hash,$/;"	f
hmap_insert_fast	.\lib\hmap.h	/^hmap_insert_fast(struct hmap *hmap, struct hmap_node *node, size_t hash)$/;"	f
hmap_is_empty	.\lib\hmap.h	/^hmap_is_empty(const struct hmap *hmap)$/;"	f
hmap_moved	.\lib\hmap.c	/^hmap_moved(struct hmap *hmap)$/;"	f
hmap_next	.\lib\hmap.h	/^hmap_next(const struct hmap *hmap, const struct hmap_node *node)$/;"	f
hmap_next__	.\lib\hmap.h	/^hmap_next__(const struct hmap *hmap, size_t start)$/;"	f
hmap_next_in_bucket	.\lib\hmap.h	/^hmap_next_in_bucket(const struct hmap_node *node)$/;"	f
hmap_next_with_hash	.\lib\hmap.h	/^hmap_next_with_hash(const struct hmap_node *node)$/;"	f
hmap_next_with_hash__	.\lib\hmap.h	/^hmap_next_with_hash__(const struct hmap_node *node, size_t hash)$/;"	f
hmap_node	.\lib\cfm.c	/^    struct hmap_node hmap_node; \/* Node in all_cfms list. *\/$/;"	m	struct:cfm	typeref:struct:cfm::hmap_node	file:
hmap_node	.\lib\classifier.c	/^    struct hmap_node hmap_node; \/* In struct cls_classifier's 'partitions'$/;"	m	struct:cls_partition	typeref:struct:cls_partition::hmap_node	file:
hmap_node	.\lib\classifier.c	/^    struct hmap_node hmap_node; \/* Within struct cls_classifier 'subtables'$/;"	m	struct:cls_subtable	typeref:struct:cls_subtable::hmap_node	file:
hmap_node	.\lib\classifier.c	/^    struct hmap_node hmap_node; \/* Within struct cls_subtable 'rules'. *\/$/;"	m	struct:cls_match	typeref:struct:cls_match::hmap_node	file:
hmap_node	.\lib\hmap.h	/^struct hmap_node {$/;"	s
hmap_node	.\lib\hmapx.h	/^    struct hmap_node hmap_node;$/;"	m	struct:hmapx_node	typeref:struct:hmapx_node::hmap_node
hmap_node	.\lib\learning-switch.c	/^    struct hmap_node hmap_node; \/* Hash node for port number. *\/$/;"	m	struct:lswitch_port	typeref:struct:lswitch_port::hmap_node	file:
hmap_node	.\lib\lockfile.c	/^    struct hmap_node hmap_node;$/;"	m	struct:lockfile	typeref:struct:lockfile::hmap_node	file:
hmap_node	.\lib\mac-learning.h	/^    struct hmap_node hmap_node; \/* Node in a mac_learning hmap. *\/$/;"	m	struct:mac_entry	typeref:struct:mac_entry::hmap_node
hmap_node	.\lib\meta-flow.c	/^    struct hmap_node hmap_node; \/* In 'all_fields' hmap. *\/$/;"	m	struct:nxm_field	typeref:struct:nxm_field::hmap_node	file:
hmap_node	.\lib\netdev-linux.c	/^    struct hmap_node hmap_node; \/* In struct tc's "queues" hmap. *\/$/;"	m	struct:tc_queue	typeref:struct:tc_queue::hmap_node	file:
hmap_node	.\lib\netdev.c	/^    struct hmap_node hmap_node; \/* In 'netdev_classes', by class->type. *\/$/;"	m	struct:netdev_registered_class	typeref:struct:netdev_registered_class::hmap_node	file:
hmap_node	.\lib\netlink-socket.c	/^    struct hmap_node hmap_node;$/;"	m	struct:genl_family	typeref:struct:genl_family::hmap_node	file:
hmap_node	.\lib\odp-util.h	/^    struct hmap_node hmap_node; \/* A node in a port number to name hmap. *\/$/;"	m	struct:odp_portno_names	typeref:struct:odp_portno_names::hmap_node
hmap_node	.\lib\ofp-msgs.c	/^    struct hmap_node hmap_node; \/* In 'raw_instance_map'. *\/$/;"	m	struct:raw_instance	typeref:struct:raw_instance::hmap_node	file:
hmap_node	.\lib\ovsdb-idl-provider.h	/^    struct hmap_node hmap_node; \/* In struct ovsdb_idl_table's 'rows'. *\/$/;"	m	struct:ovsdb_idl_row	typeref:struct:ovsdb_idl_row::hmap_node
hmap_node	.\lib\ovsdb-idl.c	/^    struct hmap_node hmap_node; \/* In struct ovsdb_idl_txn's inserted_rows. *\/$/;"	m	struct:ovsdb_idl_txn_insert	typeref:struct:ovsdb_idl_txn_insert::hmap_node	file:
hmap_node	.\lib\ovsdb-idl.c	/^    struct hmap_node hmap_node;$/;"	m	struct:ovsdb_idl_txn	typeref:struct:ovsdb_idl_txn::hmap_node	file:
hmap_node	.\lib\pcap-file.c	/^    struct hmap_node hmap_node;$/;"	m	struct:tcp_stream	typeref:struct:tcp_stream::hmap_node	file:
hmap_node	.\lib\poll-loop.c	/^    struct hmap_node hmap_node;$/;"	m	struct:poll_node	typeref:struct:poll_node::hmap_node	file:
hmap_node	.\lib\sset.h	/^    struct hmap_node hmap_node;$/;"	m	struct:sset_node	typeref:struct:sset_node::hmap_node
hmap_node	.\lib\vlandev.h	/^    struct hmap_node hmap_node;     \/* In vlan_real_dev's "vlan_devs" map. *\/$/;"	m	struct:vlan_dev	typeref:struct:vlan_dev::hmap_node
hmap_node	.\ofproto\bond.c	/^    struct hmap_node hmap_node; \/* In 'all_bonds' hmap. *\/$/;"	m	struct:bond	typeref:struct:bond::hmap_node	file:
hmap_node	.\ofproto\bond.c	/^    struct hmap_node hmap_node; \/* In struct bond's slaves hmap. *\/$/;"	m	struct:bond_slave	typeref:struct:bond_slave::hmap_node	file:
hmap_node	.\ofproto\bond.c	/^    struct hmap_node hmap_node;$/;"	m	struct:bond_pr_rule_op	typeref:struct:bond_pr_rule_op::hmap_node	file:
hmap_node	.\ofproto\connmgr.c	/^    struct hmap_node hmap_node; \/* In struct connmgr's "controllers" map. *\/$/;"	m	struct:ofconn	typeref:struct:ofconn::hmap_node	file:
hmap_node	.\ofproto\in-band.c	/^    struct hmap_node hmap_node; \/* In struct in_band's "rules" hmap. *\/$/;"	m	struct:in_band_rule	typeref:struct:in_band_rule::hmap_node	file:
hmap_node	.\ofproto\netflow.c	/^    struct hmap_node hmap_node;$/;"	m	struct:netflow_flow	typeref:struct:netflow_flow::hmap_node	file:
hmap_node	.\ofproto\ofproto-dpif-mirror.c	/^    struct hmap_node hmap_node; \/* In parent 'mbridge' map. *\/$/;"	m	struct:mbundle	typeref:struct:mbundle::hmap_node	file:
hmap_node	.\ofproto\ofproto-dpif-monitor.c	/^    struct hmap_node hmap_node;       \/* In monitor_hmap. *\/$/;"	m	struct:mport	typeref:struct:mport::hmap_node	file:
hmap_node	.\ofproto\ofproto-dpif-sflow.c	/^    struct hmap_node hmap_node; \/* In struct dpif_sflow's "ports" hmap. *\/$/;"	m	struct:dpif_sflow_port	typeref:struct:dpif_sflow_port::hmap_node	file:
hmap_node	.\ofproto\ofproto-dpif-upcall.c	/^    struct hmap_node hmap_node;     \/* In parent revalidator 'ukeys' map. *\/$/;"	m	struct:udpif_key	typeref:struct:udpif_key::hmap_node	file:
hmap_node	.\ofproto\ofproto-dpif-upcall.c	/^    struct hmap_node hmap_node;$/;"	m	struct:flow_miss	typeref:struct:flow_miss::hmap_node	file:
hmap_node	.\ofproto\ofproto-dpif-xlate.c	/^    struct hmap_node hmap_node;      \/* Node in global 'xports' map. *\/$/;"	m	struct:xport	typeref:struct:xport::hmap_node	file:
hmap_node	.\ofproto\ofproto-dpif-xlate.c	/^    struct hmap_node hmap_node;    \/* In global 'xbundles' map. *\/$/;"	m	struct:xbundle	typeref:struct:xbundle::hmap_node	file:
hmap_node	.\ofproto\ofproto-dpif-xlate.c	/^    struct hmap_node hmap_node;   \/* Node in global 'xbridges' map. *\/$/;"	m	struct:xbridge	typeref:struct:xbridge::hmap_node	file:
hmap_node	.\ofproto\ofproto-dpif-xlate.c	/^    struct hmap_node hmap_node; \/* Node in 'ofport_dpif''s 'skb_priorities'. *\/$/;"	m	struct:skb_priority_to_dscp	typeref:struct:skb_priority_to_dscp::hmap_node	file:
hmap_node	.\ofproto\ofproto-dpif.c	/^    struct hmap_node hmap_node; \/* In struct ofproto's "bundles" hmap. *\/$/;"	m	struct:ofbundle	typeref:struct:ofbundle::hmap_node	file:
hmap_node	.\ofproto\ofproto-provider.h	/^    struct hmap_node hmap_node; \/* In global 'all_ofprotos' hmap. *\/$/;"	m	struct:ofproto	typeref:struct:ofproto::hmap_node
hmap_node	.\ofproto\ofproto-provider.h	/^    struct hmap_node hmap_node; \/* In struct ofproto's "groups" hmap. *\/$/;"	m	struct:ofgroup	typeref:struct:ofgroup::hmap_node
hmap_node	.\ofproto\ofproto-provider.h	/^    struct hmap_node hmap_node; \/* In struct ofproto's "ports" hmap. *\/$/;"	m	struct:ofport	typeref:struct:ofport::hmap_node
hmap_node	.\ofproto\ofproto.c	/^    struct hmap_node hmap_node; \/* In ofproto's "deletions" hmap. *\/$/;"	m	struct:ofoperation	typeref:struct:ofoperation::hmap_node	file:
hmap_node	.\ofproto\ofproto.c	/^    struct hmap_node hmap_node; \/* In struct ofproto's "ofport_usage" hmap. *\/$/;"	m	struct:ofport_usage	typeref:struct:ofport_usage::hmap_node	file:
hmap_node	.\ovsdb\jsonrpc-server.c	/^    struct hmap_node hmap_node; \/* In ovsdb_jsonrpc_monitor_table.changes. *\/$/;"	m	struct:ovsdb_jsonrpc_monitor_row	typeref:struct:ovsdb_jsonrpc_monitor_row::hmap_node	file:
hmap_node	.\ovsdb\jsonrpc-server.c	/^    struct hmap_node hmap_node; \/* In session's "triggers" hmap. *\/$/;"	m	struct:ovsdb_jsonrpc_trigger	typeref:struct:ovsdb_jsonrpc_trigger::hmap_node	file:
hmap_node	.\ovsdb\row.h	/^    struct hmap_node hmap_node;    \/* Element in ovsdb_table's 'rows' hmap. *\/$/;"	m	struct:ovsdb_row	typeref:struct:ovsdb_row::hmap_node
hmap_node	.\ovsdb\row.h	/^    struct hmap_node hmap_node;$/;"	m	struct:ovsdb_row_hash_node	typeref:struct:ovsdb_row_hash_node::hmap_node
hmap_node	.\ovsdb\server.h	/^    struct hmap_node hmap_node;  \/* In ovsdb_server's "locks" hmap. *\/$/;"	m	struct:ovsdb_lock	typeref:struct:ovsdb_lock::hmap_node
hmap_node	.\ovsdb\transaction.c	/^    struct hmap_node hmap_node; \/* In ovsdb_txn_table's txn_rows hmap. *\/$/;"	m	struct:ovsdb_txn_row	typeref:struct:ovsdb_txn_row::hmap_node	file:
hmap_node	.\utilities\ovs-dpctl.c	/^    struct hmap_node hmap_node;$/;"	m	struct:actions_for_flow	typeref:struct:actions_for_flow::hmap_node	file:
hmap_node	.\vswitchd\bridge.c	/^    struct hmap_node hmap_node; \/* Element in struct bridge's "ports" hmap. *\/$/;"	m	struct:port	typeref:struct:port::hmap_node	file:
hmap_node	.\vswitchd\bridge.c	/^    struct hmap_node hmap_node; \/* In struct bridge's "mirrors" hmap. *\/$/;"	m	struct:mirror	typeref:struct:mirror::hmap_node	file:
hmap_node_hash	.\lib\hmap.h	/^static inline size_t hmap_node_hash(const struct hmap_node *node)$/;"	f
hmap_node_is_null	.\lib\hmap.h	/^hmap_node_is_null(const struct hmap_node *node)$/;"	f
hmap_node_moved	.\lib\hmap.c	/^hmap_node_moved(struct hmap *hmap,$/;"	f
hmap_node_nullify	.\lib\hmap.h	/^hmap_node_nullify(struct hmap_node *node)$/;"	f
hmap_pathological	.\lib\hmap.c	/^COVERAGE_DEFINE(hmap_pathological);$/;"	v
hmap_random_node	.\lib\hmap.c	/^hmap_random_node(const struct hmap *hmap)$/;"	f
hmap_remove	.\lib\hmap.h	/^hmap_remove(struct hmap *hmap, struct hmap_node *node)$/;"	f
hmap_replace	.\lib\hmap.h	/^hmap_replace(struct hmap *hmap,$/;"	f
hmap_reserve	.\lib\hmap.c	/^COVERAGE_DEFINE(hmap_reserve);$/;"	v
hmap_reserve	.\lib\hmap.h	89;"	d
hmap_reserve_at	.\lib\hmap.c	/^hmap_reserve_at(struct hmap *hmap, size_t n, const char *where)$/;"	f
hmap_shrink	.\lib\hmap.c	/^COVERAGE_DEFINE(hmap_shrink);$/;"	v
hmap_shrink	.\lib\hmap.h	86;"	d
hmap_shrink_at	.\lib\hmap.c	/^hmap_shrink_at(struct hmap *hmap, const char *where)$/;"	f
hmap_swap	.\lib\hmap.c	/^hmap_swap(struct hmap *a, struct hmap *b)$/;"	f
hmapx	.\lib\hmapx.h	/^struct hmapx {$/;"	s
hmapx_add	.\lib\hmapx.c	/^hmapx_add(struct hmapx *map, void *data)$/;"	f
hmapx_add__	.\lib\hmapx.c	/^hmapx_add__(struct hmapx *map, void *data, size_t hash)$/;"	f	file:
hmapx_add_assert	.\lib\hmapx.c	/^hmapx_add_assert(struct hmapx *map, void *data)$/;"	f
hmapx_clear	.\lib\hmapx.c	/^hmapx_clear(struct hmapx *map)$/;"	f
hmapx_clone	.\lib\hmapx.c	/^hmapx_clone(struct hmapx *map, const struct hmapx *orig)$/;"	f
hmapx_contains	.\lib\hmapx.c	/^hmapx_contains(const struct hmapx *map, const void *data)$/;"	f
hmapx_count	.\lib\hmapx.c	/^hmapx_count(const struct hmapx *map)$/;"	f
hmapx_delete	.\lib\hmapx.c	/^hmapx_delete(struct hmapx *map, struct hmapx_node *node)$/;"	f
hmapx_destroy	.\lib\hmapx.c	/^hmapx_destroy(struct hmapx *map)$/;"	f
hmapx_equals	.\lib\hmapx.c	/^hmapx_equals(const struct hmapx *a, const struct hmapx *b)$/;"	f
hmapx_find	.\lib\hmapx.c	/^hmapx_find(const struct hmapx *map, const void *data)$/;"	f
hmapx_find__	.\lib\hmapx.c	/^hmapx_find__(const struct hmapx *map, const void *data, size_t hash)$/;"	f	file:
hmapx_find_and_delete	.\lib\hmapx.c	/^hmapx_find_and_delete(struct hmapx *map, const void *data)$/;"	f
hmapx_find_and_delete_assert	.\lib\hmapx.c	/^hmapx_find_and_delete_assert(struct hmapx *map, const void *data)$/;"	f
hmapx_init	.\lib\hmapx.c	/^hmapx_init(struct hmapx *map)$/;"	f
hmapx_is_empty	.\lib\hmapx.c	/^hmapx_is_empty(const struct hmapx *map)$/;"	f
hmapx_moved	.\lib\hmapx.c	/^hmapx_moved(struct hmapx *map)$/;"	f
hmapx_node	.\lib\hmapx.h	/^struct hmapx_node {$/;"	s
hmapx_swap	.\lib\hmapx.c	/^hmapx_swap(struct hmapx *a, struct hmapx *b)$/;"	f
hold_timer	.\lib\stp.c	/^    struct stp_timer hold_timer;        \/* 8.5.6.3: BPDU rate limit timer. *\/$/;"	m	struct:stp_port	typeref:struct:stp_port::stp_timer	file:
honor_rate_limits	.\lib\vlog.h	/^    bool honor_rate_limits;       \/* Set false to ignore rate limits. *\/$/;"	m	struct:vlog_module
hook	.\lib\fatal-signal.c	/^struct hook {$/;"	s	file:
hook_cb	.\lib\fatal-signal.c	/^    void (*hook_cb)(void *aux);$/;"	m	struct:hook	file:
hooks	.\lib\fatal-signal.c	/^static struct hook hooks[MAX_HOOKS];$/;"	v	typeref:struct:hook	file:
hops	.\lib\dhcp.h	/^    uint8_t hops;               \/* Hop count; set to 0 by client. *\/$/;"	m	struct:dhcp_header
host	.\lib\sflow.h	/^    SFLString host;        \/* The host field from the HTTP header *\/$/;"	m	struct:_SFLExtended_url
host_uuid	.\vswitchd\xenserver.c	/^static char *host_uuid;$/;"	v	file:
hr	.\lib\coverage.h	/^    unsigned int hr[HR_AVG_LEN];$/;"	m	struct:coverage_counter
hstatus	.\lib\daemon-windows.c	/^static SERVICE_STATUS_HANDLE hstatus;$/;"	v	file:
htb	.\lib\netdev-linux.c	/^struct htb {$/;"	s	file:
htb_class	.\lib\netdev-linux.c	/^struct htb_class {$/;"	s	file:
htb_class_cast__	.\lib\netdev-linux.c	/^htb_class_cast__(const struct tc_queue *queue)$/;"	f	file:
htb_class_delete	.\lib\netdev-linux.c	/^htb_class_delete(struct netdev *netdev, struct tc_queue *queue)$/;"	f	file:
htb_class_dump_stats	.\lib\netdev-linux.c	/^htb_class_dump_stats(const struct netdev *netdev OVS_UNUSED,$/;"	f	file:
htb_class_get	.\lib\netdev-linux.c	/^htb_class_get(const struct netdev *netdev OVS_UNUSED,$/;"	f	file:
htb_class_get_stats	.\lib\netdev-linux.c	/^htb_class_get_stats(const struct netdev *netdev, const struct tc_queue *queue,$/;"	f	file:
htb_class_set	.\lib\netdev-linux.c	/^htb_class_set(struct netdev *netdev, unsigned int queue_id,$/;"	f	file:
htb_get__	.\lib\netdev-linux.c	/^htb_get__(const struct netdev *netdev_)$/;"	f	file:
htb_install__	.\lib\netdev-linux.c	/^htb_install__(struct netdev *netdev_, uint64_t max_rate)$/;"	f	file:
htb_parse_class_details__	.\lib\netdev-linux.c	/^htb_parse_class_details__(struct netdev *netdev,$/;"	f	file:
htb_parse_qdisc_details__	.\lib\netdev-linux.c	/^htb_parse_qdisc_details__(struct netdev *netdev_,$/;"	f	file:
htb_parse_tca_options__	.\lib\netdev-linux.c	/^htb_parse_tca_options__(struct nlattr *nl_options, struct htb_class *class)$/;"	f	file:
htb_parse_tcmsg__	.\lib\netdev-linux.c	/^htb_parse_tcmsg__(struct ofpbuf *tcmsg, unsigned int *queue_id,$/;"	f	file:
htb_qdisc_get	.\lib\netdev-linux.c	/^htb_qdisc_get(const struct netdev *netdev, struct smap *details)$/;"	f	file:
htb_qdisc_set	.\lib\netdev-linux.c	/^htb_qdisc_set(struct netdev *netdev, const struct smap *details)$/;"	f	file:
htb_query_class__	.\lib\netdev-linux.c	/^htb_query_class__(const struct netdev *netdev, unsigned int handle,$/;"	f	file:
htb_setup_class__	.\lib\netdev-linux.c	/^htb_setup_class__(struct netdev *netdev, unsigned int handle,$/;"	f	file:
htb_setup_qdisc__	.\lib\netdev-linux.c	/^htb_setup_qdisc__(struct netdev *netdev)$/;"	f	file:
htb_tc_destroy	.\lib\netdev-linux.c	/^htb_tc_destroy(struct tc *tc)$/;"	f	file:
htb_tc_install	.\lib\netdev-linux.c	/^htb_tc_install(struct netdev *netdev, const struct smap *details)$/;"	f	file:
htb_tc_load	.\lib\netdev-linux.c	/^htb_tc_load(struct netdev *netdev, struct ofpbuf *nlmsg OVS_UNUSED)$/;"	f	file:
htb_update_queue__	.\lib\netdev-linux.c	/^htb_update_queue__(struct netdev *netdev, unsigned int queue_id,$/;"	f	file:
htonl	.\include\sparse\netinet\in.h	/^static inline ovs_be32 htonl(uint32_t x)$/;"	f
htonll	.\lib\byte-order.h	/^htonll(uint64_t n)$/;"	f
htons	.\include\sparse\netinet\in.h	/^static inline ovs_be16 htons(uint16_t x)$/;"	f
htype	.\lib\dhcp.h	/^    uint8_t htype;              \/* ARP_HRD_ETHERNET (typically). *\/$/;"	m	struct:dhcp_header
hw_addr	.\include\openflow\openflow-1.0.h	/^    uint8_t hw_addr[OFP_ETH_ALEN]; \/* The hardware address is not$/;"	m	struct:ofp10_port_mod
hw_addr	.\include\openflow\openflow-1.0.h	/^    uint8_t hw_addr[OFP_ETH_ALEN];$/;"	m	struct:ofp10_phy_port
hw_addr	.\include\openflow\openflow-1.1.h	/^    uint8_t hw_addr[OFP_ETH_ALEN]; \/* The hardware address is not$/;"	m	struct:ofp11_port_mod
hw_addr	.\include\openflow\openflow-1.1.h	/^    uint8_t hw_addr[OFP_ETH_ALEN];$/;"	m	struct:ofp11_port
hw_addr	.\include\openflow\openflow-1.4.h	/^    uint8_t hw_addr[OFP_ETH_ALEN];$/;"	m	struct:ofp14_port
hw_addr	.\include\openflow\openflow-1.4.h	/^    uint8_t hw_addr[OFP_ETH_ALEN];$/;"	m	struct:ofp14_port_mod
hw_addr	.\lib\ofp-util.h	/^    uint8_t hw_addr[OFP_ETH_ALEN];$/;"	m	struct:ofputil_phy_port
hw_addr	.\lib\ofp-util.h	/^    uint8_t hw_addr[OFP_ETH_ALEN];$/;"	m	struct:ofputil_port_mod
hw_addr	.\ofproto\ofproto-dpif-monitor.c	/^    uint8_t hw_addr[OFP_ETH_ALEN];    \/* Hardware address. *\/$/;"	m	struct:mport	file:
hw_desc	.\include\openflow\openflow-common.h	/^    char hw_desc[DESC_STR_LEN];        \/* Hardware description. *\/$/;"	m	struct:ofp_desc_stats
hw_desc	.\ofproto\ofproto-provider.h	/^    char *hw_desc;              \/* Hardware (NULL for default). *\/$/;"	m	struct:ofproto
hwaddr	.\lib\netdev-dpdk.c	/^    uint8_t hwaddr[ETH_ADDR_LEN];$/;"	m	struct:netdev_dpdk	file:
i	.\tests\idltest.h	/^	int64_t i;$/;"	m	struct:idltest_link1
i	.\tests\idltest.h	/^	int64_t i;$/;"	m	struct:idltest_link2
i	.\tests\idltest.h	/^	int64_t i;$/;"	m	struct:idltest_simple
i	.\tests\test-sflow.c	/^    uint32_t i;$/;"	m	struct:sflow_xdr	file:
ia	.\tests\idltest.h	/^	int64_t *ia;$/;"	m	struct:idltest_simple
icmp6_cksum	.\include\windows\netinet\icmp6.h	/^	u_int16_t	icmp6_cksum;	\/* checksum field *\/$/;"	m	struct:icmp6_hdr
icmp6_cksum	.\lib\packets.h	/^    ovs_be16 icmp6_cksum;$/;"	m	struct:icmp6_header
icmp6_code	.\include\windows\netinet\icmp6.h	/^	u_int8_t	icmp6_code;	\/* code field *\/$/;"	m	struct:icmp6_hdr
icmp6_code	.\lib\packets.h	/^    uint8_t icmp6_code;$/;"	m	struct:icmp6_header
icmp6_data	.\lib\packets.h	/^    uint8_t icmp6_data[0];$/;"	m	struct:icmp6_header
icmp6_data16	.\include\windows\netinet\icmp6.h	81;"	d
icmp6_data32	.\include\windows\netinet\icmp6.h	80;"	d
icmp6_data8	.\include\windows\netinet\icmp6.h	82;"	d
icmp6_dataun	.\include\windows\netinet\icmp6.h	/^	} icmp6_dataun;$/;"	m	struct:icmp6_hdr	typeref:union:icmp6_hdr::__anon34
icmp6_filt	.\include\windows\netinet\icmp6.h	/^	u_int32_t icmp6_filt[8];$/;"	m	struct:icmp6_filter
icmp6_filter	.\include\windows\netinet\icmp6.h	/^struct icmp6_filter {$/;"	s
icmp6_hdr	.\datapath\linux\compat\include\linux\icmpv6.h	/^static inline struct icmp6hdr *icmp6_hdr(const struct sk_buff *skb)$/;"	f
icmp6_hdr	.\include\windows\netinet\icmp6.h	/^struct icmp6_hdr {$/;"	s
icmp6_header	.\lib\packets.h	/^struct icmp6_header {$/;"	s
icmp6_id	.\include\windows\netinet\icmp6.h	85;"	d
icmp6_maxdelay	.\include\windows\netinet\icmp6.h	87;"	d
icmp6_mtu	.\include\windows\netinet\icmp6.h	84;"	d
icmp6_namelookup	.\include\windows\netinet\icmp6.h	/^struct icmp6_namelookup {$/;"	s
icmp6_ni_hdr	.\include\windows\netinet\icmp6.h	/^	struct icmp6_hdr icmp6_ni_hdr;$/;"	m	struct:icmp6_nodeinfo	typeref:struct:icmp6_nodeinfo::icmp6_hdr
icmp6_ni_nonce	.\include\windows\netinet\icmp6.h	/^	u_int8_t icmp6_ni_nonce[8];$/;"	m	struct:icmp6_nodeinfo
icmp6_nl_hdr	.\include\windows\netinet\icmp6.h	/^	struct icmp6_hdr 	icmp6_nl_hdr;$/;"	m	struct:icmp6_namelookup	typeref:struct:icmp6_namelookup::icmp6_hdr
icmp6_nl_nonce	.\include\windows\netinet\icmp6.h	/^	u_int8_t	icmp6_nl_nonce[8];$/;"	m	struct:icmp6_namelookup
icmp6_nl_ttl	.\include\windows\netinet\icmp6.h	/^	int32_t		icmp6_nl_ttl;$/;"	m	struct:icmp6_namelookup
icmp6_nodeinfo	.\include\windows\netinet\icmp6.h	/^struct icmp6_nodeinfo {$/;"	s
icmp6_pptr	.\include\windows\netinet\icmp6.h	83;"	d
icmp6_router_renum	.\include\windows\netinet\icmp6.h	/^struct icmp6_router_renum {	\/* router renumbering header *\/$/;"	s
icmp6_seq	.\include\windows\netinet\icmp6.h	86;"	d
icmp6_type	.\include\windows\netinet\icmp6.h	/^	u_int8_t	icmp6_type;	\/* type field *\/$/;"	m	struct:icmp6_hdr
icmp6_type	.\lib\packets.h	/^    uint8_t icmp6_type;$/;"	m	struct:icmp6_header
icmp6_un_data16	.\include\windows\netinet\icmp6.h	/^		u_int16_t	icmp6_un_data16[2]; \/* type-specific field *\/$/;"	m	union:icmp6_hdr::__anon34
icmp6_un_data32	.\include\windows\netinet\icmp6.h	/^		u_int32_t	icmp6_un_data32[1]; \/* type-specific field *\/$/;"	m	union:icmp6_hdr::__anon34
icmp6_un_data8	.\include\windows\netinet\icmp6.h	/^		u_int8_t	icmp6_un_data8[4];  \/* type-specific field *\/$/;"	m	union:icmp6_hdr::__anon34
icmp6hdr_ok	.\datapath\flow.c	/^static bool icmp6hdr_ok(struct sk_buff *skb)$/;"	f	file:
icmp_code	.\include\linux\openvswitch.h	/^	__u8 icmp_code;$/;"	m	struct:ovs_key_icmp
icmp_code	.\lib\packets.h	/^    uint8_t icmp_code;$/;"	m	struct:icmp_header
icmp_csum	.\lib\packets.h	/^    ovs_be16 icmp_csum;$/;"	m	struct:icmp_header
icmp_data	.\lib\packets.h	/^    uint8_t icmp_data[0];$/;"	m	struct:icmp_header
icmp_fields	.\lib\packets.h	/^    } icmp_fields;$/;"	m	struct:icmp_header	typeref:union:icmp_header::__anon87
icmp_hdr	.\datapath\linux\compat\include\linux\icmp.h	/^static inline struct icmphdr *icmp_hdr(const struct sk_buff *skb)$/;"	f
icmp_header	.\lib\packets.h	/^struct icmp_header {$/;"	s
icmp_type	.\include\linux\openvswitch.h	/^	__u8 icmp_type;$/;"	m	struct:ovs_key_icmp
icmp_type	.\lib\packets.h	/^    uint8_t icmp_type;$/;"	m	struct:icmp_header
icmphdr_ok	.\datapath\flow.c	/^static bool icmphdr_ok(struct sk_buff *skb)$/;"	f	file:
icmpv6_code	.\include\linux\openvswitch.h	/^	__u8 icmpv6_code;$/;"	m	struct:ovs_key_icmpv6
icmpv6_type	.\include\linux\openvswitch.h	/^	__u8 icmpv6_type;$/;"	m	struct:ovs_key_icmpv6
id	.\datapath\linux\compat\include\net\genetlink.h	/^	unsigned int            id;$/;"	m	struct:rpl_genl_family
id	.\datapath\linux\compat\include\net\net_namespace.h	/^	int *id;$/;"	m	struct:rpl_pernet_operations
id	.\include\openflow\nicira-ext.h	/^    ovs_be32 id;                \/* 'id' from nx_flow_monitor_request. *\/$/;"	m	struct:nx_flow_monitor_cancel
id	.\include\openflow\nicira-ext.h	/^    ovs_be32 id;                \/* Controller-assigned ID for this monitor. *\/$/;"	m	struct:nx_flow_monitor_request
id	.\lib\dpif-netdev.c	/^    int id;$/;"	m	struct:pmd_thread	file:
id	.\lib\jsonrpc.h	/^    struct json *id;            \/* Request or reply only. *\/$/;"	m	struct:jsonrpc_msg	typeref:struct:jsonrpc_msg::json
id	.\lib\lacp.h	/^    uint16_t id;                      \/* Port ID. *\/$/;"	m	struct:lacp_slave_settings
id	.\lib\lacp.h	/^    uint8_t id[ETH_ADDR_LEN];         \/* System ID. Must be nonzero. *\/$/;"	m	struct:lacp_settings
id	.\lib\meta-flow.h	/^    enum mf_field_id id;        \/* MFF_*. *\/$/;"	m	struct:mf_field	typeref:enum:mf_field::mf_field_id
id	.\lib\netlink-socket.c	/^    uint16_t id;$/;"	m	struct:genl_family	file:
id	.\lib\ofp-util.h	/^    uint32_t id;$/;"	m	struct:ofputil_flow_monitor_request
id	.\lib\packets.h	/^            ovs_be16 id;$/;"	m	struct:icmp_header::__anon87::__anon88
id	.\lib\timeval.c	/^    clockid_t id;               \/* CLOCK_MONOTONIC or CLOCK_REALTIME. *\/$/;"	m	struct:clock	file:
id	.\lib\vswitch-idl.h	/^	int64_t id;$/;"	m	struct:ovsrec_flow_sample_collector_set
id	.\ofproto\bundles.c	/^    uint32_t          id;$/;"	m	struct:ofp_bundle	file:
id	.\ofproto\connmgr.h	/^    uint32_t id;$/;"	m	struct:ofmonitor
id	.\ofproto\ofproto-dpif-upcall.c	/^    unsigned int id;                   \/* ovsthread_id_self(). *\/$/;"	m	struct:revalidator	file:
id	.\ovsdb\jsonrpc-server.c	/^    struct json *id;$/;"	m	struct:ovsdb_jsonrpc_trigger	typeref:struct:ovsdb_jsonrpc_trigger::json	file:
id	.\tests\test-stp.c	/^    int id;$/;"	m	struct:bridge	file:
id_node	.\ofproto\ofproto.c	/^    struct hmap_node id_node;   \/* In oftable's "eviction_groups_by_id". *\/$/;"	m	struct:eviction_group	typeref:struct:eviction_group::hmap_node	file:
id_re	.\python\ovs\db\parser.py	/^id_re = re.compile("[_a-zA-Z][_a-zA-Z0-9]*$")$/;"	v
identity	.\python\compat\argparse.py	/^        def identity(string):$/;"	f	function:ArgumentParser.__init__
identity_hash	.\tests\test-hmap.c	/^identity_hash(int value)$/;"	f	file:
idl	.\lib\ovsdb-idl-provider.h	/^    struct ovsdb_idl *idl;   \/* Containing idl. *\/$/;"	m	struct:ovsdb_idl_table	typeref:struct:ovsdb_idl_table::ovsdb_idl
idl	.\lib\ovsdb-idl.c	/^    struct ovsdb_idl *idl;$/;"	m	struct:ovsdb_idl_txn	typeref:struct:ovsdb_idl_txn::ovsdb_idl	file:
idl	.\tests\test-ovsdb.py	/^import ovs.db.idl$/;"	i
idl	.\utilities\ovs-vsctl.c	/^    struct ovsdb_idl *idl;$/;"	m	struct:vsctl_context	typeref:struct:vsctl_context::ovsdb_idl	file:
idl	.\vswitchd\bridge.c	/^static struct ovsdb_idl *idl;$/;"	v	typeref:struct:ovsdb_idl	file:
idl	.\vtep\vtep-ctl.c	/^    struct ovsdb_idl *idl;$/;"	m	struct:vtep_ctl_context	typeref:struct:vtep_ctl_context::ovsdb_idl	file:
idl_seqno	.\vswitchd\bridge.c	/^static unsigned int idl_seqno;$/;"	v	file:
idl_set	.\tests\test-ovsdb.c	/^idl_set(struct ovsdb_idl *idl, char *commands, int step)$/;"	f	file:
idl_set	.\tests\test-ovsdb.py	/^def idl_set(idl, commands, step):$/;"	f
idle	.\ofproto\ofproto-dpif-xlate.c	/^            uint16_t idle;$/;"	m	struct:xc_entry::__anon136::__anon143	file:
idle_age	.\include\openflow\nicira-ext.h	/^    ovs_be16 idle_age;        \/* Seconds since last packet, plus one. *\/$/;"	m	struct:nx_flow_stats
idle_age	.\lib\ofp-util.h	/^    int idle_age;               \/* Seconds since last packet, -1 if unknown. *\/$/;"	m	struct:ofputil_flow_stats
idle_time	.\lib\mac-learning.h	/^    unsigned int idle_time;     \/* Max age before deleting an entry. *\/$/;"	m	struct:mac_learning
idle_timeout	.\include\openflow\nicira-ext.h	/^    ovs_be16 idle_timeout;        \/* Idle time before discarding (seconds). *\/$/;"	m	struct:nx_flow_mod
idle_timeout	.\include\openflow\nicira-ext.h	/^    ovs_be16 idle_timeout;      \/* Idle time before discarding (seconds). *\/$/;"	m	struct:nx_action_learn
idle_timeout	.\include\openflow\nicira-ext.h	/^    ovs_be16 idle_timeout;      \/* Number of seconds idle before expiration. *\/$/;"	m	struct:nx_flow_update_full
idle_timeout	.\include\openflow\nicira-ext.h	/^    ovs_be16 idle_timeout;    \/* Idle timeout from original flow mod. *\/$/;"	m	struct:nx_flow_removed
idle_timeout	.\include\openflow\nicira-ext.h	/^    ovs_be16 idle_timeout;    \/* Number of seconds idle before expiration. *\/$/;"	m	struct:nx_flow_stats
idle_timeout	.\include\openflow\openflow-1.0.h	/^    ovs_be16 idle_timeout;        \/* Idle time before discarding (seconds). *\/$/;"	m	struct:ofp10_flow_mod
idle_timeout	.\include\openflow\openflow-1.0.h	/^    ovs_be16 idle_timeout;    \/* Idle timeout from original flow mod. *\/$/;"	m	struct:ofp10_flow_removed
idle_timeout	.\include\openflow\openflow-1.0.h	/^    ovs_be16 idle_timeout;    \/* Number of seconds idle before expiration. *\/$/;"	m	struct:ofp10_flow_stats
idle_timeout	.\include\openflow\openflow-1.1.h	/^    ovs_be16 idle_timeout;       \/* Idle time before discarding (seconds). *\/$/;"	m	struct:ofp11_flow_mod
idle_timeout	.\include\openflow\openflow-1.1.h	/^    ovs_be16 idle_timeout;     \/* Number of seconds idle before expiration. *\/$/;"	m	struct:ofp11_flow_stats
idle_timeout	.\include\openflow\openflow-1.1.h	/^    ovs_be16 idle_timeout;    \/* Idle timeout from original flow mod. *\/$/;"	m	struct:ofp11_flow_removed
idle_timeout	.\include\openflow\openflow-1.2.h	/^    ovs_be16 idle_timeout;    \/* Idle timeout from original flow mod. *\/$/;"	m	struct:ofp12_flow_removed
idle_timeout	.\lib\ofp-actions.h	/^    uint16_t idle_timeout;      \/* Idle time before discarding (seconds). *\/$/;"	m	struct:ofpact_learn
idle_timeout	.\lib\ofp-util.h	/^    uint16_t idle_timeout;$/;"	m	struct:ofputil_flow_mod
idle_timeout	.\lib\ofp-util.h	/^    uint16_t idle_timeout;$/;"	m	struct:ofputil_flow_removed
idle_timeout	.\lib\ofp-util.h	/^    uint16_t idle_timeout;$/;"	m	struct:ofputil_flow_stats
idle_timeout	.\lib\ofp-util.h	/^    uint16_t idle_timeout;$/;"	m	struct:ofputil_flow_update
idle_timeout	.\ofproto\ofproto.c	/^    uint16_t idle_timeout;              \/* Rule's old idle timeout. *\/$/;"	m	struct:ofoperation	file:
idle_timeout	.\utilities\ovs-ofctl.c	/^    uint16_t idle_timeout;$/;"	m	struct:fte_version	file:
idltest_find_simple	.\tests\test-ovsdb.c	/^idltest_find_simple(struct ovsdb_idl *idl, int i)$/;"	f	file:
idltest_find_simple	.\tests\test-ovsdb.py	/^def idltest_find_simple(idl, i):$/;"	f
idltest_get_db_version	.\tests\idltest.c	/^idltest_get_db_version(void)$/;"	f
idltest_idl_class	.\tests\idltest.c	/^struct ovsdb_idl_class idltest_idl_class = {$/;"	v	typeref:struct:ovsdb_idl_class
idltest_init	.\tests\idltest.c	/^idltest_init(void)$/;"	f
idltest_link1	.\tests\idltest.h	/^struct idltest_link1 {$/;"	s
idltest_link1_cast	.\tests\idltest.c	/^idltest_link1_cast(const struct ovsdb_idl_row *row)$/;"	f	file:
idltest_link1_col_i	.\tests\idltest.h	40;"	d
idltest_link1_col_k	.\tests\idltest.h	41;"	d
idltest_link1_col_ka	.\tests\idltest.h	43;"	d
idltest_link1_col_l2	.\tests\idltest.h	42;"	d
idltest_link1_columns	.\tests\idltest.c	/^struct ovsdb_idl_column idltest_link1_columns[IDLTEST_LINK1_N_COLUMNS];$/;"	v	typeref:struct:ovsdb_idl_column
idltest_link1_columns_init	.\tests\idltest.c	/^idltest_link1_columns_init(void)$/;"	f	file:
idltest_link1_delete	.\tests\idltest.c	/^idltest_link1_delete(const struct idltest_link1 *row)$/;"	f
idltest_link1_first	.\tests\idltest.c	/^idltest_link1_first(const struct ovsdb_idl *idl)$/;"	f
idltest_link1_get_for_uuid	.\tests\idltest.c	/^idltest_link1_get_for_uuid(const struct ovsdb_idl *idl, const struct uuid *uuid)$/;"	f
idltest_link1_get_i	.\tests\idltest.c	/^idltest_link1_get_i(const struct idltest_link1 *row,$/;"	f
idltest_link1_get_k	.\tests\idltest.c	/^idltest_link1_get_k(const struct idltest_link1 *row,$/;"	f
idltest_link1_get_ka	.\tests\idltest.c	/^idltest_link1_get_ka(const struct idltest_link1 *row,$/;"	f
idltest_link1_get_l2	.\tests\idltest.c	/^idltest_link1_get_l2(const struct idltest_link1 *row,$/;"	f
idltest_link1_init	.\tests\idltest.c	/^idltest_link1_init(struct idltest_link1 *row)$/;"	f
idltest_link1_init__	.\tests\idltest.c	/^idltest_link1_init__(struct ovsdb_idl_row *row)$/;"	f	file:
idltest_link1_insert	.\tests\idltest.c	/^idltest_link1_insert(struct ovsdb_idl_txn *txn)$/;"	f
idltest_link1_next	.\tests\idltest.c	/^idltest_link1_next(const struct idltest_link1 *row)$/;"	f
idltest_link1_parse_i	.\tests\idltest.c	/^idltest_link1_parse_i(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
idltest_link1_parse_k	.\tests\idltest.c	/^idltest_link1_parse_k(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
idltest_link1_parse_ka	.\tests\idltest.c	/^idltest_link1_parse_ka(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
idltest_link1_parse_l2	.\tests\idltest.c	/^idltest_link1_parse_l2(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
idltest_link1_set_i	.\tests\idltest.c	/^idltest_link1_set_i(const struct idltest_link1 *row, int64_t i)$/;"	f
idltest_link1_set_k	.\tests\idltest.c	/^idltest_link1_set_k(const struct idltest_link1 *row, const struct idltest_link1 *k)$/;"	f
idltest_link1_set_ka	.\tests\idltest.c	/^idltest_link1_set_ka(const struct idltest_link1 *row, struct idltest_link1 **ka, size_t n_ka)$/;"	f
idltest_link1_set_l2	.\tests\idltest.c	/^idltest_link1_set_l2(const struct idltest_link1 *row, const struct idltest_link2 *l2)$/;"	f
idltest_link1_unparse_i	.\tests\idltest.c	/^idltest_link1_unparse_i(struct ovsdb_idl_row *row OVS_UNUSED)$/;"	f	file:
idltest_link1_unparse_k	.\tests\idltest.c	/^idltest_link1_unparse_k(struct ovsdb_idl_row *row OVS_UNUSED)$/;"	f	file:
idltest_link1_unparse_ka	.\tests\idltest.c	/^idltest_link1_unparse_ka(struct ovsdb_idl_row *row_)$/;"	f	file:
idltest_link1_unparse_l2	.\tests\idltest.c	/^idltest_link1_unparse_l2(struct ovsdb_idl_row *row OVS_UNUSED)$/;"	f	file:
idltest_link1_verify_i	.\tests\idltest.c	/^idltest_link1_verify_i(const struct idltest_link1 *row)$/;"	f
idltest_link1_verify_k	.\tests\idltest.c	/^idltest_link1_verify_k(const struct idltest_link1 *row)$/;"	f
idltest_link1_verify_ka	.\tests\idltest.c	/^idltest_link1_verify_ka(const struct idltest_link1 *row)$/;"	f
idltest_link1_verify_l2	.\tests\idltest.c	/^idltest_link1_verify_l2(const struct idltest_link1 *row)$/;"	f
idltest_link2	.\tests\idltest.h	/^struct idltest_link2 {$/;"	s
idltest_link2_cast	.\tests\idltest.c	/^idltest_link2_cast(const struct ovsdb_idl_row *row)$/;"	f	file:
idltest_link2_col_i	.\tests\idltest.h	99;"	d
idltest_link2_col_l1	.\tests\idltest.h	100;"	d
idltest_link2_columns	.\tests\idltest.c	/^struct ovsdb_idl_column idltest_link2_columns[IDLTEST_LINK2_N_COLUMNS];$/;"	v	typeref:struct:ovsdb_idl_column
idltest_link2_columns_init	.\tests\idltest.c	/^idltest_link2_columns_init(void)$/;"	f	file:
idltest_link2_delete	.\tests\idltest.c	/^idltest_link2_delete(const struct idltest_link2 *row)$/;"	f
idltest_link2_first	.\tests\idltest.c	/^idltest_link2_first(const struct ovsdb_idl *idl)$/;"	f
idltest_link2_get_for_uuid	.\tests\idltest.c	/^idltest_link2_get_for_uuid(const struct ovsdb_idl *idl, const struct uuid *uuid)$/;"	f
idltest_link2_get_i	.\tests\idltest.c	/^idltest_link2_get_i(const struct idltest_link2 *row,$/;"	f
idltest_link2_get_l1	.\tests\idltest.c	/^idltest_link2_get_l1(const struct idltest_link2 *row,$/;"	f
idltest_link2_init	.\tests\idltest.c	/^idltest_link2_init(struct idltest_link2 *row)$/;"	f
idltest_link2_init__	.\tests\idltest.c	/^idltest_link2_init__(struct ovsdb_idl_row *row)$/;"	f	file:
idltest_link2_insert	.\tests\idltest.c	/^idltest_link2_insert(struct ovsdb_idl_txn *txn)$/;"	f
idltest_link2_next	.\tests\idltest.c	/^idltest_link2_next(const struct idltest_link2 *row)$/;"	f
idltest_link2_parse_i	.\tests\idltest.c	/^idltest_link2_parse_i(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
idltest_link2_parse_l1	.\tests\idltest.c	/^idltest_link2_parse_l1(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
idltest_link2_set_i	.\tests\idltest.c	/^idltest_link2_set_i(const struct idltest_link2 *row, int64_t i)$/;"	f
idltest_link2_set_l1	.\tests\idltest.c	/^idltest_link2_set_l1(const struct idltest_link2 *row, const struct idltest_link1 *l1)$/;"	f
idltest_link2_unparse_i	.\tests\idltest.c	/^idltest_link2_unparse_i(struct ovsdb_idl_row *row OVS_UNUSED)$/;"	f	file:
idltest_link2_unparse_l1	.\tests\idltest.c	/^idltest_link2_unparse_l1(struct ovsdb_idl_row *row OVS_UNUSED)$/;"	f	file:
idltest_link2_verify_i	.\tests\idltest.c	/^idltest_link2_verify_i(const struct idltest_link2 *row)$/;"	f
idltest_link2_verify_l1	.\tests\idltest.c	/^idltest_link2_verify_l1(const struct idltest_link2 *row)$/;"	f
idltest_simple	.\tests\idltest.h	/^struct idltest_simple {$/;"	s
idltest_simple_cast	.\tests\idltest.c	/^idltest_simple_cast(const struct ovsdb_idl_row *row)$/;"	f	file:
idltest_simple_col_b	.\tests\idltest.h	187;"	d
idltest_simple_col_ba	.\tests\idltest.h	188;"	d
idltest_simple_col_i	.\tests\idltest.h	189;"	d
idltest_simple_col_ia	.\tests\idltest.h	194;"	d
idltest_simple_col_r	.\tests\idltest.h	191;"	d
idltest_simple_col_ra	.\tests\idltest.h	193;"	d
idltest_simple_col_s	.\tests\idltest.h	190;"	d
idltest_simple_col_sa	.\tests\idltest.h	195;"	d
idltest_simple_col_u	.\tests\idltest.h	192;"	d
idltest_simple_col_ua	.\tests\idltest.h	196;"	d
idltest_simple_columns	.\tests\idltest.c	/^struct ovsdb_idl_column idltest_simple_columns[IDLTEST_SIMPLE_N_COLUMNS];$/;"	v	typeref:struct:ovsdb_idl_column
idltest_simple_columns_init	.\tests\idltest.c	/^idltest_simple_columns_init(void)$/;"	f	file:
idltest_simple_delete	.\tests\idltest.c	/^idltest_simple_delete(const struct idltest_simple *row)$/;"	f
idltest_simple_first	.\tests\idltest.c	/^idltest_simple_first(const struct ovsdb_idl *idl)$/;"	f
idltest_simple_get_b	.\tests\idltest.c	/^idltest_simple_get_b(const struct idltest_simple *row,$/;"	f
idltest_simple_get_ba	.\tests\idltest.c	/^idltest_simple_get_ba(const struct idltest_simple *row,$/;"	f
idltest_simple_get_for_uuid	.\tests\idltest.c	/^idltest_simple_get_for_uuid(const struct ovsdb_idl *idl, const struct uuid *uuid)$/;"	f
idltest_simple_get_i	.\tests\idltest.c	/^idltest_simple_get_i(const struct idltest_simple *row,$/;"	f
idltest_simple_get_ia	.\tests\idltest.c	/^idltest_simple_get_ia(const struct idltest_simple *row,$/;"	f
idltest_simple_get_r	.\tests\idltest.c	/^idltest_simple_get_r(const struct idltest_simple *row,$/;"	f
idltest_simple_get_ra	.\tests\idltest.c	/^idltest_simple_get_ra(const struct idltest_simple *row,$/;"	f
idltest_simple_get_s	.\tests\idltest.c	/^idltest_simple_get_s(const struct idltest_simple *row,$/;"	f
idltest_simple_get_sa	.\tests\idltest.c	/^idltest_simple_get_sa(const struct idltest_simple *row,$/;"	f
idltest_simple_get_u	.\tests\idltest.c	/^idltest_simple_get_u(const struct idltest_simple *row,$/;"	f
idltest_simple_get_ua	.\tests\idltest.c	/^idltest_simple_get_ua(const struct idltest_simple *row,$/;"	f
idltest_simple_init	.\tests\idltest.c	/^idltest_simple_init(struct idltest_simple *row)$/;"	f
idltest_simple_init__	.\tests\idltest.c	/^idltest_simple_init__(struct ovsdb_idl_row *row)$/;"	f	file:
idltest_simple_insert	.\tests\idltest.c	/^idltest_simple_insert(struct ovsdb_idl_txn *txn)$/;"	f
idltest_simple_next	.\tests\idltest.c	/^idltest_simple_next(const struct idltest_simple *row)$/;"	f
idltest_simple_parse_b	.\tests\idltest.c	/^idltest_simple_parse_b(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
idltest_simple_parse_ba	.\tests\idltest.c	/^idltest_simple_parse_ba(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
idltest_simple_parse_i	.\tests\idltest.c	/^idltest_simple_parse_i(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
idltest_simple_parse_ia	.\tests\idltest.c	/^idltest_simple_parse_ia(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
idltest_simple_parse_r	.\tests\idltest.c	/^idltest_simple_parse_r(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
idltest_simple_parse_ra	.\tests\idltest.c	/^idltest_simple_parse_ra(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
idltest_simple_parse_s	.\tests\idltest.c	/^idltest_simple_parse_s(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
idltest_simple_parse_sa	.\tests\idltest.c	/^idltest_simple_parse_sa(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
idltest_simple_parse_u	.\tests\idltest.c	/^idltest_simple_parse_u(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
idltest_simple_parse_ua	.\tests\idltest.c	/^idltest_simple_parse_ua(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
idltest_simple_set_b	.\tests\idltest.c	/^idltest_simple_set_b(const struct idltest_simple *row, bool b)$/;"	f
idltest_simple_set_ba	.\tests\idltest.c	/^idltest_simple_set_ba(const struct idltest_simple *row, const bool *ba, size_t n_ba)$/;"	f
idltest_simple_set_i	.\tests\idltest.c	/^idltest_simple_set_i(const struct idltest_simple *row, int64_t i)$/;"	f
idltest_simple_set_ia	.\tests\idltest.c	/^idltest_simple_set_ia(const struct idltest_simple *row, const int64_t *ia, size_t n_ia)$/;"	f
idltest_simple_set_r	.\tests\idltest.c	/^idltest_simple_set_r(const struct idltest_simple *row, double r)$/;"	f
idltest_simple_set_ra	.\tests\idltest.c	/^idltest_simple_set_ra(const struct idltest_simple *row, const double *ra, size_t n_ra)$/;"	f
idltest_simple_set_s	.\tests\idltest.c	/^idltest_simple_set_s(const struct idltest_simple *row, const char *s)$/;"	f
idltest_simple_set_sa	.\tests\idltest.c	/^idltest_simple_set_sa(const struct idltest_simple *row, char **sa, size_t n_sa)$/;"	f
idltest_simple_set_u	.\tests\idltest.c	/^idltest_simple_set_u(const struct idltest_simple *row, struct uuid u)$/;"	f
idltest_simple_set_ua	.\tests\idltest.c	/^idltest_simple_set_ua(const struct idltest_simple *row, const struct uuid *ua, size_t n_ua)$/;"	f
idltest_simple_unparse_b	.\tests\idltest.c	/^idltest_simple_unparse_b(struct ovsdb_idl_row *row OVS_UNUSED)$/;"	f	file:
idltest_simple_unparse_ba	.\tests\idltest.c	/^idltest_simple_unparse_ba(struct ovsdb_idl_row *row_)$/;"	f	file:
idltest_simple_unparse_i	.\tests\idltest.c	/^idltest_simple_unparse_i(struct ovsdb_idl_row *row OVS_UNUSED)$/;"	f	file:
idltest_simple_unparse_ia	.\tests\idltest.c	/^idltest_simple_unparse_ia(struct ovsdb_idl_row *row_)$/;"	f	file:
idltest_simple_unparse_r	.\tests\idltest.c	/^idltest_simple_unparse_r(struct ovsdb_idl_row *row OVS_UNUSED)$/;"	f	file:
idltest_simple_unparse_ra	.\tests\idltest.c	/^idltest_simple_unparse_ra(struct ovsdb_idl_row *row_)$/;"	f	file:
idltest_simple_unparse_s	.\tests\idltest.c	/^idltest_simple_unparse_s(struct ovsdb_idl_row *row OVS_UNUSED)$/;"	f	file:
idltest_simple_unparse_sa	.\tests\idltest.c	/^idltest_simple_unparse_sa(struct ovsdb_idl_row *row_)$/;"	f	file:
idltest_simple_unparse_u	.\tests\idltest.c	/^idltest_simple_unparse_u(struct ovsdb_idl_row *row OVS_UNUSED)$/;"	f	file:
idltest_simple_unparse_ua	.\tests\idltest.c	/^idltest_simple_unparse_ua(struct ovsdb_idl_row *row_)$/;"	f	file:
idltest_simple_verify_b	.\tests\idltest.c	/^idltest_simple_verify_b(const struct idltest_simple *row)$/;"	f
idltest_simple_verify_ba	.\tests\idltest.c	/^idltest_simple_verify_ba(const struct idltest_simple *row)$/;"	f
idltest_simple_verify_i	.\tests\idltest.c	/^idltest_simple_verify_i(const struct idltest_simple *row)$/;"	f
idltest_simple_verify_ia	.\tests\idltest.c	/^idltest_simple_verify_ia(const struct idltest_simple *row)$/;"	f
idltest_simple_verify_r	.\tests\idltest.c	/^idltest_simple_verify_r(const struct idltest_simple *row)$/;"	f
idltest_simple_verify_ra	.\tests\idltest.c	/^idltest_simple_verify_ra(const struct idltest_simple *row)$/;"	f
idltest_simple_verify_s	.\tests\idltest.c	/^idltest_simple_verify_s(const struct idltest_simple *row)$/;"	f
idltest_simple_verify_sa	.\tests\idltest.c	/^idltest_simple_verify_sa(const struct idltest_simple *row)$/;"	f
idltest_simple_verify_u	.\tests\idltest.c	/^idltest_simple_verify_u(const struct idltest_simple *row)$/;"	f
idltest_simple_verify_ua	.\tests\idltest.c	/^idltest_simple_verify_ua(const struct idltest_simple *row)$/;"	f
idltest_table_classes	.\tests\idltest.c	/^struct ovsdb_idl_table_class idltest_table_classes[IDLTEST_N_TABLES] = {$/;"	v	typeref:struct:ovsdb_idl_table_class
idltest_table_link1	.\tests\idltest.h	261;"	d
idltest_table_link2	.\tests\idltest.h	262;"	d
idltest_table_simple	.\tests\idltest.h	260;"	d
ids	.\datapath\vport.h	/^	u32 ids[];$/;"	m	struct:vport_portids
idx	.\lib\heap.h	/^    size_t idx;$/;"	m	struct:heap_node
idx	.\ofproto\ofproto-dpif-mirror.c	/^    size_t idx;                 \/* In ofproto's "mirrors" array. *\/$/;"	m	struct:mirror	file:
idx_count	.\lib\coverage.c	/^static unsigned int idx_count = 0;$/;"	v	file:
ifDirection	.\lib\sflow.h	/^    u_int32_t ifDirection;        \/* Derived from MAU MIB (RFC 2668)$/;"	m	struct:_SFLIf_counters
ifInBroadcastPkts	.\lib\sflow.h	/^    u_int32_t ifInBroadcastPkts;$/;"	m	struct:_SFLIf_counters
ifInDiscards	.\lib\sflow.h	/^    u_int32_t ifInDiscards;$/;"	m	struct:_SFLIf_counters
ifInErrors	.\lib\sflow.h	/^    u_int32_t ifInErrors;$/;"	m	struct:_SFLIf_counters
ifInMulticastPkts	.\lib\sflow.h	/^    u_int32_t ifInMulticastPkts;$/;"	m	struct:_SFLIf_counters
ifInOctets	.\lib\sflow.h	/^    u_int64_t ifInOctets;$/;"	m	struct:_SFLIf_counters
ifInUcastPkts	.\lib\sflow.h	/^    u_int32_t ifInUcastPkts;$/;"	m	struct:_SFLIf_counters
ifInUnknownProtos	.\lib\sflow.h	/^    u_int32_t ifInUnknownProtos;$/;"	m	struct:_SFLIf_counters
ifIndex	.\lib\sflow.h	/^    u_int32_t ifIndex;$/;"	m	struct:_SFLIf_counters
ifOutBroadcastPkts	.\lib\sflow.h	/^    u_int32_t ifOutBroadcastPkts;$/;"	m	struct:_SFLIf_counters
ifOutDiscards	.\lib\sflow.h	/^    u_int32_t ifOutDiscards;$/;"	m	struct:_SFLIf_counters
ifOutErrors	.\lib\sflow.h	/^    u_int32_t ifOutErrors;$/;"	m	struct:_SFLIf_counters
ifOutMulticastPkts	.\lib\sflow.h	/^    u_int32_t ifOutMulticastPkts;$/;"	m	struct:_SFLIf_counters
ifOutOctets	.\lib\sflow.h	/^    u_int64_t ifOutOctets;$/;"	m	struct:_SFLIf_counters
ifOutUcastPkts	.\lib\sflow.h	/^    u_int32_t ifOutUcastPkts;$/;"	m	struct:_SFLIf_counters
ifPromiscuousMode	.\lib\sflow.h	/^    u_int32_t ifPromiscuousMode;$/;"	m	struct:_SFLIf_counters
ifSpeed	.\lib\sflow.h	/^    u_int64_t ifSpeed;$/;"	m	struct:_SFLIf_counters
ifStatus	.\lib\sflow.h	/^    u_int32_t ifStatus;           \/* bit field with the following bits assigned:$/;"	m	struct:_SFLIf_counters
ifType	.\lib\sflow.h	/^    u_int32_t ifType;$/;"	m	struct:_SFLIf_counters
if_index	.\lib\rtbsd.h	/^    int if_index;              \/* Index of network device. *\/$/;"	m	struct:rtbsd_change
if_name	.\lib\rtbsd.h	/^    char if_name[IF_NAMESIZE];         \/* Name of network device. *\/$/;"	m	struct:rtbsd_change
if_up	.\utilities\ovs-dpctl.c	/^static int if_up(const char *netdev_name)$/;"	f	file:
iface	.\ofproto\ofproto-dpif-xlate.c	/^            ofp_port_t iface;$/;"	m	struct:xc_entry::__anon136::__anon138	file:
iface	.\vswitchd\bridge.c	/^    struct iface *iface;$/;"	m	struct:qos_unixctl_show_cbdata	typeref:struct:qos_unixctl_show_cbdata::iface	file:
iface	.\vswitchd\bridge.c	/^struct iface {$/;"	s	file:
iface_by_name	.\vswitchd\bridge.c	/^    struct hmap iface_by_name;  \/* "struct iface"s indexed by name. *\/$/;"	m	struct:bridge	typeref:struct:bridge::hmap	file:
iface_cfg	.\utilities\ovs-vsctl.c	/^    struct ovsrec_interface *iface_cfg;$/;"	m	struct:vsctl_iface	typeref:struct:vsctl_iface::ovsrec_interface	file:
iface_clear_db_record	.\vswitchd\bridge.c	/^iface_clear_db_record(const struct ovsrec_interface *if_cfg)$/;"	f	file:
iface_configure_cfm	.\vswitchd\bridge.c	/^iface_configure_cfm(struct iface *iface)$/;"	f	file:
iface_configure_lacp	.\vswitchd\bridge.c	/^iface_configure_lacp(struct iface *iface, struct lacp_slave_settings *s)$/;"	f	file:
iface_configure_qos	.\vswitchd\bridge.c	/^iface_configure_qos(struct iface *iface, const struct ovsrec_qos *qos)$/;"	f	file:
iface_create	.\vswitchd\bridge.c	/^iface_create(struct bridge *br, const struct ovsrec_interface *iface_cfg,$/;"	f	file:
iface_destroy	.\vswitchd\bridge.c	/^iface_destroy(struct iface *iface)$/;"	f	file:
iface_destroy__	.\vswitchd\bridge.c	/^iface_destroy__(struct iface *iface)$/;"	f	file:
iface_do_create	.\vswitchd\bridge.c	/^iface_do_create(const struct bridge *br,$/;"	f	file:
iface_find	.\vswitchd\bridge.c	/^iface_find(const char *name)$/;"	f	file:
iface_from_ofp_port	.\vswitchd\bridge.c	/^iface_from_ofp_port(const struct bridge *br, ofp_port_t ofp_port)$/;"	f	file:
iface_get_requested_ofp_port	.\vswitchd\bridge.c	/^iface_get_requested_ofp_port(const struct ovsrec_interface *cfg)$/;"	f	file:
iface_get_type	.\vswitchd\bridge.c	/^iface_get_type(const struct ovsrec_interface *iface,$/;"	f	file:
iface_hint	.\ofproto\ofproto.h	/^struct iface_hint {$/;"	s
iface_is_internal	.\vswitchd\bridge.c	/^iface_is_internal(const struct ovsrec_interface *iface,$/;"	f	file:
iface_is_synthetic	.\vswitchd\bridge.c	/^iface_is_synthetic(const struct iface *iface)$/;"	f	file:
iface_lookup	.\vswitchd\bridge.c	/^iface_lookup(const struct bridge *br, const char *name)$/;"	f	file:
iface_pick_ofport	.\vswitchd\bridge.c	/^iface_pick_ofport(const struct ovsrec_interface *cfg)$/;"	f	file:
iface_refresh_cfm_stats	.\vswitchd\bridge.c	/^iface_refresh_cfm_stats(struct iface *iface)$/;"	f	file:
iface_refresh_netdev_status	.\vswitchd\bridge.c	/^iface_refresh_netdev_status(struct iface *iface)$/;"	f	file:
iface_refresh_ofproto_status	.\vswitchd\bridge.c	/^iface_refresh_ofproto_status(struct iface *iface)$/;"	f	file:
iface_refresh_stats	.\vswitchd\bridge.c	/^iface_refresh_stats(struct iface *iface)$/;"	f	file:
iface_set_mac	.\vswitchd\bridge.c	/^iface_set_mac(const struct bridge *br, const struct port *port, struct iface *iface)$/;"	f	file:
iface_set_netdev_config	.\vswitchd\bridge.c	/^iface_set_netdev_config(const struct ovsrec_interface *iface_cfg,$/;"	f	file:
iface_set_ofport	.\vswitchd\bridge.c	/^iface_set_ofport(const struct ovsrec_interface *if_cfg, ofp_port_t ofport)$/;"	f	file:
iface_validate_ofport__	.\vswitchd\bridge.c	/^iface_validate_ofport__(size_t n, int64_t *ofport)$/;"	f	file:
ifaces	.\utilities\ovs-vsctl.c	/^    struct list ifaces;         \/* Contains "struct vsctl_iface"s. *\/$/;"	m	struct:vsctl_port	typeref:struct:vsctl_port::list	file:
ifaces	.\utilities\ovs-vsctl.c	/^    struct shash ifaces;    \/* Maps from port name to struct vsctl_iface. *\/$/;"	m	struct:vsctl_context	typeref:struct:vsctl_context::shash	file:
ifaces	.\vswitchd\bridge.c	/^    struct hmap ifaces;         \/* "struct iface"s indexed by ofp_port. *\/$/;"	m	struct:bridge	typeref:struct:bridge::hmap	file:
ifaces	.\vswitchd\bridge.c	/^    struct list ifaces;         \/* List of "struct iface"s. *\/$/;"	m	struct:port	typeref:struct:port::list	file:
ifaces_node	.\utilities\ovs-vsctl.c	/^    struct list ifaces_node;     \/* In struct vsctl_port's 'ifaces' list. *\/$/;"	m	struct:vsctl_iface	typeref:struct:vsctl_iface::list	file:
iff_to_nd_flags	.\lib\netdev-bsd.c	/^iff_to_nd_flags(int iff)$/;"	f	file:
iff_to_nd_flags	.\lib\netdev-linux.c	/^iff_to_nd_flags(int iff)$/;"	f	file:
ifi_flags	.\lib\netdev-linux.c	/^    unsigned int ifi_flags;$/;"	m	struct:netdev_linux	file:
ifi_flags	.\lib\rtnetlink-link.h	/^    unsigned int ifi_flags;     \/* Flags of network device. *\/$/;"	m	struct:rtnetlink_link_change
ifi_index	.\lib\route-table.c	/^    uint32_t ifi_index;    \/* Kernel interface index. *\/$/;"	m	struct:name_node	file:
ifi_index	.\lib\rtnetlink-link.h	/^    int ifi_index;              \/* Index of network device. *\/$/;"	m	struct:rtnetlink_link_change
ifindex	.\lib\netdev-bsd.c	/^    int ifindex;$/;"	m	struct:netdev_bsd	file:
ifindex	.\lib\netdev-linux.c	/^    int ifindex;$/;"	m	struct:netdev_linux	file:
ifindex	.\lib\vswitch-idl.h	/^	int64_t *ifindex;$/;"	m	struct:ovsrec_interface
ifname	.\lib\route-table.c	/^    char ifname[IFNAMSIZ]; \/* Interface name. *\/$/;"	m	struct:name_node	file:
ifname	.\lib\rtnetlink-link.h	/^    const char *ifname;         \/* Name of network device. *\/$/;"	m	struct:rtnetlink_link_change
ifr_get_flags	.\lib\netdev-bsd.c	/^ifr_get_flags(const struct ifreq *ifr)$/;"	f	file:
ifr_set_flags	.\lib\netdev-bsd.c	/^ifr_set_flags(struct ifreq *ifr, int flags)$/;"	f	file:
ignore	.\lib\util.c	/^void ignore(bool x OVS_UNUSED) { }$/;"	f
ignore_existing_pidfile	.\lib\daemon-unix.c	/^ignore_existing_pidfile(void)$/;"	f
ignore_existing_pidfile	.\python\ovs\daemon.py	/^def ignore_existing_pidfile():$/;"	f
illegal_highdma	.\datapath\linux\compat\netdevice.c	/^static inline int illegal_highdma(struct net_device *dev, struct sk_buff *skb)$/;"	f	file:
illoptchar	.\lib\getopt_long.c	/^static const char illoptchar[] = "unknown option -- %c";$/;"	v	file:
illoptstring	.\lib\getopt_long.c	/^static const char illoptstring[] = "unknown option -- %s";$/;"	v	file:
ilog2	.\datapath\linux\compat\include\linux\log2.h	12;"	d
immediate_wake	.\python\ovs\poller.py	/^    def immediate_wake(self):$/;"	m	class:Poller
implements	.\python\ovstest\tcp.py	/^from zope.interface import implements$/;"	i
in4	.\lib\netdev-bsd.c	/^    struct in_addr in4;$/;"	m	struct:netdev_bsd	typeref:struct:netdev_bsd::in_addr	file:
in6	.\lib\netdev-bsd.c	/^    struct in6_addr in6;$/;"	m	struct:netdev_bsd	typeref:struct:netdev_bsd::in6_addr	file:
in6	.\lib\netdev-linux.c	/^    struct in6_addr in6;$/;"	m	struct:netdev_linux	typeref:struct:netdev_linux::in6_addr	file:
in6_addr	.\include\sparse\netinet\in.h	/^struct in6_addr {$/;"	s
in6addr_exact	.\lib\packets.c	/^const struct in6_addr in6addr_exact = IN6ADDR_EXACT_INIT;$/;"	v	typeref:struct:in6_addr
in_addr	.\include\sparse\netinet\in.h	/^struct in_addr {$/;"	s
in_addr_t	.\include\sparse\netinet\in.h	/^typedef ovs_be32 in_addr_t;$/;"	t
in_band	.\ofproto\connmgr.c	/^    struct in_band *in_band;$/;"	m	struct:connmgr	typeref:struct:connmgr::in_band	file:
in_band	.\ofproto\in-band.c	/^VLOG_DEFINE_THIS_MODULE(in_band);$/;"	v
in_band	.\ofproto\in-band.c	/^struct in_band {$/;"	s	file:
in_band_create	.\ofproto\in-band.c	/^in_band_create(struct ofproto *ofproto, const char *local_name,$/;"	f
in_band_destroy	.\ofproto\in-band.c	/^in_band_destroy(struct in_band *ib)$/;"	f
in_band_must_output_to_local_port	.\ofproto\in-band.c	/^in_band_must_output_to_local_port(const struct flow *flow)$/;"	f
in_band_op	.\ofproto\in-band.c	/^enum in_band_op {$/;"	g	file:
in_band_queue	.\ofproto\connmgr.c	/^    int in_band_queue;$/;"	m	struct:connmgr	file:
in_band_remote	.\ofproto\in-band.c	/^struct in_band_remote {$/;"	s	file:
in_band_rule	.\ofproto\in-band.c	/^struct in_band_rule {$/;"	s	file:
in_band_run	.\ofproto\in-band.c	/^in_band_run(struct in_band *ib)$/;"	f
in_band_set_queue	.\ofproto\in-band.c	/^in_band_set_queue(struct in_band *ib, int queue_id)$/;"	f
in_band_set_remotes	.\ofproto\in-band.c	/^in_band_set_remotes(struct in_band *ib,$/;"	f
in_band_wait	.\ofproto\in-band.c	/^in_band_wait(struct in_band *in_band)$/;"	f
in_decay	.\lib\bfd.c	/^    bool in_decay;                \/* True when bfd is in decay. *\/$/;"	m	struct:bfd	file:
in_group	.\ofproto\ofproto-dpif-xlate.c	/^    bool in_group;              \/* Currently translating ofgroup, if true. *\/$/;"	m	struct:xlate_ctx	file:
in_key	.\lib\netdev.h	/^    ovs_be64 in_key;$/;"	m	struct:netdev_tunnel_config
in_key	.\ofproto\tunnel.c	/^    ovs_be64 in_key;$/;"	m	struct:tnl_match	file:
in_key_flow	.\lib\netdev.h	/^    bool in_key_flow;$/;"	m	struct:netdev_tunnel_config
in_key_flow	.\ofproto\tunnel.c	/^    bool in_key_flow;$/;"	m	struct:tnl_match	file:
in_key_present	.\lib\netdev.h	/^    bool in_key_present;$/;"	m	struct:netdev_tunnel_config
in_phy_port	.\include\openflow\openflow-1.1.h	/^    ovs_be32 in_phy_port;   \/* Physical Port on which frame was received. *\/$/;"	m	struct:ofp11_packet_in
in_port	.\datapath\flow.h	/^		u16	in_port;	\/* Input switch port (or DP_MAX_PORTS). *\/$/;"	m	struct:sw_flow_key::__anon1
in_port	.\include\openflow\nicira-ext.h	/^    ovs_be16 in_port;               \/* New in_port for checking flow table. *\/$/;"	m	struct:nx_action_resubmit
in_port	.\include\openflow\openflow-1.0.h	/^    ovs_be16 in_port;             \/* Packet's input port (OFPP_NONE if none). *\/$/;"	m	struct:ofp10_packet_out
in_port	.\include\openflow\openflow-1.0.h	/^    ovs_be16 in_port;          \/* Input switch port. *\/$/;"	m	struct:ofp10_match
in_port	.\include\openflow\openflow-1.0.h	/^    ovs_be16 in_port;       \/* Port on which frame was received. *\/$/;"	m	struct:ofp10_packet_in
in_port	.\include\openflow\openflow-1.1.h	/^    ovs_be32 in_port;          \/* Input switch port. *\/$/;"	m	struct:ofp11_match
in_port	.\include\openflow\openflow-1.1.h	/^    ovs_be32 in_port;         \/* Packet's input port or OFPP_CONTROLLER. *\/$/;"	m	struct:ofp11_packet_out
in_port	.\include\openflow\openflow-1.1.h	/^    ovs_be32 in_port;       \/* Port on which frame was received. *\/$/;"	m	struct:ofp11_packet_in
in_port	.\lib\flow.h	/^    union flow_in_port in_port; \/* Input port.*\/$/;"	m	struct:flow	typeref:union:flow::flow_in_port
in_port	.\lib\ofp-actions.h	/^    ofp_port_t in_port;$/;"	m	struct:ofpact_resubmit
in_port	.\lib\ofp-util.h	/^    ofp_port_t in_port;         \/* Packet's input port. *\/$/;"	m	struct:ofputil_packet_out
in_port	.\lib\packets.h	/^    union flow_in_port in_port; \/* Input port. *\/$/;"	m	struct:pkt_metadata	typeref:union:pkt_metadata::flow_in_port
in_port	.\ofproto\netflow.c	/^    ofp_port_t in_port;           \/* Input port. *\/$/;"	m	struct:netflow_flow	file:
in_port	.\ofproto\ofproto.c	/^    ofp_port_t in_port;$/;"	m	struct:rule_execute	file:
in_port	.\ofproto\pktbuf.c	/^    ofp_port_t in_port;$/;"	m	struct:packet	file:
in_port_t	.\include\sparse\netinet\in.h	/^typedef ovs_be16 in_port_t;$/;"	t
in_port_values	.\tests\test-classifier.c	/^static ofp_port_t in_port_values[] = { OFP_PORT_C(1), OFPP_LOCAL };$/;"	v	file:
in_stack	.\lib\sflow.h	/^    SFLLabelStack in_stack;$/;"	m	struct:_SFLExtended_mpls
inactivity_probe	.\lib\vswitch-idl.h	/^	int64_t *inactivity_probe;$/;"	m	struct:ovsrec_controller
inactivity_probe	.\lib\vswitch-idl.h	/^	int64_t *inactivity_probe;$/;"	m	struct:ovsrec_manager
inactivity_probe	.\lib\vtep-idl.h	/^	int64_t *inactivity_probe;$/;"	m	struct:vteprec_manager
inc_column	.\lib\ovsdb-idl.c	/^    const char *inc_column;$/;"	m	struct:ovsdb_idl_txn	file:
inc_index	.\lib\ovsdb-idl.c	/^    unsigned int inc_index;$/;"	m	struct:ovsdb_idl_txn	file:
inc_new_value	.\lib\ovsdb-idl.c	/^    int64_t inc_new_value;$/;"	m	struct:ovsdb_idl_txn	file:
inc_row	.\lib\ovsdb-idl.c	/^    struct uuid inc_row;$/;"	m	struct:ovsdb_idl_txn	typeref:struct:ovsdb_idl_txn::uuid	file:
inc_table	.\lib\ovsdb-idl.c	/^    const char *inc_table;$/;"	m	struct:ovsdb_idl_txn	file:
incl_len	.\lib\pcap-file.c	/^    uint32_t incl_len;       \/* number of octets of packet saved in file *\/$/;"	m	struct:pcaprec_hdr	file:
inconsistent_match	.\lib\ofp-actions.c	/^inconsistent_match(enum ofputil_protocol *usable_protocols)$/;"	f	file:
increment	.\python\ovs\db\idl.py	/^    def increment(self, column_name):$/;"	m	class:Row
increment	.\utilities\ovs-benchmark.c	/^increment(unsigned short int *value,$/;"	f	file:
indent_line	.\lib\json.c	/^indent_line(struct json_serializer *s)$/;"	f	file:
index	.\lib\ovs-thread.c	/^    unsigned int index;$/;"	m	struct:ovsthread_key	file:
index	.\ovsdb\column.h	/^    unsigned int index;$/;"	m	struct:ovsdb_column
index_inside_part	.\datapath\linux\compat\flex_array.c	/^static unsigned int index_inside_part(struct flex_array *fa,$/;"	f	file:
index_nodes	.\lib\classifier.c	/^    struct hindex_node index_nodes[CLS_MAX_INDICES]; \/* Within subtable's$/;"	m	struct:cls_match	typeref:struct:cls_match::hindex_node	file:
index_ofs	.\lib\classifier.c	/^    uint8_t index_ofs[CLS_MAX_INDICES]; \/* u32 flow segment boundaries. *\/$/;"	m	struct:cls_subtable	file:
indexes	.\ovsdb\table.h	/^    struct hmap *indexes;$/;"	m	struct:ovsdb_table	typeref:struct:ovsdb_table::hmap
indexes	.\ovsdb\table.h	/^    struct ovsdb_column_set *indexes;$/;"	m	struct:ovsdb_table_schema	typeref:struct:ovsdb_table_schema::ovsdb_column_set
indices	.\lib\classifier.c	/^    struct hindex indices[CLS_MAX_INDICES]; \/* Staged lookup indices. *\/$/;"	m	struct:cls_subtable	typeref:struct:cls_subtable::hindex	file:
inet_aton	.\tests\flowgen.pl	/^sub inet_aton {$/;"	s
inet_frag_evictor	.\datapath\linux\compat\include\net\inet_frag.h	8;"	d
inet_get_local_port_range	.\datapath\linux\compat\include\net\ip.h	21;"	d
inet_open_active	.\lib\socket-util.c	/^inet_open_active(int style, const char *target, uint16_t default_port,$/;"	f
inet_open_active	.\python\ovs\socket_util.py	/^def inet_open_active(style, target, default_port, dscp):$/;"	f
inet_open_passive	.\lib\socket-util.c	/^inet_open_passive(int style, const char *target, int default_port,$/;"	f
inet_parse_active	.\lib\socket-util.c	/^inet_parse_active(const char *target_, uint16_t default_port,$/;"	f
inet_parse_active	.\python\ovs\socket_util.py	/^def inet_parse_active(target, default_port):$/;"	f
inet_parse_passive	.\lib\socket-util.c	/^inet_parse_passive(const char *target_, int default_port,$/;"	f
inet_proto_csum_replace16	.\datapath\linux\compat\utils.c	/^void inet_proto_csum_replace16(__sum16 *sum, struct sk_buff *skb,$/;"	f
inet_sport	.\datapath\compat.h	41;"	d
inet_sport	.\datapath\compat.h	43;"	d
info	.\lib\reconnect.c	/^    enum vlog_level info;       \/* Used for informational messages. *\/$/;"	m	struct:reconnect	typeref:enum:reconnect::vlog_level	file:
info	.\python\ovs\vlog.py	/^    def info(self, message, **kwargs):$/;"	m	class:Vlog
info_is_enabled	.\python\ovs\vlog.py	/^    def info_is_enabled(self):$/;"	m	class:Vlog
info_tx_equal	.\lib\lacp.c	/^info_tx_equal(struct lacp_info *a, struct lacp_info *b)$/;"	f	file:
ingress_policing_burst	.\lib\vswitch-idl.h	/^	int64_t ingress_policing_burst;$/;"	m	struct:ovsrec_interface
ingress_policing_rate	.\lib\vswitch-idl.h	/^	int64_t ingress_policing_rate;$/;"	m	struct:ovsrec_interface
init	.\datapath\linux\compat\include\net\net_namespace.h	/^	int (*init)(struct net *net);$/;"	m	struct:rpl_pernet_operations
init	.\lib\netdev-provider.h	/^    int (*init)(void);$/;"	m	struct:netdev_class
init	.\ofproto\ofproto-dpif.c	/^init(const struct shash *iface_hints)$/;"	f	file:
init	.\ofproto\ofproto-provider.h	/^    void (*init)(const struct shash *iface_hints);$/;"	m	struct:ofproto_class
init	.\python\ovs\vlog.py	/^    def init(log_file=None):$/;"	m	class:Vlog
initCDefault	.\python\ovs\db\types.py	/^    def initCDefault(self, var, is_optional):$/;"	m	class:BaseType
initSocket	.\lib\sflow_receiver.c	/^static void initSocket(SFLReceiver *receiver) {$/;"	f	file:
init_arch	.\datapath\linux\compat\hash.c	/^static void init_arch(void)$/;"	f	file:
init_clock	.\lib\timeval.c	/^init_clock(struct clock *c, clockid_t id)$/;"	f	file:
init_consecutive_values	.\tests\test-classifier.c	/^init_consecutive_values(int n_consecutive, struct flow *flow,$/;"	f	file:
init_ofp_ports	.\ofproto\ofproto-dpif.c	/^static struct shash init_ofp_ports = SHASH_INITIALIZER(&init_ofp_ports);$/;"	v	typeref:struct:shash	file:
init_ofp_ports	.\ofproto\ofproto.c	/^static struct shash init_ofp_ports = SHASH_INITIALIZER(&init_ofp_ports);$/;"	v	typeref:struct:shash	file:
init_ports	.\ofproto\ofproto.c	/^init_ports(struct ofproto *p)$/;"	f	file:
init_service_status	.\lib\daemon-windows.c	/^init_service_status()$/;"	f	file:
init_stack	.\ofproto\ofproto-dpif-xlate.c	/^    union mf_subvalue init_stack[1024 \/ sizeof(union mf_subvalue)];$/;"	m	struct:xlate_ctx	typeref:union:xlate_ctx::mf_subvalue	file:
init_time	.\lib\netflow.h	/^    ovs_be32 init_time;            \/* Value of sysuptime on first packet. *\/$/;"	m	struct:netflow_v5_record
init_values	.\tests\test-classifier.c	/^init_values(void)$/;"	f	file:
inited	.\lib\vswitch-idl.c	/^static bool inited;$/;"	v	file:
inited	.\lib\vtep-idl.c	/^static bool inited;$/;"	v	file:
inited	.\tests\idltest.c	/^static bool inited;$/;"	v	file:
initial_config_done	.\vswitchd\bridge.c	/^static bool initial_config_done;$/;"	v	file:
inline	.\include\windows\windefs.h	30;"	d
inner_mac_header	.\datapath\linux\compat\gso.h	/^	sk_buff_data_t	inner_mac_header;$/;"	m	struct:ovs_gso_cb
inner_network_header	.\datapath\linux\compat\gso.h	/^	sk_buff_data_t	inner_network_header;$/;"	m	struct:ovs_gso_cb
inode	.\lib\lockfile.c	/^    ino_t inode;$/;"	m	struct:lockfile	file:
input	.\lib\jsonrpc.c	/^    struct byteq input;$/;"	m	struct:jsonrpc	typeref:struct:jsonrpc::byteq	file:
input	.\lib\netflow.h	/^    ovs_be16 input;                \/* Input interface index. *\/$/;"	m	struct:netflow_v5_record
input	.\lib\sflow.h	/^    u_int32_t input;                \/* SNMP ifIndex of input interface.$/;"	m	struct:_SFLFlow_sample
input	.\lib\sflow.h	/^    u_int32_t input;                \/* SNMP ifIndex of input interface.$/;"	m	struct:_SFLFlow_sample_expanded
input	.\ovsdb\log.c	/^    char input[4096];$/;"	m	struct:ovsdb_log_read_cbdata	file:
inputFormat	.\lib\sflow.h	/^    u_int32_t inputFormat;          \/* EXPANDED *\/$/;"	m	struct:_SFLFlow_sample_expanded
inputPort	.\tests\test-sflow.c	/^    uint32_t inputPort;$/;"	m	struct:sflow_xdr	file:
inputPortFormat	.\tests\test-sflow.c	/^    uint32_t inputPortFormat;$/;"	m	struct:sflow_xdr	file:
input_buffer	.\lib\jsonrpc.c	/^    uint8_t input_buffer[512];$/;"	m	struct:jsonrpc	file:
input_vid_is_valid	.\ofproto\ofproto-dpif-xlate.c	/^input_vid_is_valid(uint16_t vid, struct xbundle *in_xbundle, bool warn)$/;"	f	file:
input_vid_to_vlan	.\ofproto\ofproto-dpif-xlate.c	/^input_vid_to_vlan(const struct xbundle *in_xbundle, uint16_t vid)$/;"	f	file:
input_vport	.\datapath\datapath.h	/^	struct vport	*input_vport;$/;"	m	struct:ovs_skb_cb	typeref:struct:ovs_skb_cb::vport
insert	.\python\ovs\db\idl.py	/^    def insert(self, table, new_uuid=None):$/;"	m	class:Transaction
insert_bal	.\ofproto\bond.c	/^insert_bal(struct list *bals, struct bond_slave *slave)$/;"	f	file:
insert_controllers	.\utilities\ovs-vsctl.c	/^insert_controllers(struct ovsdb_idl_txn *txn, char *targets[], size_t n)$/;"	f	file:
insert_managers	.\utilities\ovs-vsctl.c	/^insert_managers(struct vsctl_context *ctx, char *targets[], size_t n)$/;"	f	file:
insert_managers	.\vtep\vtep-ctl.c	/^insert_managers(struct vtep_ctl_context *ctx, char *targets[], size_t n)$/;"	f	file:
insert_rule	.\lib\classifier.c	/^insert_rule(struct cls_classifier *cls, struct cls_subtable *subtable,$/;"	f	file:
insert_subtable	.\lib\classifier.c	/^insert_subtable(struct cls_classifier *cls, const struct minimask *mask)$/;"	f	file:
inserted_rows	.\lib\ovsdb-idl.c	/^    struct hmap inserted_rows;  \/* Contains "struct ovsdb_idl_txn_insert"s. *\/$/;"	m	struct:ovsdb_idl_txn	typeref:struct:ovsdb_idl_txn::hmap	file:
inst_info	.\lib\ofp-actions.c	/^static const struct instruction_type_info inst_info[] = {$/;"	v	typeref:struct:instruction_type_info	file:
instance_id	.\datapath\vport-lisp.c	/^			__u8 instance_id[3];$/;"	m	struct:lisphdr::__anon18::__anon19	file:
instance_id_present	.\datapath\vport-lisp.c	/^	__u8 instance_id_present:1;$/;"	m	struct:lisphdr	file:
instance_id_to_tunnel_id	.\datapath\vport-lisp.c	/^static __be64 instance_id_to_tunnel_id(__u8 *iid)$/;"	f	file:
instances	.\lib\ofp-msgs.c	/^    struct raw_instance *instances; \/* min_version - max_version + 1 elems. *\/$/;"	m	struct:raw_info	typeref:struct:raw_info::raw_instance	file:
instruction_is_valid	.\lib\ofp-actions.c	/^instruction_is_valid(const struct ofp11_instruction *inst,$/;"	f	file:
instruction_next	.\lib\ofp-actions.c	/^instruction_next(const struct ofp11_instruction *inst)$/;"	f	file:
instruction_type_info	.\lib\ofp-actions.c	/^struct instruction_type_info {$/;"	s	file:
instructions	.\include\openflow\openflow-1.1.h	/^    ovs_be32 instructions;   \/* Bitmap of OFPIT_* values supported. *\/$/;"	m	struct:ofp11_table_stats
instructions	.\include\openflow\openflow-1.2.h	/^    ovs_be32 instructions;   \/* Bitmap of OFPIT_* values supported. *\/$/;"	m	struct:ofp12_table_stats
instructions	.\lib\ofp-util.h	/^        uint32_t instructions;$/;"	m	struct:ofputil_table_features::ofputil_table_instruction_features
integer	.\lib\json.c	/^        long long int integer;$/;"	m	union:json_token::__anon48	file:
integer	.\lib\json.h	/^        long long int integer;$/;"	m	union:json::__anon49
integer	.\lib\ovsdb-data.h	/^    int64_t integer;$/;"	m	union:ovsdb_atom
integer	.\lib\ovsdb-types.h	/^        } integer;$/;"	m	union:ovsdb_base_type::__anon86	typeref:struct:ovsdb_base_type::__anon86::ovsdb_integer_constraints
intel_crc4_2_hash	.\datapath\linux\compat\hash-x86.c	/^static u32 intel_crc4_2_hash(const void *data, u32 len, u32 seed)$/;"	f	file:
intel_crc4_2_hash2	.\datapath\linux\compat\hash-x86.c	/^static u32 intel_crc4_2_hash2(const u32 *data, u32 len, u32 seed)$/;"	f	file:
interface_assign_ip	.\python\ovstest\util.py	/^def interface_assign_ip(iface, ip_addr, mask):$/;"	f
interface_get_ip	.\python\ovstest\util.py	/^def interface_get_ip(iface):$/;"	f
interface_is_up	.\xenserver\opt_xensource_libexec_InterfaceReconfigureBridge.py	/^def interface_is_up(pif):$/;"	f
interface_up	.\python\ovstest\util.py	/^def interface_up(iface):$/;"	f
interfaces	.\lib\vswitch-idl.h	/^	struct ovsrec_interface **interfaces;$/;"	m	struct:ovsrec_port	typeref:struct:ovsrec_port::ovsrec_interface
interfaces	.\python\ovstest\tcp.py	/^from twisted.internet import interfaces$/;"	i
internal_dev	.\datapath\vport-internal_dev.c	/^struct internal_dev {$/;"	s	file:
internal_dev_change_mtu	.\datapath\vport-internal_dev.c	/^static int internal_dev_change_mtu(struct net_device *netdev, int new_mtu)$/;"	f	file:
internal_dev_create	.\datapath\vport-internal_dev.c	/^static struct vport *internal_dev_create(const struct vport_parms *parms)$/;"	f	file:
internal_dev_destroy	.\datapath\vport-internal_dev.c	/^static void internal_dev_destroy(struct vport *vport)$/;"	f	file:
internal_dev_destructor	.\datapath\vport-internal_dev.c	/^static void internal_dev_destructor(struct net_device *dev)$/;"	f	file:
internal_dev_ethtool_ops	.\datapath\vport-internal_dev.c	/^static const struct ethtool_ops internal_dev_ethtool_ops = {$/;"	v	typeref:struct:ethtool_ops	file:
internal_dev_get_stats	.\datapath\vport-internal_dev.c	/^static struct rtnl_link_stats64 *internal_dev_get_stats(struct net_device *netdev,$/;"	f	file:
internal_dev_getinfo	.\datapath\vport-internal_dev.c	/^static void internal_dev_getinfo(struct net_device *netdev,$/;"	f	file:
internal_dev_netdev_ops	.\datapath\vport-internal_dev.c	/^static const struct net_device_ops internal_dev_netdev_ops = {$/;"	v	typeref:struct:net_device_ops	file:
internal_dev_open	.\datapath\vport-internal_dev.c	/^static int internal_dev_open(struct net_device *netdev)$/;"	f	file:
internal_dev_priv	.\datapath\vport-internal_dev.c	/^static struct internal_dev *internal_dev_priv(struct net_device *netdev)$/;"	f	file:
internal_dev_recv	.\datapath\vport-internal_dev.c	/^static int internal_dev_recv(struct vport *vport, struct sk_buff *skb)$/;"	f	file:
internal_dev_stop	.\datapath\vport-internal_dev.c	/^static int internal_dev_stop(struct net_device *netdev)$/;"	f	file:
internal_dev_xmit	.\datapath\vport-internal_dev.c	/^static int internal_dev_xmit(struct sk_buff *skb, struct net_device *netdev)$/;"	f	file:
interpret_queued_ssl_error	.\lib\stream-ssl.c	/^interpret_queued_ssl_error(const char *function)$/;"	f	file:
interpret_ssl_error	.\lib\stream-ssl.c	/^interpret_ssl_error(const char *function, int ret, int error,$/;"	f	file:
interval	.\lib\cfm.h	/^    int interval;               \/* The requested transmission interval. *\/$/;"	m	struct:cfm_settings
invalid_utf8_sequence	.\lib\unicode.c	/^invalid_utf8_sequence(const uint8_t *s, int n, size_t *lengthp)$/;"	f	file:
ip	.\datapath\flow.h	/^	} ip;$/;"	m	struct:sw_flow_key	typeref:struct:sw_flow_key::__anon3
ip4	.\tests\test-sflow.c	/^        ovs_be32 ip4;$/;"	m	union:sflow_addr::__anon159	file:
ip6	.\tests\test-sflow.c	/^        ovs_be32 ip6[4];$/;"	m	union:sflow_addr::__anon159	file:
ip6_ctlun	.\include\sparse\netinet\ip6.h	/^    } ip6_ctlun;$/;"	m	struct:ip6_hdr	typeref:union:ip6_hdr::__anon26
ip6_ctlun	.\include\windows\netinet\ip6.h	/^	} ip6_ctlun;$/;"	m	struct:ip6_hdr	typeref:union:ip6_hdr::__anon35
ip6_ctlun	.\lib\packets.h	/^    } ip6_ctlun;$/;"	m	struct:ovs_16aligned_ip6_hdr	typeref:union:ovs_16aligned_ip6_hdr::__anon90
ip6_dest	.\include\windows\netinet\ip6.h	/^struct ip6_dest {$/;"	s
ip6_dst	.\include\sparse\netinet\ip6.h	/^    struct in6_addr ip6_dst;$/;"	m	struct:ip6_hdr	typeref:struct:ip6_hdr::in6_addr
ip6_dst	.\include\windows\netinet\ip6.h	/^	struct in6_addr ip6_dst;	\/* destination address *\/$/;"	m	struct:ip6_hdr	typeref:struct:ip6_hdr::in6_addr
ip6_dst	.\lib\packets.h	/^    union ovs_16aligned_in6_addr ip6_dst;$/;"	m	struct:ovs_16aligned_ip6_hdr	typeref:union:ovs_16aligned_ip6_hdr::ovs_16aligned_in6_addr
ip6_ext	.\include\sparse\netinet\ip6.h	/^struct ip6_ext {$/;"	s
ip6_ext	.\include\windows\netinet\ip6.h	/^struct	ip6_ext {$/;"	s
ip6_flow	.\include\sparse\netinet\ip6.h	41;"	d
ip6_flow	.\include\windows\netinet\ip6.h	87;"	d
ip6_frag	.\include\sparse\netinet\ip6.h	/^struct ip6_frag {$/;"	s
ip6_frag	.\include\windows\netinet\ip6.h	/^struct ip6_frag {$/;"	s
ip6_hbh	.\include\windows\netinet\ip6.h	/^struct ip6_hbh {$/;"	s
ip6_hdr	.\include\sparse\netinet\ip6.h	/^struct ip6_hdr {$/;"	s
ip6_hdr	.\include\windows\netinet\ip6.h	/^struct ip6_hdr {$/;"	s
ip6_hdrctl	.\include\sparse\netinet\ip6.h	/^        struct ip6_hdrctl {$/;"	s	union:ip6_hdr::__anon26
ip6_hdrctl	.\include\windows\netinet\ip6.h	/^		struct ip6_hdrctl {$/;"	s	union:ip6_hdr::__anon35
ip6_hlim	.\include\sparse\netinet\ip6.h	44;"	d
ip6_hlim	.\include\windows\netinet\ip6.h	90;"	d
ip6_hops	.\include\sparse\netinet\ip6.h	45;"	d
ip6_hops	.\include\windows\netinet\ip6.h	91;"	d
ip6_nxt	.\include\sparse\netinet\ip6.h	43;"	d
ip6_nxt	.\include\windows\netinet\ip6.h	89;"	d
ip6_opt	.\include\windows\netinet\ip6.h	/^struct ip6_opt {$/;"	s
ip6_opt_jumbo	.\include\windows\netinet\ip6.h	/^struct ip6_opt_jumbo {$/;"	s
ip6_opt_nsap	.\include\windows\netinet\ip6.h	/^struct ip6_opt_nsap {$/;"	s
ip6_opt_router	.\include\windows\netinet\ip6.h	/^struct ip6_opt_router {$/;"	s
ip6_opt_tunnel	.\include\windows\netinet\ip6.h	/^struct ip6_opt_tunnel {$/;"	s
ip6_plen	.\include\sparse\netinet\ip6.h	42;"	d
ip6_plen	.\include\windows\netinet\ip6.h	88;"	d
ip6_rthdr	.\include\sparse\netinet\ip6.h	/^struct ip6_rthdr {$/;"	s
ip6_rthdr	.\include\windows\netinet\ip6.h	/^struct ip6_rthdr {$/;"	s
ip6_rthdr0	.\include\windows\netinet\ip6.h	/^struct ip6_rthdr0 {$/;"	s
ip6_src	.\include\sparse\netinet\ip6.h	/^    struct in6_addr ip6_src;$/;"	m	struct:ip6_hdr	typeref:struct:ip6_hdr::in6_addr
ip6_src	.\include\windows\netinet\ip6.h	/^	struct in6_addr ip6_src;	\/* source address *\/$/;"	m	struct:ip6_hdr	typeref:struct:ip6_hdr::in6_addr
ip6_src	.\lib\packets.h	/^    union ovs_16aligned_in6_addr ip6_src;$/;"	m	struct:ovs_16aligned_ip6_hdr	typeref:union:ovs_16aligned_ip6_hdr::ovs_16aligned_in6_addr
ip6_un1	.\include\sparse\netinet\ip6.h	/^        } ip6_un1;$/;"	m	union:ip6_hdr::__anon26	typeref:struct:ip6_hdr::__anon26::ip6_hdrctl
ip6_un1	.\include\windows\netinet\ip6.h	/^		} ip6_un1;$/;"	m	union:ip6_hdr::__anon35	typeref:struct:ip6_hdr::__anon35::ip6_hdrctl
ip6_un1	.\lib\packets.h	/^        } ip6_un1;$/;"	m	union:ovs_16aligned_ip6_hdr::__anon90	typeref:struct:ovs_16aligned_ip6_hdr::__anon90::ovs_16aligned_ip6_hdrctl
ip6_un1_flow	.\include\sparse\netinet\ip6.h	/^            ovs_be32 ip6_un1_flow;$/;"	m	struct:ip6_hdr::__anon26::ip6_hdrctl
ip6_un1_flow	.\include\windows\netinet\ip6.h	/^			u_int32_t ip6_un1_flow;	\/* 20 bits of flow-ID *\/$/;"	m	struct:ip6_hdr::__anon35::ip6_hdrctl
ip6_un1_flow	.\lib\packets.h	/^            ovs_16aligned_be32 ip6_un1_flow;$/;"	m	struct:ovs_16aligned_ip6_hdr::__anon90::ovs_16aligned_ip6_hdrctl
ip6_un1_hlim	.\include\sparse\netinet\ip6.h	/^            uint8_t ip6_un1_hlim;$/;"	m	struct:ip6_hdr::__anon26::ip6_hdrctl
ip6_un1_hlim	.\include\windows\netinet\ip6.h	/^			u_int8_t  ip6_un1_hlim;	\/* hop limit *\/$/;"	m	struct:ip6_hdr::__anon35::ip6_hdrctl
ip6_un1_hlim	.\lib\packets.h	/^            uint8_t ip6_un1_hlim;$/;"	m	struct:ovs_16aligned_ip6_hdr::__anon90::ovs_16aligned_ip6_hdrctl
ip6_un1_nxt	.\include\sparse\netinet\ip6.h	/^            uint8_t ip6_un1_nxt;$/;"	m	struct:ip6_hdr::__anon26::ip6_hdrctl
ip6_un1_nxt	.\include\windows\netinet\ip6.h	/^			u_int8_t  ip6_un1_nxt;	\/* next header *\/$/;"	m	struct:ip6_hdr::__anon35::ip6_hdrctl
ip6_un1_nxt	.\lib\packets.h	/^            uint8_t ip6_un1_nxt;$/;"	m	struct:ovs_16aligned_ip6_hdr::__anon90::ovs_16aligned_ip6_hdrctl
ip6_un1_plen	.\include\sparse\netinet\ip6.h	/^            ovs_be16 ip6_un1_plen;$/;"	m	struct:ip6_hdr::__anon26::ip6_hdrctl
ip6_un1_plen	.\include\windows\netinet\ip6.h	/^			u_int16_t ip6_un1_plen;	\/* payload length *\/$/;"	m	struct:ip6_hdr::__anon35::ip6_hdrctl
ip6_un1_plen	.\lib\packets.h	/^            ovs_be16 ip6_un1_plen;$/;"	m	struct:ovs_16aligned_ip6_hdr::__anon90::ovs_16aligned_ip6_hdrctl
ip6_un2_vfc	.\include\sparse\netinet\ip6.h	/^        uint8_t ip6_un2_vfc;$/;"	m	union:ip6_hdr::__anon26
ip6_un2_vfc	.\include\windows\netinet\ip6.h	/^		u_int8_t ip6_un2_vfc;	\/* 4 bits version, top 4 bits class *\/$/;"	m	union:ip6_hdr::__anon35
ip6_un2_vfc	.\lib\packets.h	/^        uint8_t ip6_un2_vfc;$/;"	m	union:ovs_16aligned_ip6_hdr::__anon90
ip6_vfc	.\include\sparse\netinet\ip6.h	40;"	d
ip6_vfc	.\include\windows\netinet\ip6.h	86;"	d
ip6d_len	.\include\windows\netinet\ip6.h	/^	u_int8_t ip6d_len;	\/* length in units of 8 octets *\/$/;"	m	struct:ip6_dest
ip6d_nxt	.\include\windows\netinet\ip6.h	/^	u_int8_t ip6d_nxt;	\/* next header *\/$/;"	m	struct:ip6_dest
ip6e_len	.\include\sparse\netinet\ip6.h	/^    uint8_t ip6e_len;$/;"	m	struct:ip6_ext
ip6e_len	.\include\windows\netinet\ip6.h	/^	u_int8_t ip6e_len;$/;"	m	struct:ip6_ext
ip6e_nxt	.\include\sparse\netinet\ip6.h	/^    uint8_t ip6e_nxt;$/;"	m	struct:ip6_ext
ip6e_nxt	.\include\windows\netinet\ip6.h	/^	u_int8_t ip6e_nxt;$/;"	m	struct:ip6_ext
ip6f_ident	.\include\sparse\netinet\ip6.h	/^    ovs_be32 ip6f_ident;$/;"	m	struct:ip6_frag
ip6f_ident	.\include\windows\netinet\ip6.h	/^	u_int32_t ip6f_ident;		\/* identification *\/$/;"	m	struct:ip6_frag
ip6f_ident	.\lib\packets.h	/^    ovs_16aligned_be32 ip6f_ident;$/;"	m	struct:ovs_16aligned_ip6_frag
ip6f_nxt	.\include\sparse\netinet\ip6.h	/^    uint8_t ip6f_nxt;$/;"	m	struct:ip6_frag
ip6f_nxt	.\include\windows\netinet\ip6.h	/^	u_int8_t  ip6f_nxt;		\/* next header *\/$/;"	m	struct:ip6_frag
ip6f_nxt	.\lib\packets.h	/^    uint8_t ip6f_nxt;$/;"	m	struct:ovs_16aligned_ip6_frag
ip6f_offlg	.\include\sparse\netinet\ip6.h	/^    ovs_be16 ip6f_offlg;$/;"	m	struct:ip6_frag
ip6f_offlg	.\include\windows\netinet\ip6.h	/^	u_int16_t ip6f_offlg;		\/* offset, reserved, and flag *\/$/;"	m	struct:ip6_frag
ip6f_offlg	.\lib\packets.h	/^    ovs_be16 ip6f_offlg;$/;"	m	struct:ovs_16aligned_ip6_frag
ip6f_reserved	.\include\sparse\netinet\ip6.h	/^    uint8_t ip6f_reserved;$/;"	m	struct:ip6_frag
ip6f_reserved	.\include\windows\netinet\ip6.h	/^	u_int8_t  ip6f_reserved;	\/* reserved field *\/$/;"	m	struct:ip6_frag
ip6f_reserved	.\lib\packets.h	/^    uint8_t ip6f_reserved;$/;"	m	struct:ovs_16aligned_ip6_frag
ip6h_len	.\include\windows\netinet\ip6.h	/^	u_int8_t ip6h_len;	\/* length in units of 8 octets *\/$/;"	m	struct:ip6_hbh
ip6h_nxt	.\include\windows\netinet\ip6.h	/^	u_int8_t ip6h_nxt;	\/* next header *\/$/;"	m	struct:ip6_hbh
ip6o_len	.\include\windows\netinet\ip6.h	/^	u_int8_t ip6o_len;$/;"	m	struct:ip6_opt
ip6o_type	.\include\windows\netinet\ip6.h	/^	u_int8_t ip6o_type;$/;"	m	struct:ip6_opt
ip6oj_jumbo_len	.\include\windows\netinet\ip6.h	/^	u_int8_t ip6oj_jumbo_len[4];$/;"	m	struct:ip6_opt_jumbo
ip6oj_len	.\include\windows\netinet\ip6.h	/^	u_int8_t ip6oj_len;$/;"	m	struct:ip6_opt_jumbo
ip6oj_type	.\include\windows\netinet\ip6.h	/^	u_int8_t ip6oj_type;$/;"	m	struct:ip6_opt_jumbo
ip6on_dst_nsap_len	.\include\windows\netinet\ip6.h	/^	u_int8_t ip6on_dst_nsap_len;$/;"	m	struct:ip6_opt_nsap
ip6on_len	.\include\windows\netinet\ip6.h	/^	u_int8_t ip6on_len;$/;"	m	struct:ip6_opt_nsap
ip6on_src_nsap_len	.\include\windows\netinet\ip6.h	/^	u_int8_t ip6on_src_nsap_len;$/;"	m	struct:ip6_opt_nsap
ip6on_type	.\include\windows\netinet\ip6.h	/^	u_int8_t ip6on_type;$/;"	m	struct:ip6_opt_nsap
ip6or_len	.\include\windows\netinet\ip6.h	/^	u_int8_t ip6or_len;$/;"	m	struct:ip6_opt_router
ip6or_type	.\include\windows\netinet\ip6.h	/^	u_int8_t ip6or_type;$/;"	m	struct:ip6_opt_router
ip6or_value	.\include\windows\netinet\ip6.h	/^	u_int8_t ip6or_value[2];$/;"	m	struct:ip6_opt_router
ip6ot_encap_limit	.\include\windows\netinet\ip6.h	/^	u_int8_t ip6ot_encap_limit;$/;"	m	struct:ip6_opt_tunnel
ip6ot_len	.\include\windows\netinet\ip6.h	/^	u_int8_t ip6ot_len;$/;"	m	struct:ip6_opt_tunnel
ip6ot_type	.\include\windows\netinet\ip6.h	/^	u_int8_t ip6ot_type;$/;"	m	struct:ip6_opt_tunnel
ip6r0_len	.\include\windows\netinet\ip6.h	/^	u_int8_t  ip6r0_len;		\/* length in units of 8 octets *\/$/;"	m	struct:ip6_rthdr0
ip6r0_nxt	.\include\windows\netinet\ip6.h	/^	u_int8_t  ip6r0_nxt;		\/* next header *\/$/;"	m	struct:ip6_rthdr0
ip6r0_reserved	.\include\windows\netinet\ip6.h	/^	u_int32_t ip6r0_reserved;	\/* reserved field *\/$/;"	m	struct:ip6_rthdr0
ip6r0_segleft	.\include\windows\netinet\ip6.h	/^	u_int8_t  ip6r0_segleft;	\/* segments left *\/$/;"	m	struct:ip6_rthdr0
ip6r0_type	.\include\windows\netinet\ip6.h	/^	u_int8_t  ip6r0_type;		\/* always zero *\/$/;"	m	struct:ip6_rthdr0
ip6r_len	.\include\sparse\netinet\ip6.h	/^    uint8_t ip6r_len;$/;"	m	struct:ip6_rthdr
ip6r_len	.\include\windows\netinet\ip6.h	/^	u_int8_t  ip6r_len;	\/* length in units of 8 octets *\/$/;"	m	struct:ip6_rthdr
ip6r_nxt	.\include\sparse\netinet\ip6.h	/^    uint8_t ip6r_nxt;$/;"	m	struct:ip6_rthdr
ip6r_nxt	.\include\windows\netinet\ip6.h	/^	u_int8_t  ip6r_nxt;	\/* next header *\/$/;"	m	struct:ip6_rthdr
ip6r_segleft	.\include\sparse\netinet\ip6.h	/^    uint8_t ip6r_segleft;$/;"	m	struct:ip6_rthdr
ip6r_segleft	.\include\windows\netinet\ip6.h	/^	u_int8_t  ip6r_segleft;	\/* segments left *\/$/;"	m	struct:ip6_rthdr
ip6r_type	.\include\sparse\netinet\ip6.h	/^    uint8_t ip6r_type;$/;"	m	struct:ip6_rthdr
ip6r_type	.\include\windows\netinet\ip6.h	/^	u_int8_t  ip6r_type;	\/* routing type *\/$/;"	m	struct:ip6_rthdr
ip_address	.\python\ovstest\args.py	/^def ip_address(string):$/;"	f
ip_count_cidr_bits	.\lib\packets.c	/^ip_count_cidr_bits(ovs_be32 netmask)$/;"	f
ip_csum	.\lib\packets.h	/^    ovs_be16 ip_csum;$/;"	m	struct:ip_header
ip_dst	.\lib\bfd.c	/^    ovs_be32 ip_dst;              \/* IPv4 destination address. *\/$/;"	m	struct:bfd	file:
ip_dst	.\lib\netdev.h	/^    ovs_be32 ip_dst;$/;"	m	struct:netdev_tunnel_config
ip_dst	.\lib\packets.h	/^    ovs_16aligned_be32 ip_dst;$/;"	m	struct:ip_header
ip_dst	.\lib\packets.h	/^    ovs_be32 ip_dst;$/;"	m	struct:flow_tnl
ip_dst	.\ofproto\tunnel.c	/^    ovs_be32 ip_dst;$/;"	m	struct:tnl_match	file:
ip_dst_flow	.\lib\netdev.h	/^    bool ip_dst_flow;$/;"	m	struct:netdev_tunnel_config
ip_dst_flow	.\ofproto\tunnel.c	/^    bool ip_dst_flow;$/;"	m	struct:tnl_match	file:
ip_format_masked	.\lib\packets.c	/^ip_format_masked(ovs_be32 ip, ovs_be32 mask, struct ds *s)$/;"	f
ip_frag_off	.\lib\packets.h	/^    ovs_be16 ip_frag_off;$/;"	m	struct:ip_header
ip_from_cidr	.\python\ovstest\util.py	/^def ip_from_cidr(string):$/;"	f
ip_gre_calc_hlen	.\datapath\linux\compat\include\net\gre.h	/^static inline int ip_gre_calc_hlen(__be16 o_flags)$/;"	f
ip_gre_calc_hlen	.\datapath\linux\compat\include\net\gre.h	93;"	d
ip_hdr	.\datapath\linux\compat\include\linux\ip.h	/^static inline struct iphdr *ip_hdr(const struct sk_buff *skb)$/;"	f
ip_hdrlen	.\datapath\linux\compat\include\linux\ip.h	/^static inline unsigned int ip_hdrlen(const struct sk_buff *skb)$/;"	f
ip_header	.\lib\packets.h	/^struct ip_header {$/;"	s
ip_id	.\lib\packets.h	/^    ovs_be16 ip_id;$/;"	m	struct:ip_header
ip_ihl_ver	.\lib\packets.h	/^    uint8_t ip_ihl_ver;$/;"	m	struct:ip_header
ip_is_cidr	.\lib\packets.h	/^ip_is_cidr(ovs_be32 netmask)$/;"	f
ip_is_fragment	.\datapath\linux\compat\include\net\ip.h	/^static inline bool ip_is_fragment(const struct iphdr *iph)$/;"	f
ip_is_multicast	.\lib\packets.h	/^ip_is_multicast(ovs_be32 ip)$/;"	f
ip_local_out	.\datapath\linux\compat\gso.c	226;"	d	file:
ip_local_out	.\datapath\linux\compat\gso.h	73;"	d
ip_optional_mask	.\python\ovstest\args.py	/^def ip_optional_mask(string):$/;"	f
ip_optional_port	.\python\ovstest\args.py	/^def ip_optional_port(string, default_port, ip_callback):$/;"	f
ip_optional_port_port	.\python\ovstest\args.py	/^def ip_optional_port_port(string, default_port1, default_port2, ip_callback):$/;"	f
ip_proto	.\datapath\linux\compat\include\net\flow_keys.h	/^	u8 ip_proto;$/;"	m	struct:flow_keys
ip_proto	.\lib\netflow.h	/^    uint8_t  ip_proto;             \/* IP protocol. *\/$/;"	m	struct:netflow_v5_record
ip_proto	.\lib\packets.h	/^    uint8_t ip_proto;$/;"	m	struct:ip_header
ip_src	.\lib\bfd.c	/^    ovs_be32 ip_src;              \/* IPv4 source address. *\/$/;"	m	struct:bfd	file:
ip_src	.\lib\netdev.h	/^    ovs_be32 ip_src;$/;"	m	struct:netdev_tunnel_config
ip_src	.\lib\packets.h	/^    ovs_16aligned_be32 ip_src;$/;"	m	struct:ip_header
ip_src	.\lib\packets.h	/^    ovs_be32 ip_src;$/;"	m	struct:flow_tnl
ip_src	.\ofproto\tunnel.c	/^    ovs_be32 ip_src;$/;"	m	struct:tnl_match	file:
ip_src_flow	.\lib\netdev.h	/^    bool ip_src_flow;$/;"	m	struct:netdev_tunnel_config
ip_src_flow	.\ofproto\tunnel.c	/^    bool ip_src_flow;$/;"	m	struct:tnl_match	file:
ip_src_type	.\ofproto\tunnel.c	/^enum ip_src_type {$/;"	g	file:
ip_tos	.\lib\netflow.h	/^    uint8_t  ip_tos;               \/* IP TOS value. *\/$/;"	m	struct:netflow_v5_record
ip_tos	.\lib\packets.h	/^    uint8_t ip_tos;$/;"	m	struct:flow_tnl
ip_tos	.\lib\packets.h	/^    uint8_t ip_tos;$/;"	m	struct:ip_header
ip_tot_len	.\lib\packets.h	/^    ovs_be16 ip_tot_len;$/;"	m	struct:ip_header
ip_ttl	.\lib\packets.h	/^    uint8_t ip_ttl;$/;"	m	struct:flow_tnl
ip_ttl	.\lib\packets.h	/^    uint8_t ip_ttl;$/;"	m	struct:ip_header
ip_v4	.\lib\sflow.h	/^    SFLIPv4 ip_v4;$/;"	m	union:_SFLAddress_value
ip_v6	.\lib\sflow.h	/^    SFLIPv6 ip_v6;$/;"	m	union:_SFLAddress_value
ipaddr	.\lib\vtep-idl.h	/^	char *ipaddr;	\/* Always nonnull. *\/$/;"	m	struct:vteprec_mcast_macs_local
ipaddr	.\lib\vtep-idl.h	/^	char *ipaddr;	\/* Always nonnull. *\/$/;"	m	struct:vteprec_mcast_macs_remote
ipaddr	.\lib\vtep-idl.h	/^	char *ipaddr;	\/* Always nonnull. *\/$/;"	m	struct:vteprec_ucast_macs_local
ipaddr	.\lib\vtep-idl.h	/^	char *ipaddr;	\/* Always nonnull. *\/$/;"	m	struct:vteprec_ucast_macs_remote
ipfix	.\lib\odp-util.h	/^    } ipfix;$/;"	m	union:user_action_cookie	typeref:struct:user_action_cookie::__anon72
ipfix	.\lib\vswitch-idl.h	/^	struct ovsrec_ipfix *ipfix;$/;"	m	struct:ovsrec_bridge	typeref:struct:ovsrec_bridge::ovsrec_ipfix
ipfix	.\lib\vswitch-idl.h	/^	struct ovsrec_ipfix *ipfix;$/;"	m	struct:ovsrec_flow_sample_collector_set	typeref:struct:ovsrec_flow_sample_collector_set::ovsrec_ipfix
ipfix	.\ofproto\ofproto-dpif-ipfix.c	/^VLOG_DEFINE_THIS_MODULE(ipfix);$/;"	v
ipfix	.\ofproto\ofproto-dpif-xlate.c	/^    struct dpif_ipfix *ipfix;     \/* Ipfix handle, or null. *\/$/;"	m	struct:xbridge	typeref:struct:xbridge::dpif_ipfix	file:
ipfix	.\ofproto\ofproto-dpif.c	/^    struct dpif_ipfix *ipfix;$/;"	m	struct:ofproto_dpif	typeref:struct:ofproto_dpif::dpif_ipfix	file:
ipfix_cache_aggregate_entries	.\ofproto\ofproto-dpif-ipfix.c	/^ipfix_cache_aggregate_entries(struct ipfix_flow_cache_entry *from_entry,$/;"	f	file:
ipfix_cache_entry_init	.\ofproto\ofproto-dpif-ipfix.c	/^ipfix_cache_entry_init(struct ipfix_flow_cache_entry *entry,$/;"	f	file:
ipfix_cache_find_entry	.\ofproto\ofproto-dpif-ipfix.c	/^ipfix_cache_find_entry(const struct dpif_ipfix_exporter *exporter,$/;"	f	file:
ipfix_cache_next_timeout_msec	.\ofproto\ofproto-dpif-ipfix.c	/^ipfix_cache_next_timeout_msec(const struct dpif_ipfix_exporter *exporter,$/;"	f	file:
ipfix_cache_update	.\ofproto\ofproto-dpif-ipfix.c	/^ipfix_cache_update(struct dpif_ipfix_exporter *exporter,$/;"	f	file:
ipfix_define_template_entity	.\ofproto\ofproto-dpif-ipfix.c	/^ipfix_define_template_entity(enum ipfix_entity_id id,$/;"	f	file:
ipfix_define_template_fields	.\ofproto\ofproto-dpif-ipfix.c	/^ipfix_define_template_fields(enum ipfix_proto_l2 l2, enum ipfix_proto_l3 l3,$/;"	f	file:
ipfix_entity_id	.\ofproto\ofproto-dpif-ipfix.c	/^enum ipfix_entity_id {$/;"	g	file:
ipfix_entity_size	.\ofproto\ofproto-dpif-ipfix.c	/^enum ipfix_entity_size {$/;"	g	file:
ipfix_flow_cache_entry	.\ofproto\ofproto-dpif-ipfix.c	/^struct ipfix_flow_cache_entry {$/;"	s	file:
ipfix_flow_end_reason	.\ofproto\ofproto-dpif-ipfix.c	/^enum ipfix_flow_end_reason {$/;"	g	file:
ipfix_flow_key	.\ofproto\ofproto-dpif-ipfix.c	/^struct ipfix_flow_key {$/;"	s	file:
ipfix_flow_key_equal	.\ofproto\ofproto-dpif-ipfix.c	/^ipfix_flow_key_equal(const struct ipfix_flow_key *a,$/;"	f	file:
ipfix_get_template_id	.\ofproto\ofproto-dpif-ipfix.c	/^ipfix_get_template_id(enum ipfix_proto_l2 l2, enum ipfix_proto_l3 l3,$/;"	f	file:
ipfix_hash_flow_key	.\ofproto\ofproto-dpif-ipfix.c	/^ipfix_hash_flow_key(const struct ipfix_flow_key *flow_key, uint32_t basis)$/;"	f	file:
ipfix_init_header	.\ofproto\ofproto-dpif-ipfix.c	/^ipfix_init_header(uint32_t export_time_sec, uint32_t seq_number,$/;"	f	file:
ipfix_proto_l2	.\ofproto\ofproto-dpif-ipfix.c	/^enum ipfix_proto_l2 {$/;"	g	file:
ipfix_proto_l3	.\ofproto\ofproto-dpif-ipfix.c	/^enum ipfix_proto_l3 {$/;"	g	file:
ipfix_proto_l4	.\ofproto\ofproto-dpif-ipfix.c	/^enum ipfix_proto_l4 {$/;"	g	file:
ipfix_put_data_set	.\ofproto\ofproto-dpif-ipfix.c	/^ipfix_put_data_set(uint32_t export_time_sec,$/;"	f	file:
ipfix_send_data_msg	.\ofproto\ofproto-dpif-ipfix.c	/^ipfix_send_data_msg(struct dpif_ipfix_exporter *exporter,$/;"	f	file:
ipfix_send_msg	.\ofproto\ofproto-dpif-ipfix.c	/^ipfix_send_msg(const struct collectors *collectors, struct ofpbuf *msg)$/;"	f	file:
ipfix_send_template_msg	.\ofproto\ofproto-dpif-ipfix.c	/^ipfix_send_template_msg(struct dpif_ipfix_exporter *exporter,$/;"	f	file:
ipgre_protocol	.\datapath\linux\compat\gre.c	/^static const struct gre_protocol ipgre_protocol = {$/;"	v	typeref:struct:gre_protocol	file:
iph_to_flow_copy_addrs	.\datapath\linux\compat\flow_dissector.c	/^static void iph_to_flow_copy_addrs(struct flow_keys *flow, const struct iphdr *iph)$/;"	f	file:
ipsec	.\lib\netdev.h	/^    bool ipsec;$/;"	m	struct:netdev_tunnel_config
iptunnel_pull_header	.\datapath\linux\compat\ip_tunnels_core.c	/^int iptunnel_pull_header(struct sk_buff *skb, int hdr_len, __be16 inner_proto)$/;"	f
iptunnel_xmit	.\datapath\linux\compat\include\net\ip_tunnels.h	27;"	d
iptunnel_xmit	.\datapath\linux\compat\ip_tunnels_core.c	/^int iptunnel_xmit(struct rtable *rt,$/;"	f
ipv4	.\datapath\flow.h	/^		} ipv4;$/;"	m	union:sw_flow_key::__anon5	typeref:struct:sw_flow_key::__anon5::__anon6
ipv4	.\lib\ofp-actions.h	/^    ovs_be32 ipv4;$/;"	m	struct:ofpact_ipv4
ipv4	.\lib\sflow.h	/^    SFLSampled_ipv4 ipv4;$/;"	m	union:_SFLFlow_type
ipv4_dst	.\datapath\flow.h	/^	__be32 ipv4_dst;$/;"	m	struct:ovs_key_ipv4_tunnel
ipv4_dst	.\include\linux\openvswitch.h	/^	__be32 ipv4_dst;$/;"	m	struct:ovs_key_ipv4
ipv4_frag	.\include\linux\openvswitch.h	/^	__u8   ipv4_frag;	\/* One of OVS_FRAG_TYPE_*. *\/$/;"	m	struct:ovs_key_ipv4
ipv4_is_lbcast	.\datapath\linux\compat\include\linux\in.h	/^static inline bool ipv4_is_lbcast(__be32 addr)$/;"	f
ipv4_is_local_multicast	.\datapath\linux\compat\include\linux\in.h	/^static inline bool ipv4_is_local_multicast(__be32 addr)$/;"	f
ipv4_is_loopback	.\datapath\linux\compat\include\linux\in.h	/^static inline bool ipv4_is_loopback(__be32 addr)$/;"	f
ipv4_is_multicast	.\datapath\linux\compat\include\linux\in.h	/^static inline bool ipv4_is_multicast(__be32 addr)$/;"	f
ipv4_is_zeronet	.\datapath\linux\compat\include\linux\in.h	/^static inline bool ipv4_is_zeronet(__be32 addr)$/;"	f
ipv4_proto	.\include\linux\openvswitch.h	/^	__u8   ipv4_proto;$/;"	m	struct:ovs_key_ipv4
ipv4_src	.\datapath\flow.h	/^	__be32 ipv4_src;$/;"	m	struct:ovs_key_ipv4_tunnel
ipv4_src	.\include\linux\openvswitch.h	/^	__be32 ipv4_src;$/;"	m	struct:ovs_key_ipv4
ipv4_tos	.\datapath\flow.h	/^	u8   ipv4_tos;$/;"	m	struct:ovs_key_ipv4_tunnel
ipv4_tos	.\include\linux\openvswitch.h	/^	__u8   ipv4_tos;$/;"	m	struct:ovs_key_ipv4
ipv4_ttl	.\datapath\flow.h	/^	u8   ipv4_ttl;$/;"	m	struct:ovs_key_ipv4_tunnel
ipv4_ttl	.\include\linux\openvswitch.h	/^	__u8   ipv4_ttl;$/;"	m	struct:ovs_key_ipv4
ipv4_tun_from_nlattr	.\datapath\flow_netlink.c	/^static int ipv4_tun_from_nlattr(const struct nlattr *attr,$/;"	f	file:
ipv4_tun_to_nlattr	.\datapath\flow_netlink.c	/^static int ipv4_tun_to_nlattr(struct sk_buff *skb,$/;"	f	file:
ipv6	.\datapath\flow.h	/^		} ipv6;$/;"	m	union:sw_flow_key::__anon5	typeref:struct:sw_flow_key::__anon5::__anon9
ipv6	.\lib\meta-flow.h	/^    struct in6_addr ipv6;$/;"	m	union:mf_value	typeref:struct:mf_value::in6_addr
ipv6	.\lib\sflow.h	/^    SFLSampled_ipv6 ipv6;$/;"	m	union:_SFLFlow_type
ipv6_addr_bitand	.\lib\packets.c	/^struct in6_addr ipv6_addr_bitand(const struct in6_addr *a,$/;"	f
ipv6_addr_equals	.\lib\packets.h	/^static inline bool ipv6_addr_equals(const struct in6_addr *a,$/;"	f
ipv6_addr_hash	.\datapath\linux\compat\include\net\ipv6.h	/^static inline u32 ipv6_addr_hash(const struct in6_addr *a)$/;"	f
ipv6_count_cidr_bits	.\lib\packets.c	/^ipv6_count_cidr_bits(const struct in6_addr *netmask)$/;"	f
ipv6_create_mask	.\lib\packets.c	/^ipv6_create_mask(int mask)$/;"	f
ipv6_dst	.\include\linux\openvswitch.h	/^	__be32 ipv6_dst[4];$/;"	m	struct:ovs_key_ipv6
ipv6_dst	.\lib\flow.h	/^    struct in6_addr ipv6_dst;   \/* IPv6 destination address. *\/$/;"	m	struct:flow	typeref:struct:flow::in6_addr
ipv6_find_hdr	.\datapath\linux\compat\include\net\ipv6.h	30;"	d
ipv6_frag	.\include\linux\openvswitch.h	/^	__u8   ipv6_frag;	\/* One of OVS_FRAG_TYPE_*. *\/$/;"	m	struct:ovs_key_ipv6
ipv6_hdr	.\datapath\linux\compat\include\linux\ipv6.h	/^static inline struct ipv6hdr *ipv6_hdr(const struct sk_buff *skb)$/;"	f
ipv6_hlimit	.\include\linux\openvswitch.h	/^	__u8   ipv6_hlimit;$/;"	m	struct:ovs_key_ipv6
ipv6_is_cidr	.\lib\packets.c	/^ipv6_is_cidr(const struct in6_addr *netmask)$/;"	f
ipv6_label	.\include\linux\openvswitch.h	/^	__be32 ipv6_label;	\/* 20-bits in least-significant bits. *\/$/;"	m	struct:ovs_key_ipv6
ipv6_label	.\lib\flow.h	/^    ovs_be32 ipv6_label;        \/* IPv6 flow label. *\/$/;"	m	struct:flow
ipv6_mask_is_any	.\lib\packets.h	/^static inline bool ipv6_mask_is_any(const struct in6_addr *mask) {$/;"	f
ipv6_mask_is_exact	.\lib\packets.h	/^static inline bool ipv6_mask_is_exact(const struct in6_addr *mask) {$/;"	f
ipv6_proto	.\include\linux\openvswitch.h	/^	__u8   ipv6_proto;$/;"	m	struct:ovs_key_ipv6
ipv6_skip_exthdr	.\datapath\linux\compat\include\net\ipv6.h	13;"	d
ipv6_src	.\include\linux\openvswitch.h	/^	__be32 ipv6_src[4];$/;"	m	struct:ovs_key_ipv6
ipv6_src	.\lib\flow.h	/^    struct in6_addr ipv6_src;   \/* IPv6 source address. *\/$/;"	m	struct:flow	typeref:struct:flow::in6_addr
ipv6_tclass	.\include\linux\openvswitch.h	/^	__u8   ipv6_tclass;$/;"	m	struct:ovs_key_ipv6
is_admissible	.\ofproto\ofproto-dpif-xlate.c	/^is_admissible(struct xlate_ctx *ctx, struct xport *in_port,$/;"	f	file:
is_admitted_msg	.\lib\rconn.c	/^is_admitted_msg(const struct ofpbuf *b)$/;"	f	file:
is_alive	.\python\ovs\jsonrpc.py	/^    def is_alive(self):$/;"	m	class:Session
is_all_ones	.\lib\util.c	/^is_all_ones(const uint8_t *p, size_t n)$/;"	f
is_all_zero	.\datapath\flow_netlink.c	/^static bool is_all_zero(const u8 *fp, size_t size)$/;"	f	file:
is_all_zeros	.\lib\util.c	/^is_all_zeros(const uint8_t *p, size_t n)$/;"	f
is_already_open	.\ovsdb\ovsdb-server.c	/^is_already_open(struct server_config *config OVS_UNUSED,$/;"	f	file:
is_composite	.\python\ovs\db\types.py	/^    def is_composite(self):$/;"	m	class:Type
is_condition_satisfied	.\utilities\ovs-vsctl.c	/^is_condition_satisfied(const struct vsctl_table_class *table,$/;"	f	file:
is_condition_satisfied	.\vtep\vtep-ctl.c	/^is_condition_satisfied(const struct vtep_ctl_table_class *table,$/;"	f	file:
is_connected	.\lib\reconnect.h	/^    bool is_connected;                     \/* Currently connected? *\/$/;"	m	struct:reconnect_stats
is_connected	.\lib\vswitch-idl.h	/^	bool is_connected;$/;"	m	struct:ovsrec_controller
is_connected	.\lib\vswitch-idl.h	/^	bool is_connected;$/;"	m	struct:ovsrec_manager
is_connected	.\lib\vtep-idl.h	/^	bool is_connected;$/;"	m	struct:vteprec_manager
is_connected	.\ofproto\ofproto.h	/^    bool is_connected;$/;"	m	struct:ofproto_controller_info
is_connected	.\ovsdb\jsonrpc-server.h	/^    bool is_connected;$/;"	m	struct:ovsdb_jsonrpc_remote_status
is_connected	.\python\ovs\jsonrpc.py	/^    def is_connected(self):$/;"	m	class:Session
is_connected	.\python\ovs\reconnect.py	/^        is_connected = False$/;"	v	class:Reconnect.Backoff
is_connected	.\python\ovs\reconnect.py	/^        is_connected = False$/;"	v	class:Reconnect.ConnectInProgress
is_connected	.\python\ovs\reconnect.py	/^        is_connected = False$/;"	v	class:Reconnect.Listening
is_connected	.\python\ovs\reconnect.py	/^        is_connected = False$/;"	v	class:Reconnect.Reconnect
is_connected	.\python\ovs\reconnect.py	/^        is_connected = False$/;"	v	class:Reconnect.Void
is_connected	.\python\ovs\reconnect.py	/^        is_connected = True$/;"	v	class:Reconnect.Active
is_connected	.\python\ovs\reconnect.py	/^        is_connected = True$/;"	v	class:Reconnect.Idle
is_connected	.\python\ovs\reconnect.py	/^    def is_connected(self):$/;"	m	class:Reconnect
is_connected_state	.\lib\rconn.c	/^is_connected_state(enum state state)$/;"	f	file:
is_connected_state	.\lib\reconnect.c	/^is_connected_state(enum state state)$/;"	f	file:
is_default	.\python\ovs\db\data.py	/^    def is_default(self):$/;"	m	class:Atom
is_default	.\python\ovs\db\data.py	/^    def is_default(self):$/;"	m	class:Datum
is_delimiter	.\lib\ofp-util.c	/^is_delimiter(unsigned char c)$/;"	f	file:
is_done	.\python\ovs\json.py	/^    def is_done(self):$/;"	m	class:Parser
is_dpdk_class	.\lib\netdev-dpdk.c	/^is_dpdk_class(const struct netdev_class *class)$/;"	f	file:
is_dummy_class	.\lib\netdev-dummy.c	/^is_dummy_class(const struct netdev_class *class)$/;"	f	file:
is_enabled	.\python\ovs\reconnect.py	/^    def is_enabled(self):$/;"	m	class:Reconnect
is_fail_open_rule	.\ofproto\fail-open.h	/^is_fail_open_rule(const struct rule *rule)$/;"	f
is_gratuitous_arp	.\ofproto\ofproto-dpif-xlate.c	/^is_gratuitous_arp(const struct flow *flow, struct flow_wildcards *wc)$/;"	f	file:
is_gre_gso	.\datapath\linux\compat\gre.c	/^static bool is_gre_gso(struct sk_buff *skb)$/;"	f	file:
is_identifier	.\python\ovs\db\parser.py	/^def is_identifier(s):$/;"	f
is_layer3	.\ofproto\ofproto-dpif.c	/^    bool is_layer3;             \/* This is a layer 3 port. *\/$/;"	m	struct:ofport_dpif	file:
is_learning_vlan	.\lib\mac-learning.c	/^is_learning_vlan(const struct mac_learning *ml, uint16_t vlan)$/;"	f	file:
is_lock_contended	.\lib\ovsdb-idl.c	/^    bool is_lock_contended;     \/* Has db server told us we can't get lock? *\/$/;"	m	struct:ovsdb_idl	file:
is_map	.\python\ovs\db\types.py	/^    def is_map(self):$/;"	m	class:Type
is_mirror_output_bundle	.\ofproto\ofproto-dpif.c	/^is_mirror_output_bundle(const struct ofproto *ofproto_, void *aux)$/;"	f	file:
is_mirror_output_bundle	.\ofproto\ofproto-provider.h	/^    bool (*is_mirror_output_bundle)(const struct ofproto *ofproto, void *aux);$/;"	m	struct:ofproto_class
is_mpls	.\lib\packets.c	/^static bool is_mpls(struct ofpbuf *packet)$/;"	f	file:
is_netdev_bsd_class	.\lib\netdev-bsd.c	/^is_netdev_bsd_class(const struct netdev_class *netdev_class)$/;"	f	file:
is_netdev_linux_class	.\lib\netdev-linux.c	/^is_netdev_linux_class(const struct netdev_class *netdev_class)$/;"	f	file:
is_openflow_port	.\utilities\ovs-ofctl.c	/^is_openflow_port(ovs_be16 port_, char *ports[])$/;"	f	file:
is_optional	.\python\ovs\db\types.py	/^    def is_optional(self):$/;"	m	class:Type
is_optional_pointer	.\python\ovs\db\types.py	/^    def is_optional_pointer(self):$/;"	m	class:Type
is_passive	.\python\ovs\reconnect.py	/^    def is_passive(self):$/;"	m	class:Reconnect
is_pow2	.\lib\util.h	/^is_pow2(uintmax_t x)$/;"	f
is_ref	.\python\ovs\db\types.py	/^    def is_ref(self):$/;"	m	class:BaseType
is_root	.\lib\ovsdb-idl-provider.h	/^    bool is_root;$/;"	m	struct:ovsdb_idl_table_class
is_root	.\ovsdb\table.h	/^    bool is_root;               \/* Part of garbage collection root set? *\/$/;"	m	struct:ovsdb_table_schema
is_scalar	.\python\ovs\db\types.py	/^    def is_scalar(self):$/;"	m	class:Type
is_set	.\python\ovs\db\types.py	/^    def is_set(self):$/;"	m	class:Type
is_set_operator	.\utilities\ovs-vsctl.c	/^is_set_operator(enum relop op)$/;"	f	file:
is_set_operator	.\vtep\vtep-ctl.c	/^is_set_operator(enum relop op)$/;"	f	file:
is_smap	.\python\ovs\db\types.py	/^    def is_smap(self):$/;"	m	class:Type
is_strong_ref	.\python\ovs\db\types.py	/^    def is_strong_ref(self):$/;"	m	class:BaseType
is_tap	.\lib\netdev-linux.c	/^    bool is_tap;$/;"	m	struct:netdev_rxq_linux	file:
is_tap_netdev	.\lib\netdev-linux.c	/^is_tap_netdev(const struct netdev *netdev)$/;"	f	file:
is_tunnel	.\ofproto\ofproto-dpif-xlate.c	/^    bool is_tunnel;                  \/* Is a tunnel port. *\/$/;"	m	struct:xport	file:
is_tunnel	.\ofproto\ofproto-dpif.c	/^    bool is_tunnel;             \/* This port is a tunnel. *\/$/;"	m	struct:ofport_dpif	file:
is_valid	.\python\ovs\db\types.py	/^    def is_valid(self):$/;"	m	class:BaseType
is_valid	.\python\ovs\db\types.py	/^    def is_valid(self):$/;"	m	class:Type
is_valid	.\python\ovs\jsonrpc.py	/^    def is_valid(self):$/;"	m	class:Message
is_valid_ipv4_address	.\python\ovs\socket_util.py	/^def is_valid_ipv4_address(address):$/;"	f
is_valid_name	.\python\ovs\stream.py	/^    def is_valid_name(name):$/;"	m	class:PassiveStream
is_valid_name	.\python\ovs\stream.py	/^    def is_valid_name(name):$/;"	m	class:Stream
is_valid_port_number	.\lib\dpif-netdev.c	/^is_valid_port_number(odp_port_t port_no)$/;"	f	file:
is_valid_string	.\python\ovs\ovsuuid.py	/^def is_valid_string(s):$/;"	f
is_valid_version	.\ovsdb\ovsdb.c	/^is_valid_version(const char *s)$/;"	f	file:
is_vport_class	.\lib\netdev-vport.c	/^is_vport_class(const struct netdev_class *class)$/;"	f	file:
is_warped	.\lib\timeval.c	/^is_warped(const struct clock *c)$/;"	f	file:
is_weak_ref	.\python\ovs\db\types.py	/^    def is_weak_ref(self):$/;"	m	class:BaseType
iter	.\lib\dpif.h	/^    void *iter;$/;"	m	struct:dpif_flow_dump
jhash_bytes	.\lib\jhash.c	/^jhash_bytes(const void *p_, size_t n, uint32_t basis)$/;"	f
jhash_final	.\lib\jhash.c	/^jhash_final(uint32_t *a, uint32_t *b, uint32_t *c)$/;"	f	file:
jhash_mix	.\lib\jhash.c	/^jhash_mix(uint32_t *a, uint32_t *b, uint32_t *c)$/;"	f	file:
jhash_rot	.\lib\jhash.c	/^jhash_rot(uint32_t x, int k)$/;"	f	file:
jhash_words	.\lib\jhash.c	/^jhash_words(const uint32_t *p, size_t n, uint32_t basis)$/;"	f
jhash_words_cb	.\tests\test-hash.c	/^jhash_words_cb(uint32_t input)$/;"	f	file:
js	.\ovsdb\jsonrpc-server.c	/^    struct jsonrpc_session *js;  \/* JSON-RPC session. *\/$/;"	m	struct:ovsdb_jsonrpc_session	typeref:struct:ovsdb_jsonrpc_session::jsonrpc_session	file:
js_seqno	.\ovsdb\jsonrpc-server.c	/^    unsigned int js_seqno;       \/* Last jsonrpc_session_get_seqno() value. *\/$/;"	m	struct:ovsdb_jsonrpc_session	file:
json	.\lib\json.c	/^    struct json *json;$/;"	m	struct:json_parser_node	typeref:struct:json_parser_node::json	file:
json	.\lib\json.h	/^struct json {$/;"	s
json	.\lib\ovsdb-parser.h	/^    const struct json *json;    \/* JSON object being parsed. *\/$/;"	m	struct:ovsdb_parser	typeref:struct:ovsdb_parser::json
json	.\lib\table.h	/^    struct json *json;$/;"	m	struct:cell	typeref:struct:cell::json
json	.\ovsdb\file.c	/^    struct json *json;          \/* JSON for the whole transaction. *\/$/;"	m	struct:ovsdb_file_txn	typeref:struct:ovsdb_file_txn::json	file:
json	.\python\ovs\db\data.py	/^import ovs.json$/;"	i
json	.\python\ovs\db\error.py	/^import ovs.json$/;"	i
json	.\python\ovs\jsonrpc.py	/^import ovs.json$/;"	i
json	.\tests\test-json.py	/^import ovs.json$/;"	i
json	.\tests\test-jsonrpc.py	/^import ovs.json$/;"	i
json_array	.\lib\json.c	/^json_array(const struct json *json)$/;"	f
json_array	.\lib\json.h	/^struct json_array {$/;"	s
json_array_add	.\lib\json.c	/^json_array_add(struct json *array_, struct json *element)$/;"	f
json_array_create	.\lib\json.c	/^json_array_create(struct json **elements, size_t n)$/;"	f
json_array_create_1	.\lib\json.c	/^json_array_create_1(struct json *elem0)$/;"	f
json_array_create_2	.\lib\json.c	/^json_array_create_2(struct json *elem0, struct json *elem1)$/;"	f
json_array_create_3	.\lib\json.c	/^json_array_create_3(struct json *elem0, struct json *elem1, struct json *elem2)$/;"	f
json_array_create_empty	.\lib\json.c	/^json_array_create_empty(void)$/;"	f
json_array_trim	.\lib\json.c	/^json_array_trim(struct json *array_)$/;"	f
json_boolean	.\lib\json.c	/^json_boolean(const struct json *json)$/;"	f
json_boolean_create	.\lib\json.c	/^json_boolean_create(bool b)$/;"	f
json_clone	.\lib\json.c	/^json_clone(const struct json *json)$/;"	f
json_clone_array	.\lib\json.c	/^json_clone_array(const struct json_array *array)$/;"	f	file:
json_clone_object	.\lib\json.c	/^json_clone_object(const struct shash *object)$/;"	f	file:
json_create	.\lib\json.c	/^json_create(enum json_type type)$/;"	f	file:
json_destroy	.\lib\json.c	/^json_destroy(struct json *json)$/;"	f
json_destroy_array	.\lib\json.c	/^json_destroy_array(struct json_array *array)$/;"	f	file:
json_destroy_object	.\lib\json.c	/^json_destroy_object(struct shash *object)$/;"	f	file:
json_equal	.\lib\json.c	/^json_equal(const struct json *a, const struct json *b)$/;"	f
json_equal_array	.\lib\json.c	/^json_equal_array(const struct json_array *a, const struct json_array *b)$/;"	f	file:
json_equal_object	.\lib\json.c	/^json_equal_object(const struct shash *a, const struct shash *b)$/;"	f	file:
json_error	.\lib\json.c	/^json_error(struct json_parser *p, const char *format, ...)$/;"	f	file:
json_flags	.\lib\table.h	/^    int json_flags;             \/* CF_JSON: Flags for json_to_string(). *\/$/;"	m	struct:table_style
json_from_file	.\lib\json.c	/^json_from_file(const char *file_name)$/;"	f
json_from_stream	.\lib\json.c	/^json_from_stream(FILE *stream)$/;"	f
json_from_string	.\lib\json.c	/^json_from_string(const char *string)$/;"	f
json_hash	.\lib\json.c	/^json_hash(const struct json *json, size_t basis)$/;"	f
json_hash_array	.\lib\json.c	/^json_hash_array(const struct json_array *array, size_t basis)$/;"	f	file:
json_hash_object	.\lib\json.c	/^json_hash_object(const struct shash *object, size_t basis)$/;"	f	file:
json_integer	.\lib\json.c	/^json_integer(const struct json *json)$/;"	f
json_integer_create	.\lib\json.c	/^json_integer_create(long long int integer)$/;"	f
json_lex_4hex	.\lib\json.c	/^json_lex_4hex(const char *cp, const char *end, int *valuep)$/;"	f	file:
json_lex_input	.\lib\json.c	/^json_lex_input(struct json_parser *p, unsigned char c)$/;"	f	file:
json_lex_keyword	.\lib\json.c	/^json_lex_keyword(struct json_parser *p)$/;"	f	file:
json_lex_number	.\lib\json.c	/^json_lex_number(struct json_parser *p)$/;"	f	file:
json_lex_state	.\lib\json.c	/^enum json_lex_state {$/;"	g	file:
json_lex_string	.\lib\json.c	/^json_lex_string(struct json_parser *p)$/;"	f	file:
json_lex_unicode	.\lib\json.c	/^json_lex_unicode(const char *cp, const char *end, struct ds *out)$/;"	f	file:
json_null_create	.\lib\json.c	/^json_null_create(void)$/;"	f
json_object	.\lib\json.c	/^json_object(const struct json *json)$/;"	f
json_object_create	.\lib\json.c	/^json_object_create(void)$/;"	f
json_object_put	.\lib\json.c	/^json_object_put(struct json *json, const char *name, struct json *value)$/;"	f
json_object_put_string	.\lib\json.c	/^json_object_put_string(struct json *json, const char *name, const char *value)$/;"	f
json_parse_state	.\lib\json.c	/^enum json_parse_state {$/;"	g	file:
json_parse_value	.\lib\json.c	/^json_parse_value(struct json_parser *p, struct json_token *token,$/;"	f	file:
json_parser	.\lib\json.c	/^struct json_parser {$/;"	s	file:
json_parser_abort	.\lib\json.c	/^json_parser_abort(struct json_parser *p)$/;"	f
json_parser_create	.\lib\json.c	/^json_parser_create(int flags)$/;"	f
json_parser_feed	.\lib\json.c	/^json_parser_feed(struct json_parser *p, const char *input, size_t n)$/;"	f
json_parser_finish	.\lib\json.c	/^json_parser_finish(struct json_parser *p)$/;"	f
json_parser_input	.\lib\json.c	/^json_parser_input(struct json_parser *p, struct json_token *token)$/;"	f	file:
json_parser_input_string	.\lib\json.c	/^json_parser_input_string(struct json_parser *p, const char *s)$/;"	f	file:
json_parser_is_done	.\lib\json.c	/^json_parser_is_done(const struct json_parser *p)$/;"	f
json_parser_node	.\lib\json.c	/^struct json_parser_node {$/;"	s	file:
json_parser_pop	.\lib\json.c	/^json_parser_pop(struct json_parser *p)$/;"	f	file:
json_parser_push	.\lib\json.c	/^json_parser_push(struct json_parser *p,$/;"	f	file:
json_parser_push_array	.\lib\json.c	/^json_parser_push_array(struct json_parser *p)$/;"	f	file:
json_parser_push_object	.\lib\json.c	/^json_parser_push_object(struct json_parser *p)$/;"	f	file:
json_parser_put_value	.\lib\json.c	/^json_parser_put_value(struct json_parser *p, struct json *value)$/;"	f	file:
json_parser_top	.\lib\json.c	/^json_parser_top(struct json_parser *p)$/;"	f	file:
json_real	.\lib\json.c	/^json_real(const struct json *json)$/;"	f
json_real_create	.\lib\json.c	/^json_real_create(double real)$/;"	f
json_serialize	.\lib\json.c	/^json_serialize(const struct json *json, struct json_serializer *s)$/;"	f	file:
json_serialize_array	.\lib\json.c	/^json_serialize_array(const struct json_array *array, struct json_serializer *s)$/;"	f	file:
json_serialize_object	.\lib\json.c	/^json_serialize_object(const struct shash *object, struct json_serializer *s)$/;"	f	file:
json_serialize_object_member	.\lib\json.c	/^json_serialize_object_member(size_t i, const struct shash_node *node,$/;"	f	file:
json_serialize_string	.\lib\json.c	/^json_serialize_string(const char *string, struct ds *ds)$/;"	f	file:
json_serializer	.\lib\json.c	/^struct json_serializer {$/;"	s	file:
json_string	.\lib\json.c	/^json_string(const struct json *json)$/;"	f
json_string_create	.\lib\json.c	/^json_string_create(const char *s)$/;"	f
json_string_create_nocopy	.\lib\json.c	/^json_string_create_nocopy(char *s)$/;"	f
json_string_unescape	.\lib\json.c	/^json_string_unescape(const char *in, size_t in_len, char **outp)$/;"	f
json_to_ds	.\lib\json.c	/^json_to_ds(const struct json *json, int flags, struct ds *ds)$/;"	f
json_to_string	.\lib\json.c	/^json_to_string(const struct json *json, int flags)$/;"	f
json_token	.\lib\json.c	/^struct json_token {$/;"	s	file:
json_token_type	.\lib\json.c	/^enum json_token_type {$/;"	g	file:
json_type	.\lib\json.h	/^enum json_type {$/;"	g
json_type_to_string	.\lib\json.c	/^json_type_to_string(enum json_type type)$/;"	f
json_type_to_string	.\python\ovs\db\parser.py	/^def json_type_to_string(type_):$/;"	f
jsonrpc	.\lib\jsonrpc.c	/^VLOG_DEFINE_THIS_MODULE(jsonrpc);$/;"	v
jsonrpc	.\lib\jsonrpc.c	/^struct jsonrpc {$/;"	s	file:
jsonrpc	.\ovsdb\ovsdb-server.c	/^    struct ovsdb_jsonrpc_server *jsonrpc;$/;"	m	struct:server_config	typeref:struct:server_config::ovsdb_jsonrpc_server	file:
jsonrpc	.\python\ovs\db\data.py	/^import ovs.jsonrpc$/;"	i
jsonrpc	.\python\ovs\db\idl.py	/^import ovs.jsonrpc$/;"	i
jsonrpc	.\python\ovs\unixctl\client.py	/^import ovs.jsonrpc$/;"	i
jsonrpc	.\python\ovs\unixctl\server.py	/^import ovs.jsonrpc$/;"	i
jsonrpc	.\tests\test-jsonrpc.py	/^import ovs.jsonrpc$/;"	i
jsonrpc_cleanup	.\lib\jsonrpc.c	/^jsonrpc_cleanup(struct jsonrpc *rpc)$/;"	f	file:
jsonrpc_close	.\lib\jsonrpc.c	/^jsonrpc_close(struct jsonrpc *rpc)$/;"	f
jsonrpc_create	.\lib\jsonrpc.c	/^jsonrpc_create(enum jsonrpc_msg_type type, const char *method,$/;"	f	file:
jsonrpc_create_error	.\lib\jsonrpc.c	/^jsonrpc_create_error(struct json *error, const struct json *id)$/;"	f
jsonrpc_create_id	.\lib\jsonrpc.c	/^jsonrpc_create_id(void)$/;"	f	file:
jsonrpc_create_notify	.\lib\jsonrpc.c	/^jsonrpc_create_notify(const char *method, struct json *params)$/;"	f
jsonrpc_create_reply	.\lib\jsonrpc.c	/^jsonrpc_create_reply(struct json *result, const struct json *id)$/;"	f
jsonrpc_create_request	.\lib\jsonrpc.c	/^jsonrpc_create_request(const char *method, struct json *params,$/;"	f
jsonrpc_error	.\lib\jsonrpc.c	/^jsonrpc_error(struct jsonrpc *rpc, int error)$/;"	f	file:
jsonrpc_get_backlog	.\lib\jsonrpc.c	/^jsonrpc_get_backlog(const struct jsonrpc *rpc)$/;"	f
jsonrpc_get_name	.\lib\jsonrpc.c	/^jsonrpc_get_name(const struct jsonrpc *rpc)$/;"	f
jsonrpc_get_received_bytes	.\lib\jsonrpc.c	/^jsonrpc_get_received_bytes(const struct jsonrpc *rpc)$/;"	f
jsonrpc_get_status	.\lib\jsonrpc.c	/^jsonrpc_get_status(const struct jsonrpc *rpc)$/;"	f
jsonrpc_log_msg	.\lib\jsonrpc.c	/^jsonrpc_log_msg(const struct jsonrpc *rpc, const char *title,$/;"	f	file:
jsonrpc_msg	.\lib\jsonrpc.h	/^struct jsonrpc_msg {$/;"	s
jsonrpc_msg_destroy	.\lib\jsonrpc.c	/^jsonrpc_msg_destroy(struct jsonrpc_msg *m)$/;"	f
jsonrpc_msg_from_json	.\lib\jsonrpc.c	/^jsonrpc_msg_from_json(struct json *json, struct jsonrpc_msg **msgp)$/;"	f
jsonrpc_msg_is_valid	.\lib\jsonrpc.c	/^jsonrpc_msg_is_valid(const struct jsonrpc_msg *m)$/;"	f
jsonrpc_msg_to_json	.\lib\jsonrpc.c	/^jsonrpc_msg_to_json(struct jsonrpc_msg *m)$/;"	f
jsonrpc_msg_type	.\lib\jsonrpc.h	/^enum jsonrpc_msg_type {$/;"	g
jsonrpc_msg_type_to_string	.\lib\jsonrpc.c	/^jsonrpc_msg_type_to_string(enum jsonrpc_msg_type type)$/;"	f
jsonrpc_open	.\lib\jsonrpc.c	/^jsonrpc_open(struct stream *stream)$/;"	f
jsonrpc_parse_received_message	.\lib\jsonrpc.c	/^jsonrpc_parse_received_message(struct jsonrpc *rpc)$/;"	f	file:
jsonrpc_pstream_open	.\lib\jsonrpc.c	/^jsonrpc_pstream_open(const char *name, struct pstream **pstreamp, uint8_t dscp)$/;"	f
jsonrpc_recv	.\lib\jsonrpc.c	/^jsonrpc_recv(struct jsonrpc *rpc, struct jsonrpc_msg **msgp)$/;"	f
jsonrpc_recv_block	.\lib\jsonrpc.c	/^jsonrpc_recv_block(struct jsonrpc *rpc, struct jsonrpc_msg **msgp)$/;"	f
jsonrpc_recv_wait	.\lib\jsonrpc.c	/^jsonrpc_recv_wait(struct jsonrpc *rpc)$/;"	f
jsonrpc_run	.\lib\jsonrpc.c	/^jsonrpc_run(struct jsonrpc *rpc)$/;"	f
jsonrpc_send	.\lib\jsonrpc.c	/^jsonrpc_send(struct jsonrpc *rpc, struct jsonrpc_msg *msg)$/;"	f
jsonrpc_send_block	.\lib\jsonrpc.c	/^jsonrpc_send_block(struct jsonrpc *rpc, struct jsonrpc_msg *msg)$/;"	f
jsonrpc_session	.\lib\jsonrpc.c	/^struct jsonrpc_session {$/;"	s	file:
jsonrpc_session_close	.\lib\jsonrpc.c	/^jsonrpc_session_close(struct jsonrpc_session *s)$/;"	f
jsonrpc_session_connect	.\lib\jsonrpc.c	/^jsonrpc_session_connect(struct jsonrpc_session *s)$/;"	f	file:
jsonrpc_session_disconnect	.\lib\jsonrpc.c	/^jsonrpc_session_disconnect(struct jsonrpc_session *s)$/;"	f	file:
jsonrpc_session_enable_reconnect	.\lib\jsonrpc.c	/^jsonrpc_session_enable_reconnect(struct jsonrpc_session *s)$/;"	f
jsonrpc_session_force_reconnect	.\lib\jsonrpc.c	/^jsonrpc_session_force_reconnect(struct jsonrpc_session *s)$/;"	f
jsonrpc_session_get_backlog	.\lib\jsonrpc.c	/^jsonrpc_session_get_backlog(const struct jsonrpc_session *s)$/;"	f
jsonrpc_session_get_last_error	.\lib\jsonrpc.c	/^jsonrpc_session_get_last_error(const struct jsonrpc_session *s)$/;"	f
jsonrpc_session_get_name	.\lib\jsonrpc.c	/^jsonrpc_session_get_name(const struct jsonrpc_session *s)$/;"	f
jsonrpc_session_get_reconnect_stats	.\lib\jsonrpc.c	/^jsonrpc_session_get_reconnect_stats(const struct jsonrpc_session *s,$/;"	f
jsonrpc_session_get_seqno	.\lib\jsonrpc.c	/^jsonrpc_session_get_seqno(const struct jsonrpc_session *s)$/;"	f
jsonrpc_session_get_status	.\lib\jsonrpc.c	/^jsonrpc_session_get_status(const struct jsonrpc_session *s)$/;"	f
jsonrpc_session_is_alive	.\lib\jsonrpc.c	/^jsonrpc_session_is_alive(const struct jsonrpc_session *s)$/;"	f
jsonrpc_session_is_connected	.\lib\jsonrpc.c	/^jsonrpc_session_is_connected(const struct jsonrpc_session *s)$/;"	f
jsonrpc_session_open	.\lib\jsonrpc.c	/^jsonrpc_session_open(const char *name, bool retry)$/;"	f
jsonrpc_session_open_unreliably	.\lib\jsonrpc.c	/^jsonrpc_session_open_unreliably(struct jsonrpc *jsonrpc, uint8_t dscp)$/;"	f
jsonrpc_session_recv	.\lib\jsonrpc.c	/^jsonrpc_session_recv(struct jsonrpc_session *s)$/;"	f
jsonrpc_session_recv_wait	.\lib\jsonrpc.c	/^jsonrpc_session_recv_wait(struct jsonrpc_session *s)$/;"	f
jsonrpc_session_run	.\lib\jsonrpc.c	/^jsonrpc_session_run(struct jsonrpc_session *s)$/;"	f
jsonrpc_session_send	.\lib\jsonrpc.c	/^jsonrpc_session_send(struct jsonrpc_session *s, struct jsonrpc_msg *msg)$/;"	f
jsonrpc_session_set_dscp	.\lib\jsonrpc.c	/^jsonrpc_session_set_dscp(struct jsonrpc_session *s,$/;"	f
jsonrpc_session_set_max_backoff	.\lib\jsonrpc.c	/^jsonrpc_session_set_max_backoff(struct jsonrpc_session *s, int max_backoff)$/;"	f
jsonrpc_session_set_probe_interval	.\lib\jsonrpc.c	/^jsonrpc_session_set_probe_interval(struct jsonrpc_session *s,$/;"	f
jsonrpc_session_wait	.\lib\jsonrpc.c	/^jsonrpc_session_wait(struct jsonrpc_session *s)$/;"	f
jsonrpc_stream_open	.\lib\jsonrpc.c	/^jsonrpc_stream_open(const char *name, struct stream **streamp, uint8_t dscp)$/;"	f
jsonrpc_transact_block	.\lib\jsonrpc.c	/^jsonrpc_transact_block(struct jsonrpc *rpc, struct jsonrpc_msg *request,$/;"	f
jsonrpc_wait	.\lib\jsonrpc.c	/^jsonrpc_wait(struct jsonrpc *rpc)$/;"	f
jumpTable	.\lib\sflow_api.h	/^    SFLSampler *jumpTable[SFL_HASHTABLE_SIZ]; \/* fast lookup table for samplers (by ifIndex) *\/$/;"	m	struct:_SFLAgent
k	.\tests\idltest.h	/^	struct idltest_link1 *k;$/;"	m	struct:idltest_link1	typeref:struct:idltest_link1::idltest_link1
ka	.\tests\idltest.h	/^	struct idltest_link1 **ka;$/;"	m	struct:idltest_link1	typeref:struct:idltest_link1::idltest_link1
kbits_burst	.\lib\netdev-linux.c	/^    uint32_t kbits_burst;$/;"	m	struct:netdev_linux	file:
kbits_rate	.\lib\netdev-linux.c	/^    uint32_t kbits_rate;        \/* Policing data. *\/$/;"	m	struct:netdev_linux	file:
keep_flows	.\datapath\flow_table.h	/^	bool keep_flows;$/;"	m	struct:table_instance
kernel_name	.\lib\netdev-bsd.c	/^    char *kernel_name;$/;"	m	struct:netdev_bsd	file:
key	.\datapath\datapath.h	/^	const struct sw_flow_key *key;$/;"	m	struct:dp_upcall_info	typeref:struct:dp_upcall_info::sw_flow_key
key	.\datapath\flow.h	/^	struct sw_flow_key *key;$/;"	m	struct:sw_flow_match	typeref:struct:sw_flow_match::sw_flow_key
key	.\datapath\flow.h	/^	struct sw_flow_key key;$/;"	m	struct:sw_flow	typeref:struct:sw_flow::sw_flow_key
key	.\datapath\flow.h	/^	struct sw_flow_key key;$/;"	m	struct:sw_flow_mask	typeref:struct:sw_flow_mask::sw_flow_key
key	.\datapath\linux\compat\include\net\ip_tunnels.h	/^	__be32 key;$/;"	m	struct:tnl_ptk_info
key	.\lib\dpif-linux.c	/^    const struct nlattr *key;           \/* OVS_FLOW_ATTR_KEY. *\/$/;"	m	struct:dpif_linux_flow	typeref:struct:dpif_linux_flow::nlattr	file:
key	.\lib\dpif-netdev.c	/^    const struct miniflow *key;$/;"	m	struct:dp_netdev_execute_aux	typeref:struct:dp_netdev_execute_aux::miniflow	file:
key	.\lib\dpif.h	/^    const struct nlattr *key;       \/* Flow to delete. *\/$/;"	m	struct:dpif_flow_del	typeref:struct:dpif_flow_del::nlattr
key	.\lib\dpif.h	/^    const struct nlattr *key;       \/* Flow to put. *\/$/;"	m	struct:dpif_flow_put	typeref:struct:dpif_flow_put::nlattr
key	.\lib\dpif.h	/^    struct nlattr *key;         \/* Flow key. *\/$/;"	m	struct:dpif_upcall	typeref:struct:dpif_upcall::nlattr
key	.\lib\fat-rwlock.h	/^    ovsthread_key_t key;$/;"	m	struct:fat_rwlock
key	.\lib\lacp.c	/^    uint16_t key;                 \/* Aggregation Key. 0 if default. *\/$/;"	m	struct:slave	file:
key	.\lib\lacp.h	/^    uint16_t key;                     \/* Aggregation key. *\/$/;"	m	struct:lacp_slave_settings
key	.\lib\ovsdb-types.h	/^    struct ovsdb_base_type key;$/;"	m	struct:ovsdb_type	typeref:struct:ovsdb_type::ovsdb_base_type
key	.\lib\pcap-file.c	/^    struct tcp_key key;$/;"	m	struct:tcp_stream	typeref:struct:tcp_stream::tcp_key	file:
key	.\lib\smap.h	/^    char *key;$/;"	m	struct:smap_node
key	.\lib\uuid.c	/^static struct aes128 key;$/;"	v	typeref:struct:aes128	file:
key	.\ofproto\ofproto-dpif-upcall.c	/^    const struct nlattr *key;      \/* Datapath flow key. *\/$/;"	m	struct:udpif_key	typeref:struct:udpif_key::nlattr	file:
key	.\ofproto\ofproto-dpif-upcall.c	/^    const struct nlattr *key;$/;"	m	struct:flow_miss	typeref:struct:flow_miss::nlattr	file:
key	.\ofproto\ofproto-dpif.c	/^    const struct flow *key;$/;"	m	struct:trace_ctx	typeref:struct:trace_ctx::flow	file:
key_attr_size	.\datapath\datapath.c	/^static size_t key_attr_size(void)$/;"	f	file:
key_buf	.\ofproto\ofproto-dpif-upcall.c	/^    struct odputil_keybuf key_buf;            \/* Memory for 'key'. *\/$/;"	m	struct:udpif_key	typeref:struct:udpif_key::odputil_keybuf	file:
key_extract	.\datapath\flow.c	/^static int key_extract(struct sk_buff *skb, struct sw_flow_key *key)$/;"	f	file:
key_flow_tables	.\lib\vswitch-idl.h	/^	int64_t *key_flow_tables;$/;"	m	struct:ovsrec_bridge
key_len	.\lib\dpif-linux.c	/^    size_t key_len;$/;"	m	struct:dpif_linux_flow	file:
key_len	.\lib\dpif.h	/^    size_t key_len;                 \/* Length of 'key' in bytes. *\/$/;"	m	struct:dpif_flow_del
key_len	.\lib\dpif.h	/^    size_t key_len;                 \/* Length of 'key' in bytes. *\/$/;"	m	struct:dpif_flow_put
key_len	.\lib\dpif.h	/^    size_t key_len;             \/* Length of 'key' in bytes. *\/$/;"	m	struct:dpif_upcall
key_len	.\ofproto\ofproto-dpif-upcall.c	/^    size_t key_len;                \/* Length of 'key'. *\/$/;"	m	struct:udpif_key	file:
key_len	.\ofproto\ofproto-dpif-upcall.c	/^    size_t key_len;$/;"	m	struct:flow_miss	file:
key_mutex	.\lib\ovs-thread.c	/^static struct list free_keys OVS_GUARDED_BY(key_mutex)$/;"	v	typeref:struct:OVS_GUARDED_BY	file:
key_mutex	.\lib\ovs-thread.c	/^static struct list inuse_keys OVS_GUARDED_BY(key_mutex)$/;"	v	typeref:struct:OVS_GUARDED_BY	file:
key_mutex	.\lib\ovs-thread.c	/^static struct list slots_list OVS_GUARDED_BY(key_mutex)$/;"	v	typeref:struct:OVS_GUARDED_BY	file:
key_mutex	.\lib\ovs-thread.c	/^static struct ovs_mutex key_mutex = OVS_MUTEX_INITIALIZER;$/;"	v	typeref:struct:ovs_mutex	file:
key_queues	.\lib\vswitch-idl.h	/^	int64_t *key_queues;$/;"	m	struct:ovsrec_qos
key_slave	.\lib\lacp.c	/^    struct slave *key_slave; \/* Slave whose ID will be the aggregation key. *\/$/;"	m	struct:lacp	typeref:struct:lacp::slave	file:
key_statistics	.\lib\vswitch-idl.h	/^	char **key_statistics;$/;"	m	struct:ovsrec_interface
key_statistics	.\lib\vswitch-idl.h	/^	char **key_statistics;$/;"	m	struct:ovsrec_mirror
key_statistics	.\lib\vswitch-idl.h	/^	char **key_statistics;$/;"	m	struct:ovsrec_port
key_switch_binding	.\lib\vtep-idl.h	/^	char **key_switch_binding;$/;"	m	struct:vteprec_logical_router
key_to_tunnel_id	.\datapath\vport-gre.c	/^static __be64 key_to_tunnel_id(__be32 key, __be32 seq)$/;"	f	file:
key_type	.\lib\ovsdb-data.c	/^    enum ovsdb_atomic_type key_type;$/;"	m	struct:ovsdb_datum_sort_cbdata	typeref:enum:ovsdb_datum_sort_cbdata::ovsdb_atomic_type	file:
key_vlan_bindings	.\lib\vtep-idl.h	/^	int64_t *key_vlan_bindings;$/;"	m	struct:vteprec_physical_port
key_vlan_stats	.\lib\vtep-idl.h	/^	int64_t *key_vlan_stats;$/;"	m	struct:vteprec_physical_port
keybuf	.\lib\dpif-netdev.c	/^    struct odputil_keybuf keybuf;$/;"	m	struct:dp_netdev_flow_state	typeref:struct:dp_netdev_flow_state::odputil_keybuf	file:
keybuf	.\lib\odp-util.h	/^    uint32_t keybuf[DIV_ROUND_UP(ODPUTIL_FLOW_KEY_BYTES, 4)];$/;"	m	struct:odputil_keybuf
keys	.\lib\ovsdb-data.h	/^    union ovsdb_atom *keys;     \/* Each of the ovsdb_type's 'key_type'. *\/$/;"	m	struct:ovsdb_datum	typeref:union:ovsdb_datum::ovsdb_atom
keys	.\ofproto\ofproto.h	/^        const char *keys[4];$/;"	m	struct:ofproto_controller_info::__anon148
kill	.\utilities\ovs-dev.py	/^def kill():$/;"	f
kill_connection	.\lib\unixctl.c	/^kill_connection(struct unixctl_conn *conn)$/;"	f	file:
l1	.\tests\idltest.h	/^	struct idltest_link1 *l1;$/;"	m	struct:idltest_link2	typeref:struct:idltest_link2::idltest_link1
l2	.\tests\idltest.h	/^	struct idltest_link2 *l2;$/;"	m	struct:idltest_link1	typeref:struct:idltest_link1::idltest_link2
l2_5_ofs	.\lib\ofpbuf.h	/^    uint16_t l2_5_ofs;          \/* MPLS label stack offset from 'frame', or$/;"	m	struct:ofpbuf
l3_endpoint_client	.\python\ovstest\args.py	/^def l3_endpoint_client(string):$/;"	f
l3_endpoint_server	.\python\ovstest\args.py	/^def l3_endpoint_server(string):$/;"	f
l3_initialize_args	.\python\ovstest\args.py	/^def l3_initialize_args():$/;"	f
l3_ofs	.\lib\ofpbuf.h	/^    uint16_t l3_ofs;            \/* Network-level header offset from 'frame',$/;"	m	struct:ofpbuf
l4_ofs	.\lib\ofpbuf.h	/^    uint16_t l4_ofs;            \/* Transport-level header offset from 'frame',$/;"	m	struct:ofpbuf
label	.\datapath\flow.h	/^			__be32 label;			\/* IPv6 flow label. *\/$/;"	m	struct:sw_flow_key::__anon5::__anon9
label	.\include\openflow\nicira-ext.h	/^    ovs_be32 label;                 \/* LABEL *\/$/;"	m	struct:nx_action_mpls_label
label	.\lib\ofp-actions.h	/^    ovs_be32 label;$/;"	m	struct:ofpact_mpls_label
labelStackEncodingLength	.\lib\sflow_receiver.c	/^inline static u_int32_t labelStackEncodingLength(SFLLabelStack *labelStack) {$/;"	f	file:
lacp	.\lib\lacp.c	/^    struct lacp *lacp;            \/* LACP object containing this slave. *\/$/;"	m	struct:slave	typeref:struct:slave::lacp	file:
lacp	.\lib\lacp.c	/^VLOG_DEFINE_THIS_MODULE(lacp);$/;"	v
lacp	.\lib\lacp.c	/^struct lacp {$/;"	s	file:
lacp	.\lib\vswitch-idl.h	/^	char *lacp;$/;"	m	struct:ovsrec_port
lacp	.\ofproto\ofproto-dpif-xlate.c	/^    struct lacp *lacp;             \/* LACP handle or null. *\/$/;"	m	struct:xbundle	typeref:struct:xbundle::lacp	file:
lacp	.\ofproto\ofproto-dpif.c	/^    struct lacp *lacp;          \/* LACP if LACP is enabled, otherwise NULL. *\/$/;"	m	struct:ofbundle	typeref:struct:ofbundle::lacp	file:
lacp	.\ofproto\ofproto.h	/^    struct lacp_settings *lacp;              \/* Nonnull to enable LACP. *\/$/;"	m	struct:ofproto_bundle_settings	typeref:struct:ofproto_bundle_settings::lacp_settings
lacp_current	.\lib\vswitch-idl.h	/^	bool *lacp_current;$/;"	m	struct:ovsrec_interface
lacp_enabled	.\ofproto\ofproto-dpif.c	/^    bool lacp_enabled;$/;"	m	struct:ofproto_dpif	file:
lacp_fallback_ab	.\ofproto\bond.c	/^    bool lacp_fallback_ab; \/* Fallback to active-backup on LACP failure. *\/$/;"	m	struct:bond	file:
lacp_fallback_ab_cfg	.\ofproto\bond.h	/^    bool lacp_fallback_ab_cfg;  \/* Fallback to active-backup on LACP failure. *\/$/;"	m	struct:bond_settings
lacp_init	.\lib\lacp.c	/^lacp_init(void)$/;"	f
lacp_ref	.\lib\lacp.c	/^lacp_ref(const struct lacp *lacp_)$/;"	f
lacp_send_pdu	.\lib\lacp.h	/^typedef void lacp_send_pdu(void *slave, const void *pdu, size_t pdu_size);$/;"	t
lacp_settings	.\lib\lacp.h	/^struct lacp_settings {$/;"	s
lacp_slave_settings	.\lib\lacp.h	/^struct lacp_slave_settings {$/;"	s
lacp_slaves	.\ofproto\ofproto.h	/^    struct lacp_slave_settings *lacp_slaves; \/* Array of n_slaves elements. *\/$/;"	m	struct:ofproto_bundle_settings	typeref:struct:ofproto_bundle_settings::lacp_slave_settings
lacp_status	.\lib\lacp.h	/^enum lacp_status {$/;"	g
lacp_status	.\ofproto\bond.c	/^    enum lacp_status lacp_status; \/* Status of LACP negotiations. *\/$/;"	m	struct:bond	typeref:enum:bond::lacp_status	file:
lacp_unixctl_show	.\lib\lacp.c	/^static unixctl_cb_func lacp_unixctl_show;$/;"	v	file:
lan	.\tests\test-stp.c	/^struct lan {$/;"	s	file:
lan_conn	.\tests\test-stp.c	/^struct lan_conn {$/;"	s	file:
lans	.\tests\test-stp.c	/^    struct lan *lans[26];$/;"	m	struct:test_case	typeref:struct:test_case::lan	file:
last_action	.\datapath\actions.c	/^static bool last_action(const struct nlattr *a, int rem)$/;"	f	file:
last_activity	.\lib\rconn.c	/^    time_t last_activity;       \/* Last time we saw some activity. *\/$/;"	m	struct:rconn	file:
last_activity	.\lib\reconnect.c	/^    long long int last_activity;$/;"	m	struct:reconnect	file:
last_activity	.\lib\reconnect.h	/^    long long int last_activity;     \/* Last call to reconnect_activity(). *\/$/;"	m	struct:reconnect_stats
last_admitted	.\lib\rconn.c	/^    time_t last_admitted;$/;"	m	struct:rconn	file:
last_compact	.\ovsdb\file.c	/^    long long int last_compact;$/;"	m	struct:ovsdb_file	file:
last_connected	.\lib\rconn.c	/^    time_t last_connected;$/;"	m	struct:rconn	file:
last_connected	.\lib\reconnect.c	/^    long long int last_connected;$/;"	m	struct:reconnect	file:
last_connected	.\lib\reconnect.h	/^    long long int last_connected;    \/* Last call to reconnect_connected(). *\/$/;"	m	struct:reconnect_stats
last_disconn_secs	.\ofproto\fail-open.c	/^    int last_disconn_secs;$/;"	m	struct:fail_open	file:
last_disconnected	.\lib\rconn.c	/^    time_t last_disconnected;$/;"	m	struct:rconn	file:
last_disconnected	.\lib\reconnect.c	/^    long long int last_disconnected;$/;"	m	struct:reconnect	file:
last_disconnected	.\lib\reconnect.h	/^    long long int last_disconnected; \/* Last call to reconnect_disconnected(). *\/$/;"	m	struct:reconnect_stats
last_dropped	.\lib\vlog.h	/^    time_t last_dropped;        \/* Time of most recent message drop. *\/$/;"	m	struct:vlog_rate_limit
last_error	.\lib\jsonrpc.c	/^    int last_error;$/;"	m	struct:jsonrpc_session	file:
last_error	.\lib\rconn.c	/^    int last_error;$/;"	m	struct:rconn	file:
last_error	.\ovsdb\jsonrpc-server.h	/^    int last_error;$/;"	m	struct:ovsdb_jsonrpc_remote_status
last_expired	.\ofproto\netflow.c	/^    long long int last_expired;   \/* Time this flow last timed out. *\/$/;"	m	struct:netflow_flow	file:
last_fill	.\lib\token-bucket.h	/^    long long int last_fill;    \/* Last time tokens added. *\/$/;"	m	struct:token_bucket
last_forwarding	.\lib\bfd.c	/^    bool last_forwarding;         \/* Last calculation of forwarding flag. *\/$/;"	m	struct:bfd	file:
last_monitor_request_seqno	.\lib\ovsdb-idl.c	/^    unsigned int last_monitor_request_seqno;$/;"	m	struct:ovsdb_idl	file:
last_op	.\ofproto\connmgr.c	/^    long long int first_op, last_op; \/* Range of times for unreported ops. *\/$/;"	m	struct:ofconn	file:
last_poll	.\lib\dpif-linux.c	/^    long long int last_poll;    \/* Last time this channel was polled. *\/$/;"	m	struct:dpif_channel	file:
last_port_seq	.\lib\dpif-netdev.c	/^    uint64_t last_port_seq;$/;"	m	struct:dpif_netdev	file:
last_rehash	.\datapath\flow_table.h	/^	unsigned long last_rehash;$/;"	m	struct:flow_table
last_remote_mac	.\ofproto\in-band.c	/^    uint8_t last_remote_mac[ETH_ADDR_LEN]; \/* Previous nonzero next-hop MAC. *\/$/;"	m	struct:in_band_remote	file:
last_report	.\lib\memory.c	/^static long long int last_report;$/;"	v	file:
last_reported_maxrss	.\lib\memory.c	/^static unsigned long int last_reported_maxrss;$/;"	v	file:
last_rx	.\lib\cfm.c	/^    long long int last_rx; \/* Last CCM reception time. *\/$/;"	m	struct:remote_mp	file:
last_template_set_time	.\ofproto\ofproto-dpif-ipfix.c	/^    time_t last_template_set_time;$/;"	m	struct:dpif_ipfix_exporter	file:
last_total	.\lib\coverage.h	/^    unsigned long long int last_total;$/;"	m	struct:coverage_counter
last_tx	.\lib\bfd.c	/^    long long int last_tx;        \/* Last TX time. *\/$/;"	m	struct:bfd	file:
last_tx	.\lib\cfm.c	/^    long long int last_tx;    \/* Last CCM transmission time. *\/$/;"	m	struct:cfm	file:
last_used	.\ofproto\ofproto.c	/^    long long int last_used;    \/* Last time the 'ofp_port' was used. LLONG_MAX$/;"	m	struct:ofport_usage	file:
latch	.\lib\latch.h	/^struct latch {$/;"	s
latch_destroy	.\lib\latch-unix.c	/^latch_destroy(struct latch *latch)$/;"	f
latch_destroy	.\lib\latch-windows.c	/^latch_destroy(struct latch *latch)$/;"	f
latch_init	.\lib\latch-unix.c	/^latch_init(struct latch *latch)$/;"	f
latch_init	.\lib\latch-windows.c	/^latch_init(struct latch *latch)$/;"	f
latch_is_set	.\lib\latch-unix.c	/^latch_is_set(const struct latch *latch)$/;"	f
latch_is_set	.\lib\latch-windows.c	/^latch_is_set(const struct latch *latch)$/;"	f
latch_poll	.\lib\latch-unix.c	/^latch_poll(struct latch *latch)$/;"	f
latch_poll	.\lib\latch-windows.c	/^latch_poll(struct latch *latch)$/;"	f
latch_set	.\lib\latch-unix.c	/^latch_set(struct latch *latch)$/;"	f
latch_set	.\lib\latch-windows.c	/^latch_set(struct latch *latch)$/;"	f
latch_wait	.\lib\latch.h	45;"	d
latch_wait_at	.\lib\latch-unix.c	/^latch_wait_at(const struct latch *latch, const char *where)$/;"	f
latch_wait_at	.\lib\latch-windows.c	/^latch_wait_at(const struct latch *latch, const char *where)$/;"	f
layer2_octet_delta_count	.\ofproto\ofproto-dpif-ipfix.c	/^    uint64_t layer2_octet_delta_count;$/;"	m	struct:ipfix_flow_cache_entry	file:
learn	.\lib\ofp-actions.c	/^    struct nx_action_learn learn;$/;"	m	union:ofp_action	typeref:struct:ofp_action::nx_action_learn	file:
learn	.\ofproto\ofproto-dpif-xlate.c	/^        } learn;$/;"	m	union:xc_entry::__anon136	typeref:struct:xc_entry::__anon136::__anon141	file:
learn_check	.\lib\learn.c	/^learn_check(const struct ofpact_learn *learn, const struct flow *flow)$/;"	f
learn_execute	.\lib\learn.c	/^learn_execute(const struct ofpact_learn *learn, const struct flow *flow,$/;"	f
learn_format	.\lib\learn.c	/^learn_format(const struct ofpact_learn *learn, struct ds *s)$/;"	f
learn_from_openflow	.\lib\learn.c	/^learn_from_openflow(const struct nx_action_learn *nal, struct ofpbuf *ofpacts)$/;"	f
learn_macs	.\tests\test-controller.c	/^static bool learn_macs = true;$/;"	v	file:
learn_mask	.\lib\learn.c	/^learn_mask(const struct ofpact_learn *learn, struct flow_wildcards *wc)$/;"	f
learn_min_len	.\lib\learn.c	/^learn_min_len(uint16_t header)$/;"	f	file:
learn_parse	.\lib\learn.c	/^learn_parse(char *arg, struct ofpbuf *ofpacts)$/;"	f
learn_parse__	.\lib\learn.c	/^learn_parse__(char *orig, char *arg, struct ofpbuf *ofpacts)$/;"	f	file:
learn_parse_load_immediate	.\lib\learn.c	/^learn_parse_load_immediate(const char *s, struct ofpact_learn_spec *spec)$/;"	f	file:
learn_parse_spec	.\lib\learn.c	/^learn_parse_spec(const char *orig, char *name, char *value,$/;"	f	file:
learn_to_nxast	.\lib\learn.c	/^learn_to_nxast(const struct ofpact_learn *learn, struct ofpbuf *openflow)$/;"	f
learning_switch	.\lib\learning-switch.c	/^VLOG_DEFINE_THIS_MODULE(learning_switch);$/;"	v
leftmost_1bit_idx	.\lib\util.h	/^leftmost_1bit_idx(uint32_t x)$/;"	f
len	.\include\openflow\nicira-ext.h	/^    ovs_be16 len;                   \/* A multiple of 8, but at least 16. *\/$/;"	m	struct:nx_action_note
len	.\include\openflow\nicira-ext.h	/^    ovs_be16 len;                   \/* Length is 16. *\/$/;"	m	struct:nx_action_controller
len	.\include\openflow\nicira-ext.h	/^    ovs_be16 len;                   \/* Length is 16. *\/$/;"	m	struct:nx_action_header
len	.\include\openflow\nicira-ext.h	/^    ovs_be16 len;                   \/* Length is 16. *\/$/;"	m	struct:nx_action_pop_queue
len	.\include\openflow\nicira-ext.h	/^    ovs_be16 len;                   \/* Length is 16. *\/$/;"	m	struct:nx_action_resubmit
len	.\include\openflow\nicira-ext.h	/^    ovs_be16 len;                   \/* Length is 16. *\/$/;"	m	struct:nx_action_set_queue
len	.\include\openflow\nicira-ext.h	/^    ovs_be16 len;                   \/* Length is 16. *\/$/;"	m	struct:nx_action_set_tunnel
len	.\include\openflow\nicira-ext.h	/^    ovs_be16 len;                   \/* Length is 16. *\/$/;"	m	struct:nx_action_stack
len	.\include\openflow\nicira-ext.h	/^    ovs_be16 len;                   \/* Length is 24. *\/$/;"	m	struct:nx_action_reg_load
len	.\include\openflow\nicira-ext.h	/^    ovs_be16 len;                   \/* Length is 24. *\/$/;"	m	struct:nx_action_reg_move
len	.\include\openflow\nicira-ext.h	/^    ovs_be16 len;                   \/* Length is 24. *\/$/;"	m	struct:nx_action_sample
len	.\include\openflow\nicira-ext.h	/^    ovs_be16 len;                   \/* Length is 24. *\/$/;"	m	struct:nx_action_set_tunnel64
len	.\include\openflow\nicira-ext.h	/^    ovs_be16 len;                   \/* Length is 32. *\/$/;"	m	struct:nx_action_write_metadata
len	.\include\openflow\nicira-ext.h	/^    ovs_be16 len;                   \/* Length is 8. *\/$/;"	m	struct:nx_action_mpls_label
len	.\include\openflow\nicira-ext.h	/^    ovs_be16 len;                   \/* Length is 8. *\/$/;"	m	struct:nx_action_mpls_tc
len	.\include\openflow\nicira-ext.h	/^    ovs_be16 len;                   \/* Length is 8. *\/$/;"	m	struct:nx_action_mpls_ttl
len	.\include\openflow\nicira-ext.h	/^    ovs_be16 len;                   \/* Length is 8. *\/$/;"	m	struct:nx_action_pop_mpls
len	.\include\openflow\nicira-ext.h	/^    ovs_be16 len;                   \/* Length is 8. *\/$/;"	m	struct:nx_action_push_mpls
len	.\include\openflow\nicira-ext.h	/^    ovs_be16 len;               \/* 16. *\/$/;"	m	struct:nx_action_fin_timeout
len	.\include\openflow\nicira-ext.h	/^    ovs_be16 len;               \/* 24. *\/$/;"	m	struct:nx_action_output_reg
len	.\include\openflow\nicira-ext.h	/^    ovs_be16 len;               \/* At least 24. *\/$/;"	m	struct:nx_action_learn
len	.\include\openflow\nicira-ext.h	/^    ovs_be16 len;               \/* Length including slaves. *\/$/;"	m	struct:nx_action_bundle
len	.\include\openflow\nicira-ext.h	/^    ovs_be16 len;               \/* Length including slaves. *\/$/;"	m	struct:nx_action_cnt_ids
len	.\include\openflow\nicira-ext.h	/^    ovs_be16 len;               \/* Length is 32. *\/$/;"	m	struct:nx_action_multipath
len	.\include\openflow\openflow-1.0.h	/^    ovs_be16 len;                   \/* Length is 8. *\/$/;"	m	struct:ofp10_action_output
len	.\include\openflow\openflow-1.0.h	/^    ovs_be16 len;               \/* Length in bytes of this queue desc. *\/$/;"	m	struct:ofp10_packet_queue
len	.\include\openflow\openflow-1.0.h	/^    ovs_be16 len;             \/* Len is 16. *\/$/;"	m	struct:ofp10_action_enqueue
len	.\include\openflow\openflow-1.1.h	/^    ovs_be16 len;                     \/* Len is 8. *\/$/;"	m	struct:ofp11_action_set_queue
len	.\include\openflow\openflow-1.1.h	/^    ovs_be16 len;                     \/* Length is 16. *\/$/;"	m	struct:ofp11_action_output
len	.\include\openflow\openflow-1.1.h	/^    ovs_be16 len;                     \/* Length is 8. *\/$/;"	m	struct:ofp11_action_group
len	.\include\openflow\openflow-1.1.h	/^    ovs_be16 len;                     \/* Length is 8. *\/$/;"	m	struct:ofp11_action_mpls_label
len	.\include\openflow\openflow-1.1.h	/^    ovs_be16 len;                     \/* Length is 8. *\/$/;"	m	struct:ofp11_action_mpls_tc
len	.\include\openflow\openflow-1.1.h	/^    ovs_be16 len;                     \/* Length is 8. *\/$/;"	m	struct:ofp11_action_mpls_ttl
len	.\include\openflow\openflow-1.1.h	/^    ovs_be16 len;                     \/* Length is 8. *\/$/;"	m	struct:ofp11_action_nw_ecn
len	.\include\openflow\openflow-1.1.h	/^    ovs_be16 len;                     \/* Length is 8. *\/$/;"	m	struct:ofp11_action_nw_ttl
len	.\include\openflow\openflow-1.1.h	/^    ovs_be16 len;                     \/* Length is 8. *\/$/;"	m	struct:ofp11_action_pop_mpls
len	.\include\openflow\openflow-1.1.h	/^    ovs_be16 len;                     \/* Length is 8. *\/$/;"	m	struct:ofp11_action_push
len	.\include\openflow\openflow-1.1.h	/^    ovs_be16 len;                    \/* Length the bucket in bytes, including$/;"	m	struct:ofp11_bucket
len	.\include\openflow\openflow-1.1.h	/^    ovs_be16 len;                  \/* Length of this struct in bytes. *\/$/;"	m	struct:ofp11_instruction_goto_table
len	.\include\openflow\openflow-1.1.h	/^    ovs_be16 len;               \/* Length of this struct in bytes *\/$/;"	m	struct:ofp11_instruction_experimenter
len	.\include\openflow\openflow-1.1.h	/^    ovs_be16 len;               \/* Length of this struct in bytes. *\/$/;"	m	struct:ofp11_instruction
len	.\include\openflow\openflow-1.1.h	/^    ovs_be16 len;               \/* Length of this struct in bytes. *\/$/;"	m	struct:ofp11_instruction_actions
len	.\include\openflow\openflow-1.1.h	/^    ovs_be16 len;               \/* Length of this struct in bytes. *\/$/;"	m	struct:ofp11_instruction_write_metadata
len	.\include\openflow\openflow-1.2.h	/^    ovs_be16 len;                   \/* Length is padded to 64 bits. *\/$/;"	m	struct:ofp12_action_set_field
len	.\include\openflow\openflow-1.2.h	/^    ovs_be16 len;          \/* Length in bytes of this queue desc. *\/$/;"	m	struct:ofp12_packet_queue
len	.\include\openflow\openflow-1.3.h	/^    ovs_be16    len;         \/* Length in bytes of this band. *\/$/;"	m	struct:ofp13_action_self_learning::ofp13_meter_band_drop
len	.\include\openflow\openflow-1.3.h	/^    ovs_be16    len;         \/* Length in bytes of this band. *\/$/;"	m	struct:ofp13_action_self_learning::ofp13_meter_band_dscp_remark
len	.\include\openflow\openflow-1.3.h	/^    ovs_be16    len;         \/* Length in bytes of this band. *\/$/;"	m	struct:ofp13_action_self_learning::ofp13_meter_band_experimenter
len	.\include\openflow\openflow-1.3.h	/^    ovs_be16  len;               \/* Length in bytes of this stats. *\/$/;"	m	struct:ofp13_action_self_learning::ofp13_meter_stats
len	.\include\openflow\openflow-1.3.h	/^    ovs_be16 len;                   \/* Length is 8. *\/$/;"	m	struct:ofp13_action_self_learning
len	.\include\openflow\openflow-1.3.h	/^    ovs_be16 len;               \/* Length is 8. *\/$/;"	m	struct:ofp13_instruction_meter
len	.\include\openflow\openflow-1.3.h	/^    ovs_be16 len;        \/* Length in bytes of this band. *\/$/;"	m	struct:ofp13_action_self_learning::ofp13_meter_band_header
len	.\include\openflow\openflow-common.h	/^    ovs_be16 len;                   \/* Length is 16. *\/$/;"	m	struct:ofp_action_dl_addr
len	.\include\openflow\openflow-common.h	/^    ovs_be16 len;                   \/* Length is 8. *\/$/;"	m	struct:ofp_action_nw_addr
len	.\include\openflow\openflow-common.h	/^    ovs_be16 len;                   \/* Length is 8. *\/$/;"	m	struct:ofp_action_nw_tos
len	.\include\openflow\openflow-common.h	/^    ovs_be16 len;                   \/* Length is 8. *\/$/;"	m	struct:ofp_action_tp_port
len	.\include\openflow\openflow-common.h	/^    ovs_be16 len;                   \/* Length is 8. *\/$/;"	m	struct:ofp_action_vlan_pcp
len	.\include\openflow\openflow-common.h	/^    ovs_be16 len;                   \/* Length is 8. *\/$/;"	m	struct:ofp_action_vlan_vid
len	.\include\openflow\openflow-common.h	/^    ovs_be16 len;                   \/* Length is a multiple of 8. *\/$/;"	m	struct:ofp_action_vendor_header
len	.\include\openflow\openflow-common.h	/^    ovs_be16 len;                   \/* Length of action, including this$/;"	m	struct:ofp_action_header
len	.\include\openflow\openflow-common.h	/^    ovs_be16 len;      \/* Length of property, including this header. *\/$/;"	m	struct:ofp_queue_prop_header
len	.\lib\ofp-actions.h	/^    uint16_t len;               \/* Length of the action, in bytes, including$/;"	m	struct:ofpact
len	.\lib\ofp-util.c	/^    ovs_be16 len;$/;"	m	struct:ofp_prop_header	file:
len	.\lib\sflow.h	/^    u_int32_t len;$/;"	m	struct:_SFLString
len	.\tests\test-classifier.c	/^    int len;                    \/* Length in bytes. *\/$/;"	m	struct:cls_field	file:
length	.\include\openflow\nicira-ext.h	/^    ovs_be16 length;            \/* Length is 24. *\/$/;"	m	struct:nx_flow_update_full
length	.\include\openflow\nicira-ext.h	/^    ovs_be16 length;            \/* Length is 8. *\/$/;"	m	struct:nx_flow_update_abbrev
length	.\include\openflow\nicira-ext.h	/^    ovs_be16 length;            \/* Length of this entry. *\/$/;"	m	struct:nx_flow_update_header
length	.\include\openflow\nicira-ext.h	/^    ovs_be16 length;          \/* Length of this entry. *\/$/;"	m	struct:nx_flow_stats
length	.\include\openflow\openflow-1.0.h	/^    ovs_be16 length;          \/* Length of this entry. *\/$/;"	m	struct:ofp10_flow_stats
length	.\include\openflow\openflow-1.1.h	/^    ovs_be16 length;            \/* Length of this entry. *\/$/;"	m	struct:ofp11_group_desc_stats
length	.\include\openflow\openflow-1.1.h	/^    ovs_be16 length;           \/* Length of match *\/$/;"	m	struct:ofp11_match_header
length	.\include\openflow\openflow-1.1.h	/^    ovs_be16 length;           \/* Length of this entry. *\/$/;"	m	struct:ofp11_flow_stats
length	.\include\openflow\openflow-1.1.h	/^    ovs_be16 length;           \/* Length of this entry. *\/$/;"	m	struct:ofp11_group_stats
length	.\include\openflow\openflow-1.3.h	/^    ovs_be16          length;       \/* Length of this entry. *\/$/;"	m	struct:ofp13_action_self_learning::ofp13_meter_config
length	.\include\openflow\openflow-1.3.h	/^    ovs_be16    length;   \/* Length in bytes of this property. *\/$/;"	m	struct:ofp13_action_self_learning::ofp13_table_feature_prop_experimenter
length	.\include\openflow\openflow-1.3.h	/^    ovs_be16    length;  \/* Length in bytes of this property. *\/$/;"	m	struct:ofp13_action_self_learning::ofp13_table_feature_prop_instructions
length	.\include\openflow\openflow-1.3.h	/^    ovs_be16    length; \/* Length in bytes of this property. *\/$/;"	m	struct:ofp13_action_self_learning::ofp13_table_feature_prop_actions
length	.\include\openflow\openflow-1.3.h	/^    ovs_be16    length; \/* Length in bytes of this property. *\/$/;"	m	struct:ofp13_action_self_learning::ofp13_table_feature_prop_header
length	.\include\openflow\openflow-1.3.h	/^    ovs_be16    length; \/* Length in bytes of this property. *\/$/;"	m	struct:ofp13_action_self_learning::ofp13_table_feature_prop_next_tables
length	.\include\openflow\openflow-1.3.h	/^    ovs_be16    length; \/* Length in bytes of this property. *\/$/;"	m	struct:ofp13_action_self_learning::ofp13_table_feature_prop_oxm
length	.\include\openflow\openflow-1.3.h	/^    ovs_be16 length;          \/* Length is padded to 64 bits. *\/$/;"	m	struct:ofp13_action_self_learning::ofp13_table_features
length	.\include\openflow\openflow-1.4.h	/^    ovs_be16         length;  \/* Length in bytes of this property. *\/$/;"	m	struct:ofp14_port_desc_prop_ethernet
length	.\include\openflow\openflow-1.4.h	/^    ovs_be16         length;  \/* Length in bytes of this property. *\/$/;"	m	struct:ofp14_port_stats_prop_ethernet
length	.\include\openflow\openflow-1.4.h	/^    ovs_be16         length;  \/* Length in bytes of this property. *\/$/;"	m	struct:ofp14_table_mod_prop_eviction
length	.\include\openflow\openflow-1.4.h	/^    ovs_be16         length; \/* Length in bytes of this property. *\/$/;"	m	struct:ofp14_table_mod_prop_vacancy
length	.\include\openflow\openflow-1.4.h	/^    ovs_be16        length;     \/* Length in bytes of this property. *\/$/;"	m	struct:ofp14_async_config_prop_experimenter
length	.\include\openflow\openflow-1.4.h	/^    ovs_be16        length;     \/* Length in bytes of this property. *\/$/;"	m	struct:ofp14_role_prop_experimenter
length	.\include\openflow\openflow-1.4.h	/^    ovs_be16      length;     \/* Length in bytes of this property. *\/$/;"	m	struct:ofp14_port_mod_prop_ethernet
length	.\include\openflow\openflow-1.4.h	/^    ovs_be16    length;     \/* Length in bytes of this property. *\/$/;"	m	struct:ofp14_async_config_prop_header
length	.\include\openflow\openflow-1.4.h	/^    ovs_be16    length; \/* Length in bytes of this property. *\/$/;"	m	struct:ofp14_async_config_prop_reasons
length	.\include\openflow\openflow-1.4.h	/^    ovs_be16 length;         \/* Length of this entry. *\/$/;"	m	struct:ofp14_port_stats
length	.\include\openflow\openflow-1.4.h	/^    ovs_be16 length;         \/* Length of this entry. *\/$/;"	m	struct:ofp14_queue_stats
length	.\include\openflow\openflow-1.4.h	/^    ovs_be16 length; \/* Length in bytes of this property. *\/$/;"	m	struct:ofp14_role_prop_header
length	.\include\openflow\openflow-1.4.h	/^    ovs_be16 length;$/;"	m	struct:ofp14_port
length	.\include\openflow\openflow-common.h	/^    ovs_be16    length;      \/* Length in bytes of this element. *\/$/;"	m	struct:ofp_hello_elem_header
length	.\include\openflow\openflow-common.h	/^    ovs_be16 length;    \/* Length including this ofp_header. *\/$/;"	m	struct:ofp_header
length	.\lib\bfd.c	/^    uint8_t length;       \/* Length of this BFD message. *\/$/;"	m	struct:msg	file:
length	.\lib\dynamic-string.h	/^    size_t length;      \/* Bytes used, not including null terminator. *\/$/;"	m	struct:ds
length	.\lib\ofp-actions.h	/^    size_t length;$/;"	m	struct:ofpact_note
length	.\lib\sflow.h	/^    u_int32_t length;       \/* The length of the IP packet$/;"	m	struct:_SFLSampled_ipv6
length	.\lib\sflow.h	/^    u_int32_t length;      \/* The length of the IP packet$/;"	m	struct:_SFLSampled_ipv4
length	.\lib\sflow.h	/^    u_int32_t length; \/* number of AS numbers in set\/sequence *\/$/;"	m	struct:_SFLExtended_as_path_segment
length	.\lib\sflow.h	/^    u_int32_t length;$/;"	m	struct:_SFLCounters_sample_element
length	.\lib\sflow.h	/^    u_int32_t length;$/;"	m	struct:_SFLFlow_sample_element
length	.\ovsdb\log.c	/^    unsigned long length;$/;"	m	struct:ovsdb_log_read_cbdata	file:
level_names	.\lib\vlog.c	/^static const char *const level_names[VLL_N_LEVELS] = {$/;"	v	file:
levels	.\lib\vlog.h	/^    int levels[VLF_N_FACILITIES]; \/* Minimum log level for each facility. *\/$/;"	m	struct:vlog_module
lex_state	.\lib\json.c	/^    enum json_lex_state lex_state;$/;"	m	struct:json_parser	typeref:enum:json_parser::json_lex_state	file:
lib	.\python\compat\uuid.py	/^            lib = ctypes.CDLL(ctypes.util.find_library(libname))$/;"	v
lib	.\python\compat\uuid.py	/^        lib = None$/;"	v
lib	.\python\compat\uuid.py	/^        lib = ctypes.windll.rpcrt4$/;"	v
lib_libopenvswitch_la_LDFLAGS	.\lib\automake.mk	/^lib_libopenvswitch_la_LDFLAGS = -release $(VERSION)$/;"	m
lib_libopenvswitch_la_LIBADD	.\lib\automake.mk	/^lib_libopenvswitch_la_LIBADD = $(SSL_LIBS)$/;"	m
lib_libopenvswitch_la_SOURCES	.\lib\automake.mk	/^lib_libopenvswitch_la_SOURCES = \\$/;"	m
lib_libsflow_la_CFLAGS	.\lib\automake.mk	/^lib_libsflow_la_CFLAGS = $(AM_CFLAGS)$/;"	m
lib_libsflow_la_CPPFLAGS	.\lib\automake.mk	/^lib_libsflow_la_CPPFLAGS = $(AM_CPPFLAGS)$/;"	m
lib_libsflow_la_LDFLAGS	.\lib\automake.mk	/^lib_libsflow_la_LDFLAGS = -release $(VERSION)$/;"	m
lib_libsflow_la_SOURCES	.\lib\automake.mk	/^lib_libsflow_la_SOURCES = \\$/;"	m
line	.\tests\test-stp.c	/^static char line[128];$/;"	v	file:
line_number	.\lib\json.c	/^    int line_number;$/;"	m	struct:json_parser	file:
line_number	.\tests\test-stp.c	/^static int line_number;$/;"	v	file:
link	.\lib\netdev-dpdk.c	/^    struct rte_eth_link link;$/;"	m	struct:netdev_dpdk	typeref:struct:netdev_dpdk::rte_eth_link	file:
link_reset_cnt	.\lib\netdev-dpdk.c	/^    int link_reset_cnt;$/;"	m	struct:netdev_dpdk	file:
link_resets	.\lib\vswitch-idl.h	/^	int64_t *link_resets;$/;"	m	struct:ovsrec_interface
link_speed	.\lib\vswitch-idl.h	/^	int64_t *link_speed;$/;"	m	struct:ovsrec_interface
link_state	.\lib\vswitch-idl.h	/^	char *link_state;$/;"	m	struct:ovsrec_interface
linux_name	.\lib\netdev-linux.c	/^    const char *linux_name;$/;"	m	struct:tc_ops	file:
lisp_build_header	.\datapath\vport-lisp.c	/^static void lisp_build_header(const struct vport *vport,$/;"	f	file:
lisp_find_port	.\datapath\vport-lisp.c	/^static struct lisp_port *lisp_find_port(struct net *net, __be16 port)$/;"	f	file:
lisp_fix_segment	.\datapath\vport-lisp.c	/^static void lisp_fix_segment(struct sk_buff *skb)$/;"	f	file:
lisp_get_name	.\datapath\vport-lisp.c	/^static const char *lisp_get_name(const struct vport *vport)$/;"	f	file:
lisp_get_options	.\datapath\vport-lisp.c	/^static int lisp_get_options(const struct vport *vport, struct sk_buff *skb)$/;"	f	file:
lisp_hdr	.\datapath\vport-lisp.c	/^static inline struct lisphdr *lisp_hdr(const struct sk_buff *skb)$/;"	f	file:
lisp_port	.\datapath\vport-lisp.c	/^struct lisp_port {$/;"	s	file:
lisp_rcv	.\datapath\vport-lisp.c	/^static int lisp_rcv(struct sock *sk, struct sk_buff *skb)$/;"	f	file:
lisp_rcv_socket	.\datapath\vport-lisp.c	/^	struct socket *lisp_rcv_socket;$/;"	m	struct:lisp_port	typeref:struct:lisp_port::socket	file:
lisp_send	.\datapath\vport-lisp.c	/^static int lisp_send(struct vport *vport, struct sk_buff *skb)$/;"	f	file:
lisp_socket_init	.\datapath\vport-lisp.c	/^static int lisp_socket_init(struct lisp_port *lisp_port, struct net *net)$/;"	f	file:
lisp_tnl_create	.\datapath\vport-lisp.c	/^static struct vport *lisp_tnl_create(const struct vport_parms *parms)$/;"	f	file:
lisp_tnl_destroy	.\datapath\vport-lisp.c	/^static void lisp_tnl_destroy(struct vport *vport)$/;"	f	file:
lisp_vport	.\datapath\vport-lisp.c	/^static inline struct lisp_port *lisp_vport(const struct vport *vport)$/;"	f	file:
lisphdr	.\datapath\vport-lisp.c	/^struct lisphdr {$/;"	s	file:
list	.\datapath\vport-lisp.c	/^	struct list_head list;$/;"	m	struct:lisp_port	typeref:struct:lisp_port::list_head	file:
list	.\lib\classifier.c	/^    struct list list;           \/* List of identical, lower-priority rules. *\/$/;"	m	struct:cls_match	typeref:struct:cls_match::list	file:
list	.\lib\guarded-list.h	/^    struct list list;$/;"	m	struct:guarded_list	typeref:struct:guarded_list::list
list	.\lib\list.h	/^struct list {$/;"	s
list	.\lib\vlog.h	/^    struct list list;$/;"	m	struct:vlog_module	typeref:struct:vlog_module::list
list_back	.\lib\list.c	/^list_back(const struct list *list_)$/;"	f
list_front	.\lib\list.c	/^list_front(const struct list *list_)$/;"	f
list_init	.\lib\list.c	/^list_init(struct list *list)$/;"	f
list_insert	.\lib\list.c	/^list_insert(struct list *before, struct list *elem)$/;"	f
list_is_empty	.\lib\list.c	/^list_is_empty(const struct list *list)$/;"	f
list_is_short	.\lib\list.c	/^list_is_short(const struct list *list)$/;"	f
list_is_singleton	.\lib\list.c	/^list_is_singleton(const struct list *list)$/;"	f
list_macs	.\vtep\vtep-ctl.c	/^list_macs(struct vtep_ctl_context *ctx, bool local)$/;"	f	file:
list_make_table	.\utilities\ovs-vsctl.c	/^list_make_table(const struct ovsdb_idl_column **columns, size_t n_columns)$/;"	f	file:
list_make_table	.\vtep\vtep-ctl.c	/^list_make_table(const struct ovsdb_idl_column **columns, size_t n_columns)$/;"	f	file:
list_move	.\lib\list.c	/^list_move(struct list *dst, struct list *src)$/;"	f
list_moved	.\lib\list.c	/^list_moved(struct list *list)$/;"	f
list_node	.\datapath\datapath.h	/^	struct list_head list_node;$/;"	m	struct:datapath	typeref:struct:datapath::list_head
list_node	.\lib\fat-rwlock.c	/^    struct list list_node;      \/* In struct rwlock's 'threads' list. *\/$/;"	m	struct:fat_rwlock_slot	typeref:struct:fat_rwlock_slot::list	file:
list_node	.\lib\ofp-util.h	/^    struct list list_node;    \/* For queuing flow_mods. *\/$/;"	m	struct:ofputil_flow_mod	typeref:struct:ofputil_flow_mod::list
list_node	.\lib\ofp-util.h	/^    struct list list_node;$/;"	m	struct:ofputil_bucket	typeref:struct:ofputil_bucket::list
list_node	.\lib\ofpbuf.h	/^    struct list list_node;      \/* Private list element for use by owner. *\/$/;"	m	struct:ofpbuf	typeref:struct:ofpbuf::list
list_node	.\lib\ovs-rcu.c	/^    struct list list_node;      \/* In global list. *\/$/;"	m	struct:ovsrcu_perthread	typeref:struct:ovsrcu_perthread::list	file:
list_node	.\lib\ovs-rcu.c	/^    struct list list_node;$/;"	m	struct:ovsrcu_cbset	typeref:struct:ovsrcu_cbset::list	file:
list_node	.\lib\ovs-thread.c	/^    struct list list_node;      \/* In 'inuse_keys' or 'free_keys'. *\/$/;"	m	struct:ovsthread_key	typeref:struct:ovsthread_key::list	file:
list_node	.\lib\ovs-thread.c	/^    struct list list_node;      \/* In 'slots_list'. *\/$/;"	m	struct:ovsthread_key_slots	typeref:struct:ovsthread_key_slots::list	file:
list_node	.\ofproto\bond.c	/^    struct list list_node;      \/* In bond_slave's 'entries' list. *\/$/;"	m	struct:bond_entry	typeref:struct:bond_entry::list	file:
list_node	.\ofproto\bond.c	/^    struct list list_node;      \/* In struct bond's enabled_slaves list. *\/$/;"	m	struct:bond_slave	typeref:struct:bond_slave::list	file:
list_node	.\ofproto\connmgr.h	/^    struct list list_node;      \/* For queuing. *\/$/;"	m	struct:ofproto_packet_in	typeref:struct:ofproto_packet_in::list
list_node	.\ofproto\ofproto-dpif-monitor.c	/^    struct list list_node;            \/* In send_soon. *\/$/;"	m	struct:send_soon_entry	typeref:struct:send_soon_entry::list	file:
list_node	.\ofproto\ofproto-dpif-upcall.c	/^    struct list list_node;             \/* In all_udpifs list. *\/$/;"	m	struct:udpif	typeref:struct:udpif::list	file:
list_node	.\ofproto\ofproto-dpif-xlate.c	/^    struct list list_node;         \/* In parent 'xbridges' list. *\/$/;"	m	struct:xbundle	typeref:struct:xbundle::list	file:
list_node	.\ofproto\ofproto-dpif.c	/^    struct list list_node;$/;"	m	struct:dpif_completion	typeref:struct:dpif_completion::list	file:
list_node	.\ofproto\ofproto-dpif.c	/^    struct list list_node;$/;"	m	struct:odp_garbage	typeref:struct:odp_garbage::list	file:
list_node	.\ofproto\ofproto.c	/^    struct list list_node;      \/* In struct ofproto's "rule_executes" list. *\/$/;"	m	struct:rule_execute	typeref:struct:rule_execute::list	file:
list_poison	.\lib\list.c	/^list_poison(struct list *list)$/;"	f
list_pop_back	.\lib\list.c	/^list_pop_back(struct list *list)$/;"	f
list_pop_front	.\lib\list.c	/^list_pop_front(struct list *list)$/;"	f
list_push_back	.\lib\list.c	/^list_push_back(struct list *list, struct list *elem)$/;"	f
list_push_front	.\lib\list.c	/^list_push_front(struct list *list, struct list *elem)$/;"	f
list_record	.\utilities\ovs-vsctl.c	/^list_record(const struct ovsdb_idl_row *row,$/;"	f	file:
list_record	.\vtep\vtep-ctl.c	/^list_record(const struct ovsdb_idl_row *row,$/;"	f	file:
list_remove	.\lib\list.c	/^list_remove(struct list *elem)$/;"	f
list_replace	.\lib\list.c	/^list_replace(struct list *element, const struct list *position)$/;"	f
list_size	.\lib\list.c	/^list_size(const struct list *list)$/;"	f
list_splice	.\lib\list.c	/^list_splice(struct list *before, struct list *first, struct list *last)$/;"	f
listen	.\lib\stream-provider.h	/^    int (*listen)(const char *name, char *suffix, struct pstream **pstreamp,$/;"	m	struct:pstream_class
listen	.\lib\vconn-provider.h	/^    int (*listen)(const char *name, uint32_t allowed_versions,$/;"	m	struct:pvconn_class
listen_error	.\python\ovs\reconnect.py	/^    def listen_error(self, now, error):$/;"	m	class:Reconnect
listener	.\lib\unixctl.c	/^    struct pstream *listener;$/;"	m	struct:unixctl_server	typeref:struct:unixctl_server::pstream	file:
listener	.\ovsdb\jsonrpc-server.c	/^    struct pstream *listener;   \/* Listener, if passive. *\/$/;"	m	struct:ovsdb_jsonrpc_remote	typeref:struct:ovsdb_jsonrpc_remote::pstream	file:
listening	.\python\ovs\reconnect.py	/^    def listening(self, now):$/;"	m	class:Reconnect
lo	.\include\openvswitch\types.h	/^        ovs_be16 hi, lo;$/;"	m	struct:__anon22
lo	.\include\openvswitch\types.h	/^        ovs_be32 hi, lo;$/;"	m	struct:__anon24
lo	.\include\openvswitch\types.h	/^        uint16_t hi, lo;$/;"	m	struct:__anon21
lo	.\include\openvswitch\types.h	/^        uint32_t hi, lo;$/;"	m	struct:__anon23
load_bonding_driver	.\xenserver\opt_xensource_libexec_InterfaceReconfigureBridge.py	/^def load_bonding_driver():$/;"	f
load_config	.\ovsdb\ovsdb-server.c	/^load_config(FILE *config_file, struct sset *remotes, struct sset *db_filenames)$/;"	f	file:
local	.\lib\sha1.h	/^    int local;                   \/* Unprocessed amount in data. *\/$/;"	m	struct:sha1_ctx
local	.\lib\vtep-idl.h	/^	struct vteprec_physical_locator *local;$/;"	m	struct:vteprec_tunnel	typeref:struct:vteprec_tunnel::vteprec_physical_locator
local_addr	.\utilities\ovs-benchmark.c	/^static struct in_addr local_addr;$/;"	v	typeref:struct:in_addr	file:
local_cfg	.\vtep\vtep-ctl.c	/^    const struct vteprec_mcast_macs_local *local_cfg;$/;"	m	struct:vtep_ctl_mcast_mac	typeref:struct:vtep_ctl_mcast_mac::vteprec_mcast_macs_local	file:
local_eth_dst	.\lib\bfd.c	/^    uint8_t local_eth_dst[ETH_ADDR_LEN]; \/* Local eth dst address. *\/$/;"	m	struct:bfd	file:
local_eth_src	.\lib\bfd.c	/^    uint8_t local_eth_src[ETH_ADDR_LEN]; \/* Local eth src address. *\/$/;"	m	struct:bfd	file:
local_gateway	.\lib\vswitch-idl.h	/^	char *local_gateway;$/;"	m	struct:ovsrec_controller
local_ip	.\lib\vswitch-idl.h	/^	char *local_ip;$/;"	m	struct:ovsrec_controller
local_mac	.\ofproto\in-band.c	/^    uint8_t local_mac[ETH_ADDR_LEN]; \/* Current MAC. *\/$/;"	m	struct:in_band	file:
local_max_port	.\utilities\ovs-benchmark.c	/^static unsigned short int local_min_port, local_max_port;$/;"	v	file:
local_min_port	.\utilities\ovs-benchmark.c	/^static unsigned short int local_min_port, local_max_port;$/;"	v	file:
local_netdev	.\ofproto\in-band.c	/^    struct netdev *local_netdev;     \/* Local port's network device. *\/$/;"	m	struct:in_band	typeref:struct:in_band::netdev	file:
local_netmask	.\lib\vswitch-idl.h	/^	char *local_netmask;$/;"	m	struct:ovsrec_controller
local_port_name	.\ofproto\connmgr.c	/^    char *local_port_name;$/;"	m	struct:connmgr	file:
localpref	.\lib\sflow.h	/^    u_int32_t localpref;                      \/* LocalPref associated with this route *\/$/;"	m	struct:_SFLExtended_gateway
localtime_msec	.\lib\timeval.c	/^localtime_msec(long long int now, struct tm_msec *result)$/;"	f
localtime_r	.\lib\timeval.h	44;"	d
locator	.\lib\vtep-idl.h	/^	struct vteprec_physical_locator *locator;$/;"	m	struct:vteprec_arp_sources_local	typeref:struct:vteprec_arp_sources_local::vteprec_physical_locator
locator	.\lib\vtep-idl.h	/^	struct vteprec_physical_locator *locator;$/;"	m	struct:vteprec_arp_sources_remote	typeref:struct:vteprec_arp_sources_remote::vteprec_physical_locator
locator	.\lib\vtep-idl.h	/^	struct vteprec_physical_locator *locator;$/;"	m	struct:vteprec_ucast_macs_local	typeref:struct:vteprec_ucast_macs_local::vteprec_physical_locator
locator	.\lib\vtep-idl.h	/^	struct vteprec_physical_locator *locator;$/;"	m	struct:vteprec_ucast_macs_remote	typeref:struct:vteprec_ucast_macs_remote::vteprec_physical_locator
locator_set	.\lib\vtep-idl.h	/^	struct vteprec_physical_locator_set *locator_set;$/;"	m	struct:vteprec_mcast_macs_local	typeref:struct:vteprec_mcast_macs_local::vteprec_physical_locator_set
locator_set	.\lib\vtep-idl.h	/^	struct vteprec_physical_locator_set *locator_set;$/;"	m	struct:vteprec_mcast_macs_remote	typeref:struct:vteprec_mcast_macs_remote::vteprec_physical_locator_set
locator_status_bits	.\datapath\vport-lisp.c	/^			__u8 locator_status_bits;$/;"	m	struct:lisphdr::__anon18::__anon19	file:
locator_status_bits	.\datapath\vport-lisp.c	/^		__be32 locator_status_bits;$/;"	m	union:lisphdr::__anon18	file:
locator_status_bits_present	.\datapath\vport-lisp.c	/^	__u8 locator_status_bits_present:1;$/;"	m	struct:lisphdr	file:
locators	.\lib\vtep-idl.h	/^	struct vteprec_physical_locator **locators;$/;"	m	struct:vteprec_physical_locator_set	typeref:struct:vteprec_physical_locator_set::vteprec_physical_locator
locators	.\vtep\vtep-ctl.c	/^    struct list locators;       \/* Contains 'vtep_ctl_ploc's. *\/$/;"	m	struct:vtep_ctl_mcast_mac	typeref:struct:vtep_ctl_mcast_mac::list	file:
locators_node	.\vtep\vtep-ctl.c	/^    struct list locators_node;  \/* In struct vtep_ctl_ploc_set's 'locators'$/;"	m	struct:vtep_ctl_ploc	typeref:struct:vtep_ctl_ploc::list	file:
lock	.\datapath\flow.h	/^	spinlock_t lock;		\/* Lock for atomic stats update. *\/$/;"	m	struct:flow_stats
lock	.\lib\ovs-thread.h	/^    pthread_mutex_t lock;$/;"	m	struct:ovs_mutex
lock	.\lib\ovs-thread.h	/^    pthread_rwlock_t lock;$/;"	m	struct:ovs_rwlock
lock	.\ofproto\ofproto-dpif-rid.c	/^    struct ovs_mutex lock;$/;"	m	struct:recirc_id_pool	typeref:struct:recirc_id_pool::ovs_mutex	file:
lock	.\ovsdb\server.h	/^    struct ovsdb_lock *lock;    \/* The lock being waited for. *\/$/;"	m	struct:ovsdb_lock_waiter	typeref:struct:ovsdb_lock_waiter::ovsdb_lock
lock_handle	.\lib\lockfile.c	/^    HANDLE lock_handle;$/;"	m	struct:lockfile	file:
lock_name	.\lib\ovsdb-idl.c	/^    char *lock_name;            \/* Name of lock we need, NULL if none. *\/$/;"	m	struct:ovsdb_idl	file:
lock_name	.\ovsdb\server.h	/^    char *lock_name;$/;"	m	struct:ovsdb_lock_waiter
lock_node	.\ovsdb\server.h	/^    struct list lock_node;      \/* In ->lock->waiters's list. *\/$/;"	m	struct:ovsdb_lock_waiter	typeref:struct:ovsdb_lock_waiter::list
lock_pidfile	.\lib\daemon-unix.c	/^lock_pidfile(FILE *file, int command)$/;"	f	file:
lock_pidfile__	.\lib\daemon-unix.c	/^lock_pidfile__(FILE *file, int command, struct flock *lck)$/;"	f	file:
lock_request_id	.\lib\ovsdb-idl.c	/^    struct json *lock_request_id; \/* JSON-RPC ID of in-flight lock request. *\/$/;"	m	struct:ovsdb_idl	typeref:struct:ovsdb_idl::json	file:
lock_table__	.\lib\lockfile.c	/^static struct hmap lock_table__ = HMAP_INITIALIZER(&lock_table__);$/;"	v	typeref:struct:hmap	file:
lock_table_mutex	.\lib\lockfile.c	/^    OVS_REQUIRES(&lock_table_mutex);$/;"	v
lock_table_mutex	.\lib\lockfile.c	/^static struct hmap *const lock_table OVS_GUARDED_BY(lock_table_mutex)$/;"	v	file:
lock_table_mutex	.\lib\lockfile.c	/^static struct ovs_mutex lock_table_mutex = OVS_MUTEX_INITIALIZER;$/;"	v	typeref:struct:ovs_mutex	file:
lockdep_ovsl_is_held	.\datapath\datapath.c	/^int lockdep_ovsl_is_held(void)$/;"	f
lockdep_ovsl_is_held	.\datapath\datapath.h	149;"	d
lockdep_rtnl_is_held	.\datapath\linux\compat\include\linux\rtnetlink.h	/^static inline int lockdep_rtnl_is_held(void)$/;"	f
lockfile	.\lib\lockfile.c	/^VLOG_DEFINE_THIS_MODULE(lockfile);$/;"	v
lockfile	.\lib\lockfile.c	/^struct lockfile {$/;"	s	file:
lockfile	.\ovsdb\log.c	/^    struct lockfile *lockfile;$/;"	m	struct:ovsdb_log	typeref:struct:ovsdb_log::lockfile	file:
lockfile_do_unlock	.\lib\lockfile.c	/^lockfile_do_unlock(struct lockfile *lockfile)$/;"	f	file:
lockfile_error	.\lib\lockfile.c	/^COVERAGE_DEFINE(lockfile_error);$/;"	v
lockfile_hash	.\lib\lockfile.c	/^lockfile_hash(dev_t device, ino_t inode)$/;"	f	file:
lockfile_lock	.\lib\lockfile.c	/^COVERAGE_DEFINE(lockfile_lock);$/;"	v
lockfile_lock	.\lib\lockfile.c	/^lockfile_lock(const char *file, struct lockfile **lockfilep)$/;"	f
lockfile_name	.\lib\lockfile.c	/^lockfile_name(const char *filename_)$/;"	f
lockfile_postfork	.\lib\lockfile.c	/^lockfile_postfork(void)$/;"	f
lockfile_unlock	.\lib\lockfile.c	/^COVERAGE_DEFINE(lockfile_unlock);$/;"	v
lockfile_unlock	.\lib\lockfile.c	/^lockfile_unlock(struct lockfile *lockfile)$/;"	f
locks	.\ovsdb\server.h	/^    struct hmap locks;     \/* Contains "struct ovsdb_lock"s indexed by name. *\/$/;"	m	struct:ovsdb_server	typeref:struct:ovsdb_server::hmap
locks_held	.\ovsdb\jsonrpc-server.h	/^    char *locks_held;$/;"	m	struct:ovsdb_jsonrpc_remote_status
locks_lost	.\ovsdb\jsonrpc-server.h	/^    char *locks_lost;$/;"	m	struct:ovsdb_jsonrpc_remote_status
locks_waiting	.\ovsdb\jsonrpc-server.h	/^    char *locks_waiting;$/;"	m	struct:ovsdb_jsonrpc_remote_status
log	.\ovsdb\file.c	/^    struct ovsdb_log *log;$/;"	m	struct:ovsdb_file	typeref:struct:ovsdb_file::ovsdb_log	file:
log	.\xenserver\opt_xensource_libexec_InterfaceReconfigure.py	/^def log(s):$/;"	f
log_2_ceil	.\lib\util.h	/^log_2_ceil(uint64_t n)$/;"	f
log_2_floor	.\lib\util.h	/^log_2_floor(uint64_t n)$/;"	f
log_backtrace	.\lib\backtrace.h	61;"	d
log_backtrace_at	.\lib\backtrace.c	/^log_backtrace_at(const char *msg, const char *where)$/;"	f
log_backtrace_msg	.\lib\backtrace.h	62;"	d
log_bad_action	.\lib\ofp-actions.c	/^log_bad_action(const union ofp_action *actions, size_t max_actions,$/;"	f	file:
log_bad_vendor	.\lib\ofp-msgs.c	/^log_bad_vendor(uint32_t vendor)$/;"	f	file:
log_ca_cert	.\lib\stream-ssl.c	/^log_ca_cert(const char *file_name, X509 *cert)$/;"	f	file:
log_destination	.\xenserver\opt_xensource_libexec_InterfaceReconfigure.py	/^log_destination = "syslog"$/;"	v
log_execute_message	.\lib\dpif.c	/^log_execute_message(struct dpif *dpif, const struct dpif_execute *execute,$/;"	f	file:
log_file_mutex	.\lib\vlog.c	/^static int log_fd OVS_GUARDED_BY(log_file_mutex) = -1;$/;"	v	file:
log_file_mutex	.\lib\vlog.c	/^static struct ovs_mutex log_file_mutex = OVS_MUTEX_INITIALIZER;$/;"	v	typeref:struct:ovs_mutex	file:
log_flow_del_message	.\lib\dpif.c	/^log_flow_del_message(struct dpif *dpif, const struct dpif_flow_del *del,$/;"	f	file:
log_flow_message	.\lib\dpif.c	/^log_flow_message(const struct dpif *dpif, int error, const char *operation,$/;"	f	file:
log_flow_put_message	.\lib\dpif.c	/^log_flow_put_message(struct dpif *dpif, const struct dpif_flow_put *put,$/;"	f	file:
log_nlmsg	.\lib\netlink-socket.c	/^log_nlmsg(const char *function, int error,$/;"	f	file:
log_odp_key_attributes	.\lib\odp-util.c	/^log_odp_key_attributes(struct vlog_rate_limit *rl, const char *title,$/;"	f	file:
log_operation	.\lib\dpif.c	/^log_operation(const struct dpif *dpif, const char *operation, int error)$/;"	f	file:
log_poll_interval	.\lib\timeval.c	/^log_poll_interval(long long int last_wakeup)$/;"	f	file:
log_property	.\lib\ofp-util.c	/^log_property(bool loose, const char *message, ...)$/;"	f
log_wakeup	.\lib\poll-loop.c	/^log_wakeup(const char *where, const struct pollfd *pollfd, int timeout)$/;"	f	file:
logging	.\python\ovs\vlog.py	/^import logging$/;"	i
logging	.\python\ovs\vlog.py	/^import logging.handlers$/;"	i
logging	.\tests\test-daemon.py	/^import logging$/;"	i
logical_switch	.\lib\vtep-idl.h	/^	struct vteprec_logical_switch *logical_switch;$/;"	m	struct:vteprec_mcast_macs_local	typeref:struct:vteprec_mcast_macs_local::vteprec_logical_switch
logical_switch	.\lib\vtep-idl.h	/^	struct vteprec_logical_switch *logical_switch;$/;"	m	struct:vteprec_mcast_macs_remote	typeref:struct:vteprec_mcast_macs_remote::vteprec_logical_switch
logical_switch	.\lib\vtep-idl.h	/^	struct vteprec_logical_switch *logical_switch;$/;"	m	struct:vteprec_ucast_macs_local	typeref:struct:vteprec_ucast_macs_local::vteprec_logical_switch
logical_switch	.\lib\vtep-idl.h	/^	struct vteprec_logical_switch *logical_switch;$/;"	m	struct:vteprec_ucast_macs_remote	typeref:struct:vteprec_ucast_macs_remote::vteprec_logical_switch
login_with_password	.\tests\MockXenAPI.py	/^    def login_with_password(self, unused_username, unused_password):$/;"	m	class:XenAPI
long_options_to_short_options	.\lib\command-line.c	/^long_options_to_short_options(const struct option options[])$/;"	f
lookahead_subtable	.\lib\classifier.c	/^lookahead_subtable(const struct cls_subtable_entry *subtables)$/;"	f	file:
lookup_bond_entry	.\ofproto\bond.c	/^lookup_bond_entry(const struct bond *bond, const struct flow *flow,$/;"	f	file:
lookup_count	.\include\openflow\openflow-1.0.h	/^    ovs_32aligned_be64 lookup_count;  \/* # of packets looked up in table. *\/$/;"	m	struct:ofp10_table_stats
lookup_count	.\include\openflow\openflow-1.1.h	/^    ovs_be64 lookup_count;   \/* Number of packets looked up in table. *\/$/;"	m	struct:ofp11_table_stats
lookup_count	.\include\openflow\openflow-1.2.h	/^    ovs_be64 lookup_count;   \/* Number of packets looked up in table. *\/$/;"	m	struct:ofp12_table_stats
lookup_count	.\include\openflow\openflow-1.3.h	/^    ovs_be64 lookup_count;  \/* Number of packets looked up in table. *\/$/;"	m	struct:ofp13_action_self_learning::ofp13_table_stats
lookup_datapath	.\datapath\datapath.c	/^static struct datapath *lookup_datapath(struct net *net,$/;"	f	file:
lookup_done	.\lib\classifier.c	/^    bool lookup_done;        \/* Status of the lookup. *\/$/;"	m	struct:trie_ctx	file:
lookup_executor	.\ovsdb\execution.c	/^lookup_executor(const char *name)$/;"	f	file:
lookup_hostname	.\lib\socket-util.c	/^lookup_hostname(const char *host_name, struct in_addr *addr)$/;"	f
lookup_input_bundle	.\ofproto\ofproto-dpif-xlate.c	/^lookup_input_bundle(const struct xbridge *xbridge, ofp_port_t in_port,$/;"	f	file:
lookup_ip	.\lib\socket-util.c	/^lookup_ip(const char *host_name, struct in_addr *addr)$/;"	f
lookup_ipv6	.\lib\socket-util.c	/^lookup_ipv6(const char *host_name, struct in6_addr *addr)$/;"	f
lookup_ofproto_dpif_by_port_name	.\ofproto\ofproto-dpif.c	/^lookup_ofproto_dpif_by_port_name(const char *name)$/;"	f	file:
lookup_utf8_sequence	.\lib\unicode.c	/^lookup_utf8_sequence(uint8_t c)$/;"	f	file:
lookup_uuid	.\tests\uuidfilt.pl	/^sub lookup_uuid {$/;"	s
lookup_vport	.\datapath\datapath.c	/^static struct vport *lookup_vport(struct net *net,$/;"	f	file:
loop_counter	.\datapath\actions.c	/^struct loop_counter {$/;"	s	file:
loop_suppress	.\datapath\actions.c	/^static int loop_suppress(struct datapath *dp, struct sw_flow_actions *actions)$/;"	f	file:
looping	.\datapath\actions.c	/^	bool looping;		\/* Loop detected? *\/$/;"	m	struct:loop_counter	file:
ls_cfg	.\vtep\vtep-ctl.c	/^    const struct vteprec_logical_switch *ls_cfg;$/;"	m	struct:vtep_ctl_lswitch	typeref:struct:vtep_ctl_lswitch::vteprec_logical_switch	file:
lswitch	.\lib\learning-switch.c	/^struct lswitch {$/;"	s	file:
lswitch	.\tests\test-controller.c	/^    struct lswitch *lswitch;$/;"	m	struct:switch_	typeref:struct:switch_::lswitch	file:
lswitch_choose_destination	.\lib\learning-switch.c	/^lswitch_choose_destination(struct lswitch *sw, const struct flow *flow)$/;"	f	file:
lswitch_config	.\lib\learning-switch.h	/^struct lswitch_config {$/;"	s
lswitch_create	.\lib\learning-switch.c	/^lswitch_create(struct rconn *rconn, const struct lswitch_config *cfg)$/;"	f
lswitch_destroy	.\lib\learning-switch.c	/^lswitch_destroy(struct lswitch *sw)$/;"	f
lswitch_handshake	.\lib\learning-switch.c	/^lswitch_handshake(struct lswitch *sw)$/;"	f	file:
lswitch_is_alive	.\lib\learning-switch.c	/^lswitch_is_alive(const struct lswitch *sw)$/;"	f
lswitch_mode	.\lib\learning-switch.h	/^enum lswitch_mode {$/;"	g
lswitch_port	.\lib\learning-switch.c	/^struct lswitch_port {$/;"	s	file:
lswitch_process_packet	.\lib\learning-switch.c	/^lswitch_process_packet(struct lswitch *sw, const struct ofpbuf *msg)$/;"	f	file:
lswitch_run	.\lib\learning-switch.c	/^lswitch_run(struct lswitch *sw)$/;"	f
lswitch_state	.\lib\learning-switch.c	/^enum lswitch_state {$/;"	g	file:
lswitch_wait	.\lib\learning-switch.c	/^lswitch_wait(struct lswitch *sw)$/;"	f
lswitches	.\vtep\vtep-ctl.c	/^    struct shash lswitches; \/* Maps from logical switch name to$/;"	m	struct:vtep_ctl_context	typeref:struct:vtep_ctl_context::shash	file:
m	.\datapath\linux\compat\include\linux\reciprocal_div.h	/^	u32 m;$/;"	m	struct:reciprocal_value
mac	.\lib\mac-learning.h	/^    uint8_t mac[ETH_ADDR_LEN];  \/* Known MAC address. *\/$/;"	m	struct:mac_entry
mac	.\lib\meta-flow.h	/^    uint8_t mac[ETH_ADDR_LEN];$/;"	m	union:mf_value
mac	.\lib\ofp-actions.h	/^    uint8_t mac[ETH_ADDR_LEN];$/;"	m	struct:ofpact_mac
mac	.\lib\vswitch-idl.h	/^	char *mac;$/;"	m	struct:ovsrec_interface
mac	.\lib\vswitch-idl.h	/^	char *mac;$/;"	m	struct:ovsrec_port
mac_entry	.\lib\mac-learning.h	/^struct mac_entry {$/;"	s
mac_entry_age	.\lib\mac-learning.c	/^mac_entry_age(const struct mac_learning *ml, const struct mac_entry *e)$/;"	f
mac_entry_from_lru_node	.\lib\mac-learning.c	/^mac_entry_from_lru_node(struct list *list)$/;"	f	file:
mac_entry_is_grat_arp_locked	.\lib\mac-learning.h	/^static inline bool mac_entry_is_grat_arp_locked(const struct mac_entry *mac)$/;"	f
mac_entry_lookup	.\lib\mac-learning.c	/^mac_entry_lookup(const struct mac_learning *ml,$/;"	f	file:
mac_entry_set_grat_arp_lock	.\lib\mac-learning.h	/^static inline void mac_entry_set_grat_arp_lock(struct mac_entry *mac)$/;"	f
mac_in_use	.\lib\vswitch-idl.h	/^	char *mac_in_use;$/;"	m	struct:ovsrec_interface
mac_learning	.\lib\mac-learning.h	/^struct mac_learning {$/;"	s
mac_learning_changed	.\lib\mac-learning.c	/^mac_learning_changed(struct mac_learning *ml)$/;"	f
mac_learning_create	.\lib\mac-learning.c	/^mac_learning_create(unsigned int idle_time)$/;"	f
mac_learning_expire	.\lib\mac-learning.c	/^mac_learning_expire(struct mac_learning *ml, struct mac_entry *e)$/;"	f
mac_learning_expired	.\lib\mac-learning.c	/^COVERAGE_DEFINE(mac_learning_expired);$/;"	v
mac_learning_flush	.\lib\mac-learning.c	/^mac_learning_flush(struct mac_learning *ml)$/;"	f
mac_learning_insert	.\lib\mac-learning.c	/^mac_learning_insert(struct mac_learning *ml,$/;"	f
mac_learning_learned	.\lib\mac-learning.c	/^COVERAGE_DEFINE(mac_learning_learned);$/;"	v
mac_learning_lookup	.\lib\mac-learning.c	/^mac_learning_lookup(const struct mac_learning *ml,$/;"	f
mac_learning_may_learn	.\lib\mac-learning.c	/^mac_learning_may_learn(const struct mac_learning *ml,$/;"	f
mac_learning_ref	.\lib\mac-learning.c	/^mac_learning_ref(const struct mac_learning *ml_)$/;"	f
mac_learning_run	.\lib\mac-learning.c	/^mac_learning_run(struct mac_learning *ml)$/;"	f
mac_learning_set_flood_vlans	.\lib\mac-learning.c	/^mac_learning_set_flood_vlans(struct mac_learning *ml,$/;"	f
mac_learning_set_idle_time	.\lib\mac-learning.c	/^mac_learning_set_idle_time(struct mac_learning *ml, unsigned int idle_time)$/;"	f
mac_learning_set_max_entries	.\lib\mac-learning.c	/^mac_learning_set_max_entries(struct mac_learning *ml, size_t max_entries)$/;"	f
mac_learning_unref	.\lib\mac-learning.c	/^mac_learning_unref(struct mac_learning *ml)$/;"	f
mac_learning_wait	.\lib\mac-learning.c	/^mac_learning_wait(struct mac_learning *ml)$/;"	f
mac_table_hash	.\lib\mac-learning.c	/^mac_table_hash(const struct mac_learning *ml, const uint8_t mac[ETH_ADDR_LEN],$/;"	f	file:
magic	.\lib\sflow_api.h	/^    void *magic;             \/* ptr to pass back in getCountersFn() *\/$/;"	m	struct:_SFLPoller
magic	.\lib\sflow_api.h	/^    void *magic;            \/* ptr to pass back in logging and alloc fns *\/$/;"	m	struct:_SFLAgent
magic	.\ovsdb\log.c	/^static const char magic[] = "OVSDB JSON ";$/;"	v	file:
magic_number	.\lib\pcap-file.c	/^    uint32_t magic_number;   \/* magic number *\/$/;"	m	struct:pcap_hdr	file:
maid	.\lib\cfm.c	/^    uint8_t maid[CCM_MAID_LEN]; \/* The MAID of this CFM. *\/$/;"	m	struct:cfm	file:
main	.\ovsdb\ovsdb-client.c	/^main(int argc, char *argv[])$/;"	f
main	.\ovsdb\ovsdb-server.c	/^main(int argc, char *argv[])$/;"	f
main	.\ovsdb\ovsdb-tool.c	/^main(int argc, char *argv[])$/;"	f
main	.\tests\appctl.py	/^def main():$/;"	f
main	.\tests\ovstest.c	/^main(int argc, char *argv[])$/;"	f
main	.\tests\test-controller.c	/^main(int argc, char *argv[])$/;"	f
main	.\tests\test-daemon.py	/^def main():$/;"	f
main	.\tests\test-json.py	/^def main(argv):$/;"	f
main	.\tests\test-jsonrpc.py	/^def main(argv):$/;"	f
main	.\tests\test-ovsdb.c	/^main(int argc, char *argv[])$/;"	f
main	.\tests\test-ovsdb.py	/^def main(argv):$/;"	f
main	.\tests\test-reconnect.py	/^def main():$/;"	f
main	.\tests\test-strtok_r.c	/^main(void)$/;"	f
main	.\tests\test-type-props.c	/^main (void)$/;"	f
main	.\tests\test-unix-socket.py	/^def main(argv):$/;"	f
main	.\tests\test-unixctl.py	/^def main():$/;"	f
main	.\tests\test-vlog.py	/^def main():$/;"	f
main	.\utilities\nlmon.c	/^main(int argc OVS_UNUSED, char *argv[])$/;"	f
main	.\utilities\ovs-appctl.c	/^main(int argc, char *argv[])$/;"	f
main	.\utilities\ovs-benchmark.c	/^main(int argc, char *argv[])$/;"	f
main	.\utilities\ovs-dev.py	/^def main():$/;"	f
main	.\utilities\ovs-dpctl.c	/^main(int argc, char *argv[])$/;"	f
main	.\utilities\ovs-ofctl.c	/^main(int argc, char *argv[])$/;"	f
main	.\utilities\ovs-vlan-bug-workaround.c	/^main(int argc, char *argv[])$/;"	f
main	.\utilities\ovs-vsctl.c	/^main(int argc, char *argv[])$/;"	f
main	.\vswitchd\ovs-vswitchd.c	/^main(int argc, char *argv[])$/;"	f
main	.\vtep\vtep-ctl.c	/^main(int argc, char *argv[])$/;"	f
make	.\utilities\ovs-dev.py	/^def make(args=""):$/;"	f
make_echo_reply	.\lib\ofp-util.c	/^make_echo_reply(const struct ofp_header *rq)$/;"	f
make_echo_request	.\lib\ofp-util.c	/^make_echo_request(enum ofp_version ofp_version)$/;"	f
make_hindex	.\tests\test-hindex.c	/^make_hindex(struct hindex *hindex, struct element elements[],$/;"	f	file:
make_hmap	.\tests\test-hmap.c	/^make_hmap(struct hmap *hmap, struct element elements[],$/;"	f	file:
make_id	.\ofproto\pktbuf.c	/^make_id(unsigned int buffer_idx, unsigned int cookie)$/;"	f	file:
make_in4_sockaddr	.\lib\netdev-bsd.c	/^make_in4_sockaddr(struct sockaddr *sa, struct in_addr addr)$/;"	f	file:
make_in4_sockaddr	.\lib\netdev-linux.c	/^make_in4_sockaddr(struct sockaddr *sa, struct in_addr addr)$/;"	f	file:
make_list	.\tests\test-list.c	/^make_list(struct list *list, struct element elements[],$/;"	f	file:
make_pidfile	.\lib\daemon-unix.c	/^make_pidfile(void)$/;"	f	file:
make_pidfile	.\lib\daemon-windows.c	/^make_pidfile(void)$/;"	f	file:
make_pidfile_name	.\lib\daemon-unix.c	/^make_pidfile_name(const char *name)$/;"	f
make_pidfile_name	.\lib\daemon-windows.c	/^make_pidfile_name(const char *name)$/;"	f
make_pidfile_name	.\python\ovs\daemon.py	/^def make_pidfile_name(name):$/;"	f
make_rule	.\tests\test-classifier.c	/^make_rule(int wc_fields, unsigned int priority, int value_pat)$/;"	f	file:
make_short_name	.\python\ovs\socket_util.py	/^def make_short_name(long_name):$/;"	f
make_sockaddr_un	.\lib\socket-util.c	/^make_sockaddr_un(const char *name, struct sockaddr_un *un, socklen_t *un_len,$/;"	f	file:
make_unix_socket	.\lib\socket-util.c	/^make_unix_socket(int style, bool nonblock,$/;"	f
make_unix_socket	.\python\ovs\socket_util.py	/^def make_unix_socket(style, nonblock, bind_path, connect_path, short=False):$/;"	f
make_writable	.\datapath\actions.c	/^static int make_writable(struct sk_buff *skb, int write_len)$/;"	f	file:
management_ips	.\lib\vtep-idl.h	/^	char **management_ips;$/;"	m	struct:vteprec_physical_switch
manager	.\lib\daemon-windows.c	/^static SC_HANDLE manager, service;$/;"	v	file:
manager_options	.\lib\vswitch-idl.h	/^	struct ovsrec_manager **manager_options;$/;"	m	struct:ovsrec_open_vswitch	typeref:struct:ovsrec_open_vswitch::ovsrec_manager
managers	.\lib\vtep-idl.h	/^	struct vteprec_manager **managers;$/;"	m	struct:vteprec_global	typeref:struct:vteprec_global::vteprec_manager
map	.\lib\flow.c	/^    uint64_t map;$/;"	m	struct:mf_ctx	file:
map	.\lib\hmapx.h	/^    struct hmap map;$/;"	m	struct:hmapx	typeref:struct:hmapx::hmap
map	.\lib\shash.h	/^    struct hmap map;$/;"	m	struct:shash	typeref:struct:shash::hmap
map	.\lib\simap.h	/^    struct hmap map;            \/* Contains "struct simap_node"s. *\/$/;"	m	struct:simap	typeref:struct:simap::hmap
map	.\lib\smap.h	/^    struct hmap map;           \/* Contains "struct smap_node"s. *\/$/;"	m	struct:smap	typeref:struct:smap::hmap
map	.\lib\sset.h	/^    struct hmap map;$/;"	m	struct:sset	typeref:struct:sset::hmap
map	.\ofproto\ofproto-dpif-rid.c	/^    struct hmap map;$/;"	m	struct:rid_map	typeref:struct:rid_map::hmap	file:
map_version	.\datapath\vport-lisp.c	/^		__u8 map_version[3];$/;"	m	union:lisphdr::__anon17	file:
map_version_present	.\datapath\vport-lisp.c	/^	__u8 map_version_present:1;$/;"	m	struct:lisphdr	file:
mark	.\tests\test-csum.c	/^mark(char c)$/;"	f	file:
mask	.\datapath\flow.h	/^	struct sw_flow_mask *mask;$/;"	m	struct:sw_flow	typeref:struct:sw_flow::sw_flow_mask
mask	.\datapath\flow.h	/^	struct sw_flow_mask *mask;$/;"	m	struct:sw_flow_match	typeref:struct:sw_flow_match::sw_flow_mask
mask	.\include\openflow\nicira-ext.h	/^    ovs_be64 mask;                  \/* Metadata mask. *\/$/;"	m	struct:nx_action_write_metadata
mask	.\include\openflow\openflow-1.0.h	/^    ovs_be32 mask;          \/* Bitmap of OFPPC_* flags to be changed. *\/$/;"	m	struct:ofp10_port_mod
mask	.\include\openflow\openflow-1.1.h	/^    ovs_be32 mask;          \/* Bitmap of OFPPC_* flags to be changed. *\/$/;"	m	struct:ofp11_port_mod
mask	.\include\openflow\openflow-1.4.h	/^    ovs_be32    mask;   \/* Bitmasks of reason values. *\/$/;"	m	struct:ofp14_async_config_prop_reasons
mask	.\include\openflow\openflow-1.4.h	/^    ovs_be32 mask;          \/* Bitmap of OFPPC_* flags to be changed. *\/$/;"	m	struct:ofp14_port_mod
mask	.\lib\classifier.c	/^    struct minimask mask;       \/* Wildcards for fields. *\/$/;"	m	struct:cls_subtable	typeref:struct:cls_subtable::minimask	file:
mask	.\lib\dpif-linux.c	/^    const struct nlattr *mask;          \/* OVS_FLOW_ATTR_MASK. *\/$/;"	m	struct:dpif_linux_flow	typeref:struct:dpif_linux_flow::nlattr	file:
mask	.\lib\dpif.h	/^    const struct nlattr *mask;      \/* Mask to put. *\/$/;"	m	struct:dpif_flow_put	typeref:struct:dpif_flow_put::nlattr
mask	.\lib\hindex.h	/^    size_t mask;      \/* 0 or more lowest-order bits set, others cleared. *\/$/;"	m	struct:hindex
mask	.\lib\hmap.h	/^    size_t mask;$/;"	m	struct:hmap
mask	.\lib\match.h	/^    struct minimask mask;$/;"	m	struct:minimatch	typeref:struct:minimatch::minimask
mask	.\lib\meta-flow.c	/^    uint8_t mask;$/;"	m	struct:frag_handling	file:
mask	.\lib\ofp-actions.h	/^    ovs_be64 mask;$/;"	m	struct:ofpact_metadata
mask	.\lib\ofp-util.h	/^    enum ofputil_port_config mask;$/;"	m	struct:ofputil_port_mod	typeref:enum:ofputil_port_mod::ofputil_port_config
mask	.\lib\ofp-util.h	/^    uint64_t mask;              \/* Subset of 'match' that may have masks. *\/$/;"	m	struct:ofputil_table_features
mask_alloc	.\datapath\flow_table.c	/^static struct sw_flow_mask *mask_alloc(void)$/;"	f	file:
mask_allowed_ofp_versions	.\lib\ofp-version-opt.c	/^mask_allowed_ofp_versions(uint32_t bitmap)$/;"	f
mask_array	.\datapath\flow_table.h	/^	struct mask_array __rcu *mask_array;$/;"	m	struct:flow_table	typeref:struct:flow_table::__rcu
mask_array	.\datapath\flow_table.h	/^struct mask_array {$/;"	s
mask_array_rcu_cb	.\datapath\flow_table.c	/^static void mask_array_rcu_cb(struct rcu_head *rcu)$/;"	f	file:
mask_buf	.\ofproto\ofproto-dpif-upcall.c	/^    struct odputil_keybuf mask_buf;$/;"	m	struct:flow_miss	typeref:struct:flow_miss::odputil_keybuf	file:
mask_cache	.\datapath\flow_table.h	/^	struct mask_cache_entry __percpu *mask_cache;$/;"	m	struct:flow_table	typeref:struct:flow_table::__percpu
mask_cache_entry	.\datapath\flow_table.h	/^struct mask_cache_entry {$/;"	s
mask_equal	.\datapath\flow_table.c	/^static bool mask_equal(const struct sw_flow_mask *a,$/;"	f	file:
mask_index	.\datapath\flow_table.h	/^	u32 mask_index;$/;"	m	struct:mask_cache_entry
mask_len	.\lib\dpif-linux.c	/^    size_t mask_len;$/;"	m	struct:dpif_linux_flow	file:
mask_len	.\lib\dpif.h	/^    size_t mask_len;                \/* Length of 'mask' in bytes. *\/$/;"	m	struct:dpif_flow_put
mask_prefix_bits_set	.\lib\classifier.c	/^mask_prefix_bits_set(const struct flow_wildcards *wc, uint8_t be32ofs,$/;"	f	file:
mask_set_prefix_bits	.\lib\classifier.c	/^mask_set_prefix_bits(struct flow_wildcards *wc, uint8_t be32ofs,$/;"	f	file:
mask_str	.\tests\test-bundle.c	/^mask_str(uint8_t mask, size_t n_bits)$/;"	f	file:
maskable	.\lib\meta-flow.h	/^    enum mf_maskable maskable;$/;"	m	struct:mf_field	typeref:enum:mf_field::mf_maskable
maskbits	.\lib\classifier.c	/^    unsigned int maskbits;   \/* Prefix length needed to avoid false matches. *\/$/;"	m	struct:trie_ctx	file:
maskbuf	.\lib\dpif-netdev.c	/^    struct odputil_keybuf maskbuf;$/;"	m	struct:dp_netdev_flow_state	typeref:struct:dp_netdev_flow_state::odputil_keybuf	file:
masked_flow_lookup	.\datapath\flow_table.c	/^static struct sw_flow *masked_flow_lookup(struct table_instance *ti,$/;"	f	file:
masks	.\datapath\flow_table.h	/^	struct sw_flow_mask __rcu *masks[];$/;"	m	struct:mask_array	typeref:struct:mask_array::__rcu
master_async_config	.\ofproto\connmgr.c	/^    uint32_t master_async_config[OAM_N_TYPES]; \/* master, other *\/$/;"	m	struct:ofconn	file:
master_election_id	.\ofproto\connmgr.c	/^    uint64_t master_election_id; \/* monotonically increasing sequence number$/;"	m	struct:connmgr	file:
master_election_id_defined	.\ofproto\connmgr.c	/^    bool master_election_id_defined;$/;"	m	struct:connmgr	file:
master_ifindex	.\lib\rtbsd.h	/^    int master_ifindex;         \/* Ifindex of datapath master (0 if none). *\/$/;"	m	struct:rtbsd_change
master_ifindex	.\lib\rtnetlink-link.h	/^    int master_ifindex;         \/* Ifindex of datapath master (0 if none). *\/$/;"	m	struct:rtnetlink_link_change
match	.\include\openflow\openflow-1.0.h	/^    struct ofp10_match match;    \/* Fields to match *\/$/;"	m	struct:ofp10_flow_mod	typeref:struct:ofp10_flow_mod::ofp10_match
match	.\include\openflow\openflow-1.0.h	/^    struct ofp10_match match; \/* Description of fields. *\/$/;"	m	struct:ofp10_flow_removed	typeref:struct:ofp10_flow_removed::ofp10_match
match	.\include\openflow\openflow-1.0.h	/^    struct ofp10_match match; \/* Description of fields. *\/$/;"	m	struct:ofp10_flow_stats	typeref:struct:ofp10_flow_stats::ofp10_match
match	.\include\openflow\openflow-1.0.h	/^    struct ofp10_match match; \/* Fields to match. *\/$/;"	m	struct:ofp10_flow_stats_request	typeref:struct:ofp10_flow_stats_request::ofp10_match
match	.\include\openflow\openflow-1.1.h	/^    ovs_be32 match;          \/* Bitmap of OFPFMF_* that indicate the fields$/;"	m	struct:ofp11_table_stats
match	.\include\openflow\openflow-1.2.h	/^    ovs_be64 match;          \/* Bitmap of (1 << OFPXMT_*) that indicate the$/;"	m	struct:ofp12_table_stats
match	.\lib\classifier.h	/^    struct minimatch match;      \/* Matching rule. *\/$/;"	m	struct:cls_rule	typeref:struct:cls_rule::minimatch
match	.\lib\match.h	/^struct match {$/;"	s
match	.\lib\ofp-util.h	/^    struct match *match;$/;"	m	struct:ofputil_flow_update	typeref:struct:ofputil_flow_update::match
match	.\lib\ofp-util.h	/^    struct match match;$/;"	m	struct:ofputil_flow_mod	typeref:struct:ofputil_flow_mod::match
match	.\lib\ofp-util.h	/^    struct match match;$/;"	m	struct:ofputil_flow_monitor_request	typeref:struct:ofputil_flow_monitor_request::match
match	.\lib\ofp-util.h	/^    struct match match;$/;"	m	struct:ofputil_flow_removed	typeref:struct:ofputil_flow_removed::match
match	.\lib\ofp-util.h	/^    struct match match;$/;"	m	struct:ofputil_flow_stats	typeref:struct:ofputil_flow_stats::match
match	.\lib\ofp-util.h	/^    struct match match;$/;"	m	struct:ofputil_flow_stats_request	typeref:struct:ofputil_flow_stats_request::match
match	.\lib\ofp-util.h	/^    uint64_t match;             \/* Fields that may be matched. *\/$/;"	m	struct:ofputil_table_features
match	.\ofproto\bond.c	/^    struct match match;$/;"	m	struct:bond_pr_rule_op	typeref:struct:bond_pr_rule_op::match	file:
match	.\ofproto\connmgr.h	/^    struct minimatch match;$/;"	m	struct:ofmonitor	typeref:struct:ofmonitor::minimatch
match	.\ofproto\in-band.c	/^    struct match match;$/;"	m	struct:in_band_rule	typeref:struct:in_band_rule::match	file:
match	.\ofproto\tunnel.c	/^    struct tnl_match match;$/;"	m	struct:tnl_port	typeref:struct:tnl_port::tnl_match	file:
match	.\tests\test-classifier.c	/^match(const struct cls_rule *wild_, const struct flow *fixed)$/;"	f	file:
match	.\tests\test-stp.c	/^match(const char *want)$/;"	f	file:
match_equal	.\lib\match.c	/^match_equal(const struct match *a, const struct match *b)$/;"	f
match_format	.\lib\match.c	/^match_format(const struct match *match, struct ds *s, unsigned int priority)$/;"	f
match_has_default_dp_hash	.\lib\match.c	/^match_has_default_dp_hash(const struct match *m)$/;"	f	file:
match_has_default_hidden_fields	.\lib\match.c	/^match_has_default_hidden_fields(const struct match *m)$/;"	f
match_has_default_recirc_id	.\lib\match.c	/^match_has_default_recirc_id(const struct match *m)$/;"	f	file:
match_hash	.\lib\match.c	/^match_hash(const struct match *match, uint32_t basis)$/;"	f
match_init	.\lib\match.c	/^match_init(struct match *match,$/;"	f
match_init_catchall	.\lib\match.c	/^match_init_catchall(struct match *match)$/;"	f
match_init_hidden_fields	.\lib\match.c	/^match_init_hidden_fields(struct match *m)$/;"	f
match_len	.\include\openflow\nicira-ext.h	/^    ovs_be16 match_len;           \/* Size of nx_match. *\/$/;"	m	struct:nx_flow_mod
match_len	.\include\openflow\nicira-ext.h	/^    ovs_be16 match_len;         \/* Length of nx_match. *\/$/;"	m	struct:nx_flow_monitor_request
match_len	.\include\openflow\nicira-ext.h	/^    ovs_be16 match_len;         \/* Length of nx_match. *\/$/;"	m	struct:nx_flow_update_full
match_len	.\include\openflow\nicira-ext.h	/^    ovs_be16 match_len;       \/* Length of nx_match. *\/$/;"	m	struct:nx_aggregate_stats_request
match_len	.\include\openflow\nicira-ext.h	/^    ovs_be16 match_len;       \/* Length of nx_match. *\/$/;"	m	struct:nx_flow_stats
match_len	.\include\openflow\nicira-ext.h	/^    ovs_be16 match_len;       \/* Length of nx_match. *\/$/;"	m	struct:nx_flow_stats_request
match_len	.\include\openflow\nicira-ext.h	/^    ovs_be16 match_len;       \/* Size of nx_match. *\/$/;"	m	struct:nx_flow_removed
match_len	.\include\openflow\nicira-ext.h	/^    ovs_be16 match_len;       \/* Size of nx_match. *\/$/;"	m	struct:nx_packet_in
match_node	.\ofproto\tunnel.c	/^    struct hmap_node match_node;$/;"	m	struct:tnl_port	typeref:struct:tnl_port::hmap_node	file:
match_plen	.\lib\classifier.c	/^    unsigned int match_plen; \/* Longest prefix than could possibly match. *\/$/;"	m	struct:trie_ctx	file:
match_print	.\lib\match.c	/^match_print(const struct match *match)$/;"	f
match_set_any_mpls_bos	.\lib\match.c	/^match_set_any_mpls_bos(struct match *match, int idx)$/;"	f
match_set_any_mpls_label	.\lib\match.c	/^match_set_any_mpls_label(struct match *match, int idx)$/;"	f
match_set_any_mpls_lse	.\lib\match.c	/^match_set_any_mpls_lse(struct match *match, int idx)$/;"	f
match_set_any_mpls_tc	.\lib\match.c	/^match_set_any_mpls_tc(struct match *match, int idx)$/;"	f
match_set_any_pcp	.\lib\match.c	/^match_set_any_pcp(struct match *match)$/;"	f
match_set_any_vid	.\lib\match.c	/^match_set_any_vid(struct match *match)$/;"	f
match_set_arp_sha	.\lib\match.c	/^match_set_arp_sha(struct match *match, const uint8_t sha[ETH_ADDR_LEN])$/;"	f
match_set_arp_sha_masked	.\lib\match.c	/^match_set_arp_sha_masked(struct match *match,$/;"	f
match_set_arp_tha	.\lib\match.c	/^match_set_arp_tha(struct match *match, const uint8_t tha[ETH_ADDR_LEN])$/;"	f
match_set_arp_tha_masked	.\lib\match.c	/^match_set_arp_tha_masked(struct match *match,$/;"	f
match_set_dl_dst	.\lib\match.c	/^match_set_dl_dst(struct match *match, const uint8_t dl_dst[ETH_ADDR_LEN])$/;"	f
match_set_dl_dst_masked	.\lib\match.c	/^match_set_dl_dst_masked(struct match *match,$/;"	f
match_set_dl_src	.\lib\match.c	/^match_set_dl_src(struct match *match, const uint8_t dl_src[ETH_ADDR_LEN])$/;"	f
match_set_dl_src_masked	.\lib\match.c	/^match_set_dl_src_masked(struct match *match,$/;"	f
match_set_dl_tci	.\lib\match.c	/^match_set_dl_tci(struct match *match, ovs_be16 tci)$/;"	f
match_set_dl_tci_masked	.\lib\match.c	/^match_set_dl_tci_masked(struct match *match, ovs_be16 tci, ovs_be16 mask)$/;"	f
match_set_dl_type	.\lib\match.c	/^match_set_dl_type(struct match *match, ovs_be16 dl_type)$/;"	f
match_set_dl_vlan	.\lib\match.c	/^match_set_dl_vlan(struct match *match, ovs_be16 dl_vlan)$/;"	f
match_set_dl_vlan_pcp	.\lib\match.c	/^match_set_dl_vlan_pcp(struct match *match, uint8_t dl_vlan_pcp)$/;"	f
match_set_dp_hash	.\lib\match.c	/^match_set_dp_hash(struct match *match, uint32_t value)$/;"	f
match_set_dp_hash_masked	.\lib\match.c	/^match_set_dp_hash_masked(struct match *match, uint32_t value, uint32_t mask)$/;"	f
match_set_icmp_code	.\lib\match.c	/^match_set_icmp_code(struct match *match, uint8_t icmp_code)$/;"	f
match_set_icmp_type	.\lib\match.c	/^match_set_icmp_type(struct match *match, uint8_t icmp_type)$/;"	f
match_set_in_port	.\lib\match.c	/^match_set_in_port(struct match *match, ofp_port_t ofp_port)$/;"	f
match_set_ipv6_dst	.\lib\match.c	/^match_set_ipv6_dst(struct match *match, const struct in6_addr *dst)$/;"	f
match_set_ipv6_dst_masked	.\lib\match.c	/^match_set_ipv6_dst_masked(struct match *match, const struct in6_addr *dst,$/;"	f
match_set_ipv6_label	.\lib\match.c	/^match_set_ipv6_label(struct match *match, ovs_be32 ipv6_label)$/;"	f
match_set_ipv6_label_masked	.\lib\match.c	/^match_set_ipv6_label_masked(struct match *match, ovs_be32 ipv6_label,$/;"	f
match_set_ipv6_src	.\lib\match.c	/^match_set_ipv6_src(struct match *match, const struct in6_addr *src)$/;"	f
match_set_ipv6_src_masked	.\lib\match.c	/^match_set_ipv6_src_masked(struct match *match, const struct in6_addr *src,$/;"	f
match_set_metadata	.\lib\match.c	/^match_set_metadata(struct match *match, ovs_be64 metadata)$/;"	f
match_set_metadata_masked	.\lib\match.c	/^match_set_metadata_masked(struct match *match,$/;"	f
match_set_mpls_bos	.\lib\match.c	/^match_set_mpls_bos(struct match *match, int idx, uint8_t mpls_bos)$/;"	f
match_set_mpls_label	.\lib\match.c	/^match_set_mpls_label(struct match *match, int idx, ovs_be32 mpls_label)$/;"	f
match_set_mpls_lse	.\lib\match.c	/^match_set_mpls_lse(struct match *match, int idx, ovs_be32 lse)$/;"	f
match_set_mpls_tc	.\lib\match.c	/^match_set_mpls_tc(struct match *match, int idx, uint8_t mpls_tc)$/;"	f
match_set_nd_target	.\lib\match.c	/^match_set_nd_target(struct match *match, const struct in6_addr *target)$/;"	f
match_set_nd_target_masked	.\lib\match.c	/^match_set_nd_target_masked(struct match *match,$/;"	f
match_set_nw_dscp	.\lib\match.c	/^match_set_nw_dscp(struct match *match, uint8_t nw_dscp)$/;"	f
match_set_nw_dst	.\lib\match.c	/^match_set_nw_dst(struct match *match, ovs_be32 nw_dst)$/;"	f
match_set_nw_dst_masked	.\lib\match.c	/^match_set_nw_dst_masked(struct match *match, ovs_be32 ip, ovs_be32 mask)$/;"	f
match_set_nw_ecn	.\lib\match.c	/^match_set_nw_ecn(struct match *match, uint8_t nw_ecn)$/;"	f
match_set_nw_frag	.\lib\match.c	/^match_set_nw_frag(struct match *match, uint8_t nw_frag)$/;"	f
match_set_nw_frag_masked	.\lib\match.c	/^match_set_nw_frag_masked(struct match *match,$/;"	f
match_set_nw_proto	.\lib\match.c	/^match_set_nw_proto(struct match *match, uint8_t nw_proto)$/;"	f
match_set_nw_src	.\lib\match.c	/^match_set_nw_src(struct match *match, ovs_be32 nw_src)$/;"	f
match_set_nw_src_masked	.\lib\match.c	/^match_set_nw_src_masked(struct match *match,$/;"	f
match_set_nw_ttl	.\lib\match.c	/^match_set_nw_ttl(struct match *match, uint8_t nw_ttl)$/;"	f
match_set_pkt_mark	.\lib\match.c	/^match_set_pkt_mark(struct match *match, uint32_t pkt_mark)$/;"	f
match_set_pkt_mark_masked	.\lib\match.c	/^match_set_pkt_mark_masked(struct match *match, uint32_t pkt_mark, uint32_t mask)$/;"	f
match_set_recirc_id	.\lib\match.c	/^match_set_recirc_id(struct match *match, uint32_t value)$/;"	f
match_set_reg	.\lib\match.c	/^match_set_reg(struct match *match, unsigned int reg_idx, uint32_t value)$/;"	f
match_set_reg_masked	.\lib\match.c	/^match_set_reg_masked(struct match *match, unsigned int reg_idx,$/;"	f
match_set_skb_priority	.\lib\match.c	/^match_set_skb_priority(struct match *match, uint32_t skb_priority)$/;"	f
match_set_tcp_flags	.\lib\match.c	/^match_set_tcp_flags(struct match *match, ovs_be16 flags)$/;"	f
match_set_tcp_flags_masked	.\lib\match.c	/^match_set_tcp_flags_masked(struct match *match, ovs_be16 flags, ovs_be16 mask)$/;"	f
match_set_tp_dst	.\lib\match.c	/^match_set_tp_dst(struct match *match, ovs_be16 tp_dst)$/;"	f
match_set_tp_dst_masked	.\lib\match.c	/^match_set_tp_dst_masked(struct match *match, ovs_be16 port, ovs_be16 mask)$/;"	f
match_set_tp_src	.\lib\match.c	/^match_set_tp_src(struct match *match, ovs_be16 tp_src)$/;"	f
match_set_tp_src_masked	.\lib\match.c	/^match_set_tp_src_masked(struct match *match, ovs_be16 port, ovs_be16 mask)$/;"	f
match_set_tun_dst	.\lib\match.c	/^match_set_tun_dst(struct match *match, ovs_be32 dst)$/;"	f
match_set_tun_dst_masked	.\lib\match.c	/^match_set_tun_dst_masked(struct match *match, ovs_be32 dst, ovs_be32 mask)$/;"	f
match_set_tun_flags	.\lib\match.c	/^match_set_tun_flags(struct match *match, uint16_t flags)$/;"	f
match_set_tun_flags_masked	.\lib\match.c	/^match_set_tun_flags_masked(struct match *match, uint16_t flags, uint16_t mask)$/;"	f
match_set_tun_id	.\lib\match.c	/^match_set_tun_id(struct match *match, ovs_be64 tun_id)$/;"	f
match_set_tun_id_masked	.\lib\match.c	/^match_set_tun_id_masked(struct match *match, ovs_be64 tun_id, ovs_be64 mask)$/;"	f
match_set_tun_src	.\lib\match.c	/^match_set_tun_src(struct match *match, ovs_be32 src)$/;"	f
match_set_tun_src_masked	.\lib\match.c	/^match_set_tun_src_masked(struct match *match, ovs_be32 src, ovs_be32 mask)$/;"	f
match_set_tun_tos	.\lib\match.c	/^match_set_tun_tos(struct match *match, uint8_t tos)$/;"	f
match_set_tun_tos_masked	.\lib\match.c	/^match_set_tun_tos_masked(struct match *match, uint8_t tos, uint8_t mask)$/;"	f
match_set_tun_ttl	.\lib\match.c	/^match_set_tun_ttl(struct match *match, uint8_t ttl)$/;"	f
match_set_tun_ttl_masked	.\lib\match.c	/^match_set_tun_ttl_masked(struct match *match, uint8_t ttl, uint8_t mask)$/;"	f
match_set_vlan_vid	.\lib\match.c	/^match_set_vlan_vid(struct match *match, ovs_be16 vid)$/;"	f
match_set_vlan_vid_masked	.\lib\match.c	/^match_set_vlan_vid_masked(struct match *match, ovs_be16 vid, ovs_be16 mask)$/;"	f
match_to_string	.\lib\match.c	/^match_to_string(const struct match *match, unsigned int priority)$/;"	f
match_validate	.\datapath\flow_netlink.c	/^static bool match_validate(const struct sw_flow_match *match,$/;"	f	file:
match_wc_init	.\lib\match.c	/^match_wc_init(struct match *match, const struct flow *flow)$/;"	f
match_zero_wildcarded_fields	.\lib\match.c	/^match_zero_wildcarded_fields(struct match *match)$/;"	f
matched_count	.\include\openflow\openflow-1.0.h	/^    ovs_32aligned_be64 matched_count; \/* Number of packets that hit table. *\/$/;"	m	struct:ofp10_table_stats
matched_count	.\include\openflow\openflow-1.1.h	/^    ovs_be64 matched_count;  \/* Number of packets that hit table. *\/$/;"	m	struct:ofp11_table_stats
matched_count	.\include\openflow\openflow-1.2.h	/^    ovs_be64 matched_count;  \/* Number of packets that hit table. *\/$/;"	m	struct:ofp12_table_stats
matched_count	.\include\openflow\openflow-1.3.h	/^    ovs_be64 matched_count; \/* Number of packets that hit table. *\/$/;"	m	struct:ofp13_action_self_learning::ofp13_table_stats
math	.\python\ovstest\tests.py	/^import math$/;"	i
max	.\datapath\flow_table.h	/^	int count, max;$/;"	m	struct:mask_array
max	.\lib\ovsdb-types.h	/^            double max;         \/* minReal or DBL_MAX. *\/$/;"	m	struct:ovsdb_base_type::__anon86::ovsdb_real_constraints
max	.\lib\ovsdb-types.h	/^            int64_t max;        \/* maxInteger or INT64_MAX. *\/$/;"	m	struct:ovsdb_base_type::__anon86::ovsdb_integer_constraints
maxLen	.\lib\ovsdb-types.h	/^            unsigned int maxLen; \/* maxLength or UINT_MAX. *\/$/;"	m	struct:ovsdb_base_type::__anon86::ovsdb_string_constraints
max_age	.\lib\stp.c	/^    int max_age;                    \/* 8.5.3.4: Time to drop received data. *\/$/;"	m	struct:stp	file:
max_age	.\ofproto\ofproto.h	/^    uint16_t max_age;$/;"	m	struct:ofproto_stp_settings
max_args	.\lib\command-line.h	/^    int max_args;$/;"	m	struct:command
max_args	.\lib\unixctl.c	/^    int min_args, max_args;$/;"	m	struct:unixctl_command	file:
max_args	.\ovsdb\ovsdb-client.c	/^    int max_args;$/;"	m	struct:ovsdb_client_command	file:
max_args	.\utilities\ovs-vsctl.c	/^    int max_args;               \/* Max number of arguments following name. *\/$/;"	m	struct:vsctl_command_syntax	file:
max_args	.\vtep\vtep-ctl.c	/^    int max_args;               \/* Max number of arguments following name. *\/$/;"	m	struct:vtep_ctl_command_syntax	file:
max_attr_len	.\lib\netlink.c	/^max_attr_len(enum nl_attr_type type)$/;"	f	file:
max_backoff	.\lib\rconn.c	/^    int max_backoff;$/;"	m	struct:rconn	file:
max_backoff	.\lib\reconnect.c	/^    int max_backoff;$/;"	m	struct:reconnect	file:
max_backoff	.\lib\vswitch-idl.h	/^	int64_t *max_backoff;$/;"	m	struct:ovsrec_controller
max_backoff	.\lib\vswitch-idl.h	/^	int64_t *max_backoff;$/;"	m	struct:ovsrec_manager
max_backoff	.\lib\vtep-idl.h	/^	int64_t *max_backoff;$/;"	m	struct:vteprec_manager
max_backoff	.\ofproto\ofproto.h	/^    int max_backoff;            \/* Maximum reconnection backoff, in seconds. *\/$/;"	m	struct:ofproto_controller
max_backoff	.\ovsdb\jsonrpc-server.h	/^    int max_backoff;            \/* Maximum reconnection backoff, in msec. *\/$/;"	m	struct:ovsdb_jsonrpc_options
max_bands	.\include\openflow\openflow-1.3.h	/^    uint8_t    max_bands;     \/* Maximum bands per meters *\/$/;"	m	struct:ofp13_action_self_learning::ofp13_meter_features
max_bands	.\lib\ofp-util.h	/^    uint8_t  max_bands;$/;"	m	struct:ofputil_meter_features
max_color	.\include\openflow\openflow-1.3.h	/^    uint8_t    max_color;     \/* Maximum color value *\/$/;"	m	struct:ofp13_action_self_learning::ofp13_meter_features
max_color	.\lib\ofp-util.h	/^    uint8_t  max_color;$/;"	m	struct:ofputil_meter_features
max_count	.\lib\classifier.c	/^    unsigned int max_count;     \/* Count of max_priority rules. *\/$/;"	m	struct:cls_subtable	file:
max_entries	.\include\openflow\openflow-1.0.h	/^    ovs_be32 max_entries;    \/* Max number of entries supported. *\/$/;"	m	struct:ofp10_table_stats
max_entries	.\include\openflow\openflow-1.1.h	/^    ovs_be32 max_entries;    \/* Max number of entries supported. *\/$/;"	m	struct:ofp11_table_stats
max_entries	.\include\openflow\openflow-1.2.h	/^    ovs_be32 max_entries;    \/* Max number of entries supported. *\/$/;"	m	struct:ofp12_table_stats
max_entries	.\include\openflow\openflow-1.3.h	/^    ovs_be32 max_entries;     \/* Max number of entries supported. *\/$/;"	m	struct:ofp13_action_self_learning::ofp13_table_features
max_entries	.\lib\mac-learning.h	/^    size_t max_entries;         \/* Max number of learned MACs. *\/$/;"	m	struct:mac_learning
max_entries	.\lib\ofp-util.h	/^    uint32_t max_entries;     \/* Max number of entries supported. *\/$/;"	m	struct:ofputil_table_features
max_flows	.\ofproto\ofproto-provider.h	/^    unsigned int max_flows;$/;"	m	struct:oftable
max_flows	.\ofproto\ofproto.h	/^    unsigned int max_flows;     \/* Maximum number of flows or UINT_MAX. *\/$/;"	m	struct:ofproto_table_settings
max_groups	.\include\openflow\openflow-1.2.h	/^    ovs_be32  max_groups[4];   \/* Maximum number of groups for each type. *\/$/;"	m	struct:ofp12_group_features_stats
max_groups	.\lib\ofp-util.h	/^    uint32_t  max_groups[4];   \/* Maximum number of groups for each type. *\/$/;"	m	struct:ofputil_group_features
max_idle	.\lib\learning-switch.c	/^    int max_idle;$/;"	m	struct:lswitch	file:
max_idle	.\lib\learning-switch.h	/^    int max_idle;$/;"	m	struct:lswitch_config
max_idle	.\tests\test-controller.c	/^static int max_idle = 60;$/;"	v	file:
max_iovs	.\lib\netlink-socket.c	/^static int max_iovs;$/;"	v	file:
max_len	.\include\openflow\nicira-ext.h	/^    ovs_be16 max_len;               \/* Maximum length to send to controller. *\/$/;"	m	struct:nx_action_controller
max_len	.\include\openflow\nicira-ext.h	/^    ovs_be16 max_len;           \/* Max length to send to controller. *\/$/;"	m	struct:nx_action_output_reg
max_len	.\include\openflow\openflow-1.0.h	/^    ovs_be16 max_len;               \/* Max length to send to controller. *\/$/;"	m	struct:ofp10_action_output
max_len	.\include\openflow\openflow-1.1.h	/^    ovs_be16 max_len;                 \/* Max length to send to controller. *\/$/;"	m	struct:ofp11_action_output
max_len	.\lib\netlink.h	/^    size_t min_len, max_len;$/;"	m	struct:nl_policy
max_len	.\lib\ofp-actions.h	/^    uint16_t max_len;           \/* Max send len, for port OFPP_CONTROLLER. *\/$/;"	m	struct:ofpact_output
max_len	.\lib\ofp-actions.h	/^    uint16_t max_len;           \/* Maximum length to send to controller. *\/$/;"	m	struct:ofpact_controller
max_len	.\lib\ofp-actions.h	/^    uint16_t max_len;$/;"	m	struct:ofpact_output_reg
max_link	.\include\openflow\nicira-ext.h	/^    ovs_be16 max_link;          \/* Number of output links, minus 1. *\/$/;"	m	struct:nx_action_multipath
max_link	.\lib\ofp-actions.h	/^    uint16_t max_link;          \/* Number of output links, minus 1. *\/$/;"	m	struct:ofpact_multipath
max_meter	.\include\openflow\openflow-1.3.h	/^    ovs_be32   max_meter;     \/* Maximum number of meters. *\/$/;"	m	struct:ofp13_action_self_learning::ofp13_meter_features
max_meters	.\lib\ofp-util.h	/^    uint32_t max_meters;        \/* Maximum number of meters. *\/$/;"	m	struct:ofputil_meter_features
max_mpls_depth	.\ofproto\ofproto-dpif-xlate.c	/^    size_t max_mpls_depth;$/;"	m	struct:xbridge	file:
max_mpls_depth	.\ofproto\ofproto-dpif.c	/^    size_t max_mpls_depth;$/;"	m	struct:dpif_backer	file:
max_n_flows	.\ofproto\ofproto-dpif-upcall.c	/^    unsigned int max_n_flows;$/;"	m	struct:udpif	file:
max_packet_len	.\lib\netdev-dpdk.c	/^    int max_packet_len;$/;"	m	struct:netdev_dpdk	file:
max_ports	.\ofproto\ofproto-provider.h	/^    uint16_t max_ports;         \/* Max possible OpenFlow port num, plus one. *\/$/;"	m	struct:ofproto
max_priority	.\lib\classifier.c	/^    unsigned int max_priority;  \/* Max priority of any rule in the subtable. *\/$/;"	m	struct:cls_subtable	file:
max_priority	.\lib\classifier.c	/^    unsigned int max_priority;$/;"	m	struct:cls_subtable_entry	file:
max_rate	.\lib\netdev-linux.c	/^    uint32_t max_rate;$/;"	m	struct:hfsc	file:
max_rate	.\lib\netdev-linux.c	/^    uint32_t max_rate;$/;"	m	struct:hfsc_class	file:
max_rate	.\lib\netdev-linux.c	/^    unsigned int max_rate;      \/* In bytes\/s. *\/$/;"	m	struct:htb	file:
max_rate	.\lib\netdev-linux.c	/^    unsigned int max_rate;      \/* In bytes\/s. *\/$/;"	m	struct:htb_class	file:
max_rate	.\lib\ofp-util.h	/^    uint16_t max_rate;$/;"	m	struct:ofputil_queue_config
max_rate	.\utilities\ovs-benchmark.c	/^static double max_rate;$/;"	v	file:
max_rows	.\ovsdb\table.h	/^    unsigned int max_rows;      \/* Maximum number of rows. *\/$/;"	m	struct:ovsdb_table_schema
max_sessions	.\ovsdb\jsonrpc-server.c	/^    unsigned int n_sessions, max_sessions;$/;"	m	struct:ovsdb_jsonrpc_server	file:
max_speed	.\include\openflow\openflow-1.1.h	/^    ovs_be32 max_speed;     \/* Max port bitrate in kbps *\/$/;"	m	struct:ofp11_port
max_speed	.\include\openflow\openflow-1.4.h	/^    ovs_be32 max_speed;     \/* Max port bitrate in kbps *\/$/;"	m	struct:ofp14_port_desc_prop_ethernet
max_speed	.\lib\ofp-util.h	/^    uint32_t max_speed;         \/* Maximum supported speed, in kbps. *\/$/;"	m	struct:ofputil_phy_port
max_tries	.\lib\reconnect.c	/^    unsigned int max_tries;$/;"	m	struct:reconnect	file:
max_version	.\lib\ofp-msgs.c	/^    uint8_t max_version;$/;"	m	struct:raw_info	file:
max_version	.\lib\ofp-util.c	/^    enum ofp_version min_version, max_version;$/;"	m	struct:ofputil_flow_mod_flag	typeref:enum:ofputil_flow_mod_flag::	file:
maxattr	.\datapath\linux\compat\include\net\genetlink.h	/^	unsigned int            maxattr;$/;"	m	struct:rpl_genl_family
maximum_ip_total_length	.\ofproto\ofproto-dpif-ipfix.c	/^    uint16_t maximum_ip_total_length;  \/* 0 if not IP. *\/$/;"	m	struct:ipfix_flow_cache_entry	file:
may_add_arc	.\lib\ovsdb-idl.c	/^may_add_arc(const struct ovsdb_idl_row *src, const struct ovsdb_idl_row *dst)$/;"	f	file:
may_create	.\utilities\ovs-dpctl.c	/^static bool may_create;$/;"	v	file:
may_enable	.\ofproto\bond.c	/^    bool may_enable;            \/* Client considers this slave bondable. *\/$/;"	m	struct:bond_slave	file:
may_enable	.\ofproto\ofproto-dpif-xlate.c	/^    bool may_enable;                 \/* May be enabled in bonds. *\/$/;"	m	struct:xport	file:
may_enable	.\ofproto\ofproto-dpif.c	/^    bool may_enable;            \/* May be enabled in bonds. *\/$/;"	m	struct:ofport_dpif	file:
may_fork	.\lib\ovs-thread.c	/^may_fork(void)$/;"	f
may_learn	.\ofproto\ofproto-dpif-xlate.h	/^    bool may_learn;$/;"	m	struct:xlate_in
may_receive	.\ofproto\ofproto-dpif-xlate.c	/^may_receive(const struct xport *xport, struct xlate_ctx *ctx)$/;"	f	file:
may_send_learning_packets	.\ofproto\bond.c	/^may_send_learning_packets(const struct bond *bond)$/;"	f	file:
maybe_byte_reverse	.\lib\sha1.c	/^maybe_byte_reverse(uint32_t *buffer OVS_UNUSED, int count OVS_UNUSED)$/;"	f	file:
maybe_unlink_and_free	.\lib\stream-fd-unix.c	/^maybe_unlink_and_free(char *path)$/;"	f	file:
mbridge	.\ofproto\ofproto-dpif-mirror.c	/^    struct mbridge *mbridge;    \/* Owning ofproto. *\/$/;"	m	struct:mirror	typeref:struct:mirror::mbridge	file:
mbridge	.\ofproto\ofproto-dpif-mirror.c	/^struct mbridge {$/;"	s	file:
mbridge	.\ofproto\ofproto-dpif-xlate.c	/^            struct mbridge *mbridge;$/;"	m	struct:xc_entry::__anon136::__anon139	typeref:struct:xc_entry::__anon136::__anon139::mbridge	file:
mbridge	.\ofproto\ofproto-dpif-xlate.c	/^    struct mbridge *mbridge;      \/* Mirroring. *\/$/;"	m	struct:xbridge	typeref:struct:xbridge::mbridge	file:
mbridge	.\ofproto\ofproto-dpif.c	/^    struct mbridge *mbridge;$/;"	m	struct:ofproto_dpif	typeref:struct:ofproto_dpif::mbridge	file:
mbridge_create	.\ofproto\ofproto-dpif-mirror.c	/^mbridge_create(void)$/;"	f
mbridge_has_mirrors	.\ofproto\ofproto-dpif-mirror.c	/^mbridge_has_mirrors(struct mbridge *mbridge)$/;"	f
mbridge_need_revalidate	.\ofproto\ofproto-dpif-mirror.c	/^mbridge_need_revalidate(struct mbridge *mbridge)$/;"	f
mbridge_ref	.\ofproto\ofproto-dpif-mirror.c	/^mbridge_ref(const struct mbridge *mbridge_)$/;"	f
mbridge_register_bundle	.\ofproto\ofproto-dpif-mirror.c	/^mbridge_register_bundle(struct mbridge *mbridge, struct ofbundle *ofbundle)$/;"	f
mbridge_unref	.\ofproto\ofproto-dpif-mirror.c	/^mbridge_unref(struct mbridge *mbridge)$/;"	f
mbridge_unregister_bundle	.\ofproto\ofproto-dpif-mirror.c	/^mbridge_unregister_bundle(struct mbridge *mbridge, struct ofbundle *ofbundle)$/;"	f
mbuf	.\lib\ofpbuf.h	/^    struct rte_mbuf mbuf;       \/* DPDK mbuf *\/$/;"	m	struct:ofpbuf	typeref:struct:ofpbuf::rte_mbuf
mbundle	.\ofproto\ofproto-dpif-mirror.c	/^struct mbundle {$/;"	s	file:
mbundle_lookup	.\ofproto\ofproto-dpif-mirror.c	/^mbundle_lookup(const struct mbridge *mbridge, struct ofbundle *ofbundle)$/;"	f	file:
mbundle_lookup_multiple	.\ofproto\ofproto-dpif-mirror.c	/^mbundle_lookup_multiple(const struct mbridge *mbridge,$/;"	f	file:
mbundles	.\ofproto\ofproto-dpif-mirror.c	/^    struct hmap mbundles;$/;"	m	struct:mbridge	typeref:struct:mbridge::hmap	file:
mcast_local	.\vtep\vtep-ctl.c	/^    struct shash mcast_local;   \/* Maps from mac to vtep_ctl_mcast_mac. *\/$/;"	m	struct:vtep_ctl_lswitch	typeref:struct:vtep_ctl_lswitch::shash	file:
mcast_remote	.\vtep\vtep-ctl.c	/^    struct shash mcast_remote;  \/* Maps from mac to vtep_ctl_mcast_mac. *\/$/;"	m	struct:vtep_ctl_lswitch	typeref:struct:vtep_ctl_lswitch::shash	file:
mcgrp_offset	.\datapath\linux\compat\include\net\genetlink.h	/^	unsigned int            mcgrp_offset;   \/* private *\/$/;"	m	struct:rpl_genl_family
mcgrps	.\datapath\linux\compat\include\net\genetlink.h	/^	const struct genl_multicast_group *mcgrps; \/* private *\/$/;"	m	struct:rpl_genl_family	typeref:struct:rpl_genl_family::genl_multicast_group
md	.\lib\dpif.h	/^    struct pkt_metadata md;         \/* Packet metadata. *\/$/;"	m	struct:dpif_execute	typeref:struct:dpif_execute::pkt_metadata
md5	.\python\compat\uuid.py	/^    import md5$/;"	i
meanSkipCount	.\tests\test-sflow.c	/^    uint32_t meanSkipCount;$/;"	m	struct:sflow_xdr	file:
megaflow_stats	.\lib\dpif-linux.c	/^    struct ovs_dp_megaflow_stats megaflow_stats;$/;"	m	struct:dpif_linux_dp	typeref:struct:dpif_linux_dp::ovs_dp_megaflow_stats	file:
member_name	.\lib\json.c	/^    char *member_name;$/;"	m	struct:json_parser	file:
memory	.\lib\memory.c	/^VLOG_DEFINE_THIS_MODULE(memory);$/;"	v
memory_init	.\lib\memory.c	/^memory_init(void)$/;"	f	file:
memory_order	.\lib\ovs-atomic-clang.h	/^} memory_order;$/;"	t	typeref:enum:__anon79
memory_order	.\lib\ovs-atomic-gcc4+.h	/^} memory_order;$/;"	t	typeref:enum:__anon81
memory_order	.\lib\ovs-atomic-gcc4.7+.h	/^} memory_order;$/;"	t	typeref:enum:__anon83
memory_order	.\lib\ovs-atomic-pthreads.h	/^} memory_order;$/;"	t	typeref:enum:__anon84
memory_order_acq_rel	.\lib\ovs-atomic-clang.h	/^    memory_order_acq_rel = 4,$/;"	e	enum:__anon79
memory_order_acq_rel	.\lib\ovs-atomic-gcc4+.h	/^    memory_order_acq_rel,$/;"	e	enum:__anon81
memory_order_acq_rel	.\lib\ovs-atomic-gcc4.7+.h	/^    memory_order_acq_rel = __ATOMIC_ACQ_REL,$/;"	e	enum:__anon83
memory_order_acq_rel	.\lib\ovs-atomic-pthreads.h	/^    memory_order_acq_rel,$/;"	e	enum:__anon84
memory_order_acquire	.\lib\ovs-atomic-clang.h	/^    memory_order_acquire = 2,$/;"	e	enum:__anon79
memory_order_acquire	.\lib\ovs-atomic-gcc4+.h	/^    memory_order_acquire,$/;"	e	enum:__anon81
memory_order_acquire	.\lib\ovs-atomic-gcc4.7+.h	/^    memory_order_acquire = __ATOMIC_ACQUIRE,$/;"	e	enum:__anon83
memory_order_acquire	.\lib\ovs-atomic-pthreads.h	/^    memory_order_acquire,$/;"	e	enum:__anon84
memory_order_consume	.\lib\ovs-atomic-clang.h	/^    memory_order_consume = 1,$/;"	e	enum:__anon79
memory_order_consume	.\lib\ovs-atomic-gcc4+.h	/^    memory_order_consume,$/;"	e	enum:__anon81
memory_order_consume	.\lib\ovs-atomic-gcc4.7+.h	/^    memory_order_consume = __ATOMIC_CONSUME,$/;"	e	enum:__anon83
memory_order_consume	.\lib\ovs-atomic-pthreads.h	/^    memory_order_consume,$/;"	e	enum:__anon84
memory_order_relaxed	.\lib\ovs-atomic-clang.h	/^    memory_order_relaxed = 0,$/;"	e	enum:__anon79
memory_order_relaxed	.\lib\ovs-atomic-gcc4+.h	/^    memory_order_relaxed,$/;"	e	enum:__anon81
memory_order_relaxed	.\lib\ovs-atomic-gcc4.7+.h	/^    memory_order_relaxed = __ATOMIC_RELAXED,$/;"	e	enum:__anon83
memory_order_relaxed	.\lib\ovs-atomic-pthreads.h	/^    memory_order_relaxed,$/;"	e	enum:__anon84
memory_order_release	.\lib\ovs-atomic-clang.h	/^    memory_order_release = 3,$/;"	e	enum:__anon79
memory_order_release	.\lib\ovs-atomic-gcc4+.h	/^    memory_order_release,$/;"	e	enum:__anon81
memory_order_release	.\lib\ovs-atomic-gcc4.7+.h	/^    memory_order_release = __ATOMIC_RELEASE,$/;"	e	enum:__anon83
memory_order_release	.\lib\ovs-atomic-pthreads.h	/^    memory_order_release,$/;"	e	enum:__anon84
memory_order_seq_cst	.\lib\ovs-atomic-clang.h	/^    memory_order_seq_cst = 5$/;"	e	enum:__anon79
memory_order_seq_cst	.\lib\ovs-atomic-gcc4+.h	/^    memory_order_seq_cst$/;"	e	enum:__anon81
memory_order_seq_cst	.\lib\ovs-atomic-gcc4.7+.h	/^    memory_order_seq_cst = __ATOMIC_SEQ_CST$/;"	e	enum:__anon83
memory_order_seq_cst	.\lib\ovs-atomic-pthreads.h	/^    memory_order_seq_cst$/;"	e	enum:__anon84
memory_report	.\lib\memory.c	/^memory_report(const struct simap *usage)$/;"	f
memory_run	.\lib\memory.c	/^memory_run(void)$/;"	f
memory_should_report	.\lib\memory.c	/^memory_should_report(void)$/;"	f
memory_unixctl_show	.\lib\memory.c	/^memory_unixctl_show(struct unixctl_conn *conn, int argc OVS_UNUSED,$/;"	f	file:
memory_wait	.\lib\memory.c	/^memory_wait(void)$/;"	f
message_age_timer	.\lib\stp.c	/^    struct stp_timer message_age_timer; \/* 8.5.6.1: Age of received info. *\/$/;"	m	struct:stp_port	typeref:struct:stp_port::stp_timer	file:
meta_flow	.\lib\meta-flow.c	/^VLOG_DEFINE_THIS_MODULE(meta_flow);$/;"	v
metadata	.\include\openflow\nicira-ext.h	/^    ovs_be64 metadata;              \/* Metadata register. *\/$/;"	m	struct:nx_action_write_metadata
metadata	.\include\openflow\openflow-1.1.h	/^    ovs_be64 metadata;          \/* Metadata value to write *\/$/;"	m	struct:ofp11_instruction_write_metadata
metadata	.\include\openflow\openflow-1.1.h	/^    ovs_be64 metadata;         \/* Metadata passed between tables. *\/$/;"	m	struct:ofp11_match
metadata	.\lib\classifier.c	/^    ovs_be64 metadata;          \/* metadata value for this partition. *\/$/;"	m	struct:cls_partition	file:
metadata	.\lib\flow.h	/^    ovs_be64 metadata;          \/* OpenFlow Metadata. *\/$/;"	m	struct:flow
metadata	.\lib\ofp-actions.h	/^    ovs_be64 metadata;$/;"	m	struct:ofpact_metadata
metadata_from_nlattrs	.\datapath\flow_netlink.c	/^static int metadata_from_nlattrs(struct sw_flow_match *match,  u64 *attrs,$/;"	f	file:
metadata_from_nxast	.\lib\ofp-actions.c	/^metadata_from_nxast(const struct nx_action_write_metadata *nawm,$/;"	f	file:
metadata_mask	.\include\openflow\openflow-1.1.h	/^    ovs_be64 metadata_mask;     \/* Metadata write bitmask *\/$/;"	m	struct:ofp11_instruction_write_metadata
metadata_mask	.\include\openflow\openflow-1.1.h	/^    ovs_be64 metadata_mask;    \/* Mask for metadata. *\/$/;"	m	struct:ofp11_match
metadata_match	.\include\openflow\openflow-1.2.h	/^    ovs_be64 metadata_match; \/* Bits of metadata table can match. *\/$/;"	m	struct:ofp12_table_stats
metadata_match	.\include\openflow\openflow-1.3.h	/^    ovs_be64 metadata_match;  \/* Bits of metadata table can match. *\/$/;"	m	struct:ofp13_action_self_learning::ofp13_table_features
metadata_match	.\lib\ofp-util.h	/^    ovs_be64 metadata_match;  \/* Bits of metadata table can match. *\/$/;"	m	struct:ofputil_table_features
metadata_values	.\tests\test-classifier.c	/^static ovs_be64 metadata_values[] = {$/;"	v	file:
metadata_write	.\include\openflow\openflow-1.2.h	/^    ovs_be64 metadata_write; \/* Bits of metadata table can write. *\/$/;"	m	struct:ofp12_table_stats
metadata_write	.\include\openflow\openflow-1.3.h	/^    ovs_be64 metadata_write;  \/* Bits of metadata table can write. *\/$/;"	m	struct:ofp13_action_self_learning::ofp13_table_features
metadata_write	.\lib\ofp-util.h	/^    ovs_be64 metadata_write;  \/* Bits of metadata table can write. *\/$/;"	m	struct:ofputil_table_features
meter	.\lib\ofp-util.h	/^    struct ofputil_meter_config meter;$/;"	m	struct:ofputil_meter_mod	typeref:struct:ofputil_meter_mod::ofputil_meter_config
meter	.\ofproto\ofproto.c	/^struct meter {$/;"	s	file:
meter_create	.\ofproto\ofproto.c	/^meter_create(const struct ofputil_meter_config *config,$/;"	f	file:
meter_del	.\ofproto\ofproto-provider.h	/^    void (*meter_del)(struct ofproto *, ofproto_meter_id);$/;"	m	struct:ofproto_class
meter_features	.\ofproto\ofproto-provider.h	/^    struct ofputil_meter_features meter_features;$/;"	m	struct:ofproto	typeref:struct:ofproto::ofputil_meter_features
meter_get	.\ofproto\ofproto-provider.h	/^    enum ofperr (*meter_get)(const struct ofproto *ofproto,$/;"	m	struct:ofproto_class	typeref:enum:ofproto_class::meter_get
meter_get_features	.\ofproto\ofproto-provider.h	/^    void (*meter_get_features)(const struct ofproto *ofproto,$/;"	m	struct:ofproto_class
meter_id	.\include\openflow\openflow-1.3.h	/^    ovs_be32          meter_id;     \/* Meter instance. *\/$/;"	m	struct:ofp13_action_self_learning::ofp13_meter_config
meter_id	.\include\openflow\openflow-1.3.h	/^    ovs_be32          meter_id;     \/* Meter instance. *\/$/;"	m	struct:ofp13_action_self_learning::ofp13_meter_mod
meter_id	.\include\openflow\openflow-1.3.h	/^    ovs_be32  meter_id;          \/* Meter instance. *\/$/;"	m	struct:ofp13_action_self_learning::ofp13_meter_stats
meter_id	.\include\openflow\openflow-1.3.h	/^    ovs_be32 meter_id;          \/* Meter instance. *\/$/;"	m	struct:ofp13_instruction_meter
meter_id	.\include\openflow\openflow-1.3.h	/^    ovs_be32 meter_id;  \/* Meter instance, or OFPM_ALL. *\/$/;"	m	struct:ofp13_action_self_learning::ofp13_meter_multipart_request
meter_id	.\lib\ofp-actions.h	/^    uint32_t meter_id;$/;"	m	struct:ofpact_meter
meter_id	.\lib\ofp-util.h	/^    uint32_t meter_id;$/;"	m	struct:ofputil_meter_config
meter_id	.\lib\ofp-util.h	/^    uint32_t meter_id;$/;"	m	struct:ofputil_meter_stats
meter_set	.\ofproto\ofproto-provider.h	/^    enum ofperr (*meter_set)(struct ofproto *ofproto, ofproto_meter_id *id,$/;"	m	struct:ofproto_class	typeref:enum:ofproto_class::meter_set
meter_update	.\ofproto\ofproto.c	/^meter_update(struct meter *meter, const struct ofputil_meter_config *config)$/;"	f	file:
meters	.\ofproto\ofproto-provider.h	/^    struct meter **meters; \/* 'meter_features.max_meter' + 1 pointers. *\/$/;"	m	struct:ofproto	typeref:struct:ofproto::meter
method	.\lib\jsonrpc.h	/^    char *method;               \/* Request or notification only. *\/$/;"	m	struct:jsonrpc_msg
mf	.\lib\meta-flow.c	/^    const struct mf_field *mf;$/;"	m	struct:nxm_field	typeref:struct:nxm_field::mf_field	file:
mf_are_prereqs_ok	.\lib\meta-flow.c	/^mf_are_prereqs_ok(const struct mf_field *mf, const struct flow *flow)$/;"	f
mf_by_name	.\lib\meta-flow.c	/^static struct shash mf_by_name;$/;"	v	typeref:struct:shash	file:
mf_check__	.\lib\meta-flow.c	/^mf_check__(const struct mf_subfield *sf, const struct flow *flow,$/;"	f	file:
mf_check_dst	.\lib\meta-flow.c	/^mf_check_dst(const struct mf_subfield *sf, const struct flow *flow)$/;"	f
mf_check_src	.\lib\meta-flow.c	/^mf_check_src(const struct mf_subfield *sf, const struct flow *flow)$/;"	f
mf_ctx	.\lib\flow.c	/^struct mf_ctx {$/;"	s	file:
mf_field	.\lib\meta-flow.h	/^struct mf_field {$/;"	s
mf_field_id	.\lib\meta-flow.h	/^enum OVS_PACKED_ENUM mf_field_id {$/;"	g
mf_fields	.\lib\meta-flow.c	/^const struct mf_field mf_fields[MFF_N_IDS] = {$/;"	v	typeref:struct:mf_field
mf_format	.\lib\meta-flow.c	/^mf_format(const struct mf_field *mf,$/;"	f
mf_format_frag_string	.\lib\meta-flow.c	/^mf_format_frag_string(uint8_t value, uint8_t mask, struct ds *s)$/;"	f	file:
mf_format_integer_string	.\lib\meta-flow.c	/^mf_format_integer_string(const struct mf_field *mf, const uint8_t *valuep,$/;"	f	file:
mf_format_subfield	.\lib\meta-flow.c	/^mf_format_subfield(const struct mf_subfield *sf, struct ds *s)$/;"	f
mf_format_subvalue	.\lib\meta-flow.c	/^mf_format_subvalue(const union mf_subvalue *subvalue, struct ds *s)$/;"	f
mf_format_tcp_flags_string	.\lib\meta-flow.c	/^mf_format_tcp_flags_string(ovs_be16 value, ovs_be16 mask, struct ds *s)$/;"	f	file:
mf_format_tnl_flags_string	.\lib\meta-flow.c	/^mf_format_tnl_flags_string(const ovs_be16 *valuep, struct ds *s)$/;"	f	file:
mf_from_ethernet_string	.\lib\meta-flow.c	/^mf_from_ethernet_string(const struct mf_field *mf, const char *s,$/;"	f	file:
mf_from_frag_string	.\lib\meta-flow.c	/^mf_from_frag_string(const char *s, uint8_t *valuep, uint8_t *maskp)$/;"	f	file:
mf_from_id	.\lib\meta-flow.h	/^mf_from_id(enum mf_field_id id)$/;"	f
mf_from_integer_string	.\lib\meta-flow.c	/^mf_from_integer_string(const struct mf_field *mf, const char *s,$/;"	f	file:
mf_from_ipv4_string	.\lib\meta-flow.c	/^mf_from_ipv4_string(const struct mf_field *mf, const char *s,$/;"	f	file:
mf_from_ipv6_string	.\lib\meta-flow.c	/^mf_from_ipv6_string(const struct mf_field *mf, const char *s,$/;"	f	file:
mf_from_name	.\lib\meta-flow.c	/^mf_from_name(const char *name)$/;"	f
mf_from_nxm_header	.\lib\meta-flow.c	/^mf_from_nxm_header(uint32_t header)$/;"	f
mf_from_nxm_header__	.\lib\meta-flow.c	/^mf_from_nxm_header__(uint32_t header)$/;"	f
mf_from_ofp_port_string	.\lib\meta-flow.c	/^mf_from_ofp_port_string(const struct mf_field *mf, const char *s,$/;"	f	file:
mf_from_ofp_port_string32	.\lib\meta-flow.c	/^mf_from_ofp_port_string32(const struct mf_field *mf, const char *s,$/;"	f	file:
mf_from_tcp_flags_string	.\lib\meta-flow.c	/^mf_from_tcp_flags_string(const char *s, ovs_be16 *flagsp, ovs_be16 *maskp)$/;"	f	file:
mf_from_tun_flags_string	.\lib\meta-flow.c	/^mf_from_tun_flags_string(const char *s, ovs_be16 *valuep, ovs_be16 *maskp)$/;"	f	file:
mf_get	.\lib\meta-flow.c	/^mf_get(const struct mf_field *mf, const struct match *match,$/;"	f
mf_get_mask	.\lib\meta-flow.c	/^mf_get_mask(const struct mf_field *mf, const struct flow_wildcards *wc,$/;"	f
mf_get_subfield	.\lib\meta-flow.c	/^mf_get_subfield(const struct mf_subfield *sf, const struct flow *flow)$/;"	f
mf_get_value	.\lib\meta-flow.c	/^mf_get_value(const struct mf_field *mf, const struct flow *flow,$/;"	f
mf_is_all_wild	.\lib\meta-flow.c	/^mf_is_all_wild(const struct mf_field *mf, const struct flow_wildcards *wc)$/;"	f
mf_is_l3_or_higher	.\lib\meta-flow.h	/^mf_is_l3_or_higher(const struct mf_field *mf)$/;"	f
mf_is_mask_valid	.\lib\meta-flow.c	/^mf_is_mask_valid(const struct mf_field *mf, const union mf_value *mask)$/;"	f
mf_is_value_valid	.\lib\meta-flow.c	/^mf_is_value_valid(const struct mf_field *mf, const union mf_value *value)$/;"	f
mf_is_zero	.\lib\meta-flow.c	/^mf_is_zero(const struct mf_field *mf, const struct flow *flow)$/;"	f
mf_mask_field	.\lib\meta-flow.c	/^mf_mask_field(const struct mf_field *mf, struct flow *mask)$/;"	f
mf_mask_field_and_prereqs	.\lib\meta-flow.c	/^mf_mask_field_and_prereqs(const struct mf_field *mf, struct flow *mask)$/;"	f
mf_maskable	.\lib\meta-flow.h	/^enum OVS_PACKED_ENUM mf_maskable {$/;"	g
mf_oxm_header	.\lib\meta-flow.c	/^mf_oxm_header(enum mf_field_id id, enum ofp_version oxm_version)$/;"	f
mf_parse	.\lib\meta-flow.c	/^mf_parse(const struct mf_field *mf, const char *s,$/;"	f
mf_parse_subfield	.\lib\meta-flow.c	/^mf_parse_subfield(struct mf_subfield *sf, const char *s)$/;"	f
mf_parse_subfield__	.\lib\meta-flow.c	/^mf_parse_subfield__(struct mf_subfield *sf, const char **sp)$/;"	f
mf_parse_subfield_name	.\lib\meta-flow.c	/^mf_parse_subfield_name(const char *name, int name_len, bool *wild)$/;"	f	file:
mf_parse_value	.\lib\meta-flow.c	/^mf_parse_value(const struct mf_field *mf, const char *s, union mf_value *value)$/;"	f
mf_prereqs	.\lib\meta-flow.h	/^enum OVS_PACKED_ENUM mf_prereqs {$/;"	g
mf_read_subfield	.\lib\meta-flow.c	/^mf_read_subfield(const struct mf_subfield *sf, const struct flow *flow,$/;"	f
mf_set	.\lib\meta-flow.c	/^mf_set(const struct mf_field *mf,$/;"	f
mf_set_flow_value	.\lib\meta-flow.c	/^mf_set_flow_value(const struct mf_field *mf,$/;"	f
mf_set_value	.\lib\meta-flow.c	/^mf_set_value(const struct mf_field *mf,$/;"	f
mf_set_wild	.\lib\meta-flow.c	/^mf_set_wild(const struct mf_field *mf, struct match *match)$/;"	f
mf_string	.\lib\meta-flow.h	/^enum OVS_PACKED_ENUM mf_string {$/;"	g
mf_subfield	.\lib\meta-flow.h	/^struct mf_subfield {$/;"	s
mf_subvalue	.\lib\meta-flow.h	/^union mf_subvalue {$/;"	u
mf_value	.\lib\meta-flow.h	/^union mf_value {$/;"	u
mf_write_subfield	.\lib\meta-flow.c	/^mf_write_subfield(const struct mf_subfield *sf, const union mf_subvalue *x,$/;"	f
mf_write_subfield_flow	.\lib\meta-flow.c	/^mf_write_subfield_flow(const struct mf_subfield *sf,$/;"	f
mfr_desc	.\include\openflow\openflow-common.h	/^    char mfr_desc[DESC_STR_LEN];       \/* Manufacturer description. *\/$/;"	m	struct:ofp_desc_stats
mfr_desc	.\ofproto\ofproto-provider.h	/^    char *mfr_desc;             \/* Manufacturer (NULL for default)b. *\/$/;"	m	struct:ofproto
mhash_add	.\lib\hash.h	/^static inline uint32_t mhash_add(uint32_t hash, uint32_t data)$/;"	f
mhash_add__	.\lib\hash.h	/^static inline uint32_t mhash_add__(uint32_t hash, uint32_t data)$/;"	f
mhash_finish	.\lib\hash.h	/^static inline uint32_t mhash_finish(uint32_t hash, size_t n_bytes)$/;"	f
might_write_to_db	.\utilities\ovs-vsctl.c	/^might_write_to_db(char **argv)$/;"	f	file:
might_write_to_db	.\vtep\vtep-ctl.c	/^might_write_to_db(char **argv)$/;"	f	file:
miimon	.\lib\netdev-linux.c	/^    bool miimon;                    \/* Link status of last poll. *\/$/;"	m	struct:netdev_linux	file:
miimon_cnt	.\lib\netdev-linux.c	/^static atomic_int miimon_cnt = ATOMIC_VAR_INIT(0);$/;"	v	file:
miimon_interval	.\lib\netdev-linux.c	/^    long long int miimon_interval;  \/* Miimon Poll rate. Disabled if <= 0. *\/$/;"	m	struct:netdev_linux	file:
miimon_timer	.\lib\netdev-linux.c	/^    struct timer miimon_timer;$/;"	m	struct:netdev_linux	typeref:struct:netdev_linux::timer	file:
min	.\lib\coverage.h	/^    unsigned int min[MIN_AVG_LEN];$/;"	m	struct:coverage_counter
min	.\lib\ovsdb-types.h	/^            double min;         \/* minReal or -DBL_MAX. *\/$/;"	m	struct:ovsdb_base_type::__anon86::ovsdb_real_constraints
min	.\lib\ovsdb-types.h	/^            int64_t min;        \/* minInteger or INT64_MIN. *\/$/;"	m	struct:ovsdb_base_type::__anon86::ovsdb_integer_constraints
minLen	.\lib\ovsdb-types.h	/^            unsigned int minLen; \/* minLength or 0. *\/$/;"	m	struct:ovsdb_base_type::__anon86::ovsdb_string_constraints
min_args	.\lib\command-line.h	/^    int min_args;$/;"	m	struct:command
min_args	.\lib\unixctl.c	/^    int min_args, max_args;$/;"	m	struct:unixctl_command	file:
min_args	.\ovsdb\ovsdb-client.c	/^    int min_args;$/;"	m	struct:ovsdb_client_command	file:
min_args	.\utilities\ovs-vsctl.c	/^    int min_args;               \/* Min number of arguments following name. *\/$/;"	m	struct:vsctl_command_syntax	file:
min_args	.\vtep\vtep-ctl.c	/^    int min_args;               \/* Min number of arguments following name. *\/$/;"	m	struct:vtep_ctl_command_syntax	file:
min_attr_len	.\lib\netlink.c	/^min_attr_len(enum nl_attr_type type)$/;"	f	file:
min_backoff	.\lib\reconnect.c	/^    int min_backoff;$/;"	m	struct:reconnect	file:
min_body	.\lib\ofp-msgs.c	/^    unsigned int min_body;$/;"	m	struct:raw_info	file:
min_len	.\lib\netlink.h	/^    size_t min_len, max_len;$/;"	m	struct:nl_policy
min_level	.\lib\vlog.h	/^    int min_level;                \/* Minimum log level for any facility. *\/$/;"	m	struct:vlog_module
min_mtu	.\ofproto\ofproto-provider.h	/^    int min_mtu;                    \/* Current MTU of non-internal ports. *\/$/;"	m	struct:ofproto
min_rate	.\lib\netdev-linux.c	/^    uint32_t min_rate;$/;"	m	struct:hfsc_class	file:
min_rate	.\lib\netdev-linux.c	/^    unsigned int min_rate;      \/* In bytes\/s. *\/$/;"	m	struct:htb_class	file:
min_rate	.\lib\ofp-util.h	/^    uint16_t min_rate;$/;"	m	struct:ofputil_queue_config
min_rx	.\lib\bfd.c	/^    long long int min_rx;         \/* bfd.RequiredMinRxInterval. *\/$/;"	m	struct:bfd	file:
min_rx	.\lib\bfd.c	/^    ovs_be32 min_rx;      \/* Required minimum rx interval. *\/$/;"	m	struct:msg	file:
min_rx_echo	.\lib\bfd.c	/^    ovs_be32 min_rx_echo; \/* Required minimum echo rx interval. *\/$/;"	m	struct:msg	file:
min_tx	.\lib\bfd.c	/^    long long int min_tx;         \/* bfd.DesiredMinTxInterval. *\/$/;"	m	struct:bfd	file:
min_tx	.\lib\bfd.c	/^    ovs_be32 min_tx;      \/* Desired minimum tx interval. *\/$/;"	m	struct:msg	file:
min_version	.\lib\ofp-msgs.c	/^    uint8_t min_version;$/;"	m	struct:raw_info	file:
min_version	.\lib\ofp-util.c	/^    enum ofp_version min_version, max_version;$/;"	m	struct:ofputil_flow_mod_flag	typeref:enum:ofputil_flow_mod_flag::ofp_version	file:
miniflow_alloc_values	.\lib\flow.c	/^miniflow_alloc_values(struct miniflow *flow, int n)$/;"	f	file:
miniflow_and_mask_matches_flow	.\lib\classifier.c	/^miniflow_and_mask_matches_flow(const struct miniflow *flow,$/;"	f	file:
miniflow_and_mask_matches_miniflow	.\lib\classifier.c	/^miniflow_and_mask_matches_miniflow(const struct miniflow *flow,$/;"	f	file:
miniflow_clone	.\lib\flow.c	/^miniflow_clone(struct miniflow *dst, const struct miniflow *src)$/;"	f
miniflow_clone_inline	.\lib\flow.c	/^miniflow_clone_inline(struct miniflow *dst, const struct miniflow *src,$/;"	f
miniflow_destroy	.\lib\flow.c	/^miniflow_destroy(struct miniflow *flow)$/;"	f
miniflow_equal	.\lib\flow.c	/^miniflow_equal(const struct miniflow *a, const struct miniflow *b)$/;"	f
miniflow_equal_flow_in_minimask	.\lib\flow.c	/^miniflow_equal_flow_in_minimask(const struct miniflow *a, const struct flow *b,$/;"	f
miniflow_equal_in_minimask	.\lib\flow.c	/^miniflow_equal_in_minimask(const struct miniflow *a, const struct miniflow *b,$/;"	f
miniflow_expand	.\lib\flow.c	/^miniflow_expand(const struct miniflow *src, struct flow *dst)$/;"	f
miniflow_extract	.\lib\flow.c	/^miniflow_extract(struct ofpbuf *packet, const struct pkt_metadata *md,$/;"	f
miniflow_get	.\lib\flow.c	/^miniflow_get(const struct miniflow *flow, unsigned int u32_ofs)$/;"	f	file:
miniflow_get_map_in_range	.\lib\classifier.c	/^miniflow_get_map_in_range(const struct miniflow *miniflow,$/;"	f	file:
miniflow_hash	.\lib\classifier.c	/^miniflow_hash(const struct miniflow *flow, uint32_t basis)$/;"	f	file:
miniflow_hash_5tuple	.\lib\flow.c	/^miniflow_hash_5tuple(const struct miniflow *flow, uint32_t basis)$/;"	f
miniflow_hash_in_minimask	.\lib\classifier.c	/^miniflow_hash_in_minimask(const struct miniflow *flow,$/;"	f	file:
miniflow_init	.\lib\flow.c	/^miniflow_init(struct miniflow *dst, const struct flow *src)$/;"	f
miniflow_init__	.\lib\flow.c	/^miniflow_init__(struct miniflow *dst, const struct flow *src, int n)$/;"	f	file:
miniflow_init_with_minimask	.\lib\flow.c	/^miniflow_init_with_minimask(struct miniflow *dst, const struct flow *src,$/;"	f
miniflow_malloc	.\lib\flow.c	/^COVERAGE_DEFINE(miniflow_malloc);$/;"	v
miniflow_move	.\lib\flow.c	/^miniflow_move(struct miniflow *dst, struct miniflow *src)$/;"	f
miniflow_n_values	.\lib\flow.c	/^miniflow_n_values(const struct miniflow *flow)$/;"	f	file:
miniflow_push_be16	.\lib\flow.c	194;"	d	file:
miniflow_push_be16_	.\lib\flow.c	157;"	d	file:
miniflow_push_be32	.\lib\flow.c	176;"	d	file:
miniflow_push_be32_	.\lib\flow.c	138;"	d	file:
miniflow_push_be32_check	.\lib\flow.c	185;"	d	file:
miniflow_push_uint16	.\lib\flow.c	191;"	d	file:
miniflow_push_uint16_	.\lib\flow.c	141;"	d	file:
miniflow_push_uint32	.\lib\flow.c	173;"	d	file:
miniflow_push_uint32_	.\lib\flow.c	130;"	d	file:
miniflow_push_uint32_check	.\lib\flow.c	179;"	d	file:
miniflow_push_words	.\lib\flow.c	197;"	d	file:
miniflow_push_words_	.\lib\flow.c	161;"	d	file:
minimask_clone	.\lib\flow.c	/^minimask_clone(struct minimask *dst, const struct minimask *src)$/;"	f
minimask_combine	.\lib\flow.c	/^minimask_combine(struct minimask *dst_,$/;"	f
minimask_destroy	.\lib\flow.c	/^minimask_destroy(struct minimask *mask)$/;"	f
minimask_equal	.\lib\flow.c	/^minimask_equal(const struct minimask *a, const struct minimask *b)$/;"	f
minimask_expand	.\lib\flow.c	/^minimask_expand(const struct minimask *mask, struct flow_wildcards *wc)$/;"	f
minimask_get	.\lib\flow.c	/^minimask_get(const struct minimask *mask, unsigned int u32_ofs)$/;"	f
minimask_get_prefix_len	.\lib\classifier.c	/^minimask_get_prefix_len(const struct minimask *minimask,$/;"	f	file:
minimask_has_extra	.\lib\flow.c	/^minimask_has_extra(const struct minimask *a, const struct minimask *b)$/;"	f
minimask_hash	.\lib\classifier.c	/^minimask_hash(const struct minimask *mask, uint32_t basis)$/;"	f	file:
minimask_init	.\lib\flow.c	/^minimask_init(struct minimask *mask, const struct flow_wildcards *wc)$/;"	f
minimask_move	.\lib\flow.c	/^minimask_move(struct minimask *dst, struct minimask *src)$/;"	f
minimatch	.\lib\match.h	/^struct minimatch {$/;"	s
minimatch_clone	.\lib\match.c	/^minimatch_clone(struct minimatch *dst, const struct minimatch *src)$/;"	f
minimatch_destroy	.\lib\match.c	/^minimatch_destroy(struct minimatch *match)$/;"	f
minimatch_equal	.\lib\match.c	/^minimatch_equal(const struct minimatch *a, const struct minimatch *b)$/;"	f
minimatch_expand	.\lib\match.c	/^minimatch_expand(const struct minimatch *src, struct match *dst)$/;"	f
minimatch_format	.\lib\match.c	/^minimatch_format(const struct minimatch *match, struct ds *s,$/;"	f
minimatch_get_ports	.\lib\classifier.c	/^static inline ovs_be32 minimatch_get_ports(const struct minimatch *match)$/;"	f	file:
minimatch_get_prefix	.\lib\classifier.c	/^minimatch_get_prefix(const struct minimatch *match, const struct mf_field *mf)$/;"	f	file:
minimatch_hash	.\lib\classifier.c	/^minimatch_hash(const struct minimatch *match, uint32_t basis)$/;"	f	file:
minimatch_hash_range	.\lib\classifier.c	/^minimatch_hash_range(const struct minimatch *match, uint8_t start, uint8_t end,$/;"	f	file:
minimatch_init	.\lib\match.c	/^minimatch_init(struct minimatch *dst, const struct match *src)$/;"	f
minimatch_matches_flow	.\lib\match.c	/^minimatch_matches_flow(const struct minimatch *match,$/;"	f
minimatch_move	.\lib\match.c	/^minimatch_move(struct minimatch *dst, struct minimatch *src)$/;"	f
minimatch_to_string	.\lib\match.c	/^minimatch_to_string(const struct minimatch *match, unsigned int priority)$/;"	f
minimum_ip_total_length	.\ofproto\ofproto-dpif-ipfix.c	/^    uint16_t minimum_ip_total_length;  \/* 0 if not IP. *\/$/;"	m	struct:ipfix_flow_cache_entry	file:
mirror	.\ofproto\ofproto-dpif-mirror.c	/^struct mirror {$/;"	s	file:
mirror	.\ofproto\ofproto-dpif-xlate.c	/^        } mirror;$/;"	m	union:xc_entry::__anon136	typeref:struct:xc_entry::__anon136::__anon139	file:
mirror	.\vswitchd\bridge.c	/^struct mirror {$/;"	s	file:
mirror_bundle_dst	.\ofproto\ofproto-dpif-mirror.c	/^mirror_bundle_dst(struct mbridge *mbridge, struct ofbundle *ofbundle)$/;"	f
mirror_bundle_out	.\ofproto\ofproto-dpif-mirror.c	/^mirror_bundle_out(struct mbridge *mbridge, struct ofbundle *ofbundle)$/;"	f
mirror_bundle_src	.\ofproto\ofproto-dpif-mirror.c	/^mirror_bundle_src(struct mbridge *mbridge, struct ofbundle *ofbundle)$/;"	f
mirror_collect_ports	.\vswitchd\bridge.c	/^mirror_collect_ports(struct mirror *m,$/;"	f	file:
mirror_configure	.\vswitchd\bridge.c	/^mirror_configure(struct mirror *m)$/;"	f	file:
mirror_create	.\vswitchd\bridge.c	/^mirror_create(struct bridge *br, const struct ovsrec_mirror *cfg)$/;"	f	file:
mirror_destroy	.\ofproto\ofproto-dpif-mirror.c	/^mirror_destroy(struct mbridge *mbridge, void *aux)$/;"	f
mirror_destroy	.\vswitchd\bridge.c	/^mirror_destroy(struct mirror *m)$/;"	f	file:
mirror_find_by_uuid	.\vswitchd\bridge.c	/^mirror_find_by_uuid(struct bridge *br, const struct uuid *uuid)$/;"	f	file:
mirror_get	.\ofproto\ofproto-dpif-mirror.c	/^mirror_get(struct mbridge *mbridge, int index, unsigned long **vlans,$/;"	f
mirror_get_stats	.\ofproto\ofproto-dpif-mirror.c	/^mirror_get_stats(struct mbridge *mbridge, void *aux, uint64_t *packets,$/;"	f
mirror_get_stats	.\ofproto\ofproto-provider.h	/^    int (*mirror_get_stats)(struct ofproto *ofproto, void *aux,$/;"	m	struct:ofproto_class
mirror_get_stats__	.\ofproto\ofproto-dpif.c	/^mirror_get_stats__(struct ofproto *ofproto, void *aux,$/;"	f	file:
mirror_lookup	.\ofproto\ofproto-dpif-mirror.c	/^mirror_lookup(struct mbridge *mbridge, void *aux)$/;"	f	file:
mirror_mask_t	.\ofproto\ofproto-dpif-mirror.h	/^typedef uint32_t mirror_mask_t;$/;"	t
mirror_out	.\ofproto\ofproto-dpif-mirror.c	/^    mirror_mask_t mirror_out;   \/* Mirrors that output to this mbundle. *\/$/;"	m	struct:mbundle	file:
mirror_refresh_stats	.\vswitchd\bridge.c	/^mirror_refresh_stats(struct mirror *m)$/;"	f	file:
mirror_scan	.\ofproto\ofproto-dpif-mirror.c	/^mirror_scan(struct mbridge *mbridge)$/;"	f	file:
mirror_set	.\ofproto\ofproto-dpif-mirror.c	/^mirror_set(struct mbridge *mbridge, void *aux, const char *name,$/;"	f
mirror_set	.\ofproto\ofproto-provider.h	/^    int (*mirror_set)(struct ofproto *ofproto, void *aux,$/;"	m	struct:ofproto_class
mirror_set__	.\ofproto\ofproto-dpif.c	/^mirror_set__(struct ofproto *ofproto_, void *aux,$/;"	f	file:
mirror_update_dups	.\ofproto\ofproto-dpif-mirror.c	/^mirror_update_dups(struct mbridge *mbridge)$/;"	f	file:
mirror_update_stats	.\ofproto\ofproto-dpif-mirror.c	/^mirror_update_stats(struct mbridge *mbridge, mirror_mask_t mirrors,$/;"	f
mirrors	.\lib\vswitch-idl.h	/^	struct ovsrec_mirror **mirrors;$/;"	m	struct:ovsrec_bridge	typeref:struct:ovsrec_bridge::ovsrec_mirror
mirrors	.\ofproto\ofproto-dpif-mirror.c	/^    struct mirror *mirrors[MAX_MIRRORS];$/;"	m	struct:mbridge	typeref:struct:mbridge::mirror	file:
mirrors	.\ofproto\ofproto-dpif-xlate.c	/^            mirror_mask_t mirrors;$/;"	m	struct:xc_entry::__anon136::__anon139	file:
mirrors	.\ofproto\ofproto-dpif-xlate.h	/^    mirror_mask_t mirrors;      \/* Bitmap of associated mirrors. *\/$/;"	m	struct:xlate_out
mirrors	.\vswitchd\bridge.c	/^    struct hmap mirrors;        \/* "struct mirror" indexed by UUID. *\/$/;"	m	struct:bridge	typeref:struct:bridge::hmap	file:
miss	.\lib\ofp-util.h	/^    } nonmiss, miss;$/;"	m	struct:ofputil_table_features	typeref:struct:ofputil_table_features::ofputil_table_instruction_features
miss_rule	.\ofproto\ofproto-dpif-xlate.c	/^    struct rule_dpif *miss_rule;$/;"	m	struct:xbridge	typeref:struct:xbridge::rule_dpif	file:
miss_rule	.\ofproto\ofproto-dpif.c	/^    struct rule_dpif *miss_rule; \/* Sends flow table misses to controller. *\/$/;"	m	struct:ofproto_dpif	typeref:struct:ofproto_dpif::rule_dpif	file:
miss_send_len	.\include\openflow\openflow-common.h	/^    ovs_be16 miss_send_len;     \/* Max bytes of new flow that datapath should$/;"	m	struct:ofp_switch_config
miss_send_len	.\ofproto\connmgr.c	/^    int miss_send_len;             \/* Bytes to send of buffered packets. *\/$/;"	m	struct:ofconn	file:
miss_type	.\ofproto\connmgr.h	/^    enum ofproto_packet_in_miss_type miss_type;$/;"	m	struct:ofproto_packet_in	typeref:enum:ofproto_packet_in::ofproto_packet_in_miss_type
missing_operator_error	.\utilities\ovs-vsctl.c	/^missing_operator_error(const char *arg, const char **allowed_operators,$/;"	f	file:
missing_operator_error	.\vtep\vtep-ctl.c	/^missing_operator_error(const char *arg, const char **allowed_operators,$/;"	f	file:
ml	.\lib\learning-switch.c	/^    struct mac_learning *ml;    \/* NULL to act as hub instead of switch. *\/$/;"	m	struct:lswitch	typeref:struct:lswitch::mac_learning	file:
ml	.\ofproto\ofproto-dpif-xlate.c	/^    struct mac_learning *ml;      \/* Mac learning handle. *\/$/;"	m	struct:xbridge	typeref:struct:xbridge::mac_learning	file:
ml	.\ofproto\ofproto-dpif.c	/^    struct mac_learning *ml;$/;"	m	struct:ofproto_dpif	typeref:struct:ofproto_dpif::mac_learning	file:
mld6_addr	.\include\windows\netinet\icmp6.h	187;"	d
mld6_cksum	.\include\windows\netinet\icmp6.h	184;"	d
mld6_code	.\include\windows\netinet\icmp6.h	183;"	d
mld6_hdr	.\include\windows\netinet\icmp6.h	181;"	d
mld6_maxdelay	.\include\windows\netinet\icmp6.h	185;"	d
mld6_reserved	.\include\windows\netinet\icmp6.h	186;"	d
mld6_type	.\include\windows\netinet\icmp6.h	182;"	d
mld_addr	.\include\windows\netinet\icmp6.h	/^	struct in6_addr		mld_addr; \/* multicast address *\/$/;"	m	struct:mld_hdr	typeref:struct:mld_hdr::in6_addr
mld_cksum	.\include\windows\netinet\icmp6.h	192;"	d
mld_code	.\include\windows\netinet\icmp6.h	191;"	d
mld_hdr	.\include\windows\netinet\icmp6.h	/^struct mld_hdr {$/;"	s
mld_icmp6_hdr	.\include\windows\netinet\icmp6.h	/^	struct icmp6_hdr	mld_icmp6_hdr;$/;"	m	struct:mld_hdr	typeref:struct:mld_hdr::icmp6_hdr
mld_maxdelay	.\include\windows\netinet\icmp6.h	193;"	d
mld_reserved	.\include\windows\netinet\icmp6.h	194;"	d
mld_type	.\include\windows\netinet\icmp6.h	190;"	d
mod2_hash	.\tests\test-hindex.c	/^mod2_hash(int value)$/;"	f	file:
mod3_hash	.\tests\test-hindex.c	/^mod3_hash(int value)$/;"	f	file:
mod4_hash	.\tests\test-hindex.c	/^mod4_hash(int value)$/;"	f	file:
mod_int	.\ovsdb\mutation.c	/^mod_int(int64_t *x, int64_t y)$/;"	f	file:
mod_mutation	.\ovsdb\mutation.c	/^static const struct ovsdb_scalar_mutation mod_mutation = {$/;"	v	typeref:struct:ovsdb_scalar_mutation	file:
mod_mutation	.\ovsdb\mutation.c	/^static const struct ovsdb_scalar_mutation mod_mutation;$/;"	v	typeref:struct:ovsdb_scalar_mutation	file:
mode	.\lib\learning-switch.h	/^    enum lswitch_mode mode;$/;"	m	struct:lswitch_config	typeref:enum:lswitch_config::lswitch_mode
mode	.\ovsdb\log.c	/^    enum ovsdb_log_mode mode;$/;"	m	struct:ovsdb_log	typeref:enum:ovsdb_log::ovsdb_log_mode	file:
mode	.\ovsdb\server.h	/^    enum ovsdb_lock_mode mode;$/;"	m	struct:ovsdb_lock_waiter	typeref:enum:ovsdb_lock_waiter::ovsdb_lock_mode
mode	.\utilities\ovs-vsctl.c	/^    enum { RO, RW } mode;       \/* Does this command modify the database? *\/$/;"	m	struct:vsctl_command_syntax	typeref:enum:vsctl_command_syntax::__anon161	file:
mode	.\vtep\vtep-ctl.c	/^    enum { RO, RW } mode;       \/* Does this command modify the database? *\/$/;"	m	struct:vtep_ctl_command_syntax	typeref:enum:vtep_ctl_command_syntax::__anon162	file:
modes	.\lib\ovsdb-idl-provider.h	/^    unsigned char *modes;    \/* OVSDB_IDL_* bitmasks, indexed by column. *\/$/;"	m	struct:ovsdb_idl_table
modified	.\ofproto\ofproto-provider.h	/^    long long int modified;     \/* Time of last modification. *\/$/;"	m	struct:ofgroup
modify_cookie	.\lib\ofp-util.h	/^    bool modify_cookie;      \/* Set cookie of existing flow to 'new_cookie'? *\/$/;"	m	struct:ofputil_flow_mod
modify_group	.\ofproto\ofproto.c	/^modify_group(struct ofproto *ofproto, struct ofputil_group_mod *gm)$/;"	f	file:
modinst	.\utilities\ovs-dev.py	/^def modinst():$/;"	f
module	.\datapath\linux\compat\include\net\genetlink.h	/^	struct module           *module;$/;"	m	struct:rpl_genl_family	typeref:struct:rpl_genl_family::module
monitor	.\lib\daemon-unix.c	/^static bool monitor;$/;"	v	file:
monitor	.\lib\daemon-windows.c	/^static bool monitor;$/;"	v	file:
monitor	.\ovsdb\jsonrpc-server.c	/^    const struct ovsdb_jsonrpc_monitor *monitor;$/;"	m	struct:ovsdb_jsonrpc_monitor_aux	typeref:struct:ovsdb_jsonrpc_monitor_aux::ovsdb_jsonrpc_monitor	file:
monitor_daemon	.\lib\daemon-unix.c	/^monitor_daemon(pid_t daemon_pid)$/;"	f	file:
monitor_exit_latch	.\ofproto\ofproto-dpif-monitor.c	/^static struct latch monitor_exit_latch;$/;"	v	typeref:struct:latch	file:
monitor_heap	.\ofproto\ofproto-dpif-monitor.c	/^static struct heap monitor_heap;$/;"	v	typeref:struct:heap	file:
monitor_hmap	.\ofproto\ofproto-dpif-monitor.c	/^static struct hmap monitor_hmap = HMAP_INITIALIZER(&monitor_hmap);$/;"	v	typeref:struct:hmap	file:
monitor_id	.\ovsdb\jsonrpc-server.c	/^    struct json *monitor_id;$/;"	m	struct:ovsdb_jsonrpc_monitor	typeref:struct:ovsdb_jsonrpc_monitor::json	file:
monitor_main	.\ofproto\ofproto-dpif-monitor.c	/^monitor_main(void * args OVS_UNUSED)$/;"	f	file:
monitor_mutex	.\ofproto\ofproto-dpif-monitor.c	/^                         uint8_t[ETH_ADDR_LEN]) OVS_REQUIRES(monitor_mutex);$/;"	v
monitor_mutex	.\ofproto\ofproto-dpif-monitor.c	/^    OVS_REQUIRES(monitor_mutex);$/;"	v
monitor_mutex	.\ofproto\ofproto-dpif-monitor.c	/^static struct ovs_mutex monitor_mutex = OVS_MUTEX_INITIALIZER;$/;"	v	typeref:struct:ovs_mutex	file:
monitor_print	.\ovsdb\ovsdb-client.c	/^monitor_print(struct json *table_updates,$/;"	f	file:
monitor_print_row	.\ovsdb\ovsdb-client.c	/^monitor_print_row(struct json *row, const char *type, const char *uuid,$/;"	f	file:
monitor_print_table	.\ovsdb\ovsdb-client.c	/^monitor_print_table(struct json *table_update,$/;"	f	file:
monitor_request_id	.\lib\ovsdb-idl.c	/^    struct json *monitor_request_id;$/;"	m	struct:ovsdb_idl	typeref:struct:ovsdb_idl::json	file:
monitor_run	.\ofproto\ofproto-dpif-monitor.c	/^monitor_run(void)$/;"	f	file:
monitor_running	.\ofproto\ofproto-dpif-monitor.c	/^static bool monitor_running;$/;"	v	file:
monitor_seqno	.\ofproto\connmgr.c	/^static uint64_t monitor_seqno = 1;$/;"	v	file:
monitor_set_invalid_ttl_to_controller	.\utilities\ovs-ofctl.c	/^monitor_set_invalid_ttl_to_controller(struct vconn *vconn)$/;"	f	file:
monitor_tid	.\ofproto\ofproto-dpif-monitor.c	/^static pthread_t monitor_tid;$/;"	v	file:
monitor_vconn	.\utilities\ovs-ofctl.c	/^monitor_vconn(struct vconn *vconn, bool reply_to_echo_requests)$/;"	f	file:
monitored_table	.\ovsdb\ovsdb-client.c	/^struct monitored_table {$/;"	s	file:
monitorlogs	.\xenserver\etc_profile.d_openvswitch.sh	/^function monitorlogs {$/;"	f
monitors	.\lib\rconn.c	/^    struct vconn *monitors[8];$/;"	m	struct:rconn	typeref:struct:rconn::vconn	file:
monitors	.\ovsdb\jsonrpc-server.c	/^    struct hmap monitors;       \/* Hmap of "struct ovsdb_jsonrpc_monitor"s. *\/$/;"	m	struct:ovsdb_jsonrpc_session	typeref:struct:ovsdb_jsonrpc_session::hmap	file:
monotonic_clock	.\lib\timeval.c	/^static struct clock monotonic_clock; \/* CLOCK_MONOTONIC, if available. *\/$/;"	v	typeref:struct:clock	file:
move_routes	.\python\ovstest\util.py	/^def move_routes(iface1, iface2):$/;"	f
mp	.\lib\netdev-dpdk.c	/^    struct rte_mempool *mp;$/;"	m	struct:dpdk_mp	typeref:struct:dpdk_mp::rte_mempool	file:
mpid	.\lib\cfm.c	/^    uint64_t mpid;         \/* The Maintenance Point ID of this 'remote_mp'. *\/$/;"	m	struct:remote_mp	file:
mpid	.\lib\cfm.c	/^    uint64_t mpid;$/;"	m	struct:cfm	file:
mpid	.\lib\cfm.h	/^    uint64_t mpid;              \/* The MPID of this CFM. *\/$/;"	m	struct:cfm_settings
mpls	.\lib\sflow.h	/^    SFLExtended_mpls mpls;$/;"	m	union:_SFLFlow_type
mplsEncodingLength	.\lib\sflow_receiver.c	/^inline static u_int32_t mplsEncodingLength(SFLExtended_mpls *mpls) {$/;"	f	file:
mplsFTNDescr	.\lib\sflow.h	/^    SFLString mplsFTNDescr;$/;"	m	struct:_SFLExtended_mpls_FTN
mplsFTNMask	.\lib\sflow.h	/^    u_int32_t mplsFTNMask;$/;"	m	struct:_SFLExtended_mpls_FTN
mplsFecAddrPrefixLength	.\lib\sflow.h	/^    u_int32_t mplsFecAddrPrefixLength;$/;"	m	struct:_SFLExtended_mpls_LDP_FEC
mplsFtnEncodingLength	.\lib\sflow_receiver.c	/^inline static u_int32_t mplsFtnEncodingLength(SFLExtended_mpls_FTN *ftn) {$/;"	f	file:
mplsLdpFecEncodingLength	.\lib\sflow_receiver.c	/^inline static u_int32_t mplsLdpFecEncodingLength(SFLExtended_mpls_LDP_FEC *ldpfec) {$/;"	f	file:
mplsTunnelEncodingLength	.\lib\sflow_receiver.c	/^inline static u_int32_t mplsTunnelEncodingLength(SFLExtended_mpls_tunnel *tunnel) {$/;"	f	file:
mplsVcEncodingLength	.\lib\sflow_receiver.c	/^inline static u_int32_t mplsVcEncodingLength(SFLExtended_mpls_vc *vc) {$/;"	f	file:
mpls_ethertype	.\include\linux\openvswitch.h	/^	__be16 mpls_ethertype; \/* Either %ETH_P_MPLS_UC or %ETH_P_MPLS_MC *\/$/;"	m	struct:ovs_action_push_mpls
mpls_ftn	.\lib\sflow.h	/^    SFLExtended_mpls_FTN mpls_ftn;$/;"	m	union:_SFLFlow_type
mpls_hdr	.\lib\packets.h	/^struct mpls_hdr {$/;"	s
mpls_label	.\include\openflow\openflow-1.1.h	/^    ovs_be32 mpls_label;              \/* MPLS label *\/$/;"	m	struct:ofp11_action_mpls_label
mpls_label	.\include\openflow\openflow-1.1.h	/^    ovs_be32 mpls_label;       \/* MPLS label. *\/$/;"	m	struct:ofp11_match
mpls_label	.\lib\ofp-actions.c	/^    struct nx_action_mpls_label mpls_label;$/;"	m	union:ofp_action	typeref:struct:ofp_action::nx_action_mpls_label	file:
mpls_ldp_fec	.\lib\sflow.h	/^    SFLExtended_mpls_LDP_FEC mpls_ldp_fec;$/;"	m	union:_SFLFlow_type
mpls_lse	.\include\linux\openvswitch.h	/^	__be32 mpls_lse;$/;"	m	struct:ovs_action_push_mpls
mpls_lse	.\include\linux\openvswitch.h	/^	__be32 mpls_lse;$/;"	m	struct:ovs_key_mpls
mpls_lse	.\lib\flow.h	/^    ovs_be32 mpls_lse[FLOW_MAX_MPLS_LABELS]; \/* MPLS label stack entry. *\/$/;"	m	struct:flow
mpls_lse	.\lib\packets.h	/^    ovs_16aligned_be32 mpls_lse;$/;"	m	struct:mpls_hdr
mpls_lse_from_components	.\lib\odp-util.c	/^mpls_lse_from_components(int mpls_label, int mpls_tc, int mpls_ttl, int mpls_bos)$/;"	f	file:
mpls_lse_to_bos	.\lib\packets.h	/^mpls_lse_to_bos(ovs_be32 mpls_lse)$/;"	f
mpls_lse_to_label	.\lib\packets.h	/^mpls_lse_to_label(ovs_be32 mpls_lse)$/;"	f
mpls_lse_to_tc	.\lib\packets.h	/^mpls_lse_to_tc(ovs_be32 mpls_lse)$/;"	f
mpls_lse_to_ttl	.\lib\packets.h	/^mpls_lse_to_ttl(ovs_be32 mpls_lse)$/;"	f
mpls_tc	.\include\openflow\openflow-1.1.h	/^    uint8_t mpls_tc;                  \/* MPLS TC *\/$/;"	m	struct:ofp11_action_mpls_tc
mpls_tc	.\include\openflow\openflow-1.1.h	/^    uint8_t mpls_tc;           \/* MPLS TC. *\/$/;"	m	struct:ofp11_match
mpls_tc	.\lib\ofp-actions.c	/^    struct nx_action_mpls_tc mpls_tc;$/;"	m	union:ofp_action	typeref:struct:ofp_action::nx_action_mpls_tc	file:
mpls_ttl	.\include\openflow\openflow-1.1.h	/^    uint8_t mpls_ttl;                 \/* MPLS TTL *\/$/;"	m	struct:ofp11_action_mpls_ttl
mpls_ttl	.\lib\ofp-actions.c	/^    struct nx_action_mpls_ttl mpls_ttl;$/;"	m	union:ofp_action	typeref:struct:ofp_action::nx_action_mpls_ttl	file:
mpls_tunnel	.\lib\sflow.h	/^    SFLExtended_mpls_tunnel mpls_tunnel;$/;"	m	union:_SFLFlow_type
mpls_vc	.\lib\sflow.h	/^    SFLExtended_mpls_vc mpls_vc;$/;"	m	union:_SFLFlow_type
mport	.\ofproto\ofproto-dpif-monitor.c	/^struct mport {$/;"	s	file:
ms_to_ccm_interval	.\lib\cfm.c	/^ms_to_ccm_interval(int interval_ms)$/;"	f	file:
ms_to_timer	.\lib\stp.c	/^ms_to_timer(int ms)$/;"	f	file:
msec	.\lib\timeval.h	/^  int msec;$/;"	m	struct:tm_msec
msec	.\python\ovs\timeval.py	/^def msec():$/;"	f
msec_since_connect	.\lib\reconnect.h	/^    unsigned int msec_since_connect;       \/* Time since last connect. *\/$/;"	m	struct:reconnect_stats
msec_since_disconnect	.\lib\reconnect.h	/^    unsigned int msec_since_disconnect;    \/* Time since last disconnect. *\/$/;"	m	struct:reconnect_stats
msg	.\lib\bfd.c	/^struct msg {$/;"	s	file:
msg	.\lib\netlink-protocol.h	/^        struct nlmsghdr msg;$/;"	m	struct:nlmsgerr	typeref:struct:nlmsgerr::nlmsghdr
msg	.\lib\ofp-util.h	/^    const struct ofp_header   *msg;$/;"	m	struct:ofputil_bundle_add_msg	typeref:struct:ofputil_bundle_add_msg::ofp_header
msg	.\ofproto\bundles.c	/^    struct ofp_header *msg;$/;"	m	struct:bundle_message	typeref:struct:bundle_message::ofp_header	file:
msg_control	.\include\sparse\sys\socket.h	/^    void          *msg_control;$/;"	m	struct:msghdr
msg_controllen	.\include\sparse\sys\socket.h	/^    socklen_t      msg_controllen;$/;"	m	struct:msghdr
msg_flags	.\include\sparse\sys\socket.h	/^    int            msg_flags;$/;"	m	struct:msghdr
msg_iov	.\include\sparse\sys\socket.h	/^    struct iovec  *msg_iov;$/;"	m	struct:msghdr	typeref:struct:msghdr::iovec
msg_iovlen	.\include\sparse\sys\socket.h	/^    int            msg_iovlen;$/;"	m	struct:msghdr
msg_list	.\ofproto\bundles.c	/^    struct list       msg_list;$/;"	m	struct:ofp_bundle	typeref:struct:ofp_bundle::list	file:
msg_name	.\include\sparse\sys\socket.h	/^    void *msg_name;$/;"	m	struct:msghdr
msg_namelen	.\include\sparse\sys\socket.h	/^    socklen_t      msg_namelen;$/;"	m	struct:msghdr
msg_type	.\lib\rtbsd.h	/^    int msg_type;             \/* e.g. XXX. *\/$/;"	m	struct:rtbsd_change
msghdr	.\include\sparse\sys\socket.h	/^struct msghdr {$/;"	s
mt	.\ovsdb\jsonrpc-server.c	/^    struct ovsdb_jsonrpc_monitor_table *mt;$/;"	m	struct:ovsdb_jsonrpc_monitor_aux	typeref:struct:ovsdb_jsonrpc_monitor_aux::ovsdb_jsonrpc_monitor_table	file:
mtime	.\lib\stream-ssl.c	/^    struct timespec mtime;      \/* File mtime as of last time we read it. *\/$/;"	m	struct:ssl_config_file	typeref:struct:ssl_config_file::timespec	file:
mtu	.\lib\netdev-bsd.c	/^    int mtu;$/;"	m	struct:netdev_bsd	file:
mtu	.\lib\netdev-dpdk.c	/^    int mtu;$/;"	m	struct:dpdk_mp	file:
mtu	.\lib\netdev-dpdk.c	/^    int mtu;$/;"	m	struct:netdev_dpdk	file:
mtu	.\lib\netdev-linux.c	/^    int mtu;$/;"	m	struct:netdev_linux	file:
mtu	.\lib\packets.h	/^            ovs_be16 mtu;$/;"	m	struct:icmp_header::__anon87::__anon89
mtu	.\lib\rtnetlink-link.h	/^    int mtu;                    \/* Current MTU. *\/$/;"	m	struct:rtnetlink_link_change
mtu	.\lib\vswitch-idl.h	/^	int64_t *mtu;$/;"	m	struct:ovsrec_interface
mtu	.\ofproto\ofproto-provider.h	/^    int mtu;$/;"	m	struct:ofport
mtu_setting	.\xenserver\opt_xensource_libexec_InterfaceReconfigure.py	/^def mtu_setting(nw, type, oc):$/;"	f
mul_double	.\ovsdb\mutation.c	/^mul_double(double *x, double y)$/;"	f	file:
mul_int	.\ovsdb\mutation.c	/^mul_int(int64_t *x, int64_t y)$/;"	f	file:
mul_mutation	.\ovsdb\mutation.c	/^static const struct ovsdb_scalar_mutation mul_mutation = {$/;"	v	typeref:struct:ovsdb_scalar_mutation	file:
mul_mutation	.\ovsdb\mutation.c	/^static const struct ovsdb_scalar_mutation mul_mutation;$/;"	v	typeref:struct:ovsdb_scalar_mutation	file:
mult	.\lib\bfd.c	/^    uint8_t mult;                 \/* bfd.DetectMult. *\/$/;"	m	struct:bfd	file:
mult	.\lib\bfd.c	/^    uint8_t mult;         \/* Fault detection multiplier. *\/$/;"	m	struct:msg	file:
multicast	.\lib\netdev.h	/^    uint64_t multicast;         \/* Multicast packets received. *\/$/;"	m	struct:netdev_stats
multicastPkts	.\lib\sflow.h	/^    u_int32_t multicastPkts;$/;"	m	struct:_SFLVlan_counters
multicast_group	.\lib\netlink-notifier.c	/^    int multicast_group;         \/* Multicast group we listen on. *\/$/;"	m	struct:nln	file:
multipart_hash	.\tests\test-hindex.c	/^multipart_hash(int value)$/;"	f	file:
multipath	.\lib\multipath.c	/^VLOG_DEFINE_THIS_MODULE(multipath);$/;"	v
multipath	.\lib\ofp-actions.c	/^    struct nx_action_multipath multipath;$/;"	m	union:ofp_action	typeref:struct:ofp_action::nx_action_multipath	file:
multipath_algorithm	.\lib\multipath.c	/^multipath_algorithm(uint32_t hash, enum nx_mp_algorithm algorithm,$/;"	f	file:
multipath_check	.\lib\multipath.c	/^multipath_check(const struct ofpact_multipath *mp,$/;"	f
multipath_execute	.\lib\multipath.c	/^multipath_execute(const struct ofpact_multipath *mp, struct flow *flow,$/;"	f
multipath_format	.\lib\multipath.c	/^multipath_format(const struct ofpact_multipath *mp, struct ds *s)$/;"	f
multipath_from_openflow	.\lib\multipath.c	/^multipath_from_openflow(const struct nx_action_multipath *nam,$/;"	f
multipath_parse	.\lib\multipath.c	/^multipath_parse(struct ofpact_multipath *mp, const char *s_)$/;"	f
multipath_parse__	.\lib\multipath.c	/^multipath_parse__(struct ofpact_multipath *mp, const char *s_, char *s)$/;"	f	file:
multipath_to_nxast	.\lib\multipath.c	/^multipath_to_nxast(const struct ofpact_multipath *mp, struct ofpbuf *openflow)$/;"	f
multiple	.\tests\test-json.c	/^static int multiple = 0;$/;"	v	file:
multithreaded	.\lib\ovs-thread.c	/^static bool multithreaded;$/;"	v	file:
must_get_int	.\tests\test-stp.c	/^must_get_int(void)$/;"	f	file:
must_get_row	.\vtep\vtep-ctl.c	/^must_get_row(struct vtep_ctl_context *ctx,$/;"	f	file:
must_match	.\tests\test-stp.c	/^must_match(const char *want)$/;"	f	file:
must_not_fork	.\lib\ovs-thread.c	/^static const char *must_not_fork;$/;"	v	file:
mutate_integer	.\ovsdb\mutation.c	/^    int (*mutate_integer)(int64_t *x, int64_t y);$/;"	m	struct:ovsdb_scalar_mutation	file:
mutate_real	.\ovsdb\mutation.c	/^    int (*mutate_real)(double *x, double y);$/;"	m	struct:ovsdb_scalar_mutation	file:
mutate_row_cb	.\ovsdb\execution.c	/^mutate_row_cb(const struct ovsdb_row *row, void *mr_)$/;"	f	file:
mutate_row_cbdata	.\ovsdb\execution.c	/^struct mutate_row_cbdata {$/;"	s	file:
mutate_scalar	.\ovsdb\mutation.c	/^mutate_scalar(const struct ovsdb_type *dst_type, struct ovsdb_datum *dst,$/;"	f	file:
mutations	.\ovsdb\execution.c	/^    const struct ovsdb_mutation_set *mutations;$/;"	m	struct:mutate_row_cbdata	typeref:struct:mutate_row_cbdata::ovsdb_mutation_set	file:
mutations	.\ovsdb\mutation.h	/^    struct ovsdb_mutation *mutations;$/;"	m	struct:ovsdb_mutation_set	typeref:struct:ovsdb_mutation_set::ovsdb_mutation
mutator	.\ovsdb\mutation.c	/^    enum ovsdb_mutator mutator;$/;"	m	struct:ovsdb_scalar_mutation	typeref:enum:ovsdb_scalar_mutation::ovsdb_mutator	file:
mutator	.\ovsdb\mutation.h	/^    enum ovsdb_mutator mutator;$/;"	m	struct:ovsdb_mutation	typeref:enum:ovsdb_mutation::ovsdb_mutator
mute	.\lib\learning-switch.c	/^    bool mute;$/;"	m	struct:lswitch	file:
mute	.\lib\learning-switch.h	/^    bool mute;$/;"	m	struct:lswitch_config
mute	.\tests\test-controller.c	/^static bool mute = false;$/;"	v	file:
mutex	.\lib\bfd.c	/^                    const struct bfd *) OVS_REQUIRES(mutex);$/;"	v
mutex	.\lib\bfd.c	/^    OVS_REQUIRES(mutex);$/;"	v
mutex	.\lib\bfd.c	/^static bool bfd_forwarding__(struct bfd *) OVS_REQUIRES(mutex);$/;"	v
mutex	.\lib\bfd.c	/^static bool bfd_in_poll(const struct bfd *) OVS_REQUIRES(mutex);$/;"	v
mutex	.\lib\bfd.c	/^static const char *bfd_diag_str(enum diag) OVS_REQUIRES(mutex);$/;"	v
mutex	.\lib\bfd.c	/^static const char *bfd_state_str(enum state) OVS_REQUIRES(mutex);$/;"	v
mutex	.\lib\bfd.c	/^static long long int bfd_min_tx(const struct bfd *) OVS_REQUIRES(mutex);$/;"	v
mutex	.\lib\bfd.c	/^static struct hmap *const all_bfds OVS_GUARDED_BY(mutex) = &all_bfds__;$/;"	v	file:
mutex	.\lib\bfd.c	/^static struct ovs_mutex mutex = OVS_MUTEX_INITIALIZER;$/;"	v	typeref:struct:ovs_mutex	file:
mutex	.\lib\bfd.c	/^static uint32_t generate_discriminator(void) OVS_REQUIRES(mutex);$/;"	v
mutex	.\lib\bfd.c	/^static uint64_t bfd_rx_packets(const struct bfd *) OVS_REQUIRES(mutex);$/;"	v
mutex	.\lib\bfd.c	/^static void bfd_decay_update(struct bfd *) OVS_REQUIRES(mutex);$/;"	v
mutex	.\lib\bfd.c	/^static void bfd_forwarding_if_rx_update(struct bfd *) OVS_REQUIRES(mutex);$/;"	v
mutex	.\lib\bfd.c	/^static void bfd_poll(struct bfd *bfd) OVS_REQUIRES(mutex);$/;"	v
mutex	.\lib\bfd.c	/^static void bfd_set_next_tx(struct bfd *) OVS_REQUIRES(mutex);$/;"	v
mutex	.\lib\bfd.c	/^static void bfd_status_changed(struct bfd *) OVS_REQUIRES(mutex);$/;"	v
mutex	.\lib\bfd.c	/^static void bfd_try_decay(struct bfd *) OVS_REQUIRES(mutex);$/;"	v
mutex	.\lib\cfm.c	/^static struct hmap *const all_cfms OVS_GUARDED_BY(mutex) = &all_cfms__;$/;"	v	file:
mutex	.\lib\cfm.c	/^static struct ovs_mutex mutex = OVS_MUTEX_INITIALIZER;$/;"	v	typeref:struct:ovs_mutex	file:
mutex	.\lib\dpif-netdev.c	/^    struct ovs_mutex mutex;          \/* Protects 'n'. *\/$/;"	m	struct:dp_netdev_stats	typeref:struct:dp_netdev_stats::ovs_mutex	file:
mutex	.\lib\dpif-netdev.c	/^    struct ovs_mutex mutex;         \/* Guards all the other members. *\/$/;"	m	struct:dp_netdev_flow_stats	typeref:struct:dp_netdev_flow_stats::ovs_mutex	file:
mutex	.\lib\dpif-netdev.c	/^    struct ovs_mutex mutex;$/;"	m	struct:dp_netdev_flow_iter	typeref:struct:dp_netdev_flow_iter::ovs_mutex	file:
mutex	.\lib\dpif-netdev.c	/^    struct ovs_mutex mutex;$/;"	m	struct:dp_netdev_queue	typeref:struct:dp_netdev_queue::ovs_mutex	file:
mutex	.\lib\fat-rwlock.c	/^    struct ovs_mutex mutex;$/;"	m	struct:fat_rwlock_slot	typeref:struct:fat_rwlock_slot::ovs_mutex	file:
mutex	.\lib\fat-rwlock.h	/^    struct ovs_mutex mutex;$/;"	m	struct:fat_rwlock	typeref:struct:fat_rwlock::ovs_mutex
mutex	.\lib\fatal-signal.c	/^static struct ovs_mutex mutex;$/;"	v	typeref:struct:ovs_mutex	file:
mutex	.\lib\guarded-list.h	/^    struct ovs_mutex mutex;$/;"	m	struct:guarded_list	typeref:struct:guarded_list::ovs_mutex
mutex	.\lib\lacp.c	/^    OVS_REQUIRES(mutex);$/;"	v
mutex	.\lib\lacp.c	/^static struct list *const all_lacps OVS_GUARDED_BY(mutex) = &all_lacps__;$/;"	v	file:
mutex	.\lib\lacp.c	/^static struct ovs_mutex mutex;$/;"	v	typeref:struct:ovs_mutex	file:
mutex	.\lib\lacp.c	/^static void lacp_update_attached(struct lacp *) OVS_REQUIRES(mutex);$/;"	v
mutex	.\lib\lacp.c	/^static void slave_destroy(struct slave *) OVS_REQUIRES(mutex);$/;"	v
mutex	.\lib\lacp.c	/^static void slave_set_defaulted(struct slave *) OVS_REQUIRES(mutex);$/;"	v
mutex	.\lib\lacp.c	/^static void slave_set_expired(struct slave *) OVS_REQUIRES(mutex);$/;"	v
mutex	.\lib\netdev-bsd.c	/^    struct ovs_mutex mutex;$/;"	m	struct:netdev_bsd	typeref:struct:netdev_bsd::ovs_mutex	file:
mutex	.\lib\netdev-linux.c	/^    struct ovs_mutex mutex;$/;"	m	struct:netdev_linux	typeref:struct:netdev_linux::ovs_mutex	file:
mutex	.\lib\netdev-vport.c	/^    struct ovs_mutex mutex;$/;"	m	struct:netdev_vport	typeref:struct:netdev_vport::ovs_mutex	file:
mutex	.\lib\netlink-socket.h	/^    struct ovs_mutex mutex;$/;"	m	struct:nl_dump	typeref:struct:nl_dump::ovs_mutex
mutex	.\lib\ovs-rcu.c	/^    struct ovs_mutex mutex;$/;"	m	struct:ovsrcu_perthread	typeref:struct:ovsrcu_perthread::ovs_mutex	file:
mutex	.\lib\ovs-thread.h	/^    OVS_ACQUIRES(mutex);$/;"	v
mutex	.\lib\ovs-thread.h	/^    struct ovs_mutex mutex;$/;"	m	struct:ovsthread_once	typeref:struct:ovsthread_once::ovs_mutex
mutex	.\lib\ovs-thread.h	/^    struct ovs_mutex mutex;$/;"	m	struct:ovsthread_stats	typeref:struct:ovsthread_stats::ovs_mutex
mutex	.\lib\ovs-thread.h	/^void ovs_mutex_unlock(const struct ovs_mutex *mutex) OVS_RELEASES(mutex);$/;"	v
mutex	.\lib\rconn.c	/^    struct ovs_mutex mutex;$/;"	m	struct:rconn	typeref:struct:rconn::ovs_mutex	file:
mutex	.\lib\rconn.h	/^    struct ovs_mutex mutex;$/;"	m	struct:rconn_packet_counter	typeref:struct:rconn_packet_counter::ovs_mutex
mutex	.\lib\stp.c	/^                                const struct stp_port *) OVS_REQUIRES(mutex);$/;"	v
mutex	.\lib\stp.c	/^    OVS_REQUIRES(mutex);$/;"	v
mutex	.\lib\stp.c	/^static struct list *const all_stps OVS_GUARDED_BY(mutex) = &all_stps__;$/;"	v	file:
mutex	.\lib\stp.c	/^static struct ovs_mutex mutex;$/;"	v	typeref:struct:ovs_mutex	file:
mutex	.\lib\stp.c	/^static void stp_become_root_bridge(struct stp *) OVS_REQUIRES(mutex);$/;"	v
mutex	.\lib\stp.c	/^static void stp_config_bpdu_generation(struct stp *) OVS_REQUIRES(mutex);$/;"	v
mutex	.\lib\stp.c	/^static void stp_configuration_update(struct stp *) OVS_REQUIRES(mutex);$/;"	v
mutex	.\lib\stp.c	/^static void stp_designated_port_selection(struct stp *) OVS_REQUIRES(mutex);$/;"	v
mutex	.\lib\stp.c	/^static void stp_hello_timer_expiry(struct stp *) OVS_REQUIRES(mutex);$/;"	v
mutex	.\lib\stp.c	/^static void stp_hold_timer_expiry(struct stp_port *) OVS_REQUIRES(mutex);$/;"	v
mutex	.\lib\stp.c	/^static void stp_make_blocking(struct stp_port *) OVS_REQUIRES(mutex);$/;"	v
mutex	.\lib\stp.c	/^static void stp_make_forwarding(struct stp_port *) OVS_REQUIRES(mutex);$/;"	v
mutex	.\lib\stp.c	/^static void stp_port_state_selection(struct stp *) OVS_REQUIRES(mutex);$/;"	v
mutex	.\lib\stp.c	/^static void stp_root_selection(struct stp *) OVS_REQUIRES(mutex);$/;"	v
mutex	.\lib\stp.c	/^static void stp_tcn_timer_expiry(struct stp *) OVS_REQUIRES(mutex);$/;"	v
mutex	.\lib\stp.c	/^static void stp_topology_change_detection(struct stp *) OVS_REQUIRES(mutex);$/;"	v
mutex	.\lib\stp.c	/^static void stp_transmit_config(struct stp_port *) OVS_REQUIRES(mutex);$/;"	v
mutex	.\lib\stp.c	/^static void stp_transmit_tcn(struct stp *) OVS_REQUIRES(mutex);$/;"	v
mutex	.\lib\stp.c	/^static void stp_update_bridge_timers(struct stp *) OVS_REQUIRES(mutex);$/;"	v
mutex	.\lib\timeval.c	/^    struct ovs_mutex mutex;$/;"	m	struct:clock	typeref:struct:clock::ovs_mutex	file:
mutex	.\lib\vlog.h	/^    struct ovs_mutex mutex;     \/* Mutual exclusion for rate limit. *\/$/;"	m	struct:vlog_rate_limit	typeref:struct:vlog_rate_limit::ovs_mutex
mutex	.\ofproto\netflow.c	/^    OVS_REQUIRES(mutex);$/;"	v
mutex	.\ofproto\netflow.c	/^static struct ovs_mutex mutex = OVS_MUTEX_INITIALIZER;$/;"	v	typeref:struct:ovs_mutex	file:
mutex	.\ofproto\netflow.c	/^static void netflow_run__(struct netflow *) OVS_REQUIRES(mutex);$/;"	v
mutex	.\ofproto\ofproto-dpif-ipfix.c	/^static struct ovs_mutex mutex = OVS_MUTEX_INITIALIZER;$/;"	v	typeref:struct:ovs_mutex	file:
mutex	.\ofproto\ofproto-dpif-sflow.c	/^static struct ovs_mutex mutex;$/;"	v	typeref:struct:ovs_mutex	file:
mutex	.\ofproto\ofproto-dpif-upcall.c	/^        struct ovs_mutex mutex;        \/* Guards the following. *\/$/;"	m	struct:udpif::__anon135	typeref:struct:udpif::__anon135::ovs_mutex	file:
mutex	.\ofproto\ofproto-dpif-upcall.c	/^    struct ovs_mutex mutex;                   \/* Guards the following. *\/$/;"	m	struct:udpif_key	typeref:struct:udpif_key::ovs_mutex	file:
mutex	.\vswitchd\system-stats.c	/^static struct ovs_mutex mutex = OVS_MUTEX_INITIALIZER;$/;"	v	typeref:struct:ovs_mutex	file:
mutex_for_pointer	.\lib\ovs-atomic-locked.c	/^    OVS_ACQUIRES(mutex_for_pointer(p))$/;"	f
mutex_for_pointer	.\lib\ovs-atomic-locked.c	/^    OVS_RELEASES(mutex_for_pointer(p))$/;"	f
mutex_for_pointer	.\lib\ovs-atomic-locked.c	/^mutex_for_pointer(void *p)$/;"	f	file:
myIP	.\lib\sflow_api.h	/^    SFLAddress myIP;        \/* IP address of this node *\/$/;"	m	struct:_SFLAgent
myReceiver	.\lib\sflow_api.h	/^    SFLReceiver *myReceiver;$/;"	m	struct:_SFLPoller
myReceiver	.\lib\sflow_api.h	/^    SFLReceiver *myReceiver;$/;"	m	struct:_SFLSampler
my_disc	.\lib\bfd.c	/^    ovs_be32 my_disc;     \/* My discriminator. *\/$/;"	m	struct:msg	file:
n	.\lib\guarded-list.h	/^    size_t n;$/;"	m	struct:guarded_list
n	.\lib\heap.h	/^    size_t n;                   \/* Number of nodes currently in the heap. *\/$/;"	m	struct:heap
n	.\lib\hmap.h	/^    size_t n;$/;"	m	struct:hmap
n	.\lib\json.h	/^    size_t n, n_allocated;$/;"	m	struct:json_array
n	.\lib\netlink-socket.c	/^    int n;$/;"	m	struct:nl_pool	file:
n	.\lib\ovsdb-data.h	/^    unsigned int n;             \/* Number of 'keys' and 'values'. *\/$/;"	m	struct:ovsdb_datum
n	.\lib\svec.h	/^    size_t n;$/;"	m	struct:svec
n	.\ofproto\ofproto-provider.h	/^    size_t n;                   \/* Number of rules collected. *\/$/;"	m	struct:rule_collection
n	.\ofproto\ofproto.h	/^        size_t n;$/;"	m	struct:ofproto_controller_info::__anon148
n	.\ofproto\pinsched.c	/^    int n;                      \/* Number of packets in 'packets'. *\/$/;"	m	struct:pinqueue	file:
n_add	.\ofproto\connmgr.c	/^    int n_add, n_delete, n_modify; \/* Number of unreported ops of each kind. *\/$/;"	m	struct:ofconn	file:
n_all	.\ofproto\ofproto-dpif-sflow.c	/^    size_t n_flood, n_all;$/;"	m	struct:dpif_sflow	file:
n_allocated	.\lib\json.h	/^    size_t n, n_allocated;$/;"	m	struct:json_array
n_attempted_connections	.\lib\rconn.c	/^    unsigned int n_attempted_connections, n_successful_connections;$/;"	m	struct:rconn	file:
n_attempted_connections	.\lib\reconnect.c	/^    unsigned int n_attempted_connections, n_successful_connections;$/;"	m	struct:reconnect	file:
n_attempted_connections	.\lib\reconnect.h	/^    unsigned int n_attempted_connections;$/;"	m	struct:reconnect_stats
n_ba	.\tests\idltest.h	/^	size_t n_ba;$/;"	m	struct:idltest_simple
n_bands	.\lib\ofp-util.h	/^    uint16_t n_bands;$/;"	m	struct:ofputil_meter_config
n_bands	.\lib\ofp-util.h	/^    uint16_t n_bands;$/;"	m	struct:ofputil_meter_stats
n_bands	.\ofproto\ofproto.c	/^    uint16_t n_bands;           \/* Number of meter bands. *\/$/;"	m	struct:meter	file:
n_batches	.\utilities\ovs-benchmark.c	/^static int n_batches = 1;$/;"	v	file:
n_bits	.\include\openflow\nicira-ext.h	/^    ovs_be16 n_bits;                \/* (n_bits + 1) bits of the field. *\/$/;"	m	struct:nx_action_stack
n_bits	.\include\openflow\nicira-ext.h	/^    ovs_be16 n_bits;                \/* Number of bits. *\/$/;"	m	struct:nx_action_reg_move
n_bits	.\lib\meta-flow.h	/^    unsigned int n_bits;        \/* Number of bits. *\/$/;"	m	struct:mf_subfield
n_bits	.\lib\meta-flow.h	/^    unsigned int n_bits;        \/* Number of significant bits in field. *\/$/;"	m	struct:mf_field
n_bits	.\lib\ofp-actions.h	/^    int n_bits;                 \/* Number of bits in source and dest. *\/$/;"	m	struct:ofpact_learn_spec
n_bridges	.\lib\vswitch-idl.h	/^	size_t n_bridges;$/;"	m	struct:ovsrec_open_vswitch
n_bridges	.\tests\test-stp.c	/^    int n_bridges;$/;"	m	struct:test_case	file:
n_buckets	.\datapath\flow_table.h	/^	unsigned int n_buckets;$/;"	m	struct:table_instance
n_buckets	.\lib\ofp-util.h	/^    uint32_t n_buckets;$/;"	m	struct:ofputil_group_stats
n_buckets	.\ofproto\ofproto-provider.h	/^    uint32_t n_buckets;$/;"	m	struct:ofgroup
n_buffers	.\include\openflow\openflow-common.h	/^    ovs_be32 n_buffers;     \/* Max packets buffered at once. *\/$/;"	m	struct:ofp_switch_features
n_buffers	.\lib\ofp-util.h	/^    uint32_t n_buffers;         \/* Max packets buffered at once. *\/$/;"	m	struct:ofputil_switch_features
n_bytes	.\include\linux\openvswitch.h	/^	__u64 n_bytes;           \/* Number of matched bytes. *\/$/;"	m	struct:ovs_flow_stats
n_bytes	.\lib\dpif.h	/^    uint64_t n_bytes;$/;"	m	struct:dpif_flow_stats
n_bytes	.\lib\meta-flow.h	/^    unsigned int n_bytes;       \/* Width of the field in bytes. *\/$/;"	m	struct:mf_field
n_cache_active_timeout	.\lib\vswitch-idl.h	/^	size_t n_cache_active_timeout;$/;"	m	struct:ovsrec_ipfix
n_cache_max_flows	.\lib\vswitch-idl.h	/^	size_t n_cache_max_flows;$/;"	m	struct:ovsrec_ipfix
n_cbs	.\lib\ovs-rcu.c	/^    int n_cbs;$/;"	m	struct:ovsrcu_cbset	file:
n_cfm_fault	.\lib\vswitch-idl.h	/^	size_t n_cfm_fault;$/;"	m	struct:ovsrec_interface
n_cfm_fault_status	.\lib\vswitch-idl.h	/^	size_t n_cfm_fault_status;$/;"	m	struct:ovsrec_interface
n_cfm_flap_count	.\lib\vswitch-idl.h	/^	size_t n_cfm_flap_count;$/;"	m	struct:ovsrec_interface
n_cfm_health	.\lib\vswitch-idl.h	/^	size_t n_cfm_health;$/;"	m	struct:ovsrec_interface
n_cfm_mpid	.\lib\vswitch-idl.h	/^	size_t n_cfm_mpid;$/;"	m	struct:ovsrec_interface
n_cfm_remote_mpids	.\lib\vswitch-idl.h	/^	size_t n_cfm_remote_mpids;$/;"	m	struct:ovsrec_interface
n_clauses	.\ovsdb\condition.h	/^    size_t n_clauses;$/;"	m	struct:ovsdb_condition
n_columns	.\lib\ovsdb-idl-provider.h	/^    size_t n_columns;$/;"	m	struct:ovsdb_idl_table_class
n_columns	.\lib\table.h	/^    size_t n_columns, allocated_columns;$/;"	m	struct:table
n_columns	.\ovsdb\column.h	/^    size_t n_columns, allocated_columns;$/;"	m	struct:ovsdb_column_set
n_columns	.\ovsdb\jsonrpc-server.c	/^    size_t n_columns;$/;"	m	struct:ovsdb_jsonrpc_monitor_table	file:
n_columns	.\ovsdb\ovsdb-client.c	/^    size_t n_columns;$/;"	m	struct:dump_table_aux	file:
n_commands	.\tests\ovstest.c	/^static size_t n_commands = 0;$/;"	v	file:
n_connections	.\ovsdb\jsonrpc-server.h	/^    int n_connections;$/;"	m	struct:ovsdb_jsonrpc_remote_status
n_conns	.\lib\memory.c	/^static size_t n_conns;$/;"	v	file:
n_conns	.\tests\test-stp.c	/^    int n_conns;$/;"	m	struct:lan	file:
n_controller	.\lib\vswitch-idl.h	/^	size_t n_controller;$/;"	m	struct:ovsrec_bridge
n_controller_burst_limit	.\lib\vswitch-idl.h	/^	size_t n_controller_burst_limit;$/;"	m	struct:ovsrec_controller
n_controller_rate_limit	.\lib\vswitch-idl.h	/^	size_t n_controller_rate_limit;$/;"	m	struct:ovsrec_controller
n_controllers	.\include\openflow\nicira-ext.h	/^    ovs_be16 n_controllers;     \/* Number of controllers. *\/$/;"	m	struct:nx_action_cnt_ids
n_controllers	.\lib\ofp-actions.h	/^    unsigned int n_controllers;$/;"	m	struct:ofpact_cnt_ids
n_coverage_counters	.\lib\coverage.c	/^static size_t n_coverage_counters = 0;$/;"	v	file:
n_criteria	.\utilities\ovs-ofctl.c	/^static size_t n_criteria, allocated_criteria;$/;"	v	file:
n_default_flows	.\lib\learning-switch.c	/^    size_t n_default_flows;$/;"	m	struct:lswitch	file:
n_default_flows	.\lib\learning-switch.h	/^    size_t n_default_flows;$/;"	m	struct:lswitch_config
n_default_flows	.\tests\test-controller.c	/^static size_t n_default_flows;$/;"	v	file:
n_delete	.\ofproto\connmgr.c	/^    int n_add, n_delete, n_modify; \/* Number of unreported ops of each kind. *\/$/;"	m	struct:ofconn	file:
n_dropped	.\lib\vlog.h	/^    unsigned int n_dropped;     \/* Number of messages dropped. *\/$/;"	m	struct:vlog_rate_limit
n_dscp	.\lib\vswitch-idl.h	/^	size_t n_dscp;$/;"	m	struct:ovsrec_queue
n_dsts	.\ofproto\ofproto.h	/^    size_t n_dsts;$/;"	m	struct:ofproto_mirror_settings
n_enable_async_messages	.\lib\vswitch-idl.h	/^	size_t n_enable_async_messages;$/;"	m	struct:ovsrec_controller
n_engine_id	.\lib\vswitch-idl.h	/^	size_t n_engine_id;$/;"	m	struct:ovsrec_netflow
n_engine_type	.\lib\vswitch-idl.h	/^	size_t n_engine_type;$/;"	m	struct:ovsrec_netflow
n_events	.\lib\dpif-linux.c	/^    int n_events;                 \/* Num events returned by epoll_wait(). *\/$/;"	m	struct:dpif_handler	file:
n_eviction_fields	.\ofproto\ofproto-provider.h	/^    size_t n_eviction_fields;$/;"	m	struct:oftable
n_extra_remotes	.\ofproto\connmgr.c	/^    size_t n_extra_remotes;$/;"	m	struct:connmgr	file:
n_fds	.\ofproto\collectors.c	/^    size_t n_fds;                 \/* Number of sockets. *\/$/;"	m	struct:collectors	file:
n_flood	.\ofproto\ofproto-dpif-sflow.c	/^    size_t n_flood, n_all;$/;"	m	struct:dpif_sflow	file:
n_flood_vlans	.\lib\vswitch-idl.h	/^	size_t n_flood_vlans;$/;"	m	struct:ovsrec_bridge
n_flow_limit	.\lib\vswitch-idl.h	/^	size_t n_flow_limit;$/;"	m	struct:ovsrec_flow_table
n_flow_segments	.\lib\classifier.c	/^    uint8_t n_flow_segments;$/;"	m	struct:cls_classifier	file:
n_flow_tables	.\lib\vswitch-idl.h	/^	size_t n_flow_tables;$/;"	m	struct:ovsrec_bridge
n_flows	.\include\linux\openvswitch.h	/^	__u64 n_flows;           \/* Number of flows present *\/$/;"	m	struct:ovs_dp_stats
n_flows	.\lib\dpif.h	/^    uint64_t n_flows;           \/* Number of flows present. *\/$/;"	m	struct:dpif_dp_stats
n_flows	.\ofproto\ofproto-dpif-upcall.c	/^    atomic_ulong n_flows;           \/* Number of flows in the datapath. *\/$/;"	m	struct:udpif	file:
n_flows_mutex	.\ofproto\ofproto-dpif-upcall.c	/^    struct ovs_mutex n_flows_mutex;$/;"	m	struct:udpif	typeref:struct:udpif::ovs_mutex	file:
n_flows_timestamp	.\ofproto\ofproto-dpif-upcall.c	/^    atomic_llong n_flows_timestamp;    \/* Last time n_flows was updated. *\/$/;"	m	struct:udpif	file:
n_frames	.\lib\backtrace.h	/^    int n_frames;$/;"	m	struct:backtrace
n_from_json	.\lib\ovsdb-types.c	/^n_from_json(const struct json *json, unsigned int *n)$/;"	f	file:
n_groups	.\lib\vswitch-idl.h	/^	size_t n_groups;$/;"	m	struct:ovsrec_flow_table
n_groups	.\ofproto\ofproto.h	/^    size_t n_groups;$/;"	m	struct:ofproto_table_settings
n_handlers	.\lib\dpif-linux.c	/^    uint32_t n_handlers;           \/* Num of upcall handlers. *\/$/;"	m	struct:dpif_linux	file:
n_handlers	.\lib\dpif-netdev.c	/^    uint32_t n_handlers;$/;"	m	struct:dp_netdev	file:
n_handlers	.\ofproto\ofproto-dpif-upcall.c	/^    size_t n_handlers;$/;"	m	struct:udpif	file:
n_handlers	.\ofproto\ofproto.c	/^size_t n_handlers, n_revalidators;$/;"	v
n_head	.\lib\stream-ssl.c	/^    short int n_head;$/;"	m	struct:ssl_stream	file:
n_header	.\lib\vswitch-idl.h	/^	size_t n_header;$/;"	m	struct:ovsrec_sflow
n_hit	.\datapath\datapath.h	/^	u64 n_hit;$/;"	m	struct:dp_stats_percpu
n_hit	.\include\linux\openvswitch.h	/^	__u64 n_hit;             \/* Number of flow table matches. *\/$/;"	m	struct:ovs_dp_stats
n_hit	.\lib\dpif.h	/^    uint64_t n_hit;             \/* Number of flow table matches. *\/$/;"	m	struct:dpif_dp_stats
n_hooks	.\lib\fatal-signal.c	/^static size_t n_hooks;$/;"	v	file:
n_ia	.\tests\idltest.h	/^	size_t n_ia;$/;"	m	struct:idltest_simple
n_ids	.\datapath\vport.h	/^	u32 n_ids;$/;"	m	struct:vport_portids
n_ids	.\ofproto\ofproto-dpif-rid.c	/^    uint32_t n_ids;        \/* Total number of ids in the pool. *\/$/;"	m	struct:rid_pool	file:
n_ifindex	.\lib\vswitch-idl.h	/^	size_t n_ifindex;$/;"	m	struct:ovsrec_interface
n_inactivity_probe	.\lib\vswitch-idl.h	/^	size_t n_inactivity_probe;$/;"	m	struct:ovsrec_controller
n_inactivity_probe	.\lib\vswitch-idl.h	/^	size_t n_inactivity_probe;$/;"	m	struct:ovsrec_manager
n_inactivity_probe	.\lib\vtep-idl.h	/^	size_t n_inactivity_probe;$/;"	m	struct:vteprec_manager
n_indexes	.\ovsdb\table.h	/^    size_t n_indexes;$/;"	m	struct:ovsdb_table_schema
n_indices	.\lib\classifier.c	/^    uint8_t n_indices;           \/* How many indices to use. *\/$/;"	m	struct:cls_subtable	file:
n_interfaces	.\lib\vswitch-idl.h	/^	size_t n_interfaces;$/;"	m	struct:ovsrec_port
n_ka	.\tests\idltest.h	/^	size_t n_ka;$/;"	m	struct:idltest_link1
n_lacp_current	.\lib\vswitch-idl.h	/^	size_t n_lacp_current;$/;"	m	struct:ovsrec_interface
n_lans	.\tests\test-stp.c	/^    int n_lans;$/;"	m	struct:test_case	file:
n_limited	.\ofproto\pinsched.c	/^    unsigned long long n_limited;       \/* # queued for rate limiting. *\/$/;"	m	struct:pinsched	file:
n_link_resets	.\lib\vswitch-idl.h	/^	size_t n_link_resets;$/;"	m	struct:ovsrec_interface
n_link_speed	.\lib\vswitch-idl.h	/^	size_t n_link_speed;$/;"	m	struct:ovsrec_interface
n_locators	.\lib\vtep-idl.h	/^	size_t n_locators;$/;"	m	struct:vteprec_physical_locator_set
n_lost	.\datapath\datapath.h	/^	u64 n_lost;$/;"	m	struct:dp_stats_percpu
n_lost	.\include\linux\openvswitch.h	/^	__u64 n_lost;            \/* Number of misses not sent to userspace. *\/$/;"	m	struct:ovs_dp_stats
n_lost	.\lib\dpif.h	/^    uint64_t n_lost;            \/* Number of misses not sent to userspace. *\/$/;"	m	struct:dpif_dp_stats
n_management_ips	.\lib\vtep-idl.h	/^	size_t n_management_ips;$/;"	m	struct:vteprec_physical_switch
n_manager_options	.\lib\vswitch-idl.h	/^	size_t n_manager_options;$/;"	m	struct:ovsrec_open_vswitch
n_managers	.\lib\vtep-idl.h	/^	size_t n_managers;$/;"	m	struct:vteprec_global
n_mask_hit	.\datapath\datapath.h	/^	u64 n_mask_hit;$/;"	m	struct:dp_stats_percpu
n_mask_hit	.\include\linux\openvswitch.h	/^	__u64 n_mask_hit;	 \/* Number of masks used for flow lookups. *\/$/;"	m	struct:ovs_dp_megaflow_stats
n_mask_hit	.\lib\dpif.h	/^    uint64_t n_mask_hit;        \/* Number of mega flow masks visited for$/;"	m	struct:dpif_dp_stats
n_masks	.\include\linux\openvswitch.h	/^	__u32 n_masks;		 \/* Number of masks for the datapath. *\/$/;"	m	struct:ovs_dp_megaflow_stats
n_masks	.\lib\dpif.h	/^    uint32_t n_masks;           \/* Number of mega flow masks. *\/$/;"	m	struct:dpif_dp_stats
n_matches	.\ovsdb\execution.c	/^    size_t n_matches;$/;"	m	struct:delete_row_cbdata	file:
n_matches	.\ovsdb\execution.c	/^    size_t n_matches;$/;"	m	struct:mutate_row_cbdata	file:
n_matches	.\ovsdb\execution.c	/^    size_t n_matches;$/;"	m	struct:update_row_cbdata	file:
n_max	.\lib\ovsdb-types.h	/^    unsigned int n_max;         \/* UINT_MAX stands in for "unlimited". *\/$/;"	m	struct:ovsdb_type
n_max_backoff	.\lib\vswitch-idl.h	/^	size_t n_max_backoff;$/;"	m	struct:ovsrec_controller
n_max_backoff	.\lib\vswitch-idl.h	/^	size_t n_max_backoff;$/;"	m	struct:ovsrec_manager
n_max_backoff	.\lib\vtep-idl.h	/^	size_t n_max_backoff;$/;"	m	struct:vteprec_manager
n_mcgrps	.\datapath\linux\compat\include\net\genetlink.h	/^	unsigned int            n_mcgrps;       \/* private *\/$/;"	m	struct:rpl_genl_family
n_min	.\lib\ovsdb-types.h	/^    unsigned int n_min;$/;"	m	struct:ovsdb_type
n_mirrors	.\lib\vswitch-idl.h	/^	size_t n_mirrors;$/;"	m	struct:ovsrec_bridge
n_missed	.\datapath\datapath.h	/^	u64 n_missed;$/;"	m	struct:dp_stats_percpu
n_missed	.\include\linux\openvswitch.h	/^	__u64 n_missed;          \/* Number of flow table misses. *\/$/;"	m	struct:ovs_dp_stats
n_missed	.\lib\dpif.h	/^    uint64_t n_missed;          \/* Number of flow table misses. *\/$/;"	m	struct:dpif_dp_stats
n_modify	.\ofproto\connmgr.c	/^    int n_add, n_delete, n_modify; \/* Number of unreported ops of each kind. *\/$/;"	m	struct:ofconn	file:
n_monitors	.\lib\rconn.c	/^    size_t n_monitors;$/;"	m	struct:rconn	file:
n_mtu	.\lib\vswitch-idl.h	/^	size_t n_mtu;$/;"	m	struct:ovsrec_interface
n_mutations	.\ovsdb\mutation.h	/^    size_t n_mutations;$/;"	m	struct:ovsdb_mutation_set
n_neoteric_ifaces	.\utilities\ovs-vsctl.c	/^static size_t n_neoteric_ifaces;$/;"	v	file:
n_normal	.\ofproto\pinsched.c	/^    unsigned long long n_normal;        \/* # txed w\/o rate limit queuing. *\/$/;"	m	struct:pinsched	file:
n_obs_domain_id	.\lib\vswitch-idl.h	/^	size_t n_obs_domain_id;$/;"	m	struct:ovsrec_ipfix
n_obs_point_id	.\lib\vswitch-idl.h	/^	size_t n_obs_point_id;$/;"	m	struct:ovsrec_ipfix
n_ofport	.\lib\vswitch-idl.h	/^	size_t n_ofport;$/;"	m	struct:ovsrec_interface
n_ofport_request	.\lib\vswitch-idl.h	/^	size_t n_ofport_request;$/;"	m	struct:ovsrec_interface
n_ofproto_classes	.\ofproto\ofproto.c	/^static size_t n_ofproto_classes;$/;"	v	file:
n_ops	.\datapath\linux\compat\include\net\genetlink.h	/^	unsigned int            n_ops;          \/* private *\/$/;"	m	struct:rpl_genl_family
n_output_vlan	.\lib\vswitch-idl.h	/^	size_t n_output_vlan;$/;"	m	struct:ovsrec_mirror
n_packets	.\include\linux\openvswitch.h	/^	__u64 n_packets;         \/* Number of matched packets. *\/$/;"	m	struct:ovs_flow_stats
n_packets	.\lib\dpif.h	/^    uint64_t n_packets;$/;"	m	struct:dpif_flow_stats
n_packets	.\lib\vconn-stream.c	/^    int n_packets;$/;"	m	struct:vconn_stream	file:
n_pmd_threads	.\lib\dpif-netdev.c	/^    size_t n_pmd_threads;$/;"	m	struct:dp_netdev	file:
n_polling	.\lib\vswitch-idl.h	/^	size_t n_polling;$/;"	m	struct:ovsrec_sflow
n_port_fault_status	.\lib\vtep-idl.h	/^	size_t n_port_fault_status;$/;"	m	struct:vteprec_physical_port
n_ports	.\lib\vswitch-idl.h	/^	size_t n_ports;$/;"	m	struct:ovsrec_bridge
n_ports	.\lib\vtep-idl.h	/^	size_t n_ports;$/;"	m	struct:vteprec_physical_switch
n_ports	.\tests\test-stp.c	/^    int n_ports;$/;"	m	struct:bridge	file:
n_prefix_fields	.\ofproto\ofproto.h	/^    unsigned int n_prefix_fields;$/;"	m	struct:ofproto_table_settings
n_prefixes	.\lib\vswitch-idl.h	/^	size_t n_prefixes;$/;"	m	struct:ovsrec_flow_table
n_processed	.\ovsdb\transaction.c	/^    unsigned int n_processed;   \/* Number of rows processed. *\/$/;"	m	struct:ovsdb_txn_table	file:
n_protocols	.\lib\vswitch-idl.h	/^	size_t n_protocols;$/;"	m	struct:ovsrec_bridge
n_qdscp	.\ofproto\ofproto-dpif.c	/^    size_t n_qdscp;$/;"	m	struct:ofport_dpif	file:
n_queue_dropped	.\ofproto\pinsched.c	/^    unsigned long long n_queue_dropped; \/* # dropped due to queue overflow. *\/$/;"	m	struct:pinsched	file:
n_queued	.\ofproto\pinsched.c	/^    int n_queued;               \/* Sum over queues[*].n. *\/$/;"	m	struct:pinsched	file:
n_queues	.\lib\netdev-linux.c	/^    size_t n_queues;$/;"	m	struct:netdev_linux_queue_state	file:
n_queues	.\lib\netdev-linux.c	/^    unsigned int n_queues;$/;"	m	struct:tc_ops	file:
n_queues	.\lib\netdev.h	/^    unsigned int n_queues;$/;"	m	struct:netdev_qos_capabilities
n_queues	.\lib\vswitch-idl.h	/^	size_t n_queues;$/;"	m	struct:ovsrec_qos
n_ra	.\tests\idltest.h	/^	size_t n_ra;$/;"	m	struct:idltest_simple
n_recs	.\vswitchd\bridge.c	/^static size_t n_recs, allocated_recs;$/;"	v	file:
n_refs	.\ovsdb\row.h	/^    size_t n_refs;$/;"	m	struct:ovsdb_row
n_refs	.\ovsdb\transaction.c	/^    size_t n_refs;              \/* Number of remaining references. *\/$/;"	m	struct:ovsdb_txn_row	file:
n_remotes	.\ofproto\in-band.c	/^    size_t n_remotes;$/;"	m	struct:in_band	file:
n_revalidators	.\ofproto\ofproto-dpif-upcall.c	/^    size_t n_revalidators;$/;"	m	struct:udpif	file:
n_revalidators	.\ofproto\ofproto.c	/^size_t n_handlers, n_revalidators;$/;"	v
n_rmps	.\ofproto\ofproto.h	/^    size_t n_rmps;$/;"	m	struct:ofproto_cfm_status
n_rows	.\lib\table.h	/^    size_t n_rows, allocated_rows;$/;"	m	struct:table
n_rows	.\ovsdb\row.h	/^    size_t n_rows, allocated_rows;$/;"	m	struct:ovsdb_row_set
n_rows	.\tests\test-ovsdb.c	/^    size_t n_rows;$/;"	m	struct:do_query_cbdata	file:
n_rules	.\lib\classifier.c	/^    int n_rules;                \/* Number of rules, including duplicates. *\/$/;"	m	struct:cls_subtable	file:
n_rules	.\lib\classifier.c	/^    int n_rules;                \/* Total number of rules. *\/$/;"	m	struct:cls_classifier	file:
n_rules	.\lib\classifier.c	/^    unsigned int n_rules;      \/* Number of rules that have this prefix. *\/$/;"	m	struct:trie_node	file:
n_rules	.\tests\test-classifier.c	/^    size_t n_rules;$/;"	m	struct:tcls	file:
n_running	.\ofproto\ofproto.c	/^    int n_running;              \/* Number of ops still pending. *\/$/;"	m	struct:ofopgroup	file:
n_rxq	.\lib\netdev-provider.h	/^    int n_rxq;$/;"	m	struct:netdev
n_sa	.\tests\idltest.h	/^	size_t n_sa;$/;"	m	struct:idltest_simple
n_sampling	.\lib\vswitch-idl.h	/^	size_t n_sampling;$/;"	m	struct:ovsrec_ipfix
n_sampling	.\lib\vswitch-idl.h	/^	size_t n_sampling;$/;"	m	struct:ovsrec_sflow
n_select_dst_port	.\lib\vswitch-idl.h	/^	size_t n_select_dst_port;$/;"	m	struct:ovsrec_mirror
n_select_src_port	.\lib\vswitch-idl.h	/^	size_t n_select_src_port;$/;"	m	struct:ovsrec_mirror
n_select_vlan	.\lib\vswitch-idl.h	/^	size_t n_select_vlan;$/;"	m	struct:ovsrec_mirror
n_sessions	.\ovsdb\jsonrpc-server.c	/^    unsigned int n_sessions, max_sessions;$/;"	m	struct:ovsdb_jsonrpc_server	file:
n_slaves	.\include\openflow\nicira-ext.h	/^    ovs_be16 n_slaves;          \/* Number of slaves. *\/$/;"	m	struct:nx_action_bundle
n_slaves	.\lib\ofp-actions.h	/^    unsigned int n_slaves;$/;"	m	struct:ofpact_bundle
n_slaves	.\ofproto\ofproto.h	/^    size_t n_slaves;$/;"	m	struct:ofproto_bundle_settings
n_slaves	.\tests\test-bundle.c	/^    size_t n_slaves;$/;"	m	struct:slave_group	file:
n_snoops	.\ofproto\connmgr.c	/^    size_t n_snoops;$/;"	m	struct:connmgr	file:
n_sockets	.\utilities\ovs-benchmark.c	/^static int n_sockets = 100;$/;"	v	file:
n_specs	.\lib\ofp-actions.h	/^    unsigned int n_specs;$/;"	m	struct:ofpact_learn
n_srcs	.\ofproto\ofproto.h	/^    size_t n_srcs;$/;"	m	struct:ofproto_mirror_settings
n_statistics	.\lib\vswitch-idl.h	/^	size_t n_statistics;$/;"	m	struct:ovsrec_interface
n_statistics	.\lib\vswitch-idl.h	/^	size_t n_statistics;$/;"	m	struct:ovsrec_mirror
n_statistics	.\lib\vswitch-idl.h	/^	size_t n_statistics;$/;"	m	struct:ovsrec_port
n_streams	.\lib\netdev-dummy.c	/^    size_t n_streams;$/;"	m	struct:dummy_packet_pconn	file:
n_successful_connections	.\lib\rconn.c	/^    unsigned int n_attempted_connections, n_successful_connections;$/;"	m	struct:rconn	file:
n_successful_connections	.\lib\reconnect.c	/^    unsigned int n_attempted_connections, n_successful_connections;$/;"	m	struct:reconnect	file:
n_successful_connections	.\lib\reconnect.h	/^    unsigned int n_successful_connections;$/;"	m	struct:reconnect_stats
n_switch_binding	.\lib\vtep-idl.h	/^	size_t n_switch_binding;$/;"	m	struct:vteprec_logical_router
n_switch_fault_status	.\lib\vtep-idl.h	/^	size_t n_switch_fault_status;$/;"	m	struct:vteprec_physical_switch
n_switches	.\lib\vtep-idl.h	/^	size_t n_switches;$/;"	m	struct:vteprec_global
n_tables	.\include\openflow\openflow-common.h	/^    uint8_t n_tables;       \/* Number of tables supported by datapath. *\/$/;"	m	struct:ofp_switch_features
n_tables	.\lib\ofp-util.h	/^    uint8_t n_tables;           \/* Number of tables supported by datapath. *\/$/;"	m	struct:ofputil_switch_features
n_tables	.\lib\ovsdb-idl-provider.h	/^    size_t n_tables;$/;"	m	struct:ovsdb_idl_class
n_tables	.\ofproto\ofproto-provider.h	/^    int n_tables;$/;"	m	struct:ofproto
n_tag	.\lib\vswitch-idl.h	/^	size_t n_tag;$/;"	m	struct:ovsrec_port
n_targets	.\lib\vswitch-idl.h	/^	size_t n_targets;$/;"	m	struct:ovsrec_ipfix
n_targets	.\lib\vswitch-idl.h	/^	size_t n_targets;$/;"	m	struct:ovsrec_netflow
n_targets	.\lib\vswitch-idl.h	/^	size_t n_targets;$/;"	m	struct:ovsrec_sflow
n_transactions	.\ovsdb\file.c	/^    unsigned int n_transactions;$/;"	m	struct:ovsdb_file	file:
n_tries	.\lib\classifier.c	/^    unsigned int n_tries;$/;"	m	struct:cls_classifier	file:
n_trunks	.\lib\vswitch-idl.h	/^	size_t n_trunks;$/;"	m	struct:ovsrec_port
n_tunnel_ips	.\lib\vtep-idl.h	/^	size_t n_tunnel_ips;$/;"	m	struct:vteprec_physical_switch
n_tunnel_key	.\lib\vtep-idl.h	/^	size_t n_tunnel_key;$/;"	m	struct:vteprec_logical_switch
n_tunnels	.\lib\vtep-idl.h	/^	size_t n_tunnels;$/;"	m	struct:vteprec_physical_switch
n_txq	.\ofproto\pinsched.c	/^    int n_txq;                  \/* No. of packets waiting in rconn for tx. *\/$/;"	m	struct:pinsched	file:
n_ua	.\tests\idltest.h	/^	size_t n_ua;$/;"	m	struct:idltest_simple
n_unique	.\lib\hindex.h	/^    size_t n_unique;  \/* Number of unique hashes (the number of head nodes). *\/$/;"	m	struct:hindex
n_upcall_pids	.\lib\dpif-linux.h	/^    uint32_t n_upcall_pids;$/;"	m	struct:dpif_linux_vport
n_vlan_bindings	.\lib\vtep-idl.h	/^	size_t n_vlan_bindings;$/;"	m	struct:vteprec_physical_port
n_vlan_stats	.\lib\vtep-idl.h	/^	size_t n_vlan_stats;$/;"	m	struct:vteprec_physical_port
n_warnings	.\tests\test-stp.c	/^static int n_warnings;$/;"	v	file:
name	.\datapath\linux\compat\include\net\genetlink.h	/^	char                    name[GENL_NAMSIZ];$/;"	m	struct:rpl_genl_family
name	.\datapath\vport-lisp.c	/^	char name[IFNAMSIZ];$/;"	m	struct:lisp_port	file:
name	.\datapath\vport-vxlan.c	/^	char name[IFNAMSIZ];$/;"	m	struct:vxlan_port	file:
name	.\datapath\vport.h	/^	const char *name;$/;"	m	struct:vport_parms
name	.\include\openflow\openflow-1.0.h	/^    char name[OFP_MAX_PORT_NAME_LEN]; \/* Null-terminated *\/$/;"	m	struct:ofp10_phy_port
name	.\include\openflow\openflow-1.0.h	/^    char name[OFP_MAX_TABLE_NAME_LEN];$/;"	m	struct:ofp10_table_stats
name	.\include\openflow\openflow-1.1.h	/^    char name[OFP_MAX_PORT_NAME_LEN]; \/* Null-terminated *\/$/;"	m	struct:ofp11_port
name	.\include\openflow\openflow-1.1.h	/^    char name[OFP_MAX_TABLE_NAME_LEN];$/;"	m	struct:ofp11_table_stats
name	.\include\openflow\openflow-1.2.h	/^    char name[OFP_MAX_TABLE_NAME_LEN];$/;"	m	struct:ofp12_table_stats
name	.\include\openflow\openflow-1.3.h	/^    char name[OFP_MAX_TABLE_NAME_LEN];$/;"	m	struct:ofp13_action_self_learning::ofp13_table_features
name	.\include\openflow\openflow-1.4.h	/^    char name[OFP_MAX_PORT_NAME_LEN]; \/* Null-terminated *\/$/;"	m	struct:ofp14_port
name	.\include\windows\getopt.h	/^	const char *name;$/;"	m	struct:option
name	.\lib\bfd.c	/^    char *name;                   \/* Name used for logging. *\/$/;"	m	struct:bfd	file:
name	.\lib\cfm.c	/^    const char *name;           \/* Name of this CFM object. *\/$/;"	m	struct:cfm	file:
name	.\lib\command-line.h	/^    const char *name;$/;"	m	struct:command
name	.\lib\coverage.h	/^    const char *const name;            \/* Textual name. *\/$/;"	m	struct:coverage_counter
name	.\lib\dpif-linux.c	/^    const char *name;                  \/* OVS_DP_ATTR_NAME. *\/$/;"	m	struct:dpif_linux_dp	file:
name	.\lib\dpif-linux.h	/^    const char *name;                      \/* OVS_VPORT_ATTR_NAME. *\/$/;"	m	struct:dpif_linux_vport
name	.\lib\dpif-netdev.c	/^    char *name;$/;"	m	struct:dp_netdev_port_state	file:
name	.\lib\dpif-netdev.c	/^    const char *const name;$/;"	m	struct:dp_netdev	file:
name	.\lib\dpif.h	/^    char *name;                 \/* Network device name, e.g. "eth0". *\/$/;"	m	struct:dpif_port
name	.\lib\jsonrpc.c	/^    char *name;$/;"	m	struct:jsonrpc	file:
name	.\lib\lacp.c	/^    char *name;                   \/* Name of this lacp object. *\/$/;"	m	struct:lacp	file:
name	.\lib\lacp.c	/^    char *name;                   \/* Name of this slave. *\/$/;"	m	struct:slave	file:
name	.\lib\lacp.h	/^    char *name;                       \/* Name (for debugging). *\/$/;"	m	struct:lacp_settings
name	.\lib\lacp.h	/^    char *name;                       \/* Name (for debugging). *\/$/;"	m	struct:lacp_slave_settings
name	.\lib\lockfile.c	/^    char *name;$/;"	m	struct:lockfile	file:
name	.\lib\meta-flow.c	/^    const char *name;$/;"	m	struct:frag_handling	file:
name	.\lib\meta-flow.h	/^    const char *name;           \/* Name of this field, e.g. "eth_type". *\/$/;"	m	struct:mf_field
name	.\lib\netdev-provider.h	/^    char *name;                         \/* Name of network device. *\/$/;"	m	struct:netdev
name	.\lib\netlink-socket.c	/^    char *name;$/;"	m	struct:genl_family	file:
name	.\lib\odp-util.h	/^    char *name;                 \/* Name associated with the above 'port_no'. *\/$/;"	m	struct:odp_portno_names
name	.\lib\ofp-actions.c	/^    const char *name;$/;"	m	struct:instruction_type_info	file:
name	.\lib\ofp-msgs.c	/^    const char *name;$/;"	m	struct:raw_info	file:
name	.\lib\ofp-parse.c	/^    const char *name;$/;"	m	struct:protocol	file:
name	.\lib\ofp-util.c	/^    const char *name;$/;"	m	struct:proto_abbrev	file:
name	.\lib\ofp-util.h	/^    char name[OFP_MAX_PORT_NAME_LEN];$/;"	m	struct:ofputil_phy_port
name	.\lib\ofp-util.h	/^    char name[OFP_MAX_TABLE_NAME_LEN];$/;"	m	struct:ofputil_table_features
name	.\lib\ovs-rcu.c	/^    char name[16];              \/* This thread's name. *\/$/;"	m	struct:ovsrcu_perthread	file:
name	.\lib\ovs-thread.c	/^    char name[16];$/;"	m	struct:ovsthread_aux	file:
name	.\lib\ovsdb-idl-provider.h	/^    char *name;$/;"	m	struct:ovsdb_idl_column
name	.\lib\ovsdb-idl-provider.h	/^    char *name;$/;"	m	struct:ovsdb_idl_table_class
name	.\lib\ovsdb-parser.h	/^    char *name;                 \/* Used only in error messages. *\/$/;"	m	struct:ovsdb_parser
name	.\lib\process.c	/^    char *name;$/;"	m	struct:process	file:
name	.\lib\rconn.c	/^    char *name;                 \/* Human-readable descriptive name. *\/$/;"	m	struct:rconn	file:
name	.\lib\reconnect.c	/^    char *name;$/;"	m	struct:reconnect	file:
name	.\lib\shash.h	/^    char *name;$/;"	m	struct:shash_node
name	.\lib\simap.h	/^    char *name;$/;"	m	struct:simap_node
name	.\lib\sset.h	/^    char name[1];$/;"	m	struct:sset_node
name	.\lib\stp.c	/^    char *name;                     \/* Human-readable name for log messages. *\/$/;"	m	struct:stp	file:
name	.\lib\stream-provider.h	/^    char *name;$/;"	m	struct:pstream
name	.\lib\stream-provider.h	/^    char *name;$/;"	m	struct:stream
name	.\lib\stream-provider.h	/^    const char *name;$/;"	m	struct:pstream_class
name	.\lib\stream-provider.h	/^    const char *name;$/;"	m	struct:stream_class
name	.\lib\vconn-provider.h	/^    char *name;$/;"	m	struct:pvconn
name	.\lib\vconn-provider.h	/^    char *name;$/;"	m	struct:vconn
name	.\lib\vconn-provider.h	/^    const char *name;$/;"	m	struct:pvconn_class
name	.\lib\vconn-provider.h	/^    const char *name;$/;"	m	struct:vconn_class
name	.\lib\vlandev.h	/^    char *name;                     \/* VLAN device name, e.g. "eth0.10". *\/$/;"	m	struct:vlan_dev
name	.\lib\vlandev.h	/^    char *name;                 \/* Name, e.g. "eth0". *\/$/;"	m	struct:vlan_real_dev
name	.\lib\vlog.c	/^    const char *name;           \/* Name. *\/$/;"	m	struct:facility	file:
name	.\lib\vlog.h	/^    const char *name;             \/* User-visible name. *\/$/;"	m	struct:vlog_module
name	.\lib\vswitch-idl.h	/^	char *name;	\/* Always nonnull. *\/$/;"	m	struct:ovsrec_bridge
name	.\lib\vswitch-idl.h	/^	char *name;	\/* Always nonnull. *\/$/;"	m	struct:ovsrec_interface
name	.\lib\vswitch-idl.h	/^	char *name;	\/* Always nonnull. *\/$/;"	m	struct:ovsrec_mirror
name	.\lib\vswitch-idl.h	/^	char *name;	\/* Always nonnull. *\/$/;"	m	struct:ovsrec_port
name	.\lib\vswitch-idl.h	/^	char *name;$/;"	m	struct:ovsrec_flow_table
name	.\lib\vtep-idl.h	/^	char *name;	\/* Always nonnull. *\/$/;"	m	struct:vteprec_logical_router
name	.\lib\vtep-idl.h	/^	char *name;	\/* Always nonnull. *\/$/;"	m	struct:vteprec_logical_switch
name	.\lib\vtep-idl.h	/^	char *name;	\/* Always nonnull. *\/$/;"	m	struct:vteprec_physical_port
name	.\lib\vtep-idl.h	/^	char *name;	\/* Always nonnull. *\/$/;"	m	struct:vteprec_physical_switch
name	.\ofproto\bond.c	/^    char *name;                 \/* Name (a copy of netdev_get_name(netdev)). *\/$/;"	m	struct:bond_slave	file:
name	.\ofproto\bond.c	/^    char *name;                 \/* Name provided by client. *\/$/;"	m	struct:bond	file:
name	.\ofproto\bond.h	/^    char *name;                 \/* Bond's name, for log messages. *\/$/;"	m	struct:bond_settings
name	.\ofproto\connmgr.c	/^    char *name;$/;"	m	struct:connmgr	file:
name	.\ofproto\ofproto-dpif-xlate.c	/^    char *name;                    \/* Name used in log messages. *\/$/;"	m	struct:xbundle	file:
name	.\ofproto\ofproto-dpif-xlate.c	/^    char *name;                   \/* Name used in log messages. *\/$/;"	m	struct:xbridge	file:
name	.\ofproto\ofproto-dpif.c	/^    char *name;                 \/* Identifier for log messages. *\/$/;"	m	struct:ofbundle	file:
name	.\ofproto\ofproto-provider.h	/^    char *name;                 \/* Datapath name. *\/$/;"	m	struct:ofproto
name	.\ofproto\ofproto-provider.h	/^    char *name;                 \/* Table name exposed via OpenFlow, or NULL. *\/$/;"	m	struct:oftable
name	.\ofproto\ofproto.h	/^    char *name;                 \/* For use in log messages. *\/$/;"	m	struct:ofproto_bundle_settings
name	.\ofproto\ofproto.h	/^    char *name;                 \/* Name exported via OpenFlow or NULL. *\/$/;"	m	struct:ofproto_table_settings
name	.\ofproto\ofproto.h	/^    char *name;                 \/* Network device name, e.g. "eth0". *\/$/;"	m	struct:ofproto_port
name	.\ofproto\ofproto.h	/^    char *name;$/;"	m	struct:ofproto_mirror_settings
name	.\ovsdb\column.h	/^    char *name;$/;"	m	struct:ovsdb_column
name	.\ovsdb\log.c	/^    char *name;$/;"	m	struct:ovsdb_log	file:
name	.\ovsdb\ovsdb-client.c	/^    const char *name;$/;"	m	struct:ovsdb_client_command	file:
name	.\ovsdb\ovsdb.h	/^    char *name;$/;"	m	struct:ovsdb_schema
name	.\ovsdb\server.h	/^    char *name;                  \/* Unique name. *\/$/;"	m	struct:ovsdb_lock
name	.\ovsdb\table.h	/^    char *name;$/;"	m	struct:ovsdb_table_schema
name	.\python\ovs\reconnect.py	/^        name = "ACTIVE"$/;"	v	class:Reconnect.Active
name	.\python\ovs\reconnect.py	/^        name = "BACKOFF"$/;"	v	class:Reconnect.Backoff
name	.\python\ovs\reconnect.py	/^        name = "CONNECTING"$/;"	v	class:Reconnect.ConnectInProgress
name	.\python\ovs\reconnect.py	/^        name = "IDLE"$/;"	v	class:Reconnect.Idle
name	.\python\ovs\reconnect.py	/^        name = "LISTENING"$/;"	v	class:Reconnect.Listening
name	.\python\ovs\reconnect.py	/^        name = "RECONNECT"$/;"	v	class:Reconnect.Reconnect
name	.\python\ovs\reconnect.py	/^        name = "VOID"$/;"	v	class:Reconnect.Void
name	.\tests\test-classifier.c	/^    const char *name;           \/* Name (for debugging). *\/$/;"	m	struct:cls_field	file:
name	.\tests\test-lockfile.c	/^    const char *name;$/;"	m	struct:test	file:
name	.\tests\test-stp.c	/^    const char *name;$/;"	m	struct:lan	file:
name	.\utilities\ovs-vsctl.c	/^    char *name;$/;"	m	struct:vsctl_bridge	file:
name	.\utilities\ovs-vsctl.c	/^    const char *name;           \/* e.g. "add-br" *\/$/;"	m	struct:vsctl_command_syntax	file:
name	.\vswitchd\bridge.c	/^    char *name;                 \/* Host network device name. *\/$/;"	m	struct:iface	file:
name	.\vswitchd\bridge.c	/^    char *name;                 \/* User-specified arbitrary name. *\/$/;"	m	struct:bridge	file:
name	.\vswitchd\bridge.c	/^    char *name;$/;"	m	struct:mirror	file:
name	.\vswitchd\bridge.c	/^    char *name;$/;"	m	struct:port	file:
name	.\vswitchd\system-stats.c	/^    char name[18];              \/* Name (surrounded by parentheses). *\/$/;"	m	struct:raw_process_info	file:
name	.\vtep\vtep-ctl.c	/^    char *name;$/;"	m	struct:vtep_ctl_lswitch	file:
name	.\vtep\vtep-ctl.c	/^    char *name;$/;"	m	struct:vtep_ctl_pswitch	file:
name	.\vtep\vtep-ctl.c	/^    const char *name;           \/* e.g. "add-ps" *\/$/;"	m	struct:vtep_ctl_command_syntax	file:
name_column	.\utilities\ovs-vsctl.c	/^    const struct ovsdb_idl_column *name_column;$/;"	m	struct:cmd_show_table	typeref:struct:cmd_show_table::ovsdb_idl_column	file:
name_column	.\utilities\ovs-vsctl.c	/^    const struct ovsdb_idl_column *name_column;$/;"	m	struct:vsctl_row_id	typeref:struct:vsctl_row_id::ovsdb_idl_column	file:
name_column	.\vtep\vtep-ctl.c	/^    const struct ovsdb_idl_column *name_column;$/;"	m	struct:vtep_ctl_row_id	typeref:struct:vtep_ctl_row_id::ovsdb_idl_column	file:
name_map	.\lib\route-table.c	/^static struct hmap name_map;$/;"	v	typeref:struct:hmap	file:
name_map_clear	.\lib\route-table.c	/^name_map_clear(void)$/;"	f	file:
name_node	.\lib\route-table.c	/^struct name_node {$/;"	s	file:
name_node	.\vswitchd\bridge.c	/^    struct hmap_node name_node; \/* In struct bridge's "iface_by_name" hmap. *\/$/;"	m	struct:iface	typeref:struct:iface::hmap_node	file:
name_node_lookup	.\lib\route-table.c	/^name_node_lookup(int ifi_index)$/;"	f	file:
name_notifier	.\lib\route-table.c	/^static struct nln_notifier *name_notifier = NULL;$/;"	v	typeref:struct:nln_notifier	file:
name_table_change	.\lib\route-table.c	/^name_table_change(const struct rtnetlink_link_change *change OVS_UNUSED,$/;"	f	file:
name_table_init	.\lib\route-table.c	/^name_table_init(void)$/;"	f	file:
name_table_reset	.\lib\route-table.c	/^name_table_reset(void)$/;"	f	file:
name_table_uninit	.\lib\route-table.c	/^name_table_uninit(void)$/;"	f	file:
name_table_valid	.\lib\route-table.c	/^static bool name_table_valid = false;$/;"	v	file:
names	.\lib\ofp-util.c	/^static const char *const names[OFPUTIL_N_ACTIONS] = {$/;"	v	file:
names	.\lib\svec.h	/^    char **names;$/;"	m	struct:svec
nat	.\lib\sflow.h	/^    SFLExtended_nat nat;$/;"	m	union:_SFLFlow_type
natEncodingLength	.\lib\sflow_receiver.c	/^inline static u_int32_t natEncodingLength(SFLExtended_nat *nat) {$/;"	f	file:
nbits	.\lib\classifier.c	/^    uint8_t  nbits;            \/* Never zero, except for the root node. *\/$/;"	m	struct:trie_node	file:
nd	.\datapath\flow.h	/^			} nd;$/;"	m	struct:sw_flow_key::__anon5::__anon9	typeref:struct:sw_flow_key::__anon5::__anon9::__anon11
nd_na_cksum	.\include\windows\netinet\icmp6.h	259;"	d
nd_na_code	.\include\windows\netinet\icmp6.h	258;"	d
nd_na_flags_reserved	.\include\windows\netinet\icmp6.h	260;"	d
nd_na_hdr	.\include\windows\netinet\icmp6.h	/^	struct icmp6_hdr	nd_na_hdr;$/;"	m	struct:nd_neighbor_advert	typeref:struct:nd_neighbor_advert::icmp6_hdr
nd_na_target	.\include\windows\netinet\icmp6.h	/^	struct in6_addr		nd_na_target;	\/* target address *\/$/;"	m	struct:nd_neighbor_advert	typeref:struct:nd_neighbor_advert::in6_addr
nd_na_type	.\include\windows\netinet\icmp6.h	257;"	d
nd_neighbor_advert	.\include\windows\netinet\icmp6.h	/^struct nd_neighbor_advert {	\/* neighbor advertisement *\/$/;"	s
nd_neighbor_solicit	.\include\windows\netinet\icmp6.h	/^struct nd_neighbor_solicit {	\/* neighbor solicitation *\/$/;"	s
nd_ns_cksum	.\include\windows\netinet\icmp6.h	248;"	d
nd_ns_code	.\include\windows\netinet\icmp6.h	247;"	d
nd_ns_hdr	.\include\windows\netinet\icmp6.h	/^	struct icmp6_hdr	nd_ns_hdr;$/;"	m	struct:nd_neighbor_solicit	typeref:struct:nd_neighbor_solicit::icmp6_hdr
nd_ns_reserved	.\include\windows\netinet\icmp6.h	249;"	d
nd_ns_target	.\include\windows\netinet\icmp6.h	/^	struct in6_addr		nd_ns_target;	\/*target address *\/$/;"	m	struct:nd_neighbor_solicit	typeref:struct:nd_neighbor_solicit::in6_addr
nd_ns_type	.\include\windows\netinet\icmp6.h	246;"	d
nd_opt_dnssl	.\include\windows\netinet\icmp6.h	/^struct nd_opt_dnssl {		\/* DNSSL option RFC 6106 *\/$/;"	s
nd_opt_dnssl_len	.\include\windows\netinet\icmp6.h	/^	u_int8_t	nd_opt_dnssl_len;$/;"	m	struct:nd_opt_dnssl
nd_opt_dnssl_lifetime	.\include\windows\netinet\icmp6.h	/^	u_int32_t	nd_opt_dnssl_lifetime;$/;"	m	struct:nd_opt_dnssl
nd_opt_dnssl_reserved	.\include\windows\netinet\icmp6.h	/^	u_int16_t	nd_opt_dnssl_reserved;$/;"	m	struct:nd_opt_dnssl
nd_opt_dnssl_type	.\include\windows\netinet\icmp6.h	/^	u_int8_t	nd_opt_dnssl_type;$/;"	m	struct:nd_opt_dnssl
nd_opt_hdr	.\include\windows\netinet\icmp6.h	/^struct nd_opt_hdr {		\/* Neighbor discovery option header *\/$/;"	s
nd_opt_len	.\include\windows\netinet\icmp6.h	/^	u_int8_t	nd_opt_len;$/;"	m	struct:nd_opt_hdr
nd_opt_mtu	.\include\windows\netinet\icmp6.h	/^struct nd_opt_mtu {		\/* MTU option *\/$/;"	s
nd_opt_mtu_len	.\include\windows\netinet\icmp6.h	/^	u_int8_t	nd_opt_mtu_len;$/;"	m	struct:nd_opt_mtu
nd_opt_mtu_mtu	.\include\windows\netinet\icmp6.h	/^	u_int32_t	nd_opt_mtu_mtu;$/;"	m	struct:nd_opt_mtu
nd_opt_mtu_reserved	.\include\windows\netinet\icmp6.h	/^	u_int16_t	nd_opt_mtu_reserved;$/;"	m	struct:nd_opt_mtu
nd_opt_mtu_type	.\include\windows\netinet\icmp6.h	/^	u_int8_t	nd_opt_mtu_type;$/;"	m	struct:nd_opt_mtu
nd_opt_pi_flags_reserved	.\include\windows\netinet\icmp6.h	/^	u_int8_t	nd_opt_pi_flags_reserved;$/;"	m	struct:nd_opt_prefix_info
nd_opt_pi_len	.\include\windows\netinet\icmp6.h	/^	u_int8_t	nd_opt_pi_len;$/;"	m	struct:nd_opt_prefix_info
nd_opt_pi_preferred_time	.\include\windows\netinet\icmp6.h	/^	u_int32_t	nd_opt_pi_preferred_time;$/;"	m	struct:nd_opt_prefix_info
nd_opt_pi_prefix	.\include\windows\netinet\icmp6.h	/^	struct in6_addr	nd_opt_pi_prefix;$/;"	m	struct:nd_opt_prefix_info	typeref:struct:nd_opt_prefix_info::in6_addr
nd_opt_pi_prefix_len	.\include\windows\netinet\icmp6.h	/^	u_int8_t	nd_opt_pi_prefix_len;$/;"	m	struct:nd_opt_prefix_info
nd_opt_pi_reserved2	.\include\windows\netinet\icmp6.h	/^	u_int32_t	nd_opt_pi_reserved2;$/;"	m	struct:nd_opt_prefix_info
nd_opt_pi_type	.\include\windows\netinet\icmp6.h	/^	u_int8_t	nd_opt_pi_type;$/;"	m	struct:nd_opt_prefix_info
nd_opt_pi_valid_time	.\include\windows\netinet\icmp6.h	/^	u_int32_t	nd_opt_pi_valid_time;$/;"	m	struct:nd_opt_prefix_info
nd_opt_prefix_info	.\include\windows\netinet\icmp6.h	/^struct nd_opt_prefix_info {	\/* prefix information *\/$/;"	s
nd_opt_rd_hdr	.\include\windows\netinet\icmp6.h	/^struct nd_opt_rd_hdr {		\/* redirected header *\/$/;"	s
nd_opt_rdnss	.\include\windows\netinet\icmp6.h	/^struct nd_opt_rdnss {		\/* RDNSS option RFC 6106 *\/$/;"	s
nd_opt_rdnss_len	.\include\windows\netinet\icmp6.h	/^	u_int8_t	nd_opt_rdnss_len;$/;"	m	struct:nd_opt_rdnss
nd_opt_rdnss_lifetime	.\include\windows\netinet\icmp6.h	/^	u_int32_t	nd_opt_rdnss_lifetime;$/;"	m	struct:nd_opt_rdnss
nd_opt_rdnss_reserved	.\include\windows\netinet\icmp6.h	/^	u_int16_t	nd_opt_rdnss_reserved;$/;"	m	struct:nd_opt_rdnss
nd_opt_rdnss_type	.\include\windows\netinet\icmp6.h	/^	u_int8_t	nd_opt_rdnss_type;$/;"	m	struct:nd_opt_rdnss
nd_opt_rh_len	.\include\windows\netinet\icmp6.h	/^	u_int8_t	nd_opt_rh_len;$/;"	m	struct:nd_opt_rd_hdr
nd_opt_rh_reserved1	.\include\windows\netinet\icmp6.h	/^	u_int16_t	nd_opt_rh_reserved1;$/;"	m	struct:nd_opt_rd_hdr
nd_opt_rh_reserved2	.\include\windows\netinet\icmp6.h	/^	u_int32_t	nd_opt_rh_reserved2;$/;"	m	struct:nd_opt_rd_hdr
nd_opt_rh_type	.\include\windows\netinet\icmp6.h	/^	u_int8_t	nd_opt_rh_type;$/;"	m	struct:nd_opt_rd_hdr
nd_opt_route_info	.\include\windows\netinet\icmp6.h	/^struct nd_opt_route_info {	\/* route info *\/$/;"	s
nd_opt_rti_flags	.\include\windows\netinet\icmp6.h	/^	u_int8_t	nd_opt_rti_flags;$/;"	m	struct:nd_opt_route_info
nd_opt_rti_len	.\include\windows\netinet\icmp6.h	/^	u_int8_t	nd_opt_rti_len;$/;"	m	struct:nd_opt_route_info
nd_opt_rti_lifetime	.\include\windows\netinet\icmp6.h	/^	u_int32_t	nd_opt_rti_lifetime;$/;"	m	struct:nd_opt_route_info
nd_opt_rti_prefixlen	.\include\windows\netinet\icmp6.h	/^	u_int8_t	nd_opt_rti_prefixlen;$/;"	m	struct:nd_opt_route_info
nd_opt_rti_type	.\include\windows\netinet\icmp6.h	/^	u_int8_t	nd_opt_rti_type;$/;"	m	struct:nd_opt_route_info
nd_opt_type	.\include\windows\netinet\icmp6.h	/^	u_int8_t	nd_opt_type;$/;"	m	struct:nd_opt_hdr
nd_ra_cksum	.\include\windows\netinet\icmp6.h	221;"	d
nd_ra_code	.\include\windows\netinet\icmp6.h	220;"	d
nd_ra_curhoplimit	.\include\windows\netinet\icmp6.h	222;"	d
nd_ra_flags_reserved	.\include\windows\netinet\icmp6.h	223;"	d
nd_ra_hdr	.\include\windows\netinet\icmp6.h	/^	struct icmp6_hdr	nd_ra_hdr;$/;"	m	struct:nd_router_advert	typeref:struct:nd_router_advert::icmp6_hdr
nd_ra_reachable	.\include\windows\netinet\icmp6.h	/^	u_int32_t		nd_ra_reachable;	\/* reachable time *\/$/;"	m	struct:nd_router_advert
nd_ra_retransmit	.\include\windows\netinet\icmp6.h	/^	u_int32_t		nd_ra_retransmit;	\/* retransmit timer *\/$/;"	m	struct:nd_router_advert
nd_ra_router_lifetime	.\include\windows\netinet\icmp6.h	238;"	d
nd_ra_type	.\include\windows\netinet\icmp6.h	219;"	d
nd_rd_cksum	.\include\windows\netinet\icmp6.h	274;"	d
nd_rd_code	.\include\windows\netinet\icmp6.h	273;"	d
nd_rd_dst	.\include\windows\netinet\icmp6.h	/^	struct in6_addr		nd_rd_dst;	\/* destination address *\/$/;"	m	struct:nd_redirect	typeref:struct:nd_redirect::in6_addr
nd_rd_hdr	.\include\windows\netinet\icmp6.h	/^	struct icmp6_hdr	nd_rd_hdr;$/;"	m	struct:nd_redirect	typeref:struct:nd_redirect::icmp6_hdr
nd_rd_reserved	.\include\windows\netinet\icmp6.h	275;"	d
nd_rd_target	.\include\windows\netinet\icmp6.h	/^	struct in6_addr		nd_rd_target;	\/* target address *\/$/;"	m	struct:nd_redirect	typeref:struct:nd_redirect::in6_addr
nd_rd_type	.\include\windows\netinet\icmp6.h	272;"	d
nd_redirect	.\include\windows\netinet\icmp6.h	/^struct nd_redirect {		\/* redirect *\/$/;"	s
nd_router_advert	.\include\windows\netinet\icmp6.h	/^struct nd_router_advert {	\/* router advertisement *\/$/;"	s
nd_router_solicit	.\include\windows\netinet\icmp6.h	/^struct nd_router_solicit {	\/* router solicitation *\/$/;"	s
nd_rs_cksum	.\include\windows\netinet\icmp6.h	209;"	d
nd_rs_code	.\include\windows\netinet\icmp6.h	208;"	d
nd_rs_hdr	.\include\windows\netinet\icmp6.h	/^	struct icmp6_hdr 	nd_rs_hdr;$/;"	m	struct:nd_router_solicit	typeref:struct:nd_router_solicit::icmp6_hdr
nd_rs_reserved	.\include\windows\netinet\icmp6.h	210;"	d
nd_rs_type	.\include\windows\netinet\icmp6.h	207;"	d
nd_sll	.\include\linux\openvswitch.h	/^	__u8  nd_sll[ETH_ALEN];$/;"	m	struct:ovs_key_nd
nd_target	.\include\linux\openvswitch.h	/^	__u32 nd_target[4];$/;"	m	struct:ovs_key_nd
nd_target	.\lib\flow.h	/^    struct in6_addr nd_target;  \/* IPv6 neighbor discovery (ND) target. *\/$/;"	m	struct:flow	typeref:struct:flow::in6_addr
nd_tll	.\include\linux\openvswitch.h	/^	__u8  nd_tll[ETH_ALEN];$/;"	m	struct:ovs_key_nd
nd_to_iff_flags	.\lib\netdev-bsd.c	/^nd_to_iff_flags(enum netdev_flags nd)$/;"	f	file:
nd_to_iff_flags	.\lib\netdev-linux.c	/^nd_to_iff_flags(enum netdev_flags nd)$/;"	f	file:
need	.\ovsdb\ovsdb-client.c	/^    enum args_needed need;$/;"	m	struct:ovsdb_client_command	typeref:enum:ovsdb_client_command::args_needed	file:
need_revalidate	.\lib\mac-learning.h	/^    bool need_revalidate;$/;"	m	struct:mac_learning
need_revalidate	.\ofproto\ofproto-dpif-mirror.c	/^    bool need_revalidate;$/;"	m	struct:mbridge	file:
need_revalidate	.\ofproto\ofproto-dpif-upcall.c	/^    bool need_revalidate;              \/* As indicated by 'reval_seq'. *\/$/;"	m	struct:udpif	file:
need_revalidate	.\ofproto\ofproto-dpif.c	/^    enum revalidate_reason need_revalidate; \/* Revalidate all flows. *\/$/;"	m	struct:dpif_backer	typeref:enum:dpif_backer::revalidate_reason	file:
need_table	.\lib\ovsdb-idl-provider.h	/^    bool need_table;         \/* Monitor table even if no columns? *\/$/;"	m	struct:ovsdb_idl_table
needs_help	.\lib\dpif.h	/^    bool needs_help;$/;"	m	struct:dpif_execute
needs_probes	.\lib\stream-provider.h	/^    bool needs_probes;$/;"	m	struct:pstream_class
needs_probes	.\lib\stream-provider.h	/^    bool needs_probes;$/;"	m	struct:stream_class
negotiated	.\lib\lacp.c	/^    bool negotiated;         \/* True if LACP negotiations were successful. *\/$/;"	m	struct:lacp	file:
neoteric_ifaces	.\utilities\ovs-vsctl.c	/^static struct uuid *neoteric_ifaces;$/;"	v	typeref:struct:uuid	file:
net	.\datapath\datapath.h	/^	struct net *net;$/;"	m	struct:datapath	typeref:struct:datapath::net
net_alert_ratelimited	.\datapath\linux\compat\include\linux\net.h	16;"	d
net_crit_ratelimited	.\datapath\linux\compat\include\linux\net.h	18;"	d
net_dbg_ratelimited	.\datapath\linux\compat\include\linux\net.h	28;"	d
net_emerg_ratelimited	.\datapath\linux\compat\include\linux\net.h	14;"	d
net_err_ratelimited	.\datapath\linux\compat\include\linux\net.h	20;"	d
net_get_random_once	.\datapath\linux\compat\include\linux\net.h	39;"	d
net_gre_protocol	.\datapath\linux\compat\gre.c	/^static const struct net_protocol net_gre_protocol = {$/;"	v	typeref:struct:net_protocol	file:
net_info_ratelimited	.\datapath\linux\compat\include\linux\net.h	26;"	d
net_notice_ratelimited	.\datapath\linux\compat\include\linux\net.h	22;"	d
net_ratelimited_function	.\datapath\linux\compat\include\linux\net.h	8;"	d
net_warn_ratelimited	.\datapath\linux\compat\include\linux\net.h	24;"	d
netbios	.\python\compat\uuid.py	/^    import win32wnet, netbios$/;"	i
netdev	.\lib\bfd.c	/^    struct netdev *netdev;$/;"	m	struct:bfd	typeref:struct:bfd::netdev	file:
netdev	.\lib\cfm.c	/^    struct netdev *netdev;$/;"	m	struct:cfm	typeref:struct:cfm::netdev	file:
netdev	.\lib\dpif-netdev.c	/^    struct netdev *netdev;$/;"	m	struct:dp_netdev_port	typeref:struct:dp_netdev_port::netdev	file:
netdev	.\lib\netdev-provider.h	/^    struct netdev *netdev;      \/* Owns a reference to the netdev. *\/$/;"	m	struct:netdev_rxq	typeref:struct:netdev_rxq::netdev
netdev	.\lib\netdev-provider.h	/^struct netdev {$/;"	s
netdev	.\lib\netdev.c	/^    struct netdev *netdev;$/;"	m	struct:netdev_saved_flags	typeref:struct:netdev_saved_flags::netdev	file:
netdev	.\lib\netdev.c	/^VLOG_DEFINE_THIS_MODULE(netdev);$/;"	v
netdev	.\lib\netdev.h	/^    struct netdev *netdev;$/;"	m	struct:netdev_queue_dump	typeref:struct:netdev_queue_dump::netdev
netdev	.\ofproto\bond.c	/^    struct netdev *netdev;      \/* Network device, owned by the client. *\/$/;"	m	struct:bond_slave	typeref:struct:bond_slave::netdev	file:
netdev	.\ofproto\ofproto-dpif-xlate.c	/^    struct netdev *netdev;           \/* 'ofport''s netdev. *\/$/;"	m	struct:xport	typeref:struct:xport::netdev	file:
netdev	.\ofproto\ofproto-provider.h	/^    struct netdev *netdev;$/;"	m	struct:ofport	typeref:struct:ofport::netdev
netdev	.\ofproto\tunnel.c	/^    struct netdev *netdev;$/;"	m	struct:tnl_port	typeref:struct:tnl_port::netdev	file:
netdev	.\vswitchd\bridge.c	/^    struct netdev *netdev;      \/* Network device. *\/$/;"	m	struct:iface	typeref:struct:iface::netdev	file:
netdev_add_router	.\lib\netdev.c	/^COVERAGE_DEFINE(netdev_add_router);$/;"	v
netdev_add_router	.\lib\netdev.c	/^netdev_add_router(struct netdev *netdev, struct in_addr router)$/;"	f
netdev_arp_lookup	.\lib\netdev-linux.c	/^COVERAGE_DEFINE(netdev_arp_lookup);$/;"	v
netdev_arp_lookup	.\lib\netdev.c	/^netdev_arp_lookup(const struct netdev *netdev,$/;"	f
netdev_bsd	.\lib\netdev-bsd.c	/^VLOG_DEFINE_THIS_MODULE(netdev_bsd);$/;"	v
netdev_bsd	.\lib\netdev-bsd.c	/^struct netdev_bsd {$/;"	s	file:
netdev_bsd_alloc	.\lib\netdev-bsd.c	/^netdev_bsd_alloc(void)$/;"	f	file:
netdev_bsd_arp_lookup	.\lib\netdev-bsd.c	/^netdev_bsd_arp_lookup(const struct netdev *netdev OVS_UNUSED,$/;"	f	file:
netdev_bsd_cache_cb	.\lib\netdev-bsd.c	/^netdev_bsd_cache_cb(const struct rtbsd_change *change,$/;"	f	file:
netdev_bsd_cache_notifier	.\lib\netdev-bsd.c	/^static struct rtbsd_notifier netdev_bsd_cache_notifier;$/;"	v	typeref:struct:rtbsd_notifier	file:
netdev_bsd_cast	.\lib\netdev-bsd.c	/^netdev_bsd_cast(const struct netdev *netdev)$/;"	f	file:
netdev_bsd_class	.\lib\netdev-bsd.c	/^const struct netdev_class netdev_bsd_class =$/;"	v	typeref:struct:netdev_class
netdev_bsd_construct_system	.\lib\netdev-bsd.c	/^netdev_bsd_construct_system(struct netdev *netdev_)$/;"	f	file:
netdev_bsd_construct_tap	.\lib\netdev-bsd.c	/^netdev_bsd_construct_tap(struct netdev *netdev_)$/;"	f	file:
netdev_bsd_dealloc	.\lib\netdev-bsd.c	/^netdev_bsd_dealloc(struct netdev *netdev_)$/;"	f	file:
netdev_bsd_destruct	.\lib\netdev-bsd.c	/^netdev_bsd_destruct(struct netdev *netdev_)$/;"	f	file:
netdev_bsd_get_carrier	.\lib\netdev-bsd.c	/^netdev_bsd_get_carrier(const struct netdev *netdev_, bool *carrier)$/;"	f	file:
netdev_bsd_get_etheraddr	.\lib\netdev-bsd.c	/^netdev_bsd_get_etheraddr(const struct netdev *netdev_,$/;"	f	file:
netdev_bsd_get_features	.\lib\netdev-bsd.c	/^netdev_bsd_get_features(const struct netdev *netdev,$/;"	f	file:
netdev_bsd_get_ifindex	.\lib\netdev-bsd.c	/^netdev_bsd_get_ifindex(const struct netdev *netdev_)$/;"	f	file:
netdev_bsd_get_in4	.\lib\netdev-bsd.c	/^netdev_bsd_get_in4(const struct netdev *netdev_, struct in_addr *in4,$/;"	f	file:
netdev_bsd_get_in6	.\lib\netdev-bsd.c	/^netdev_bsd_get_in6(const struct netdev *netdev_, struct in6_addr *in6)$/;"	f	file:
netdev_bsd_get_mtu	.\lib\netdev-bsd.c	/^netdev_bsd_get_mtu(const struct netdev *netdev_, int *mtup)$/;"	f	file:
netdev_bsd_get_next_hop	.\lib\netdev-bsd.c	/^netdev_bsd_get_next_hop(const struct in_addr *host OVS_UNUSED,$/;"	f	file:
netdev_bsd_get_stats	.\lib\netdev-bsd.c	/^netdev_bsd_get_stats(const struct netdev *netdev_, struct netdev_stats *stats)$/;"	f	file:
netdev_bsd_kernel_name_to_ovs_name	.\lib\netdev-bsd.c	/^netdev_bsd_kernel_name_to_ovs_name(const char *kernel_name)$/;"	f	file:
netdev_bsd_open_pcap	.\lib\netdev-bsd.c	/^netdev_bsd_open_pcap(const char *name, pcap_t **pcapp, int *fdp)$/;"	f	file:
netdev_bsd_parse_media	.\lib\netdev-bsd.c	/^netdev_bsd_parse_media(int media)$/;"	f	file:
netdev_bsd_run	.\lib\netdev-bsd.c	/^netdev_bsd_run(void)$/;"	f	file:
netdev_bsd_rxq_alloc	.\lib\netdev-bsd.c	/^netdev_bsd_rxq_alloc(void)$/;"	f	file:
netdev_bsd_rxq_construct	.\lib\netdev-bsd.c	/^netdev_bsd_rxq_construct(struct netdev_rxq *rxq_)$/;"	f	file:
netdev_bsd_rxq_dealloc	.\lib\netdev-bsd.c	/^netdev_bsd_rxq_dealloc(struct netdev_rxq *rxq_)$/;"	f	file:
netdev_bsd_rxq_destruct	.\lib\netdev-bsd.c	/^netdev_bsd_rxq_destruct(struct netdev_rxq *rxq_)$/;"	f	file:
netdev_bsd_rxq_drain	.\lib\netdev-bsd.c	/^netdev_bsd_rxq_drain(struct netdev_rxq *rxq_)$/;"	f	file:
netdev_bsd_rxq_recv	.\lib\netdev-bsd.c	/^netdev_bsd_rxq_recv(struct netdev_rxq *rxq_, struct ofpbuf **packet, int *c)$/;"	f	file:
netdev_bsd_rxq_wait	.\lib\netdev-bsd.c	/^netdev_bsd_rxq_wait(struct netdev_rxq *rxq_)$/;"	f	file:
netdev_bsd_send	.\lib\netdev-bsd.c	/^netdev_bsd_send(struct netdev *netdev_, struct ofpbuf *pkt, bool may_steal)$/;"	f	file:
netdev_bsd_send_wait	.\lib\netdev-bsd.c	/^netdev_bsd_send_wait(struct netdev *netdev_)$/;"	f	file:
netdev_bsd_set_etheraddr	.\lib\netdev-bsd.c	/^netdev_bsd_set_etheraddr(struct netdev *netdev_,$/;"	f	file:
netdev_bsd_set_in4	.\lib\netdev-bsd.c	/^netdev_bsd_set_in4(struct netdev *netdev_, struct in_addr addr,$/;"	f	file:
netdev_bsd_update_flags	.\lib\netdev-bsd.c	/^netdev_bsd_update_flags(struct netdev *netdev_, enum netdev_flags off,$/;"	f	file:
netdev_bsd_wait	.\lib\netdev-bsd.c	/^netdev_bsd_wait(void)$/;"	f	file:
netdev_change_seq_changed	.\lib\netdev-provider.h	/^netdev_change_seq_changed(const struct netdev *netdev_)$/;"	f
netdev_class	.\lib\netdev-provider.h	/^    const struct netdev_class *netdev_class; \/* Functions to control$/;"	m	struct:netdev	typeref:struct:netdev::netdev_class
netdev_class	.\lib\netdev-provider.h	/^struct netdev_class {$/;"	s
netdev_class	.\lib\netdev-vport.c	/^    struct netdev_class netdev_class;$/;"	m	struct:vport_class	typeref:struct:vport_class::netdev_class	file:
netdev_class_mutex	.\lib\netdev.c	/^static struct hmap netdev_classes OVS_GUARDED_BY(netdev_class_mutex)$/;"	v	typeref:struct:OVS_GUARDED_BY	file:
netdev_create	.\datapath\vport-netdev.c	/^static struct vport *netdev_create(const struct vport_parms *parms)$/;"	f	file:
netdev_delete_queue	.\lib\netdev.c	/^netdev_delete_queue(struct netdev *netdev, unsigned int queue_id)$/;"	f
netdev_destroy	.\datapath\vport-netdev.c	/^static void netdev_destroy(struct vport *vport)$/;"	f	file:
netdev_down	.\xenserver\opt_xensource_libexec_InterfaceReconfigureBridge.py	/^def netdev_down(netdev):$/;"	f
netdev_down	.\xenserver\opt_xensource_libexec_InterfaceReconfigureVswitch.py	/^def netdev_down(netdev):$/;"	f
netdev_dpdk	.\lib\netdev-dpdk.c	/^struct netdev_dpdk {$/;"	s	file:
netdev_dpdk_alloc	.\lib\netdev-dpdk.c	/^netdev_dpdk_alloc(void)$/;"	f	file:
netdev_dpdk_cast	.\lib\netdev-dpdk.c	/^netdev_dpdk_cast(const struct netdev *netdev)$/;"	f	file:
netdev_dpdk_class	.\lib\netdev-dpdk.c	/^static struct netdev_class netdev_dpdk_class = {$/;"	v	typeref:struct:netdev_class	file:
netdev_dpdk_construct	.\lib\netdev-dpdk.c	/^netdev_dpdk_construct(struct netdev *netdev_)$/;"	f	file:
netdev_dpdk_dealloc	.\lib\netdev-dpdk.c	/^netdev_dpdk_dealloc(struct netdev *netdev_)$/;"	f	file:
netdev_dpdk_destruct	.\lib\netdev-dpdk.c	/^netdev_dpdk_destruct(struct netdev *netdev_)$/;"	f	file:
netdev_dpdk_get_carrier	.\lib\netdev-dpdk.c	/^netdev_dpdk_get_carrier(const struct netdev *netdev_, bool *carrier)$/;"	f	file:
netdev_dpdk_get_carrier_resets	.\lib\netdev-dpdk.c	/^netdev_dpdk_get_carrier_resets(const struct netdev *netdev_)$/;"	f	file:
netdev_dpdk_get_config	.\lib\netdev-dpdk.c	/^netdev_dpdk_get_config(const struct netdev *netdev_, struct smap *args)$/;"	f	file:
netdev_dpdk_get_etheraddr	.\lib\netdev-dpdk.c	/^netdev_dpdk_get_etheraddr(const struct netdev *netdev,$/;"	f	file:
netdev_dpdk_get_features	.\lib\netdev-dpdk.c	/^netdev_dpdk_get_features(const struct netdev *netdev_,$/;"	f	file:
netdev_dpdk_get_ifindex	.\lib\netdev-dpdk.c	/^netdev_dpdk_get_ifindex(const struct netdev *netdev)$/;"	f	file:
netdev_dpdk_get_mtu	.\lib\netdev-dpdk.c	/^netdev_dpdk_get_mtu(const struct netdev *netdev, int *mtup)$/;"	f	file:
netdev_dpdk_get_stats	.\lib\netdev-dpdk.c	/^netdev_dpdk_get_stats(const struct netdev *netdev, struct netdev_stats *stats)$/;"	f	file:
netdev_dpdk_get_status	.\lib\netdev-dpdk.c	/^netdev_dpdk_get_status(const struct netdev *netdev_, struct smap *args)$/;"	f	file:
netdev_dpdk_register	.\lib\netdev-dpdk.c	/^netdev_dpdk_register(void)$/;"	f
netdev_dpdk_register	.\lib\netdev-dpdk.h	/^netdev_dpdk_register(void)$/;"	f
netdev_dpdk_rxq_alloc	.\lib\netdev-dpdk.c	/^netdev_dpdk_rxq_alloc(void)$/;"	f	file:
netdev_dpdk_rxq_construct	.\lib\netdev-dpdk.c	/^netdev_dpdk_rxq_construct(struct netdev_rxq *rxq_)$/;"	f	file:
netdev_dpdk_rxq_dealloc	.\lib\netdev-dpdk.c	/^netdev_dpdk_rxq_dealloc(struct netdev_rxq *rxq_)$/;"	f	file:
netdev_dpdk_rxq_destruct	.\lib\netdev-dpdk.c	/^netdev_dpdk_rxq_destruct(struct netdev_rxq *rxq_ OVS_UNUSED)$/;"	f	file:
netdev_dpdk_rxq_recv	.\lib\netdev-dpdk.c	/^netdev_dpdk_rxq_recv(struct netdev_rxq *rxq_, struct ofpbuf **packets, int *c)$/;"	f	file:
netdev_dpdk_send	.\lib\netdev-dpdk.c	/^netdev_dpdk_send(struct netdev *netdev,$/;"	f	file:
netdev_dpdk_set_admin_state	.\lib\netdev-dpdk.c	/^netdev_dpdk_set_admin_state(struct unixctl_conn *conn, int argc,$/;"	f	file:
netdev_dpdk_set_etheraddr	.\lib\netdev-dpdk.c	/^netdev_dpdk_set_etheraddr(struct netdev *netdev,$/;"	f	file:
netdev_dpdk_set_miimon	.\lib\netdev-dpdk.c	/^netdev_dpdk_set_miimon(struct netdev *netdev_ OVS_UNUSED,$/;"	f	file:
netdev_dpdk_set_mtu	.\lib\netdev-dpdk.c	/^netdev_dpdk_set_mtu(const struct netdev *netdev, int mtu)$/;"	f	file:
netdev_dpdk_set_stats	.\lib\netdev-dpdk.c	/^netdev_dpdk_set_stats(struct netdev *netdev, const struct netdev_stats *stats)$/;"	f	file:
netdev_dpdk_update_flags	.\lib\netdev-dpdk.c	/^netdev_dpdk_update_flags(struct netdev *netdev_,$/;"	f	file:
netdev_dummy	.\lib\netdev-dummy.c	/^VLOG_DEFINE_THIS_MODULE(netdev_dummy);$/;"	v
netdev_dummy	.\lib\netdev-dummy.c	/^struct netdev_dummy {$/;"	s	file:
netdev_dummy_alloc	.\lib\netdev-dummy.c	/^netdev_dummy_alloc(void)$/;"	f	file:
netdev_dummy_cast	.\lib\netdev-dummy.c	/^netdev_dummy_cast(const struct netdev *netdev)$/;"	f	file:
netdev_dummy_construct	.\lib\netdev-dummy.c	/^netdev_dummy_construct(struct netdev *netdev_)$/;"	f	file:
netdev_dummy_dealloc	.\lib\netdev-dummy.c	/^netdev_dummy_dealloc(struct netdev *netdev_)$/;"	f	file:
netdev_dummy_destruct	.\lib\netdev-dummy.c	/^netdev_dummy_destruct(struct netdev *netdev_)$/;"	f	file:
netdev_dummy_get_config	.\lib\netdev-dummy.c	/^netdev_dummy_get_config(const struct netdev *netdev_, struct smap *args)$/;"	f	file:
netdev_dummy_get_etheraddr	.\lib\netdev-dummy.c	/^netdev_dummy_get_etheraddr(const struct netdev *netdev,$/;"	f	file:
netdev_dummy_get_ifindex	.\lib\netdev-dummy.c	/^netdev_dummy_get_ifindex(const struct netdev *netdev)$/;"	f	file:
netdev_dummy_get_mtu	.\lib\netdev-dummy.c	/^netdev_dummy_get_mtu(const struct netdev *netdev, int *mtup)$/;"	f	file:
netdev_dummy_get_stats	.\lib\netdev-dummy.c	/^netdev_dummy_get_stats(const struct netdev *netdev, struct netdev_stats *stats)$/;"	f	file:
netdev_dummy_queue_packet__	.\lib\netdev-dummy.c	/^netdev_dummy_queue_packet__(struct netdev_rxq_dummy *rx, struct ofpbuf *packet)$/;"	f	file:
netdev_dummy_receive	.\lib\netdev-dummy.c	/^netdev_dummy_receive(struct unixctl_conn *conn,$/;"	f	file:
netdev_dummy_register	.\lib\netdev-dummy.c	/^netdev_dummy_register(bool override)$/;"	f
netdev_dummy_run	.\lib\netdev-dummy.c	/^netdev_dummy_run(void)$/;"	f	file:
netdev_dummy_rxq_alloc	.\lib\netdev-dummy.c	/^netdev_dummy_rxq_alloc(void)$/;"	f	file:
netdev_dummy_rxq_construct	.\lib\netdev-dummy.c	/^netdev_dummy_rxq_construct(struct netdev_rxq *rxq_)$/;"	f	file:
netdev_dummy_rxq_dealloc	.\lib\netdev-dummy.c	/^netdev_dummy_rxq_dealloc(struct netdev_rxq *rxq_)$/;"	f	file:
netdev_dummy_rxq_destruct	.\lib\netdev-dummy.c	/^netdev_dummy_rxq_destruct(struct netdev_rxq *rxq_)$/;"	f	file:
netdev_dummy_rxq_drain	.\lib\netdev-dummy.c	/^netdev_dummy_rxq_drain(struct netdev_rxq *rxq_)$/;"	f	file:
netdev_dummy_rxq_recv	.\lib\netdev-dummy.c	/^netdev_dummy_rxq_recv(struct netdev_rxq *rxq_, struct ofpbuf **arr, int *c)$/;"	f	file:
netdev_dummy_rxq_wait	.\lib\netdev-dummy.c	/^netdev_dummy_rxq_wait(struct netdev_rxq *rxq_)$/;"	f	file:
netdev_dummy_send	.\lib\netdev-dummy.c	/^netdev_dummy_send(struct netdev *netdev, struct ofpbuf *pkt, bool may_steal)$/;"	f	file:
netdev_dummy_set_admin_state	.\lib\netdev-dummy.c	/^netdev_dummy_set_admin_state(struct unixctl_conn *conn, int argc,$/;"	f	file:
netdev_dummy_set_admin_state	.\lib\netdev-dummy.c	/^static unixctl_cb_func netdev_dummy_set_admin_state;$/;"	v	file:
netdev_dummy_set_config	.\lib\netdev-dummy.c	/^netdev_dummy_set_config(struct netdev *netdev_, const struct smap *args)$/;"	f	file:
netdev_dummy_set_etheraddr	.\lib\netdev-dummy.c	/^netdev_dummy_set_etheraddr(struct netdev *netdev,$/;"	f	file:
netdev_dummy_set_mtu	.\lib\netdev-dummy.c	/^netdev_dummy_set_mtu(const struct netdev *netdev, int mtu)$/;"	f	file:
netdev_dummy_set_stats	.\lib\netdev-dummy.c	/^netdev_dummy_set_stats(struct netdev *netdev, const struct netdev_stats *stats)$/;"	f	file:
netdev_dummy_update_flags	.\lib\netdev-dummy.c	/^netdev_dummy_update_flags(struct netdev *netdev_,$/;"	f	file:
netdev_dummy_wait	.\lib\netdev-dummy.c	/^netdev_dummy_wait(void)$/;"	f	file:
netdev_dump_queue_stats	.\lib\netdev.c	/^netdev_dump_queue_stats(const struct netdev *netdev,$/;"	f
netdev_dump_queue_stats_cb	.\lib\netdev.h	/^typedef void netdev_dump_queue_stats_cb(unsigned int queue_id,$/;"	t
netdev_exists	.\xenserver\opt_xensource_libexec_InterfaceReconfigure.py	/^def netdev_exists(netdev):$/;"	f
netdev_feature_to_name	.\lib\ofp-print.c	/^netdev_feature_to_name(uint32_t bit)$/;"	f	file:
netdev_features	.\lib\netdev.h	/^enum netdev_features {$/;"	g
netdev_features_is_full_duplex	.\lib\netdev.c	/^netdev_features_is_full_duplex(enum netdev_features features)$/;"	f
netdev_features_t	.\datapath\linux\compat\include\linux\netdevice.h	/^typedef u32 netdev_features_t;$/;"	t
netdev_features_to_bps	.\lib\netdev.c	/^netdev_features_to_bps(enum netdev_features features,$/;"	f
netdev_flags	.\lib\netdev.h	/^enum netdev_flags {$/;"	g
netdev_frame_hook	.\datapath\vport-netdev.c	/^static rx_handler_result_t netdev_frame_hook(struct sk_buff **pskb)$/;"	f	file:
netdev_frame_hook	.\datapath\vport-netdev.c	/^static struct sk_buff *netdev_frame_hook(struct net_bridge_port *p,$/;"	f	file:
netdev_frame_hook	.\datapath\vport-netdev.c	/^static struct sk_buff *netdev_frame_hook(struct sk_buff *skb)$/;"	f	file:
netdev_get_carrier	.\lib\netdev.c	/^netdev_get_carrier(const struct netdev *netdev)$/;"	f
netdev_get_carrier_resets	.\lib\netdev.c	/^netdev_get_carrier_resets(const struct netdev *netdev)$/;"	f
netdev_get_change_seq	.\lib\netdev.c	/^netdev_get_change_seq(const struct netdev *netdev)$/;"	f
netdev_get_class	.\lib\netdev.c	/^netdev_get_class(const struct netdev *netdev)$/;"	f
netdev_get_driver_name	.\xenserver\opt_xensource_libexec_InterfaceReconfigureVswitch.py	/^def netdev_get_driver_name(netdev):$/;"	f
netdev_get_etheraddr	.\lib\netdev.c	/^netdev_get_etheraddr(const struct netdev *netdev, uint8_t mac[ETH_ADDR_LEN])$/;"	f
netdev_get_ethtool	.\lib\netdev-linux.c	/^COVERAGE_DEFINE(netdev_get_ethtool);$/;"	v
netdev_get_features	.\lib\netdev.c	/^netdev_get_features(const struct netdev *netdev,$/;"	f
netdev_get_features	.\xenserver\opt_xensource_libexec_InterfaceReconfigureVswitch.py	/^def netdev_get_features(netdev):$/;"	f
netdev_get_flags	.\lib\netdev.c	/^netdev_get_flags(const struct netdev *netdev_, enum netdev_flags *flagsp)$/;"	f
netdev_get_hwaddr	.\lib\netdev-linux.c	/^COVERAGE_DEFINE(netdev_get_hwaddr);$/;"	v
netdev_get_ifindex	.\lib\netdev-linux.c	/^COVERAGE_DEFINE(netdev_get_ifindex);$/;"	v
netdev_get_ifindex	.\lib\netdev.c	/^netdev_get_ifindex(const struct netdev *netdev)$/;"	f
netdev_get_in4	.\lib\netdev.c	/^netdev_get_in4(const struct netdev *netdev,$/;"	f
netdev_get_in4_by_name	.\lib\netdev.c	/^netdev_get_in4_by_name(const char *device_name, struct in_addr *in4)$/;"	f
netdev_get_in6	.\lib\netdev.c	/^netdev_get_in6(const struct netdev *netdev, struct in6_addr *in6)$/;"	f
netdev_get_kernel_name	.\lib\netdev-bsd.c	/^netdev_get_kernel_name(const struct netdev *netdev)$/;"	f	file:
netdev_get_mtu	.\lib\netdev.c	/^netdev_get_mtu(const struct netdev *netdev, int *mtup)$/;"	f
netdev_get_n_queues	.\lib\netdev.c	/^netdev_get_n_queues(const struct netdev *netdev,$/;"	f
netdev_get_name	.\lib\netdev.c	/^netdev_get_name(const struct netdev *netdev)$/;"	f
netdev_get_next_hop	.\lib\netdev.c	/^netdev_get_next_hop(const struct netdev *netdev,$/;"	f
netdev_get_qos	.\lib\netdev.c	/^netdev_get_qos(const struct netdev *netdev,$/;"	f
netdev_get_qos_capabilities	.\lib\netdev.c	/^netdev_get_qos_capabilities(const struct netdev *netdev, const char *type,$/;"	f
netdev_get_qos_types	.\lib\netdev.c	/^netdev_get_qos_types(const struct netdev *netdev, struct sset *types)$/;"	f
netdev_get_queue	.\lib\netdev.c	/^netdev_get_queue(const struct netdev *netdev,$/;"	f
netdev_get_queue_stats	.\lib\netdev.c	/^netdev_get_queue_stats(const struct netdev *netdev, unsigned int queue_id,$/;"	f
netdev_get_stats	.\lib\netdev.c	/^COVERAGE_DEFINE(netdev_get_stats);$/;"	v
netdev_get_stats	.\lib\netdev.c	/^netdev_get_stats(const struct netdev *netdev, struct netdev_stats *stats)$/;"	f
netdev_get_status	.\lib\netdev.c	/^netdev_get_status(const struct netdev *netdev, struct smap *smap)$/;"	f
netdev_get_type	.\lib\netdev.c	/^netdev_get_type(const struct netdev *netdev)$/;"	f
netdev_get_type_from_name	.\lib\netdev.c	/^netdev_get_type_from_name(const char *name)$/;"	f
netdev_has_vlan_accel	.\xenserver\opt_xensource_libexec_InterfaceReconfigureVswitch.py	/^def netdev_has_vlan_accel(netdev):$/;"	f
netdev_internal_class	.\lib\netdev-linux.c	/^const struct netdev_class netdev_internal_class =$/;"	v	typeref:struct:netdev_class
netdev_internal_get_stats	.\lib\netdev-linux.c	/^netdev_internal_get_stats(const struct netdev *netdev_,$/;"	f	file:
netdev_internal_get_status	.\lib\netdev-linux.c	/^netdev_internal_get_status(const struct netdev *netdev OVS_UNUSED,$/;"	f	file:
netdev_internal_set_stats	.\lib\netdev-linux.c	/^netdev_internal_set_stats(struct netdev *netdev,$/;"	f	file:
netdev_is_pmd	.\lib\netdev.c	/^netdev_is_pmd(const struct netdev *netdev)$/;"	f
netdev_linux	.\lib\netdev-linux.c	/^VLOG_DEFINE_THIS_MODULE(netdev_linux);$/;"	v
netdev_linux	.\lib\netdev-linux.c	/^struct netdev_linux {$/;"	s	file:
netdev_linux_add_router	.\lib\netdev-linux.c	/^netdev_linux_add_router(struct netdev *netdev OVS_UNUSED, struct in_addr router)$/;"	f	file:
netdev_linux_alloc	.\lib\netdev-linux.c	/^netdev_linux_alloc(void)$/;"	f	file:
netdev_linux_arp_lookup	.\lib\netdev-linux.c	/^netdev_linux_arp_lookup(const struct netdev *netdev,$/;"	f	file:
netdev_linux_cast	.\lib\netdev-linux.c	/^netdev_linux_cast(const struct netdev *netdev)$/;"	f	file:
netdev_linux_class	.\lib\netdev-linux.c	/^const struct netdev_class netdev_linux_class =$/;"	v	typeref:struct:netdev_class
netdev_linux_common_construct	.\lib\netdev-linux.c	/^netdev_linux_common_construct(struct netdev_linux *netdev)$/;"	f	file:
netdev_linux_construct	.\lib\netdev-linux.c	/^netdev_linux_construct(struct netdev *netdev_)$/;"	f	file:
netdev_linux_construct_tap	.\lib\netdev-linux.c	/^netdev_linux_construct_tap(struct netdev *netdev_)$/;"	f	file:
netdev_linux_dealloc	.\lib\netdev-linux.c	/^netdev_linux_dealloc(struct netdev *netdev_)$/;"	f	file:
netdev_linux_delete_queue	.\lib\netdev-linux.c	/^netdev_linux_delete_queue(struct netdev *netdev_, unsigned int queue_id)$/;"	f	file:
netdev_linux_destruct	.\lib\netdev-linux.c	/^netdev_linux_destruct(struct netdev *netdev_)$/;"	f	file:
netdev_linux_do_ethtool	.\lib\netdev-linux.c	/^netdev_linux_do_ethtool(const char *name, struct ethtool_cmd *ecmd,$/;"	f	file:
netdev_linux_do_miimon	.\lib\netdev-linux.c	/^netdev_linux_do_miimon(const char *name, int cmd, const char *cmd_name,$/;"	f	file:
netdev_linux_dump_queue_stats	.\lib\netdev-linux.c	/^netdev_linux_dump_queue_stats(const struct netdev *netdev_,$/;"	f	file:
netdev_linux_ethtool_set_flag	.\lib\netdev-linux.c	/^netdev_linux_ethtool_set_flag(struct netdev *netdev, uint32_t flag,$/;"	f
netdev_linux_get_carrier	.\lib\netdev-linux.c	/^netdev_linux_get_carrier(const struct netdev *netdev_, bool *carrier)$/;"	f	file:
netdev_linux_get_carrier_resets	.\lib\netdev-linux.c	/^netdev_linux_get_carrier_resets(const struct netdev *netdev_)$/;"	f	file:
netdev_linux_get_etheraddr	.\lib\netdev-linux.c	/^netdev_linux_get_etheraddr(const struct netdev *netdev_,$/;"	f	file:
netdev_linux_get_features	.\lib\netdev-linux.c	/^netdev_linux_get_features(const struct netdev *netdev_,$/;"	f	file:
netdev_linux_get_ifindex	.\lib\netdev-linux.c	/^netdev_linux_get_ifindex(const struct netdev *netdev_)$/;"	f	file:
netdev_linux_get_in4	.\lib\netdev-linux.c	/^netdev_linux_get_in4(const struct netdev *netdev_,$/;"	f	file:
netdev_linux_get_in6	.\lib\netdev-linux.c	/^netdev_linux_get_in6(const struct netdev *netdev_, struct in6_addr *in6)$/;"	f	file:
netdev_linux_get_ipv4	.\lib\netdev-linux.c	/^netdev_linux_get_ipv4(const struct netdev *netdev, struct in_addr *ip,$/;"	f	file:
netdev_linux_get_miimon	.\lib\netdev-linux.c	/^netdev_linux_get_miimon(const char *name, bool *miimon)$/;"	f	file:
netdev_linux_get_mtu	.\lib\netdev-linux.c	/^netdev_linux_get_mtu(const struct netdev *netdev_, int *mtup)$/;"	f	file:
netdev_linux_get_mtu__	.\lib\netdev-linux.c	/^netdev_linux_get_mtu__(struct netdev_linux *netdev, int *mtup)$/;"	f	file:
netdev_linux_get_next_hop	.\lib\netdev-linux.c	/^netdev_linux_get_next_hop(const struct in_addr *host, struct in_addr *next_hop,$/;"	f	file:
netdev_linux_get_qos	.\lib\netdev-linux.c	/^netdev_linux_get_qos(const struct netdev *netdev_,$/;"	f	file:
netdev_linux_get_qos_capabilities	.\lib\netdev-linux.c	/^netdev_linux_get_qos_capabilities(const struct netdev *netdev OVS_UNUSED,$/;"	f	file:
netdev_linux_get_qos_types	.\lib\netdev-linux.c	/^netdev_linux_get_qos_types(const struct netdev *netdev OVS_UNUSED,$/;"	f	file:
netdev_linux_get_queue	.\lib\netdev-linux.c	/^netdev_linux_get_queue(const struct netdev *netdev_,$/;"	f	file:
netdev_linux_get_queue_stats	.\lib\netdev-linux.c	/^netdev_linux_get_queue_stats(const struct netdev *netdev_,$/;"	f	file:
netdev_linux_get_stats	.\lib\netdev-linux.c	/^netdev_linux_get_stats(const struct netdev *netdev_,$/;"	f	file:
netdev_linux_get_status	.\lib\netdev-linux.c	/^netdev_linux_get_status(const struct netdev *netdev_, struct smap *smap)$/;"	f	file:
netdev_linux_miimon_enabled	.\lib\netdev-linux.c	/^netdev_linux_miimon_enabled(void)$/;"	f	file:
netdev_linux_miimon_run	.\lib\netdev-linux.c	/^netdev_linux_miimon_run(void)$/;"	f	file:
netdev_linux_miimon_wait	.\lib\netdev-linux.c	/^netdev_linux_miimon_wait(void)$/;"	f	file:
netdev_linux_notify_sock	.\lib\netdev-linux.c	/^netdev_linux_notify_sock(void)$/;"	f	file:
netdev_linux_queue_dump_done	.\lib\netdev-linux.c	/^netdev_linux_queue_dump_done(const struct netdev *netdev OVS_UNUSED,$/;"	f	file:
netdev_linux_queue_dump_next	.\lib\netdev-linux.c	/^netdev_linux_queue_dump_next(const struct netdev *netdev_, void *state_,$/;"	f	file:
netdev_linux_queue_dump_start	.\lib\netdev-linux.c	/^netdev_linux_queue_dump_start(const struct netdev *netdev_, void **statep)$/;"	f	file:
netdev_linux_queue_state	.\lib\netdev-linux.c	/^struct netdev_linux_queue_state {$/;"	s	file:
netdev_linux_read_features	.\lib\netdev-linux.c	/^netdev_linux_read_features(struct netdev_linux *netdev)$/;"	f	file:
netdev_linux_run	.\lib\netdev-linux.c	/^netdev_linux_run(void)$/;"	f	file:
netdev_linux_rxq_alloc	.\lib\netdev-linux.c	/^netdev_linux_rxq_alloc(void)$/;"	f	file:
netdev_linux_rxq_construct	.\lib\netdev-linux.c	/^netdev_linux_rxq_construct(struct netdev_rxq *rxq_)$/;"	f	file:
netdev_linux_rxq_dealloc	.\lib\netdev-linux.c	/^netdev_linux_rxq_dealloc(struct netdev_rxq *rxq_)$/;"	f	file:
netdev_linux_rxq_destruct	.\lib\netdev-linux.c	/^netdev_linux_rxq_destruct(struct netdev_rxq *rxq_)$/;"	f	file:
netdev_linux_rxq_drain	.\lib\netdev-linux.c	/^netdev_linux_rxq_drain(struct netdev_rxq *rxq_)$/;"	f	file:
netdev_linux_rxq_recv	.\lib\netdev-linux.c	/^netdev_linux_rxq_recv(struct netdev_rxq *rxq_, struct ofpbuf **packet, int *c)$/;"	f	file:
netdev_linux_rxq_recv_sock	.\lib\netdev-linux.c	/^netdev_linux_rxq_recv_sock(int fd, struct ofpbuf *buffer)$/;"	f	file:
netdev_linux_rxq_recv_tap	.\lib\netdev-linux.c	/^netdev_linux_rxq_recv_tap(int fd, struct ofpbuf *buffer)$/;"	f	file:
netdev_linux_rxq_wait	.\lib\netdev-linux.c	/^netdev_linux_rxq_wait(struct netdev_rxq *rxq_)$/;"	f	file:
netdev_linux_send	.\lib\netdev-linux.c	/^netdev_linux_send(struct netdev *netdev_, struct ofpbuf *pkt, bool may_steal)$/;"	f	file:
netdev_linux_send_wait	.\lib\netdev-linux.c	/^netdev_linux_send_wait(struct netdev *netdev)$/;"	f	file:
netdev_linux_set_advertisements	.\lib\netdev-linux.c	/^netdev_linux_set_advertisements(struct netdev *netdev_,$/;"	f	file:
netdev_linux_set_etheraddr	.\lib\netdev-linux.c	/^netdev_linux_set_etheraddr(struct netdev *netdev_,$/;"	f	file:
netdev_linux_set_in4	.\lib\netdev-linux.c	/^netdev_linux_set_in4(struct netdev *netdev_, struct in_addr address,$/;"	f	file:
netdev_linux_set_miimon_interval	.\lib\netdev-linux.c	/^netdev_linux_set_miimon_interval(struct netdev *netdev_,$/;"	f	file:
netdev_linux_set_mtu	.\lib\netdev-linux.c	/^netdev_linux_set_mtu(const struct netdev *netdev_, int mtu)$/;"	f	file:
netdev_linux_set_policing	.\lib\netdev-linux.c	/^netdev_linux_set_policing(struct netdev *netdev_,$/;"	f	file:
netdev_linux_set_qos	.\lib\netdev-linux.c	/^netdev_linux_set_qos(struct netdev *netdev_,$/;"	f	file:
netdev_linux_set_queue	.\lib\netdev-linux.c	/^netdev_linux_set_queue(struct netdev *netdev_,$/;"	f	file:
netdev_linux_update_flags	.\lib\netdev-linux.c	/^netdev_linux_update_flags(struct netdev *netdev_, enum netdev_flags off,$/;"	f	file:
netdev_linux_wait	.\lib\netdev-linux.c	/^netdev_linux_wait(void)$/;"	f	file:
netdev_master_upper_dev_get	.\datapath\linux\compat\include\linux\netdevice.h	/^static inline struct net_device *netdev_master_upper_dev_get(struct net_device *dev)$/;"	f
netdev_master_upper_dev_link	.\datapath\linux\compat\include\linux\netdevice.h	/^static inline int netdev_master_upper_dev_link(struct net_device *dev,$/;"	f
netdev_max_backlog	.\ofproto\ofproto-dpif-xlate.c	/^netdev_max_backlog(void)$/;"	f	file:
netdev_mtu_error	.\lib\netdev-linux.c	/^    int netdev_mtu_error;       \/* Cached error code from SIOCGIFMTU or SIOCSIFMTU. *\/$/;"	m	struct:netdev_linux	file:
netdev_mutex	.\lib\netdev.c	/^static struct ovs_mutex netdev_mutex = OVS_MUTEX_INITIALIZER;$/;"	v	typeref:struct:ovs_mutex	file:
netdev_mutex	.\lib\netdev.c	/^static struct shash netdev_shash OVS_GUARDED_BY(netdev_mutex)$/;"	v	typeref:struct:OVS_GUARDED_BY	file:
netdev_n_rxq	.\lib\netdev.c	/^netdev_n_rxq(const struct netdev *netdev)$/;"	f
netdev_notifier_info_to_dev	.\datapath\linux\compat\include\linux\netdevice.h	/^static inline struct net_device *netdev_notifier_info_to_dev(void *info)$/;"	f
netdev_parse_name	.\lib\netdev.c	/^netdev_parse_name(const char *netdev_name_, char **name, char **type)$/;"	f
netdev_policing_error	.\lib\netdev-linux.c	/^    int netdev_policing_error;  \/* Cached error code from set policing. *\/$/;"	m	struct:netdev_linux	file:
netdev_port_features_from_ofp10	.\lib\ofp-util.c	/^netdev_port_features_from_ofp10(ovs_be32 ofp10_)$/;"	f	file:
netdev_port_features_from_ofp11	.\lib\ofp-util.c	/^netdev_port_features_from_ofp11(ovs_be32 ofp11)$/;"	f	file:
netdev_port_features_to_ofp10	.\lib\ofp-util.c	/^netdev_port_features_to_ofp10(enum netdev_features features)$/;"	f	file:
netdev_port_features_to_ofp11	.\lib\ofp-util.c	/^netdev_port_features_to_ofp11(enum netdev_features features)$/;"	f	file:
netdev_port_receive	.\datapath\vport-netdev.c	/^static void netdev_port_receive(struct vport *vport, struct sk_buff *skb)$/;"	f	file:
netdev_qos_capabilities	.\lib\netdev.h	/^struct netdev_qos_capabilities {$/;"	s
netdev_queue_dump	.\lib\netdev.h	/^struct netdev_queue_dump {$/;"	s
netdev_queue_dump_done	.\lib\netdev.c	/^netdev_queue_dump_done(struct netdev_queue_dump *dump)$/;"	f
netdev_queue_dump_next	.\lib\netdev.c	/^netdev_queue_dump_next(struct netdev_queue_dump *dump,$/;"	f
netdev_queue_dump_start	.\lib\netdev.c	/^netdev_queue_dump_start(struct netdev_queue_dump *dump,$/;"	f
netdev_queue_stats	.\lib\netdev.h	/^struct netdev_queue_stats {$/;"	s
netdev_received	.\lib\netdev.c	/^COVERAGE_DEFINE(netdev_received);$/;"	v
netdev_registered_class	.\lib\netdev.c	/^struct netdev_registered_class {$/;"	s	file:
netdev_rx_handler_register	.\datapath\linux\compat\dev-openvswitch.c	/^int netdev_rx_handler_register(struct net_device *dev,$/;"	f
netdev_rx_handler_unregister	.\datapath\linux\compat\dev-openvswitch.c	/^void netdev_rx_handler_unregister(struct net_device *dev)$/;"	f
netdev_rxq	.\lib\netdev-provider.h	/^struct netdev_rxq {$/;"	s
netdev_rxq_bsd	.\lib\netdev-bsd.c	/^struct netdev_rxq_bsd {$/;"	s	file:
netdev_rxq_bsd_cast	.\lib\netdev-bsd.c	/^netdev_rxq_bsd_cast(const struct netdev_rxq *rxq)$/;"	f	file:
netdev_rxq_bsd_recv_pcap	.\lib\netdev-bsd.c	/^netdev_rxq_bsd_recv_pcap(struct netdev_rxq_bsd *rxq, struct ofpbuf *buffer)$/;"	f	file:
netdev_rxq_bsd_recv_tap	.\lib\netdev-bsd.c	/^netdev_rxq_bsd_recv_tap(struct netdev_rxq_bsd *rxq, struct ofpbuf *buffer)$/;"	f	file:
netdev_rxq_dpdk	.\lib\netdev-dpdk.c	/^struct netdev_rxq_dpdk {$/;"	s	file:
netdev_rxq_dpdk_cast	.\lib\netdev-dpdk.c	/^netdev_rxq_dpdk_cast(const struct netdev_rxq *rx)$/;"	f	file:
netdev_rxq_drain	.\lib\netdev.c	/^netdev_rxq_drain(struct netdev_rxq *rx)$/;"	f
netdev_rxq_dummy	.\lib\netdev-dummy.c	/^struct netdev_rxq_dummy {$/;"	s	file:
netdev_rxq_dummy_cast	.\lib\netdev-dummy.c	/^netdev_rxq_dummy_cast(const struct netdev_rxq *rx)$/;"	f	file:
netdev_rxq_get_name	.\lib\netdev.c	/^netdev_rxq_get_name(const struct netdev_rxq *rx)$/;"	f
netdev_rxq_get_netdev	.\lib\netdev.c	/^netdev_rxq_get_netdev(const struct netdev_rxq *rx)$/;"	f
netdev_rxq_linux	.\lib\netdev-linux.c	/^struct netdev_rxq_linux {$/;"	s	file:
netdev_rxq_linux_cast	.\lib\netdev-linux.c	/^netdev_rxq_linux_cast(const struct netdev_rxq *rx)$/;"	f	file:
netdev_rxq_recv	.\lib\netdev.c	/^netdev_rxq_recv(struct netdev_rxq *rx, struct ofpbuf **buffers, int *cnt)$/;"	f
netdev_rxq_wait	.\lib\netdev.c	/^netdev_rxq_wait(struct netdev_rxq *rx)$/;"	f
netdev_saved_flags	.\lib\netdev.c	/^struct netdev_saved_flags {$/;"	s	file:
netdev_send	.\datapath\vport-netdev.c	/^static int netdev_send(struct vport *vport, struct sk_buff *skb)$/;"	f	file:
netdev_send	.\lib\netdev.c	/^netdev_send(struct netdev *netdev, struct ofpbuf *buffer, bool may_steal)$/;"	f
netdev_send_wait	.\lib\netdev.c	/^netdev_send_wait(struct netdev *netdev)$/;"	f
netdev_sent	.\lib\netdev.c	/^COVERAGE_DEFINE(netdev_sent);$/;"	v
netdev_set_advertisements	.\lib\netdev.c	/^netdev_set_advertisements(struct netdev *netdev,$/;"	f
netdev_set_etheraddr	.\lib\netdev.c	/^netdev_set_etheraddr(struct netdev *netdev, const uint8_t mac[ETH_ADDR_LEN])$/;"	f
netdev_set_ethtool	.\lib\netdev-linux.c	/^COVERAGE_DEFINE(netdev_set_ethtool);$/;"	v
netdev_set_flags	.\lib\netdev.c	/^netdev_set_flags(struct netdev *netdev, enum netdev_flags flags,$/;"	f
netdev_set_hwaddr	.\lib\netdev-linux.c	/^COVERAGE_DEFINE(netdev_set_hwaddr);$/;"	v
netdev_set_in4	.\lib\netdev.c	/^netdev_set_in4(struct netdev *netdev, struct in_addr addr, struct in_addr mask)$/;"	f
netdev_set_miimon_interval	.\lib\netdev.c	/^netdev_set_miimon_interval(struct netdev *netdev, long long int interval)$/;"	f
netdev_set_mtu	.\lib\netdev.c	/^netdev_set_mtu(const struct netdev *netdev, int mtu)$/;"	f
netdev_set_policing	.\lib\netdev-linux.c	/^COVERAGE_DEFINE(netdev_set_policing);$/;"	v
netdev_set_policing	.\lib\netdev.c	/^netdev_set_policing(struct netdev *netdev, uint32_t kbits_rate,$/;"	f
netdev_set_qos	.\lib\netdev.c	/^netdev_set_qos(struct netdev *netdev,$/;"	f
netdev_set_queue	.\lib\netdev.c	/^netdev_set_queue(struct netdev *netdev,$/;"	f
netdev_set_stats	.\lib\netdev.c	/^netdev_set_stats(struct netdev *netdev, const struct netdev_stats *stats)$/;"	f
netdev_stats	.\lib\netdev.h	/^struct netdev_stats {$/;"	s
netdev_stats_from_ovs_vport_stats	.\lib\netdev-linux.c	/^netdev_stats_from_ovs_vport_stats(struct netdev_stats *dst,$/;"	f	file:
netdev_stats_from_rtnl_link_stats	.\lib\netdev-linux.c	/^netdev_stats_from_rtnl_link_stats(struct netdev_stats *dst,$/;"	f	file:
netdev_tap_class	.\lib\netdev-bsd.c	/^const struct netdev_class netdev_tap_class =$/;"	v	typeref:struct:netdev_class
netdev_tap_class	.\lib\netdev-linux.c	/^const struct netdev_class netdev_tap_class =$/;"	v	typeref:struct:netdev_class
netdev_tap_get_stats	.\lib\netdev-linux.c	/^netdev_tap_get_stats(const struct netdev *netdev_, struct netdev_stats *stats)$/;"	f	file:
netdev_to_ovs_vport_type	.\lib\dpif-linux.c	/^netdev_to_ovs_vport_type(const struct netdev *netdev)$/;"	f	file:
netdev_tunnel_config	.\lib\netdev.h	/^struct netdev_tunnel_config {$/;"	s
netdev_turn_flags_off	.\lib\netdev.c	/^netdev_turn_flags_off(struct netdev *netdev, enum netdev_flags flags,$/;"	f
netdev_turn_flags_on	.\lib\netdev.c	/^netdev_turn_flags_on(struct netdev *netdev, enum netdev_flags flags,$/;"	f
netdev_up	.\xenserver\opt_xensource_libexec_InterfaceReconfigureBridge.py	/^def netdev_up(netdev, mtu=None):$/;"	f
netdev_up	.\xenserver\opt_xensource_libexec_InterfaceReconfigureVswitch.py	/^def netdev_up(netdev, mtu=None):$/;"	f
netdev_upper_dev_unlink	.\datapath\linux\compat\include\linux\netdevice.h	/^static inline void netdev_upper_dev_unlink(struct net_device *dev,$/;"	f
netdev_vport	.\datapath\vport-netdev.h	/^struct netdev_vport {$/;"	s
netdev_vport	.\lib\netdev-vport.c	/^VLOG_DEFINE_THIS_MODULE(netdev_vport);$/;"	v
netdev_vport	.\lib\netdev-vport.c	/^struct netdev_vport {$/;"	s	file:
netdev_vport_alloc	.\lib\netdev-vport.c	/^netdev_vport_alloc(void)$/;"	f	file:
netdev_vport_cast	.\lib\netdev-vport.c	/^netdev_vport_cast(const struct netdev *netdev)$/;"	f	file:
netdev_vport_class_get_dpif_port	.\lib\netdev-vport.c	/^netdev_vport_class_get_dpif_port(const struct netdev_class *class)$/;"	f
netdev_vport_construct	.\lib\netdev-vport.c	/^netdev_vport_construct(struct netdev *netdev_)$/;"	f	file:
netdev_vport_dealloc	.\lib\netdev-vport.c	/^netdev_vport_dealloc(struct netdev *netdev_)$/;"	f	file:
netdev_vport_destruct	.\lib\netdev-vport.c	/^netdev_vport_destruct(struct netdev *netdev_)$/;"	f	file:
netdev_vport_get_dpif_port	.\lib\netdev-vport.c	/^netdev_vport_get_dpif_port(const struct netdev *netdev,$/;"	f
netdev_vport_get_dpif_port_strdup	.\lib\netdev-vport.c	/^netdev_vport_get_dpif_port_strdup(const struct netdev *netdev)$/;"	f
netdev_vport_get_etheraddr	.\lib\netdev-vport.c	/^netdev_vport_get_etheraddr(const struct netdev *netdev_,$/;"	f	file:
netdev_vport_inc_rx	.\lib\netdev-vport.c	/^netdev_vport_inc_rx(const struct netdev *netdev,$/;"	f
netdev_vport_inc_tx	.\lib\netdev-vport.c	/^netdev_vport_inc_tx(const struct netdev *netdev,$/;"	f
netdev_vport_is_layer3	.\lib\netdev-vport.c	/^netdev_vport_is_layer3(const struct netdev *dev)$/;"	f
netdev_vport_is_patch	.\lib\netdev-vport.c	/^netdev_vport_is_patch(const struct netdev *netdev)$/;"	f
netdev_vport_is_vport_class	.\lib\netdev-vport.c	/^netdev_vport_is_vport_class(const struct netdev_class *class)$/;"	f
netdev_vport_needs_dst_port	.\lib\netdev-vport.c	/^netdev_vport_needs_dst_port(const struct netdev *dev)$/;"	f	file:
netdev_vport_patch_peer	.\lib\netdev-vport.c	/^netdev_vport_patch_peer(const struct netdev *netdev_)$/;"	f
netdev_vport_patch_register	.\lib\netdev-vport.c	/^netdev_vport_patch_register(void)$/;"	f
netdev_vport_priv	.\datapath\vport-netdev.h	/^netdev_vport_priv(const struct vport *vport)$/;"	f
netdev_vport_route_changed	.\lib\netdev-vport.c	/^netdev_vport_route_changed(void)$/;"	f	file:
netdev_vport_run	.\lib\netdev-vport.c	/^netdev_vport_run(void)$/;"	f	file:
netdev_vport_set_etheraddr	.\lib\netdev-vport.c	/^netdev_vport_set_etheraddr(struct netdev *netdev_,$/;"	f	file:
netdev_vport_tunnel_register	.\lib\netdev-vport.c	/^netdev_vport_tunnel_register(void)$/;"	f
netdev_vport_update_flags	.\lib\netdev-vport.c	/^netdev_vport_update_flags(struct netdev *netdev OVS_UNUSED,$/;"	f	file:
netdev_vport_wait	.\lib\netdev-vport.c	/^netdev_vport_wait(void)$/;"	f	file:
netflow	.\lib\vswitch-idl.h	/^	struct ovsrec_netflow *netflow;$/;"	m	struct:ovsrec_bridge	typeref:struct:ovsrec_bridge::ovsrec_netflow
netflow	.\ofproto\netflow.c	/^VLOG_DEFINE_THIS_MODULE(netflow);$/;"	v
netflow	.\ofproto\netflow.c	/^struct netflow {$/;"	s	file:
netflow	.\ofproto\ofproto-dpif-xlate.c	/^            struct netflow *netflow;$/;"	m	struct:xc_entry::__anon136::__anon138	typeref:struct:xc_entry::__anon136::__anon138::netflow	file:
netflow	.\ofproto\ofproto-dpif-xlate.c	/^    struct netflow *netflow;      \/* Netflow handle, or null. *\/$/;"	m	struct:xbridge	typeref:struct:xbridge::netflow	file:
netflow	.\ofproto\ofproto-dpif.c	/^    struct netflow *netflow;$/;"	m	struct:ofproto_dpif	typeref:struct:ofproto_dpif::netflow	file:
netflow_cnt	.\ofproto\netflow.c	/^    uint32_t netflow_cnt;         \/* Flow sequence number for NetFlow. *\/$/;"	m	struct:netflow	file:
netflow_count	.\ofproto\netflow.c	/^static atomic_uint netflow_count = ATOMIC_VAR_INIT(0);$/;"	v	file:
netflow_create	.\ofproto\netflow.c	/^netflow_create(void)$/;"	f
netflow_engine_id	.\lib\dpif-provider.h	/^    uint8_t netflow_engine_id;$/;"	m	struct:dpif
netflow_engine_type	.\lib\dpif-provider.h	/^    uint8_t netflow_engine_type;$/;"	m	struct:dpif
netflow_exists	.\ofproto\netflow.c	/^netflow_exists(void)$/;"	f
netflow_flow	.\ofproto\netflow.c	/^struct netflow_flow {$/;"	s	file:
netflow_flow_hash	.\ofproto\netflow.c	/^netflow_flow_hash(const struct flow *flow)$/;"	f	file:
netflow_mask_wc	.\ofproto\netflow.c	/^netflow_mask_wc(struct flow *flow, struct flow_wildcards *wc)$/;"	f
netflow_options	.\ofproto\netflow.h	/^struct netflow_options {$/;"	s
netflow_ref	.\ofproto\netflow.c	/^netflow_ref(const struct netflow *nf_)$/;"	f
netflow_run	.\ofproto\netflow.c	/^netflow_run(struct netflow *nf)$/;"	f
netflow_unref	.\ofproto\netflow.c	/^netflow_unref(struct netflow *nf)$/;"	f
netflow_v5_header	.\lib\netflow.h	/^struct netflow_v5_header {$/;"	s
netflow_v5_record	.\lib\netflow.h	/^struct netflow_v5_record {$/;"	s
netif_needs_gso	.\datapath\linux\compat\include\linux\netdevice.h	75;"	d
netif_skb_features	.\datapath\linux\compat\include\linux\netdevice.h	72;"	d
netlink	.\lib\netlink.c	/^VLOG_DEFINE_THIS_MODULE(netlink);$/;"	v
netlink_notifier	.\lib\netlink-notifier.c	/^VLOG_DEFINE_THIS_MODULE(netlink_notifier);$/;"	v
netlink_overflow	.\lib\netlink-socket.c	/^COVERAGE_DEFINE(netlink_overflow);$/;"	v
netlink_received	.\lib\netlink-socket.c	/^COVERAGE_DEFINE(netlink_received);$/;"	v
netlink_recv_jumbo	.\lib\netlink-socket.c	/^COVERAGE_DEFINE(netlink_recv_jumbo);$/;"	v
netlink_sent	.\lib\netlink-socket.c	/^COVERAGE_DEFINE(netlink_sent);$/;"	v
netlink_socket	.\lib\netlink-socket.c	/^VLOG_DEFINE_THIS_MODULE(netlink_socket);$/;"	v
netmask	.\lib\netdev-bsd.c	/^    struct in_addr netmask;$/;"	m	struct:netdev_bsd	typeref:struct:netdev_bsd::in_addr	file:
netmask	.\lib\netdev-linux.c	/^    struct in_addr address, netmask;$/;"	m	struct:netdev_linux	typeref:struct:netdev_linux::	file:
netnsok	.\datapath\linux\compat\include\net\genetlink.h	/^	bool                    netnsok;$/;"	m	struct:rpl_genl_family
network	.\lib\pcap-file.c	/^    uint32_t network;        \/* data link type *\/$/;"	m	struct:pcap_hdr	file:
new	.\ovsdb\jsonrpc-server.c	/^    struct ovsdb_datum *new;    \/* New data, NULL for a deleted row. *\/$/;"	m	struct:ovsdb_jsonrpc_monitor_row	typeref:struct:ovsdb_jsonrpc_monitor_row::ovsdb_datum	file:
new	.\ovsdb\transaction.c	/^    struct ovsdb_row *new;      \/* The new row. *\/$/;"	m	struct:ovsdb_txn_row	typeref:struct:ovsdb_txn_row::ovsdb_row	file:
new	.\python\ovs\db\data.py	/^    def new(x):$/;"	m	class:Atom
new_bridge	.\tests\test-stp.c	/^new_bridge(struct test_case *tc, int id)$/;"	f	file:
new_cookie	.\lib\ofp-util.h	/^    ovs_be64 new_cookie;     \/* New cookie to install or UINT64_MAX. *\/$/;"	m	struct:ofputil_flow_mod
new_fd_pstream	.\lib\stream-fd-unix.c	/^new_fd_pstream(const char *name, int fd,$/;"	f
new_fd_pstream	.\lib\stream-fd-windows.c	/^new_fd_pstream(const char *name, int fd,$/;"	f
new_fd_stream	.\lib\stream-fd-unix.c	/^new_fd_stream(const char *name, int fd, int connect_status,$/;"	f
new_fd_stream	.\lib\stream-fd-windows.c	/^new_fd_stream(const char *name, int fd, int connect_status,$/;"	f
new_lan	.\tests\test-stp.c	/^new_lan(struct test_case *tc, const char *name)$/;"	f	file:
new_port	.\tests\test-stp.c	/^new_port(struct bridge *b, struct lan *lan, int path_cost)$/;"	f	file:
new_ssl_stream	.\lib\stream-ssl.c	/^new_ssl_stream(const char *name, int fd, enum session_type type,$/;"	f	file:
new_switch	.\tests\test-controller.c	/^new_switch(struct switch_ *sw, struct vconn *vconn)$/;"	f	file:
new_tcp_stream	.\lib\stream-tcp.c	/^new_tcp_stream(const char *name, int fd, int connect_status,$/;"	f	file:
new_test_case	.\tests\test-stp.c	/^new_test_case(void)$/;"	f	file:
new_vport	.\datapath\datapath.c	/^static struct vport *new_vport(const struct vport_parms *parms)$/;"	f	file:
newer	.\lib\timeval.c	/^    struct cpu_usage newer;$/;"	m	struct:cpu_tracker	typeref:struct:cpu_tracker::cpu_usage	file:
next	.\lib\hmap.h	/^    struct hmap_node *next;     \/* Next in linked list. *\/$/;"	m	struct:hmap_node	typeref:struct:hmap_node::hmap_node
next	.\lib\list.h	/^    struct list *next;     \/* Next list element. *\/$/;"	m	struct:list	typeref:struct:list::list
next	.\lib\ofp-util.h	/^        unsigned long int next[BITMAP_N_LONGS(255)];$/;"	m	struct:ofputil_table_features::ofputil_table_instruction_features
nextHop	.\lib\sflow.h	/^    SFLAddress nextHop;        \/* Address of the next hop *\/$/;"	m	struct:_SFLExtended_mpls
nextRandomSkip	.\lib\sflow_sampler.c	/^inline static u_int32_t nextRandomSkip(u_int32_t mean)$/;"	f	file:
next_bogus_packet_in	.\ofproto\fail-open.c	/^    long long int next_bogus_packet_in;$/;"	m	struct:fail_open	file:
next_cfg	.\lib\vswitch-idl.h	/^	int64_t next_cfg;$/;"	m	struct:ovsrec_open_vswitch
next_check	.\lib\memory.c	/^static long long int next_check;$/;"	v	file:
next_compact	.\ovsdb\file.c	/^    long long int next_compact;$/;"	m	struct:ovsdb_file	file:
next_fake_iface_update	.\ofproto\bond.c	/^    long long int next_fake_iface_update; \/* LLONG_MAX if disabled. *\/$/;"	m	struct:bond	file:
next_free_id	.\ofproto\ofproto-dpif-rid.c	/^    uint32_t next_free_id; \/* Possible next free id. *\/$/;"	m	struct:rid_pool	file:
next_local_refresh	.\ofproto\in-band.c	/^    time_t next_local_refresh;       \/* Refresh timer. *\/$/;"	m	struct:in_band	file:
next_matching_table	.\ofproto\ofproto.c	/^next_matching_table(const struct ofproto *ofproto,$/;"	f	file:
next_op_report	.\ofproto\connmgr.c	/^    long long int next_op_report;    \/* Time to report ops, or LLONG_MAX. *\/$/;"	m	struct:ofconn	file:
next_permutation	.\tests\test-classifier.c	/^next_permutation(int *a, int n)$/;"	f	file:
next_permutation	.\tests\test-heap.c	/^next_permutation(uint32_t *a, int n)$/;"	f	file:
next_ports	.\utilities\ovs-benchmark.c	/^next_ports(unsigned short int *local_port, unsigned short int *remote_port)$/;"	f	file:
next_random_flow	.\tests\test-classifier.c	/^next_random_flow(struct flow *flow, unsigned int idx)$/;"	f	file:
next_real_row	.\lib\ovsdb-idl.c	/^next_real_row(struct ovsdb_idl_table *table, struct hmap_node *node)$/;"	f	file:
next_rebalance	.\ofproto\bond.c	/^    long long int next_rebalance; \/* Next rebalancing time. *\/$/;"	m	struct:bond	file:
next_remote_refresh	.\ofproto\in-band.c	/^    time_t next_remote_refresh; \/* Refresh timer. *\/$/;"	m	struct:in_band	file:
next_rule_in_list	.\lib\classifier.c	/^next_rule_in_list(struct cls_match *rule)$/;"	f	file:
next_rule_in_list__	.\lib\classifier.c	/^next_rule_in_list__(struct cls_match *rule)$/;"	f	file:
next_seq	.\lib\netlink-socket.c	/^    uint32_t next_seq;$/;"	m	struct:nl_sock	file:
next_session_nr	.\lib\stream-ssl.c	/^static unsigned int next_session_nr;$/;"	v	file:
next_tick	.\ofproto\ofproto-dpif-sflow.c	/^    time_t next_tick;$/;"	m	struct:dpif_sflow	file:
next_timeout	.\ofproto\netflow.c	/^    long long int next_timeout;   \/* Next scheduled active timeout. *\/$/;"	m	struct:netflow	file:
next_tx	.\lib\bfd.c	/^    long long int next_tx;        \/* Next TX time. *\/$/;"	m	struct:bfd	file:
next_txq	.\ofproto\pinsched.c	/^    struct pinqueue *next_txq;  \/* Next pinqueue check in round-robin. *\/$/;"	m	struct:pinsched	typeref:struct:pinsched::pinqueue	file:
next_visible_table	.\ofproto\ofproto.c	/^next_visible_table(const struct ofproto *ofproto, uint8_t table_id)$/;"	f	file:
nexthop	.\lib\netflow.h	/^    ovs_be32 nexthop;              \/* IP address of next hop.  Set to 0. *\/$/;"	m	struct:netflow_v5_record
nexthop	.\lib\sflow.h	/^    SFLAddress nexthop;                       \/* Address of the border router that should$/;"	m	struct:_SFLExtended_gateway
nexthop	.\lib\sflow.h	/^    SFLAddress nexthop;               \/* IP address of next hop router *\/$/;"	m	struct:_SFLExtended_router
nf	.\ofproto\ofproto-dpif-xlate.c	/^        } nf;$/;"	m	union:xc_entry::__anon136	typeref:struct:xc_entry::__anon136::__anon138	file:
nf_output_iface	.\ofproto\ofproto-dpif-xlate.h	/^    ofp_port_t nf_output_iface; \/* Output interface index for NetFlow. *\/$/;"	m	struct:xlate_out
ni_cksum	.\include\windows\netinet\icmp6.h	377;"	d
ni_code	.\include\windows\netinet\icmp6.h	376;"	d
ni_flags	.\include\windows\netinet\icmp6.h	379;"	d
ni_fqdn_name	.\include\windows\netinet\icmp6.h	/^	u_int8_t ni_fqdn_name[3]; \/* XXX: alignment *\/$/;"	m	struct:ni_reply_fqdn
ni_fqdn_namelen	.\include\windows\netinet\icmp6.h	/^	u_int8_t ni_fqdn_namelen; \/* length in octets of the FQDN *\/$/;"	m	struct:ni_reply_fqdn
ni_fqdn_ttl	.\include\windows\netinet\icmp6.h	/^	u_int32_t ni_fqdn_ttl;	\/* TTL *\/$/;"	m	struct:ni_reply_fqdn
ni_qtype	.\include\windows\netinet\icmp6.h	378;"	d
ni_reply_fqdn	.\include\windows\netinet\icmp6.h	/^struct ni_reply_fqdn {$/;"	s
ni_type	.\include\windows\netinet\icmp6.h	375;"	d
nicira10_stats_msg	.\include\openflow\nicira-ext.h	/^struct nicira10_stats_msg {$/;"	s
nicira11_stats_msg	.\include\openflow\nicira-ext.h	/^struct nicira11_stats_msg {$/;"	s
nicira_header	.\include\openflow\nicira-ext.h	/^struct nicira_header {$/;"	s
nl_attr_find	.\lib\netlink.c	/^nl_attr_find(const struct ofpbuf *buf, size_t hdr_len, uint16_t type)$/;"	f
nl_attr_find__	.\lib\netlink.c	/^nl_attr_find__(const struct nlattr *attrs, size_t size, uint16_t type)$/;"	f
nl_attr_find_nested	.\lib\netlink.c	/^nl_attr_find_nested(const struct nlattr *nla, uint16_t type)$/;"	f
nl_attr_get	.\lib\netlink.c	/^nl_attr_get(const struct nlattr *nla)$/;"	f
nl_attr_get_be16	.\lib\netlink.c	/^nl_attr_get_be16(const struct nlattr *nla)$/;"	f
nl_attr_get_be32	.\lib\netlink.c	/^nl_attr_get_be32(const struct nlattr *nla)$/;"	f
nl_attr_get_be64	.\lib\netlink.c	/^nl_attr_get_be64(const struct nlattr *nla)$/;"	f
nl_attr_get_flag	.\lib\netlink.c	/^nl_attr_get_flag(const struct nlattr *nla)$/;"	f
nl_attr_get_nested	.\lib\netlink.c	/^nl_attr_get_nested(const struct nlattr *nla, struct ofpbuf *nested)$/;"	f
nl_attr_get_odp_port	.\lib\netlink.c	/^nl_attr_get_odp_port(const struct nlattr *nla)$/;"	f
nl_attr_get_size	.\lib\netlink.c	/^nl_attr_get_size(const struct nlattr *nla)$/;"	f
nl_attr_get_string	.\lib\netlink.c	/^nl_attr_get_string(const struct nlattr *nla)$/;"	f
nl_attr_get_u16	.\lib\netlink.c	/^nl_attr_get_u16(const struct nlattr *nla)$/;"	f
nl_attr_get_u32	.\lib\netlink.c	/^nl_attr_get_u32(const struct nlattr *nla)$/;"	f
nl_attr_get_u64	.\lib\netlink.c	/^nl_attr_get_u64(const struct nlattr *nla)$/;"	f
nl_attr_get_u8	.\lib\netlink.c	/^nl_attr_get_u8(const struct nlattr *nla)$/;"	f
nl_attr_get_unspec	.\lib\netlink.c	/^nl_attr_get_unspec(const struct nlattr *nla, size_t size)$/;"	f
nl_attr_is_valid	.\lib\netlink.h	/^nl_attr_is_valid(const struct nlattr *nla, size_t maxlen)$/;"	f
nl_attr_len_pad	.\lib\netlink.h	/^nl_attr_len_pad(const struct nlattr *nla, size_t maxlen)$/;"	f
nl_attr_next	.\lib\netlink.h	/^nl_attr_next(const struct nlattr *nla)$/;"	f
nl_attr_oversized	.\lib\netlink.c	/^nl_attr_oversized(size_t payload_size)$/;"	f
nl_attr_type	.\lib\netlink.c	/^nl_attr_type(const struct nlattr *nla)$/;"	f
nl_attr_type	.\lib\netlink.h	/^enum nl_attr_type$/;"	g
nl_attr_validate	.\lib\netlink.c	/^nl_attr_validate(const struct nlattr *nla, const struct nl_policy *policy)$/;"	f
nl_dump	.\lib\netlink-socket.h	/^struct nl_dump {$/;"	s
nl_dump_done	.\lib\netlink-socket.c	/^nl_dump_done(struct nl_dump *dump)$/;"	f
nl_dump_next	.\lib\netlink-socket.c	/^nl_dump_next(struct nl_dump *dump, struct ofpbuf *reply, struct ofpbuf *buffer)$/;"	f
nl_dump_peek	.\lib\netlink-socket.c	/^nl_dump_peek(struct ofpbuf *reply, struct ofpbuf *buffer)$/;"	f
nl_dump_start	.\lib\netlink-socket.c	/^nl_dump_start(struct nl_dump *dump, int protocol, const struct ofpbuf *request)$/;"	f
nl_family	.\lib\netlink-protocol.h	/^    sa_family_t nl_family;$/;"	m	struct:sockaddr_nl
nl_groups	.\lib\netlink-protocol.h	/^    uint32_t nl_groups;$/;"	m	struct:sockaddr_nl
nl_lookup_genl_family	.\lib\netlink-socket.c	/^nl_lookup_genl_family(const char *name, int *number)$/;"	f
nl_lookup_genl_mcgroup	.\lib\netlink-socket.c	/^nl_lookup_genl_mcgroup(const char *family_name, const char *group_name,$/;"	f
nl_msg_end_nested	.\lib\netlink.c	/^nl_msg_end_nested(struct ofpbuf *msg, size_t offset)$/;"	f
nl_msg_genlmsghdr	.\lib\netlink.c	/^nl_msg_genlmsghdr(const struct ofpbuf *msg)$/;"	f
nl_msg_next	.\lib\netlink.c	/^nl_msg_next(struct ofpbuf *buffer, struct ofpbuf *msg)$/;"	f
nl_msg_nlmsgerr	.\lib\netlink.c	/^nl_msg_nlmsgerr(const struct ofpbuf *msg, int *errorp)$/;"	f
nl_msg_nlmsghdr	.\lib\netlink.c	/^nl_msg_nlmsghdr(const struct ofpbuf *msg)$/;"	f
nl_msg_push	.\lib\netlink.c	/^nl_msg_push(struct ofpbuf *msg, const void *data, size_t size)$/;"	f
nl_msg_push_be16	.\lib\netlink.c	/^nl_msg_push_be16(struct ofpbuf *msg, uint16_t type, ovs_be16 value)$/;"	f
nl_msg_push_be32	.\lib\netlink.c	/^nl_msg_push_be32(struct ofpbuf *msg, uint16_t type, ovs_be32 value)$/;"	f
nl_msg_push_be64	.\lib\netlink.c	/^nl_msg_push_be64(struct ofpbuf *msg, uint16_t type, ovs_be64 value)$/;"	f
nl_msg_push_flag	.\lib\netlink.c	/^nl_msg_push_flag(struct ofpbuf *msg, uint16_t type)$/;"	f
nl_msg_push_string	.\lib\netlink.c	/^nl_msg_push_string(struct ofpbuf *msg, uint16_t type, const char *value)$/;"	f
nl_msg_push_u16	.\lib\netlink.c	/^nl_msg_push_u16(struct ofpbuf *msg, uint16_t type, uint16_t value)$/;"	f
nl_msg_push_u32	.\lib\netlink.c	/^nl_msg_push_u32(struct ofpbuf *msg, uint16_t type, uint32_t value)$/;"	f
nl_msg_push_u64	.\lib\netlink.c	/^nl_msg_push_u64(struct ofpbuf *msg, uint16_t type, uint64_t value)$/;"	f
nl_msg_push_u8	.\lib\netlink.c	/^nl_msg_push_u8(struct ofpbuf *msg, uint16_t type, uint8_t value)$/;"	f
nl_msg_push_uninit	.\lib\netlink.c	/^nl_msg_push_uninit(struct ofpbuf *msg, size_t size)$/;"	f
nl_msg_push_unspec	.\lib\netlink.c	/^nl_msg_push_unspec(struct ofpbuf *msg, uint16_t type,$/;"	f
nl_msg_push_unspec_uninit	.\lib\netlink.c	/^nl_msg_push_unspec_uninit(struct ofpbuf *msg, uint16_t type, size_t size)$/;"	f
nl_msg_put	.\lib\netlink.c	/^nl_msg_put(struct ofpbuf *msg, const void *data, size_t size)$/;"	f
nl_msg_put_be16	.\lib\netlink.c	/^nl_msg_put_be16(struct ofpbuf *msg, uint16_t type, ovs_be16 value)$/;"	f
nl_msg_put_be32	.\lib\netlink.c	/^nl_msg_put_be32(struct ofpbuf *msg, uint16_t type, ovs_be32 value)$/;"	f
nl_msg_put_be64	.\lib\netlink.c	/^nl_msg_put_be64(struct ofpbuf *msg, uint16_t type, ovs_be64 value)$/;"	f
nl_msg_put_flag	.\lib\netlink.c	/^nl_msg_put_flag(struct ofpbuf *msg, uint16_t type)$/;"	f
nl_msg_put_genlmsghdr	.\lib\netlink.c	/^nl_msg_put_genlmsghdr(struct ofpbuf *msg, size_t expected_payload,$/;"	f
nl_msg_put_nested	.\lib\netlink.c	/^nl_msg_put_nested(struct ofpbuf *msg,$/;"	f
nl_msg_put_nlmsghdr	.\lib\netlink.c	/^nl_msg_put_nlmsghdr(struct ofpbuf *msg,$/;"	f
nl_msg_put_odp_port	.\lib\netlink.c	/^nl_msg_put_odp_port(struct ofpbuf *msg, uint16_t type, odp_port_t value)$/;"	f
nl_msg_put_string	.\lib\netlink.c	/^nl_msg_put_string(struct ofpbuf *msg, uint16_t type, const char *value)$/;"	f
nl_msg_put_u16	.\lib\netlink.c	/^nl_msg_put_u16(struct ofpbuf *msg, uint16_t type, uint16_t value)$/;"	f
nl_msg_put_u32	.\lib\netlink.c	/^nl_msg_put_u32(struct ofpbuf *msg, uint16_t type, uint32_t value)$/;"	f
nl_msg_put_u64	.\lib\netlink.c	/^nl_msg_put_u64(struct ofpbuf *msg, uint16_t type, uint64_t value)$/;"	f
nl_msg_put_u8	.\lib\netlink.c	/^nl_msg_put_u8(struct ofpbuf *msg, uint16_t type, uint8_t value)$/;"	f
nl_msg_put_uninit	.\lib\netlink.c	/^nl_msg_put_uninit(struct ofpbuf *msg, size_t size)$/;"	f
nl_msg_put_unspec	.\lib\netlink.c	/^nl_msg_put_unspec(struct ofpbuf *msg, uint16_t type,$/;"	f
nl_msg_put_unspec_uninit	.\lib\netlink.c	/^nl_msg_put_unspec_uninit(struct ofpbuf *msg, uint16_t type, size_t size)$/;"	f
nl_msg_put_unspec_zero	.\lib\netlink.c	/^nl_msg_put_unspec_zero(struct ofpbuf *msg, uint16_t type, size_t size)$/;"	f
nl_msg_reserve	.\lib\netlink.c	/^nl_msg_reserve(struct ofpbuf *msg, size_t size)$/;"	f
nl_msg_start_nested	.\lib\netlink.c	/^nl_msg_start_nested(struct ofpbuf *msg, uint16_t type)$/;"	f
nl_pad	.\lib\netlink-protocol.h	/^    unsigned short int nl_pad;$/;"	m	struct:sockaddr_nl
nl_parse_nested	.\lib\netlink.c	/^nl_parse_nested(const struct nlattr *nla, const struct nl_policy policy[],$/;"	f
nl_pid	.\lib\netlink-protocol.h	/^    uint32_t nl_pid;$/;"	m	struct:sockaddr_nl
nl_policy	.\lib\netlink.h	/^struct nl_policy$/;"	s
nl_policy_parse	.\lib\netlink.c	/^nl_policy_parse(const struct ofpbuf *msg, size_t nla_offset,$/;"	f
nl_pool	.\lib\netlink-socket.c	/^struct nl_pool {$/;"	s	file:
nl_pool_alloc	.\lib\netlink-socket.c	/^nl_pool_alloc(int protocol, struct nl_sock **sockp)$/;"	f	file:
nl_pool_release	.\lib\netlink-socket.c	/^nl_pool_release(struct nl_sock *sock)$/;"	f	file:
nl_seq	.\lib\netlink-socket.h	/^    uint32_t nl_seq;            \/* Expected nlmsg_seq for replies. *\/$/;"	m	struct:nl_dump
nl_sock	.\lib\netlink-socket.c	/^struct nl_sock {$/;"	s	file:
nl_sock_allocate_seq	.\lib\netlink-socket.c	/^nl_sock_allocate_seq(struct nl_sock *sock, unsigned int n)$/;"	f	file:
nl_sock_clone	.\lib\netlink-socket.c	/^nl_sock_clone(const struct nl_sock *src, struct nl_sock **sockp)$/;"	f
nl_sock_create	.\lib\netlink-socket.c	/^nl_sock_create(int protocol, struct nl_sock **sockp)$/;"	f
nl_sock_destroy	.\lib\netlink-socket.c	/^nl_sock_destroy(struct nl_sock *sock)$/;"	f
nl_sock_drain	.\lib\netlink-socket.c	/^nl_sock_drain(struct nl_sock *sock)$/;"	f
nl_sock_fd	.\lib\netlink-socket.c	/^nl_sock_fd(const struct nl_sock *sock)$/;"	f
nl_sock_join_mcgroup	.\lib\netlink-socket.c	/^nl_sock_join_mcgroup(struct nl_sock *sock, unsigned int multicast_group)$/;"	f
nl_sock_leave_mcgroup	.\lib\netlink-socket.c	/^nl_sock_leave_mcgroup(struct nl_sock *sock, unsigned int multicast_group)$/;"	f
nl_sock_pid	.\lib\netlink-socket.c	/^nl_sock_pid(const struct nl_sock *sock)$/;"	f
nl_sock_record_errors__	.\lib\netlink-socket.c	/^nl_sock_record_errors__(struct nl_transaction **transactions, size_t n,$/;"	f	file:
nl_sock_recv	.\lib\netlink-socket.c	/^nl_sock_recv(struct nl_sock *sock, struct ofpbuf *buf, bool wait)$/;"	f
nl_sock_recv__	.\lib\netlink-socket.c	/^nl_sock_recv__(struct nl_sock *sock, struct ofpbuf *buf, bool wait)$/;"	f	file:
nl_sock_send	.\lib\netlink-socket.c	/^nl_sock_send(struct nl_sock *sock, const struct ofpbuf *msg, bool wait)$/;"	f
nl_sock_send__	.\lib\netlink-socket.c	/^nl_sock_send__(struct nl_sock *sock, const struct ofpbuf *msg,$/;"	f	file:
nl_sock_send_seq	.\lib\netlink-socket.c	/^nl_sock_send_seq(struct nl_sock *sock, const struct ofpbuf *msg,$/;"	f
nl_sock_transact	.\lib\netlink-socket.c	/^nl_sock_transact(struct nl_sock *sock, const struct ofpbuf *request,$/;"	f
nl_sock_transact_multiple	.\lib\netlink-socket.c	/^nl_sock_transact_multiple(struct nl_sock *sock,$/;"	f
nl_sock_transact_multiple__	.\lib\netlink-socket.c	/^nl_sock_transact_multiple__(struct nl_sock *sock,$/;"	f	file:
nl_sock_wait	.\lib\netlink-socket.c	/^nl_sock_wait(const struct nl_sock *sock, short int events)$/;"	f
nl_transact	.\lib\netlink-socket.c	/^nl_transact(int protocol, const struct ofpbuf *request,$/;"	f
nl_transact_multiple	.\lib\netlink-socket.c	/^nl_transact_multiple(int protocol,$/;"	f
nl_transaction	.\lib\netlink-socket.h	/^struct nl_transaction {$/;"	s
nla_find_nested	.\datapath\linux\compat\include\net\netlink.h	/^static inline struct nlattr *nla_find_nested(struct nlattr *nla, int attrtype)$/;"	f
nla_for_each_nested	.\datapath\linux\compat\include\net\netlink.h	55;"	d
nla_get_be16	.\datapath\linux\compat\include\net\netlink.h	/^static inline __be16 nla_get_be16(const struct nlattr *nla)$/;"	f
nla_get_be64	.\datapath\linux\compat\include\net\netlink.h	/^static inline __be64 nla_get_be64(const struct nlattr *nla)$/;"	f
nla_get_be64	.\datapath\linux\compat\include\net\netlink.h	21;"	d
nla_len	.\lib\netlink-protocol.h	/^    uint16_t nla_len;$/;"	m	struct:nlattr
nla_put_be16	.\datapath\linux\compat\include\net\netlink.h	/^static inline int nla_put_be16(struct sk_buff *skb, int attrtype, __be16 value)$/;"	f
nla_put_be32	.\datapath\linux\compat\include\net\netlink.h	/^static inline int nla_put_be32(struct sk_buff *skb, int attrtype, __be32 value)$/;"	f
nla_put_be64	.\datapath\linux\compat\include\net\netlink.h	/^static inline int nla_put_be64(struct sk_buff *skb, int attrtype, __be64 value)$/;"	f
nla_type	.\lib\netlink-protocol.h	/^    uint16_t nla_type;$/;"	m	struct:nlattr
nlattr	.\lib\netlink-protocol.h	/^struct nlattr {$/;"	s
nlmsg_flags	.\lib\dpif-linux.c	/^    unsigned int nlmsg_flags;$/;"	m	struct:dpif_linux_flow	file:
nlmsg_flags	.\lib\netlink-protocol.h	/^    uint16_t nlmsg_flags;$/;"	m	struct:nlmsghdr
nlmsg_len	.\lib\netlink-protocol.h	/^    uint32_t nlmsg_len;$/;"	m	struct:nlmsghdr
nlmsg_pid	.\lib\netlink-protocol.h	/^    uint32_t nlmsg_pid;$/;"	m	struct:nlmsghdr
nlmsg_seq	.\lib\netlink-protocol.h	/^    uint32_t nlmsg_seq;$/;"	m	struct:nlmsghdr
nlmsg_to_string	.\lib\netlink-socket.c	/^nlmsg_to_string(const struct ofpbuf *buffer, int protocol)$/;"	f	file:
nlmsg_type	.\lib\netlink-protocol.h	/^    uint16_t nlmsg_type;$/;"	m	struct:nlmsghdr
nlmsg_type	.\lib\route-table.c	/^    int nlmsg_type;       \/* e.g. RTM_NEWROUTE, RTM_DELROUTE. *\/$/;"	m	struct:route_table_msg	file:
nlmsg_type	.\lib\rtnetlink-link.h	/^    int nlmsg_type;             \/* e.g. RTM_NEWLINK, RTM_DELLINK. *\/$/;"	m	struct:rtnetlink_link_change
nlmsgerr	.\lib\netlink-protocol.h	/^struct nlmsgerr$/;"	s
nlmsghdr	.\lib\netlink-protocol.h	/^struct nlmsghdr {$/;"	s
nlmsghdr_to_string	.\lib\netlink-socket.c	/^nlmsghdr_to_string(const struct nlmsghdr *h, int protocol, struct ds *ds)$/;"	f	file:
nln	.\lib\netlink-notifier.c	/^    struct nln *nln;             \/* Parent nln. *\/$/;"	m	struct:nln_notifier	typeref:struct:nln_notifier::nln	file:
nln	.\lib\netlink-notifier.c	/^struct nln {$/;"	s	file:
nln	.\lib\route-table.c	/^static struct nln *nln = NULL;$/;"	v	typeref:struct:nln	file:
nln	.\lib\rtnetlink-link.c	/^static struct nln *nln = NULL;$/;"	v	typeref:struct:nln	file:
nln_changed	.\lib\netlink-notifier.c	/^COVERAGE_DEFINE(nln_changed);$/;"	v
nln_create	.\lib\netlink-notifier.c	/^nln_create(int protocol, int multicast_group, nln_parse_func *parse,$/;"	f
nln_destroy	.\lib\netlink-notifier.c	/^nln_destroy(struct nln *nln)$/;"	f
nln_notifier	.\lib\netlink-notifier.c	/^struct nln_notifier {$/;"	s	file:
nln_notifier_create	.\lib\netlink-notifier.c	/^nln_notifier_create(struct nln *nln, nln_notify_func *cb, void *aux)$/;"	f
nln_notifier_destroy	.\lib\netlink-notifier.c	/^nln_notifier_destroy(struct nln_notifier *notifier)$/;"	f
nln_notify_func	.\lib\netlink-notifier.h	/^typedef void nln_notify_func(const void *change, void *aux);$/;"	t
nln_parse_func	.\lib\netlink-notifier.h	/^typedef bool nln_parse_func(struct ofpbuf *buf, void *change);$/;"	t
nln_report	.\lib\netlink-notifier.c	/^nln_report(struct nln *nln, void *change)$/;"	f	file:
nln_run	.\lib\netlink-notifier.c	/^nln_run(struct nln *nln)$/;"	f
nln_wait	.\lib\netlink-notifier.c	/^nln_wait(struct nln *nln)$/;"	f
no_argument	.\include\windows\getopt.h	41;"	d
no_packet_in_rule	.\ofproto\ofproto-dpif-xlate.c	/^    struct rule_dpif *no_packet_in_rule;$/;"	m	struct:xbridge	typeref:struct:xbridge::rule_dpif	file:
no_packet_in_rule	.\ofproto\ofproto-dpif.c	/^    struct rule_dpif *no_packet_in_rule; \/* Drops flow table misses. *\/$/;"	m	struct:ofproto_dpif	typeref:struct:ofproto_dpif::rule_dpif	file:
noarg	.\lib\getopt_long.c	/^static const char noarg[] = "option doesn't take an argument -- %.*s";$/;"	v	file:
nobase_pkgdata_DATA	.\python\automake.mk	/^nobase_pkgdata_DATA = $(ovs_pyfiles) $(ovstest_pyfiles)$/;"	m
node	.\lib\bfd.c	/^    struct hmap_node node;        \/* In 'all_bfds'. *\/$/;"	m	struct:bfd	typeref:struct:bfd::hmap_node	file:
node	.\lib\cfm.c	/^    struct hmap_node node; \/* Node in 'remote_mps' map. *\/$/;"	m	struct:remote_mp	typeref:struct:remote_mp::hmap_node	file:
node	.\lib\dpif-netdev.c	/^    const struct hmap_node node; \/* In owning dp_netdev's 'flow_table'. *\/$/;"	m	struct:dp_netdev_flow	typeref:struct:dp_netdev_flow::hmap_node	file:
node	.\lib\dpif-netdev.c	/^    struct hmap_node node;      \/* Node in dp_netdev's 'ports'. *\/$/;"	m	struct:dp_netdev_port	typeref:struct:dp_netdev_port::hmap_node	file:
node	.\lib\lacp.c	/^    struct hmap_node node;        \/* Node in master's slaves map. *\/$/;"	m	struct:slave	typeref:struct:slave::hmap_node	file:
node	.\lib\lacp.c	/^    struct list node;             \/* Node in all_lacps list. *\/$/;"	m	struct:lacp	typeref:struct:lacp::list	file:
node	.\lib\netdev-dummy.c	/^    struct list node;           \/* In netdev_dummy's "rxes" list. *\/$/;"	m	struct:netdev_rxq_dummy	typeref:struct:netdev_rxq_dummy::list	file:
node	.\lib\netdev-provider.h	/^    struct shash_node *node;            \/* Pointer to element in global map. *\/$/;"	m	struct:netdev	typeref:struct:netdev::shash_node
node	.\lib\netdev.c	/^    struct list node;           \/* In struct netdev's saved_flags_list. *\/$/;"	m	struct:netdev_saved_flags	typeref:struct:netdev_saved_flags::list	file:
node	.\lib\netlink-notifier.c	/^    struct list node;$/;"	m	struct:nln_notifier	typeref:struct:nln_notifier::list	file:
node	.\lib\process.c	/^    struct list node;$/;"	m	struct:process	typeref:struct:process::list	file:
node	.\lib\route-table.c	/^    struct hmap_node node; \/* Node in name_map. *\/$/;"	m	struct:name_node	typeref:struct:name_node::hmap_node	file:
node	.\lib\route-table.c	/^    struct hmap_node node; \/* Node in route_map. *\/$/;"	m	struct:route_node	typeref:struct:route_node::hmap_node	file:
node	.\lib\rtbsd.h	/^    struct list node;$/;"	m	struct:rtbsd_notifier	typeref:struct:rtbsd_notifier::list
node	.\lib\shash.h	/^    struct hmap_node node;$/;"	m	struct:shash_node	typeref:struct:shash_node::hmap_node
node	.\lib\simap.h	/^    struct hmap_node node;      \/* In struct simap's 'map' hmap. *\/$/;"	m	struct:simap_node	typeref:struct:simap_node::hmap_node
node	.\lib\smap.h	/^    struct hmap_node node;     \/* In struct smap's 'map' hmap. *\/$/;"	m	struct:smap_node	typeref:struct:smap_node::hmap_node
node	.\lib\stp.c	/^    struct list node;               \/* Node in all_stps list. *\/$/;"	m	struct:stp	typeref:struct:stp::list	file:
node	.\lib\unixctl.c	/^    struct list node;$/;"	m	struct:unixctl_conn	typeref:struct:unixctl_conn::list	file:
node	.\ofproto\bundles.c	/^    struct hmap_node  node;      \/* In struct ofconn's "bundles" hmap. *\/$/;"	m	struct:ofp_bundle	typeref:struct:ofp_bundle::hmap_node	file:
node	.\ofproto\bundles.c	/^    struct list       node;  \/* Element in 'struct ofp_bundles's msg_list *\/$/;"	m	struct:bundle_message	typeref:struct:bundle_message::list	file:
node	.\ofproto\connmgr.c	/^    struct hmap_node node;      \/* In struct connmgr's "services" hmap. *\/$/;"	m	struct:ofservice	typeref:struct:ofservice::hmap_node	file:
node	.\ofproto\connmgr.c	/^    struct list node;           \/* In struct connmgr's "all_conns" list. *\/$/;"	m	struct:ofconn	typeref:struct:ofconn::list	file:
node	.\ofproto\ofproto-dpif-ipfix.c	/^    struct hmap_node node;$/;"	m	struct:dpif_ipfix_flow_exporter_map_node	typeref:struct:dpif_ipfix_flow_exporter_map_node::hmap_node	file:
node	.\ofproto\ofproto-dpif-rid.c	/^    struct hmap_node node;$/;"	m	struct:rid_node	typeref:struct:rid_node::hmap_node	file:
node	.\ofproto\pinsched.c	/^    struct hmap_node node;      \/* In struct pinsched's 'queues' hmap. *\/$/;"	m	struct:pinqueue	typeref:struct:pinqueue::hmap_node	file:
node	.\ovsdb\jsonrpc-server.c	/^    struct hmap_node node;      \/* In ovsdb_jsonrpc_session's "monitors". *\/$/;"	m	struct:ovsdb_jsonrpc_monitor	typeref:struct:ovsdb_jsonrpc_monitor::hmap_node	file:
node	.\ovsdb\jsonrpc-server.c	/^    struct list node;           \/* Element in remote's sessions list. *\/$/;"	m	struct:ovsdb_jsonrpc_session	typeref:struct:ovsdb_jsonrpc_session::list	file:
node	.\ovsdb\ovsdb.h	/^    struct list node;           \/* Element in "struct ovsdb" replicas list. *\/$/;"	m	struct:ovsdb_replica	typeref:struct:ovsdb_replica::list
node	.\ovsdb\transaction.c	/^    struct list node;           \/* Element in ovsdb_txn's txn_tables list. *\/$/;"	m	struct:ovsdb_txn_table	typeref:struct:ovsdb_txn_table::list	file:
node	.\ovsdb\trigger.h	/^    struct list node;           \/* !result: in db->triggers;$/;"	m	struct:ovsdb_trigger	typeref:struct:ovsdb_trigger::list
node	.\python\compat\uuid.py	/^    node = property(get_node)$/;"	v	class:UUID
node	.\tests\test-hindex.c	/^    struct hindex_node node;$/;"	m	struct:element	typeref:struct:element::hindex_node	file:
node	.\tests\test-hmap.c	/^    struct hmap_node node;$/;"	m	struct:element	typeref:struct:element::hmap_node	file:
node	.\tests\test-list.c	/^    struct list node;$/;"	m	struct:element	typeref:struct:element::list	file:
node	.\vswitchd\bridge.c	/^    struct hmap_node node;      \/* In 'all_bridges'. *\/$/;"	m	struct:bridge	typeref:struct:bridge::hmap_node	file:
node_ver	.\datapath\flow_table.h	/^	int node_ver;$/;"	m	struct:table_instance
nodist_lib_libopenvswitch_la_SOURCES	.\lib\automake.mk	/^nodist_lib_libopenvswitch_la_SOURCES = \\$/;"	m
nonce	.\datapath\vport-lisp.c	/^		__u8 nonce[3];$/;"	m	union:lisphdr::__anon17	file:
nonce_present	.\datapath\vport-lisp.c	/^	__u8 nonce_present:1;$/;"	m	struct:lisphdr	file:
nonmiss	.\lib\ofp-util.h	/^    } nonmiss, miss;$/;"	m	struct:ofputil_table_features	typeref:struct:ofputil_table_features::ofputil_table_instruction_features
nonopt_end	.\lib\getopt_long.c	/^static int nonopt_end = -1;   \/* first option after non options (for permute) *\/$/;"	v	file:
nonopt_start	.\lib\getopt_long.c	/^static int nonopt_start = -1; \/* first non option argument (for permute) *\/$/;"	v	file:
normal	.\ofproto\ofproto-dpif-xlate.c	/^        } normal;$/;"	m	union:xc_entry::__anon136	typeref:struct:xc_entry::__anon136::__anon142	file:
normalize_idle_time	.\lib\mac-learning.c	/^normalize_idle_time(unsigned int idle_time)$/;"	f	file:
nossl_option	.\lib\stream-nossl.c	/^nossl_option(const char *detail)$/;"	f	file:
note	.\include\openflow\nicira-ext.h	/^    uint8_t note[6];                \/* Start of user-defined data. *\/$/;"	m	struct:nx_action_note
note	.\lib\ofp-actions.c	/^    struct nx_action_note note;$/;"	m	union:ofp_action	typeref:struct:ofp_action::nx_action_note	file:
note_from_openflow	.\lib\ofp-actions.c	/^note_from_openflow(const struct nx_action_note *nan, struct ofpbuf *out)$/;"	f	file:
notify_sock	.\lib\netlink-notifier.c	/^    struct nl_sock *notify_sock; \/* Netlink socket. *\/$/;"	m	struct:nln	typeref:struct:nln::nl_sock	file:
notify_sock	.\lib\rtbsd.c	/^static int notify_sock = -1;$/;"	v	file:
now	.\lib\sflow_api.h	/^    time_t now;             \/* time now *\/$/;"	m	struct:_SFLAgent
now	.\ofproto\ofproto.c	/^    long long int now;$/;"	m	struct:queue_stats_cbdata	file:
now	.\tests\test-reconnect.c	/^static int now;$/;"	v	file:
now	.\tests\test-reconnect.py	/^now = 0$/;"	v
nr_bridges	.\datapath\linux\compat\dev-openvswitch.c	/^static int nr_bridges;$/;"	v	file:
ntohl	.\include\sparse\netinet\in.h	/^static inline uint32_t ntohl(ovs_be32 x)$/;"	f
ntohll	.\lib\byte-order.h	/^ntohll(ovs_be64 n)$/;"	f
ntohs	.\include\sparse\netinet\in.h	/^static inline uint16_t ntohs(ovs_be16 x)$/;"	f
ntt_actor	.\lib\lacp.c	/^    struct lacp_info ntt_actor;   \/* Used to decide if we Need To Transmit. *\/$/;"	m	struct:slave	typeref:struct:slave::lacp_info	file:
null_fd	.\python\ovs\socket_util.py	/^null_fd = -1$/;"	v
null_from_json_null	.\lib\jsonrpc.c	/^null_from_json_null(struct json *json)$/;"	f	file:
null_idx	.\ofproto\pktbuf.c	/^    unsigned int null_idx;$/;"	m	struct:pktbuf	file:
nullable_string_is_equal	.\ofproto\ofproto-dpif-sflow.c	/^nullable_string_is_equal(const char *a, const char *b)$/;"	f	file:
numSamples	.\lib\sflow_api.h	/^    u_int32_t numSamples;$/;"	m	struct:_SFLSampleCollector
num_elements	.\lib\sflow.h	/^    u_int32_t num_elements;$/;"	m	struct:_SFLCounters_sample
num_elements	.\lib\sflow.h	/^    u_int32_t num_elements;$/;"	m	struct:_SFLCounters_sample_expanded
num_elements	.\lib\sflow.h	/^    u_int32_t num_elements;$/;"	m	struct:_SFLFlow_sample
num_elements	.\lib\sflow.h	/^    u_int32_t num_elements;$/;"	m	struct:_SFLFlow_sample_expanded
num_health_ccm	.\lib\cfm.c	/^    uint8_t num_health_ccm; \/* Number of received ccm frames every$/;"	m	struct:remote_mp	file:
num_records	.\lib\sflow.h	/^    u_int32_t num_records;           \/* Number of tag-len-val flow\/counter records to follow *\/$/;"	m	struct:_SFLSample_datagram_hdr
number	.\tests\test-ovsdb.c	/^    int number;$/;"	m	struct:test_trigger	file:
nw_addr	.\include\openflow\openflow-common.h	/^    ovs_be32 nw_addr;               \/* IP address. *\/$/;"	m	struct:ofp_action_nw_addr
nw_addr	.\lib\ofp-actions.c	/^    struct ofp_action_nw_addr nw_addr;$/;"	m	union:ofp_action	typeref:struct:ofp_action::ofp_action_nw_addr	file:
nw_dscp_values	.\tests\test-classifier.c	/^static uint8_t nw_dscp_values[] = { 48, 0 };$/;"	v	file:
nw_dst	.\include\openflow\openflow-1.0.h	/^    ovs_be32 nw_dst;           \/* IP destination address. *\/$/;"	m	struct:ofp10_match
nw_dst	.\include\openflow\openflow-1.1.h	/^    ovs_be32 nw_dst;           \/* IP destination address. *\/$/;"	m	struct:ofp11_match
nw_dst	.\lib\flow.h	/^    ovs_be32 nw_dst;            \/* IPv4 destination address. *\/$/;"	m	struct:flow
nw_dst	.\lib\pcap-file.c	/^    ovs_be32 nw_src, nw_dst;$/;"	m	struct:tcp_key	file:
nw_dst	.\ofproto\netflow.c	/^    ovs_be32 nw_dst;              \/* IPv4 destination address. *\/$/;"	m	struct:netflow_flow	file:
nw_dst_mask	.\include\openflow\openflow-1.1.h	/^    ovs_be32 nw_dst_mask;      \/* IP destination address mask. *\/$/;"	m	struct:ofp11_match
nw_dst_values	.\tests\test-classifier.c	/^static ovs_be32 nw_dst_values[] = { CONSTANT_HTONL(0xc0a80002),$/;"	v	file:
nw_ecn	.\include\openflow\openflow-1.1.h	/^    uint8_t nw_ecn;                   \/* IP ECN (2 bits). *\/$/;"	m	struct:ofp11_action_nw_ecn
nw_ecn	.\lib\ofp-actions.c	/^    struct ofp11_action_nw_ecn nw_ecn;$/;"	m	union:ofp_action	typeref:struct:ofp_action::ofp11_action_nw_ecn	file:
nw_frag	.\lib\flow.h	/^    uint8_t nw_frag;            \/* FLOW_FRAG_* flags. *\/$/;"	m	struct:flow
nw_proto	.\include\openflow\openflow-1.0.h	/^    uint8_t nw_proto;          \/* IP protocol or lower 8 bits of$/;"	m	struct:ofp10_match
nw_proto	.\include\openflow\openflow-1.1.h	/^    uint8_t nw_proto;          \/* IP protocol or lower 8 bits of ARP opcode. *\/$/;"	m	struct:ofp11_match
nw_proto	.\lib\flow.h	/^    uint8_t nw_proto;           \/* IP protocol or low 8 bits of ARP opcode. *\/$/;"	m	struct:flow
nw_proto	.\lib\ofp-parse.c	/^    uint8_t nw_proto;$/;"	m	struct:protocol	file:
nw_proto	.\ofproto\netflow.c	/^    uint8_t nw_proto;             \/* IP protocol. *\/$/;"	m	struct:netflow_flow	file:
nw_proto_values	.\tests\test-classifier.c	/^static uint8_t nw_proto_values[] = { IPPROTO_TCP, IPPROTO_ICMP };$/;"	v	file:
nw_src	.\include\openflow\openflow-1.0.h	/^    ovs_be32 nw_src;           \/* IP source address. *\/$/;"	m	struct:ofp10_match
nw_src	.\include\openflow\openflow-1.1.h	/^    ovs_be32 nw_src;           \/* IP source address. *\/$/;"	m	struct:ofp11_match
nw_src	.\lib\flow.h	/^    ovs_be32 nw_src;            \/* IPv4 source address. *\/$/;"	m	struct:flow
nw_src	.\lib\pcap-file.c	/^    ovs_be32 nw_src, nw_dst;$/;"	m	struct:tcp_key	file:
nw_src	.\ofproto\netflow.c	/^    ovs_be32 nw_src;              \/* IPv4 source address. *\/$/;"	m	struct:netflow_flow	file:
nw_src_mask	.\include\openflow\openflow-1.1.h	/^    ovs_be32 nw_src_mask;      \/* IP source address mask. *\/$/;"	m	struct:ofp11_match
nw_src_values	.\tests\test-classifier.c	/^static ovs_be32 nw_src_values[] = { CONSTANT_HTONL(0xc0a80001),$/;"	v	file:
nw_tos	.\include\openflow\openflow-1.0.h	/^    uint8_t nw_tos;            \/* IP ToS (DSCP field, 6 bits). *\/$/;"	m	struct:ofp10_match
nw_tos	.\include\openflow\openflow-1.1.h	/^    uint8_t nw_tos;            \/* IP ToS (actually DSCP field, 6 bits). *\/$/;"	m	struct:ofp11_match
nw_tos	.\include\openflow\openflow-common.h	/^    uint8_t nw_tos;                 \/* DSCP in high 6 bits, rest ignored. *\/$/;"	m	struct:ofp_action_nw_tos
nw_tos	.\lib\flow.h	/^    uint8_t nw_tos;             \/* IP ToS (including DSCP and ECN). *\/$/;"	m	struct:flow
nw_tos	.\lib\ofp-actions.c	/^    struct ofp_action_nw_tos nw_tos;$/;"	m	union:ofp_action	typeref:struct:ofp_action::ofp_action_nw_tos	file:
nw_tos	.\ofproto\netflow.c	/^    uint8_t nw_tos;               \/* IP ToS (including DSCP and ECN). *\/$/;"	m	struct:netflow_flow	file:
nw_ttl	.\include\openflow\openflow-1.1.h	/^    uint8_t nw_ttl;                   \/* IP TTL *\/$/;"	m	struct:ofp11_action_nw_ttl
nw_ttl	.\lib\flow.h	/^    uint8_t nw_ttl;             \/* IP TTL\/Hop Limit. *\/$/;"	m	struct:flow
nw_ttl	.\lib\ofp-actions.c	/^    struct ofp11_action_nw_ttl nw_ttl;$/;"	m	union:ofp_action	typeref:struct:ofp_action::ofp11_action_nw_ttl	file:
nx_action_bundle	.\include\openflow\nicira-ext.h	/^struct nx_action_bundle {$/;"	s
nx_action_cnt_ids	.\include\openflow\nicira-ext.h	/^struct nx_action_cnt_ids {$/;"	s
nx_action_controller	.\include\openflow\nicira-ext.h	/^struct nx_action_controller {$/;"	s
nx_action_fin_timeout	.\include\openflow\nicira-ext.h	/^struct nx_action_fin_timeout {$/;"	s
nx_action_header	.\include\openflow\nicira-ext.h	/^struct nx_action_header {$/;"	s
nx_action_learn	.\include\openflow\nicira-ext.h	/^struct nx_action_learn {$/;"	s
nx_action_mpls_label	.\include\openflow\nicira-ext.h	/^struct nx_action_mpls_label {$/;"	s
nx_action_mpls_tc	.\include\openflow\nicira-ext.h	/^struct nx_action_mpls_tc {$/;"	s
nx_action_mpls_ttl	.\include\openflow\nicira-ext.h	/^struct nx_action_mpls_ttl {$/;"	s
nx_action_multipath	.\include\openflow\nicira-ext.h	/^struct nx_action_multipath {$/;"	s
nx_action_note	.\include\openflow\nicira-ext.h	/^struct nx_action_note {$/;"	s
nx_action_output_reg	.\include\openflow\nicira-ext.h	/^struct nx_action_output_reg {$/;"	s
nx_action_pop_mpls	.\include\openflow\nicira-ext.h	/^struct nx_action_pop_mpls {$/;"	s
nx_action_pop_queue	.\include\openflow\nicira-ext.h	/^struct nx_action_pop_queue {$/;"	s
nx_action_push_mpls	.\include\openflow\nicira-ext.h	/^struct nx_action_push_mpls {$/;"	s
nx_action_reg_load	.\include\openflow\nicira-ext.h	/^struct nx_action_reg_load {$/;"	s
nx_action_reg_move	.\include\openflow\nicira-ext.h	/^struct nx_action_reg_move {$/;"	s
nx_action_resubmit	.\include\openflow\nicira-ext.h	/^struct nx_action_resubmit {$/;"	s
nx_action_sample	.\include\openflow\nicira-ext.h	/^struct nx_action_sample {$/;"	s
nx_action_set_queue	.\include\openflow\nicira-ext.h	/^struct nx_action_set_queue {$/;"	s
nx_action_set_tunnel	.\include\openflow\nicira-ext.h	/^struct nx_action_set_tunnel {$/;"	s
nx_action_set_tunnel64	.\include\openflow\nicira-ext.h	/^struct nx_action_set_tunnel64 {$/;"	s
nx_action_stack	.\include\openflow\nicira-ext.h	/^struct nx_action_stack {$/;"	s
nx_action_subtype	.\include\openflow\nicira-ext.h	/^enum nx_action_subtype {$/;"	g
nx_action_write_metadata	.\include\openflow\nicira-ext.h	/^struct nx_action_write_metadata {$/;"	s
nx_aggregate_stats_request	.\include\openflow\nicira-ext.h	/^struct nx_aggregate_stats_request {$/;"	s
nx_async_config	.\include\openflow\nicira-ext.h	/^struct nx_async_config {$/;"	s
nx_bd_algorithm	.\include\openflow\nicira-ext.h	/^enum nx_bd_algorithm {$/;"	g
nx_controller_id	.\include\openflow\nicira-ext.h	/^struct nx_controller_id {$/;"	s
nx_entry_ok	.\lib\nx-match.c	/^nx_entry_ok(const void *p, unsigned int match_len)$/;"	f	file:
nx_flow_format	.\include\openflow\nicira-ext.h	/^enum nx_flow_format {$/;"	g
nx_flow_mod	.\include\openflow\nicira-ext.h	/^struct nx_flow_mod {$/;"	s
nx_flow_mod_table_id	.\include\openflow\nicira-ext.h	/^struct nx_flow_mod_table_id {$/;"	s
nx_flow_monitor_cancel	.\include\openflow\nicira-ext.h	/^struct nx_flow_monitor_cancel {$/;"	s
nx_flow_monitor_flags	.\include\openflow\nicira-ext.h	/^enum nx_flow_monitor_flags {$/;"	g
nx_flow_monitor_flags_to_name	.\lib\ofp-print.c	/^nx_flow_monitor_flags_to_name(uint32_t bit)$/;"	f	file:
nx_flow_monitor_request	.\include\openflow\nicira-ext.h	/^struct nx_flow_monitor_request {$/;"	s
nx_flow_removed	.\include\openflow\nicira-ext.h	/^struct nx_flow_removed {$/;"	s
nx_flow_stats	.\include\openflow\nicira-ext.h	/^struct nx_flow_stats {$/;"	s
nx_flow_stats_request	.\include\openflow\nicira-ext.h	/^struct nx_flow_stats_request {$/;"	s
nx_flow_update_abbrev	.\include\openflow\nicira-ext.h	/^struct nx_flow_update_abbrev {$/;"	s
nx_flow_update_event	.\include\openflow\nicira-ext.h	/^enum nx_flow_update_event {$/;"	g
nx_flow_update_full	.\include\openflow\nicira-ext.h	/^struct nx_flow_update_full {$/;"	s
nx_flow_update_header	.\include\openflow\nicira-ext.h	/^struct nx_flow_update_header {$/;"	s
nx_hash_fields	.\include\openflow\nicira-ext.h	/^enum nx_hash_fields {$/;"	g
nx_match	.\lib\nx-match.c	/^VLOG_DEFINE_THIS_MODULE(nx_match);$/;"	v
nx_match_from_string	.\lib\nx-match.c	/^nx_match_from_string(const char *s, struct ofpbuf *b)$/;"	f
nx_match_from_string_raw	.\lib\nx-match.c	/^nx_match_from_string_raw(const char *s, struct ofpbuf *b)$/;"	f	file:
nx_match_to_string	.\lib\nx-match.c	/^nx_match_to_string(const uint8_t *p, unsigned int match_len)$/;"	f
nx_mp_algorithm	.\include\openflow\nicira-ext.h	/^enum nx_mp_algorithm {$/;"	g
nx_packet_in	.\include\openflow\nicira-ext.h	/^struct nx_packet_in {$/;"	s
nx_packet_in_format	.\include\openflow\nicira-ext.h	/^enum nx_packet_in_format {$/;"	g
nx_pull_match	.\lib\nx-match.c	/^nx_pull_match(struct ofpbuf *b, unsigned int match_len, struct match *match,$/;"	f
nx_pull_match__	.\lib\nx-match.c	/^nx_pull_match__(struct ofpbuf *b, unsigned int match_len, bool strict,$/;"	f	file:
nx_pull_match_loose	.\lib\nx-match.c	/^nx_pull_match_loose(struct ofpbuf *b, unsigned int match_len,$/;"	f
nx_pull_raw	.\lib\nx-match.c	/^nx_pull_raw(const uint8_t *p, unsigned int match_len, bool strict,$/;"	f	file:
nx_put_match	.\lib\nx-match.c	/^nx_put_match(struct ofpbuf *b, const struct match *match,$/;"	f
nx_put_raw	.\lib\nx-match.c	/^nx_put_raw(struct ofpbuf *b, enum ofp_version oxm, const struct match *match,$/;"	f	file:
nx_role	.\include\openflow\nicira-ext.h	/^enum nx_role {$/;"	g
nx_role_request	.\include\openflow\nicira-ext.h	/^struct nx_role_request {$/;"	s
nx_set_flow_format	.\include\openflow\nicira-ext.h	/^struct nx_set_flow_format {$/;"	s
nx_set_packet_in_format	.\include\openflow\nicira-ext.h	/^struct nx_set_packet_in_format {$/;"	s
nx_stack_pop	.\lib\nx-match.c	/^nx_stack_pop(struct ofpbuf *stack)$/;"	f	file:
nx_stack_push	.\lib\nx-match.c	/^nx_stack_push(struct ofpbuf *stack, union mf_subvalue *v)$/;"	f	file:
nx_vendor_code	.\include\openflow\nicira-ext.h	/^enum nx_vendor_code {$/;"	g
nx_vendor_error	.\include\openflow\nicira-ext.h	/^struct nx_vendor_error {$/;"	s
nxa_header	.\lib\ofp-actions.c	/^    struct nx_action_header nxa_header;$/;"	m	union:ofp_action	typeref:struct:ofp_action::nx_action_header	file:
nxm_decode_n_bits	.\lib\nx-match.h	/^nxm_decode_n_bits(ovs_be16 ofs_nbits)$/;"	f
nxm_decode_ofs	.\lib\nx-match.h	/^nxm_decode_ofs(ovs_be16 ofs_nbits)$/;"	f
nxm_do_init	.\lib\meta-flow.c	/^nxm_do_init(void)$/;"	f	file:
nxm_encode_ofs_nbits	.\lib\nx-match.h	/^nxm_encode_ofs_nbits(int ofs, int n_bits)$/;"	f
nxm_execute_reg_load	.\lib\nx-match.c	/^nxm_execute_reg_load(const struct ofpact_reg_load *load, struct flow *flow,$/;"	f
nxm_execute_reg_move	.\lib\nx-match.c	/^nxm_execute_reg_move(const struct ofpact_reg_move *move,$/;"	f
nxm_execute_stack_pop	.\lib\nx-match.c	/^nxm_execute_stack_pop(const struct ofpact_stack *pop,$/;"	f
nxm_execute_stack_push	.\lib\nx-match.c	/^nxm_execute_stack_push(const struct ofpact_stack *push,$/;"	f
nxm_field	.\lib\meta-flow.c	/^struct nxm_field {$/;"	s	file:
nxm_field_bits	.\lib\nx-match.c	/^nxm_field_bits(uint32_t header)$/;"	f
nxm_field_bytes	.\lib\nx-match.c	/^nxm_field_bytes(uint32_t header)$/;"	f
nxm_format_reg_load	.\lib\nx-match.c	/^nxm_format_reg_load(const struct ofpact_reg_load *load, struct ds *s)$/;"	f
nxm_format_reg_move	.\lib\nx-match.c	/^nxm_format_reg_move(const struct ofpact_reg_move *move, struct ds *s)$/;"	f
nxm_format_stack_pop	.\lib\nx-match.c	/^nxm_format_stack_pop(const struct ofpact_stack *pop, struct ds *s)$/;"	f
nxm_format_stack_push	.\lib\nx-match.c	/^nxm_format_stack_push(const struct ofpact_stack *push, struct ds *s)$/;"	f
nxm_header	.\lib\meta-flow.h	/^    uint32_t nxm_header;        \/* An NXM_* (or OXM_*) constant. *\/$/;"	m	struct:mf_field
nxm_init	.\lib\meta-flow.c	/^nxm_init(void)$/;"	f	file:
nxm_init_add_field	.\lib\meta-flow.c	/^nxm_init_add_field(const struct mf_field *mf, uint32_t header)$/;"	f	file:
nxm_name	.\lib\meta-flow.h	/^    const char *nxm_name;       \/* The nxm_header constant's name. *\/$/;"	m	struct:mf_field
nxm_parse_reg_load	.\lib\nx-match.c	/^nxm_parse_reg_load(struct ofpact_reg_load *load, const char *s)$/;"	f
nxm_parse_reg_move	.\lib\nx-match.c	/^nxm_parse_reg_move(struct ofpact_reg_move *move, const char *s)$/;"	f
nxm_parse_stack_action	.\lib\nx-match.c	/^nxm_parse_stack_action(struct ofpact_stack *stack_action, const char *s)$/;"	f
nxm_put_16	.\lib\nx-match.c	/^nxm_put_16(struct ofpbuf *b, uint32_t header, ovs_be16 value)$/;"	f	file:
nxm_put_16m	.\lib\nx-match.c	/^nxm_put_16m(struct ofpbuf *b, uint32_t header, ovs_be16 value, ovs_be16 mask)$/;"	f	file:
nxm_put_16w	.\lib\nx-match.c	/^nxm_put_16w(struct ofpbuf *b, uint32_t header, ovs_be16 value, ovs_be16 mask)$/;"	f	file:
nxm_put_32	.\lib\nx-match.c	/^nxm_put_32(struct ofpbuf *b, uint32_t header, ovs_be32 value)$/;"	f	file:
nxm_put_32m	.\lib\nx-match.c	/^nxm_put_32m(struct ofpbuf *b, uint32_t header, ovs_be32 value, ovs_be32 mask)$/;"	f	file:
nxm_put_32w	.\lib\nx-match.c	/^nxm_put_32w(struct ofpbuf *b, uint32_t header, ovs_be32 value, ovs_be32 mask)$/;"	f	file:
nxm_put_64	.\lib\nx-match.c	/^nxm_put_64(struct ofpbuf *b, uint32_t header, ovs_be64 value)$/;"	f	file:
nxm_put_64m	.\lib\nx-match.c	/^nxm_put_64m(struct ofpbuf *b, uint32_t header, ovs_be64 value, ovs_be64 mask)$/;"	f	file:
nxm_put_64w	.\lib\nx-match.c	/^nxm_put_64w(struct ofpbuf *b, uint32_t header, ovs_be64 value, ovs_be64 mask)$/;"	f	file:
nxm_put_8	.\lib\nx-match.c	/^nxm_put_8(struct ofpbuf *b, uint32_t header, uint8_t value)$/;"	f	file:
nxm_put_8m	.\lib\nx-match.c	/^nxm_put_8m(struct ofpbuf *b, uint32_t header, uint8_t value, uint8_t mask)$/;"	f	file:
nxm_put_eth	.\lib\nx-match.c	/^nxm_put_eth(struct ofpbuf *b, uint32_t header,$/;"	f	file:
nxm_put_eth_masked	.\lib\nx-match.c	/^nxm_put_eth_masked(struct ofpbuf *b, uint32_t header,$/;"	f	file:
nxm_put_frag	.\lib\nx-match.c	/^nxm_put_frag(struct ofpbuf *b, const struct match *match)$/;"	f	file:
nxm_put_header	.\lib\nx-match.c	/^nxm_put_header(struct ofpbuf *b, uint32_t header)$/;"	f	file:
nxm_put_ip	.\lib\nx-match.c	/^nxm_put_ip(struct ofpbuf *b, const struct match *match, enum ofp_version oxm)$/;"	f	file:
nxm_put_ipv6	.\lib\nx-match.c	/^nxm_put_ipv6(struct ofpbuf *b, uint32_t header,$/;"	f	file:
nxm_reg_load	.\lib\nx-match.c	/^nxm_reg_load(const struct mf_subfield *dst, uint64_t src_data,$/;"	f
nxm_reg_load_check	.\lib\nx-match.c	/^nxm_reg_load_check(const struct ofpact_reg_load *load, const struct flow *flow)$/;"	f
nxm_reg_load_from_openflow	.\lib\nx-match.c	/^nxm_reg_load_from_openflow(const struct nx_action_reg_load *narl,$/;"	f
nxm_reg_load_to_nxast	.\lib\nx-match.c	/^nxm_reg_load_to_nxast(const struct ofpact_reg_load *load,$/;"	f
nxm_reg_move_check	.\lib\nx-match.c	/^nxm_reg_move_check(const struct ofpact_reg_move *move, const struct flow *flow)$/;"	f
nxm_reg_move_from_openflow	.\lib\nx-match.c	/^nxm_reg_move_from_openflow(const struct nx_action_reg_move *narm,$/;"	f
nxm_reg_move_to_nxast	.\lib\nx-match.c	/^nxm_reg_move_to_nxast(const struct ofpact_reg_move *move,$/;"	f
nxm_stack_pop_check	.\lib\nx-match.c	/^nxm_stack_pop_check(const struct ofpact_stack *pop,$/;"	f
nxm_stack_pop_from_openflow	.\lib\nx-match.c	/^nxm_stack_pop_from_openflow(const struct nx_action_stack *nasp,$/;"	f
nxm_stack_pop_to_nxast	.\lib\nx-match.c	/^nxm_stack_pop_to_nxast(const struct ofpact_stack *stack,$/;"	f
nxm_stack_push_check	.\lib\nx-match.c	/^nxm_stack_push_check(const struct ofpact_stack *push,$/;"	f
nxm_stack_push_from_openflow	.\lib\nx-match.c	/^nxm_stack_push_from_openflow(const struct nx_action_stack *nasp,$/;"	f
nxm_stack_push_to_nxast	.\lib\nx-match.c	/^nxm_stack_push_to_nxast(const struct ofpact_stack *stack,$/;"	f
nxm_stack_to_nxast__	.\lib\nx-match.c	/^nxm_stack_to_nxast__(const struct ofpact_stack *stack_action,$/;"	f	file:
nxt	.\lib\sflow.h	/^    struct _SFLCounters_sample_element *nxt; \/* linked list *\/$/;"	m	struct:_SFLCounters_sample_element	typeref:struct:_SFLCounters_sample_element::_SFLCounters_sample_element
nxt	.\lib\sflow.h	/^    struct _SFLFlow_sample_element *nxt;$/;"	m	struct:_SFLFlow_sample_element	typeref:struct:_SFLFlow_sample_element::_SFLFlow_sample_element
nxt	.\lib\sflow_api.h	/^    struct _SFLPoller *nxt;$/;"	m	struct:_SFLPoller	typeref:struct:_SFLPoller::_SFLPoller
nxt	.\lib\sflow_api.h	/^    struct _SFLReceiver *nxt;$/;"	m	struct:_SFLReceiver	typeref:struct:_SFLReceiver::_SFLReceiver
nxt	.\lib\sflow_api.h	/^    struct _SFLSampler *nxt;$/;"	m	struct:_SFLSampler	typeref:struct:_SFLSampler::_SFLSampler
object	.\lib\json.h	/^        struct shash *object;   \/* Contains "struct json *"s. *\/$/;"	m	union:json::__anon49	typeref:struct:json::__anon49::shash
obs_domain_id	.\include\openflow\nicira-ext.h	/^    ovs_be32 obs_domain_id;         \/* ID of sampling observation domain. *\/$/;"	m	struct:nx_action_sample
obs_domain_id	.\lib\odp-util.h	/^        uint32_t obs_domain_id; \/* Observation Domain ID. *\/$/;"	m	struct:user_action_cookie::__anon71
obs_domain_id	.\lib\ofp-actions.h	/^    uint32_t obs_domain_id;$/;"	m	struct:ofpact_sample
obs_domain_id	.\lib\vswitch-idl.h	/^	int64_t *obs_domain_id;$/;"	m	struct:ovsrec_ipfix
obs_domain_id	.\ofproto\ofproto-dpif-ipfix.c	/^    uint32_t obs_domain_id;$/;"	m	struct:ipfix_flow_key	file:
obs_domain_id	.\ofproto\ofproto.h	/^    uint32_t obs_domain_id;  \/* Bridge-wide Observation Domain ID. *\/$/;"	m	struct:ofproto_ipfix_bridge_exporter_options
obs_point_id	.\include\openflow\nicira-ext.h	/^    ovs_be32 obs_point_id;          \/* ID of sampling observation point. *\/$/;"	m	struct:nx_action_sample
obs_point_id	.\lib\odp-util.h	/^        uint32_t obs_point_id;  \/* Observation Point ID. *\/$/;"	m	struct:user_action_cookie::__anon71
obs_point_id	.\lib\ofp-actions.h	/^    uint32_t obs_point_id;$/;"	m	struct:ofpact_sample
obs_point_id	.\lib\vswitch-idl.h	/^	int64_t *obs_point_id;$/;"	m	struct:ovsrec_ipfix
obs_point_id	.\ofproto\ofproto.h	/^    uint32_t obs_point_id;  \/* Bridge-wide Observation Point ID. *\/$/;"	m	struct:ofproto_ipfix_bridge_exporter_options
octet_delta_count	.\ofproto\ofproto-dpif-ipfix.c	/^    uint64_t octet_delta_count;$/;"	m	struct:ipfix_flow_cache_entry	file:
octet_delta_sum_of_squares	.\ofproto\ofproto-dpif-ipfix.c	/^    uint64_t octet_delta_sum_of_squares;  \/* 0 if not IP. *\/$/;"	m	struct:ipfix_flow_cache_entry	file:
octets	.\lib\sflow.h	/^    u_int64_t octets;$/;"	m	struct:_SFLVlan_counters
octets	.\lib\unicode.c	/^    uint8_t octets[5][2];$/;"	m	struct:utf8_sequence	file:
odp_action_len	.\lib\odp-util.c	/^odp_action_len(uint16_t type)$/;"	f	file:
odp_actions	.\ofproto\ofproto-dpif-xlate.h	/^    struct ofpbuf odp_actions;$/;"	m	struct:xlate_out	typeref:struct:xlate_out::ofpbuf
odp_actions_from_string	.\lib\odp-util.c	/^odp_actions_from_string(const char *s, const struct simap *port_names,$/;"	f
odp_actions_stub	.\ofproto\ofproto-dpif-xlate.h	/^    uint64_t odp_actions_stub[256 \/ 8];$/;"	m	struct:xlate_out
odp_eth_set_addrs	.\lib\odp-execute.c	/^odp_eth_set_addrs(struct ofpbuf *packet,$/;"	f	file:
odp_execute_actions	.\lib\odp-execute.c	/^odp_execute_actions(void *dp, struct ofpbuf *packet, bool steal,$/;"	f
odp_execute_actions__	.\lib\odp-execute.c	/^odp_execute_actions__(void *dp, struct ofpbuf *packet, bool steal,$/;"	f	file:
odp_execute_cb	.\lib\odp-execute.h	/^typedef void (*odp_execute_cb)(void *dp, struct ofpbuf *packet,$/;"	t
odp_execute_sample	.\lib\odp-execute.c	/^odp_execute_sample(void *dp, struct ofpbuf *packet, bool steal,$/;"	f	file:
odp_execute_set_action	.\lib\odp-execute.c	/^odp_execute_set_action(struct ofpbuf *packet, const struct nlattr *a,$/;"	f	file:
odp_flow_format	.\lib\odp-util.c	/^odp_flow_format(const struct nlattr *key, size_t key_len,$/;"	f
odp_flow_from_string	.\lib\odp-util.c	/^odp_flow_from_string(const char *s, const struct simap *port_names,$/;"	f
odp_flow_key_attr_len	.\lib\odp-util.c	/^odp_flow_key_attr_len(uint16_t type)$/;"	f	file:
odp_flow_key_format	.\lib\odp-util.c	/^odp_flow_key_format(const struct nlattr *key,$/;"	f
odp_flow_key_from_flow	.\lib\odp-util.c	/^odp_flow_key_from_flow(struct ofpbuf *buf, const struct flow *flow,$/;"	f
odp_flow_key_from_flow__	.\lib\odp-util.c	/^odp_flow_key_from_flow__(struct ofpbuf *buf, const struct flow *flow,$/;"	f	file:
odp_flow_key_from_mask	.\lib\odp-util.c	/^odp_flow_key_from_mask(struct ofpbuf *buf, const struct flow *mask,$/;"	f
odp_flow_key_hash	.\lib\odp-util.c	/^odp_flow_key_hash(const struct nlattr *key, size_t key_len)$/;"	f
odp_flow_key_to_flow	.\lib\odp-util.c	/^odp_flow_key_to_flow(const struct nlattr *key, size_t key_len,$/;"	f
odp_flow_key_to_flow__	.\lib\odp-util.c	/^odp_flow_key_to_flow__(const struct nlattr *key, size_t key_len,$/;"	f	file:
odp_flow_key_to_mask	.\lib\odp-util.c	/^odp_flow_key_to_mask(const struct nlattr *key, size_t key_len,$/;"	f
odp_garbage	.\ofproto\ofproto-dpif.c	/^struct odp_garbage {$/;"	s	file:
odp_in_port	.\ofproto\ofproto-dpif-upcall.c	/^    odp_port_t odp_in_port;$/;"	m	struct:flow_miss	file:
odp_key_fitness	.\lib\odp-util.h	/^enum odp_key_fitness {$/;"	g
odp_key_fitness_to_string	.\lib\odp-util.c	/^odp_key_fitness_to_string(enum odp_key_fitness fitness)$/;"	f
odp_key_from_pkt_metadata	.\lib\odp-util.c	/^odp_key_from_pkt_metadata(struct ofpbuf *buf, const struct pkt_metadata *md)$/;"	f
odp_key_to_pkt_metadata	.\lib\odp-util.c	/^odp_key_to_pkt_metadata(const struct nlattr *key, size_t key_len,$/;"	f
odp_mask_attr_is_exact	.\lib\odp-util.c	/^odp_mask_attr_is_exact(const struct nlattr *ma)$/;"	f	file:
odp_mask_attr_is_wildcard	.\lib\odp-util.c	/^odp_mask_attr_is_wildcard(const struct nlattr *ma)$/;"	f	file:
odp_port	.\lib\packets.h	/^    odp_port_t odp_port;$/;"	m	union:flow_in_port
odp_port	.\ofproto\ofproto-dpif-sflow.c	/^    odp_port_t odp_port;$/;"	m	struct:dpif_sflow_port	file:
odp_port	.\ofproto\ofproto-dpif-xlate.c	/^    odp_port_t odp_port;             \/* Datapath port number or ODPP_NONE. *\/$/;"	m	struct:xport	file:
odp_port	.\ofproto\ofproto-dpif.c	/^    odp_port_t odp_port;$/;"	m	struct:odp_garbage	file:
odp_port	.\ofproto\ofproto-dpif.c	/^    odp_port_t odp_port;$/;"	m	struct:ofport_dpif	file:
odp_port	.\ofproto\tunnel.c	/^    odp_port_t odp_port;$/;"	m	struct:tnl_match	file:
odp_port_is_alive	.\ofproto\ofproto-dpif-xlate.c	/^odp_port_is_alive(const struct xlate_ctx *ctx, ofp_port_t ofp_port)$/;"	f	file:
odp_port_node	.\ofproto\ofproto-dpif.c	/^    struct hmap_node odp_port_node; \/* In dpif_backer's "odp_to_ofport_map". *\/$/;"	m	struct:ofport_dpif	typeref:struct:ofport_dpif::hmap_node	file:
odp_port_t	.\include\openvswitch\types.h	/^typedef uint32_t OVS_BITWISE odp_port_t;$/;"	t
odp_port_to_ofp_port	.\ofproto\ofproto-dpif.c	/^odp_port_to_ofp_port(const struct ofproto_dpif *ofproto, odp_port_t odp_port)$/;"	f	file:
odp_port_to_ofport	.\ofproto\ofproto-dpif.c	/^odp_port_to_ofport(const struct dpif_backer *backer, odp_port_t odp_port)$/;"	f
odp_portno_names	.\lib\odp-util.h	/^struct odp_portno_names {$/;"	s
odp_portno_names_destroy	.\lib\odp-util.c	/^odp_portno_names_destroy(struct hmap *portno_names)$/;"	f
odp_portno_names_get	.\lib\odp-util.c	/^odp_portno_names_get(const struct hmap *portno_names, odp_port_t port_no)$/;"	f	file:
odp_portno_names_set	.\lib\odp-util.c	/^odp_portno_names_set(struct hmap *portno_names, odp_port_t port_no,$/;"	f
odp_put_pkt_mark_action	.\lib\odp-util.c	/^odp_put_pkt_mark_action(const uint32_t pkt_mark,$/;"	f
odp_put_tunnel_action	.\lib\odp-util.c	/^odp_put_tunnel_action(const struct flow_tnl *tunnel,$/;"	f
odp_put_userspace_action	.\lib\odp-util.c	/^odp_put_userspace_action(uint32_t pid,$/;"	f
odp_set_tunnel_action	.\lib\odp-execute.c	/^odp_set_tunnel_action(const struct nlattr *a, struct flow_tnl *tun_key)$/;"	f	file:
odp_to_ofport_lock	.\ofproto\ofproto-dpif.c	/^    struct ovs_rwlock odp_to_ofport_lock;$/;"	m	struct:dpif_backer	typeref:struct:dpif_backer::ovs_rwlock	file:
odp_to_ovs_frag	.\lib\odp-util.c	/^odp_to_ovs_frag(uint8_t odp_frag, struct flow *flow)$/;"	f	file:
odp_tun_key_from_attr	.\lib\odp-util.c	/^odp_tun_key_from_attr(const struct nlattr *attr, struct flow_tnl *tun)$/;"	f
odp_util	.\lib\odp-util.c	/^VLOG_DEFINE_THIS_MODULE(odp_util);$/;"	v
odputil_keybuf	.\lib\odp-util.h	/^struct odputil_keybuf {$/;"	s
of10_action_bits	.\lib\ofp-util.c	/^static const struct ofputil_action_bit_translation of10_action_bits[] = {$/;"	v	typeref:struct:ofputil_action_bit_translation	file:
of_bit	.\lib\ofp-util.c	/^    int of_bit;$/;"	m	struct:ofputil_action_bit_translation	file:
ofbundle	.\ofproto\ofproto-dpif-mirror.c	/^    struct ofbundle *ofbundle;$/;"	m	struct:mbundle	typeref:struct:mbundle::ofbundle	file:
ofbundle	.\ofproto\ofproto-dpif-xlate.c	/^    struct ofbundle *ofbundle;     \/* Key in global 'xbundles' map. *\/$/;"	m	struct:xbundle	typeref:struct:xbundle::ofbundle	file:
ofbundle	.\ofproto\ofproto-dpif.c	/^struct ofbundle {$/;"	s	file:
ofbundle_get_a_port	.\ofproto\ofproto-dpif.c	/^ofbundle_get_a_port(const struct ofbundle *bundle)$/;"	f	file:
ofconn	.\ofproto\connmgr.c	/^struct ofconn {$/;"	s	file:
ofconn	.\ofproto\connmgr.h	/^    struct ofconn *ofconn;      \/* Owning 'ofconn'. *\/$/;"	m	struct:ofmonitor	typeref:struct:ofmonitor::ofconn
ofconn	.\ofproto\ofproto.c	/^    struct ofconn *ofconn;      \/* ofconn for reply (but see note above). *\/$/;"	m	struct:ofopgroup	typeref:struct:ofopgroup::ofconn	file:
ofconn_add_opgroup	.\ofproto\connmgr.c	/^ofconn_add_opgroup(struct ofconn *ofconn, struct list *ofconn_node)$/;"	f
ofconn_async_msg_type	.\ofproto\connmgr.h	/^enum ofconn_async_msg_type {$/;"	g
ofconn_create	.\ofproto\connmgr.c	/^ofconn_create(struct connmgr *mgr, struct rconn *rconn, enum ofconn_type type,$/;"	f	file:
ofconn_get_async_config	.\ofproto\connmgr.c	/^ofconn_get_async_config(struct ofconn *ofconn,$/;"	f
ofconn_get_bundles	.\ofproto\connmgr.c	/^ofconn_get_bundles(struct ofconn *ofconn)$/;"	f
ofconn_get_invalid_ttl_to_controller	.\ofproto\connmgr.c	/^ofconn_get_invalid_ttl_to_controller(struct ofconn *ofconn)$/;"	f
ofconn_get_master_election_id	.\ofproto\connmgr.c	/^ofconn_get_master_election_id(const struct ofconn *ofconn, uint64_t *idp)$/;"	f
ofconn_get_miss_send_len	.\ofproto\connmgr.c	/^ofconn_get_miss_send_len(const struct ofconn *ofconn)$/;"	f
ofconn_get_ofproto	.\ofproto\connmgr.c	/^ofconn_get_ofproto(const struct ofconn *ofconn)$/;"	f
ofconn_get_packet_in_format	.\ofproto\connmgr.c	/^ofconn_get_packet_in_format(struct ofconn *ofconn)$/;"	f
ofconn_get_protocol	.\ofproto\connmgr.c	/^ofconn_get_protocol(const struct ofconn *ofconn)$/;"	f
ofconn_get_role	.\ofproto\connmgr.c	/^ofconn_get_role(const struct ofconn *ofconn)$/;"	f
ofconn_get_target	.\ofproto\connmgr.c	/^ofconn_get_target(const struct ofconn *ofconn)$/;"	f	file:
ofconn_get_type	.\ofproto\connmgr.c	/^ofconn_get_type(const struct ofconn *ofconn)$/;"	f
ofconn_has_pending_opgroups	.\ofproto\connmgr.c	/^ofconn_has_pending_opgroups(const struct ofconn *ofconn)$/;"	f
ofconn_log_flow_mods	.\ofproto\connmgr.c	/^ofconn_log_flow_mods(struct ofconn *ofconn)$/;"	f	file:
ofconn_make_name	.\ofproto\connmgr.c	/^ofconn_make_name(const struct connmgr *mgr, const char *target)$/;"	f	file:
ofconn_may_recv	.\ofproto\connmgr.c	/^ofconn_may_recv(const struct ofconn *ofconn)$/;"	f	file:
ofconn_node	.\ofproto\connmgr.h	/^    struct hmap_node ofconn_node; \/* In ofconn's 'monitors' hmap. *\/$/;"	m	struct:ofmonitor	typeref:struct:ofmonitor::hmap_node
ofconn_node	.\ofproto\ofproto.c	/^    struct list ofconn_node;    \/* In ofconn's list of pending opgroups. *\/$/;"	m	struct:ofopgroup	typeref:struct:ofopgroup::list	file:
ofconn_pktbuf_retrieve	.\ofproto\connmgr.c	/^ofconn_pktbuf_retrieve(struct ofconn *ofconn, uint32_t id,$/;"	f
ofconn_receives_async_msg	.\ofproto\connmgr.c	/^ofconn_receives_async_msg(const struct ofconn *ofconn,$/;"	f	file:
ofconn_reconfigure	.\ofproto\connmgr.c	/^ofconn_reconfigure(struct ofconn *ofconn, const struct ofproto_controller *c)$/;"	f	file:
ofconn_report_flow_mod	.\ofproto\connmgr.c	/^ofconn_report_flow_mod(struct ofconn *ofconn,$/;"	f
ofconn_run	.\ofproto\connmgr.c	/^ofconn_run(struct ofconn *ofconn,$/;"	f	file:
ofconn_send	.\ofproto\connmgr.c	/^ofconn_send(const struct ofconn *ofconn, struct ofpbuf *msg,$/;"	f	file:
ofconn_send_error	.\ofproto\connmgr.c	/^ofconn_send_error(const struct ofconn *ofconn,$/;"	f
ofconn_send_replies	.\ofproto\connmgr.c	/^ofconn_send_replies(const struct ofconn *ofconn, struct list *replies)$/;"	f
ofconn_send_reply	.\ofproto\connmgr.c	/^ofconn_send_reply(const struct ofconn *ofconn, struct ofpbuf *msg)$/;"	f
ofconn_send_role_status	.\ofproto\connmgr.c	/^ofconn_send_role_status(struct ofconn *ofconn, uint32_t role, uint8_t reason)$/;"	f
ofconn_set_async_config	.\ofproto\connmgr.c	/^ofconn_set_async_config(struct ofconn *ofconn,$/;"	f
ofconn_set_controller_id	.\ofproto\connmgr.c	/^ofconn_set_controller_id(struct ofconn *ofconn, uint16_t controller_id)$/;"	f
ofconn_set_invalid_ttl_to_controller	.\ofproto\connmgr.c	/^ofconn_set_invalid_ttl_to_controller(struct ofconn *ofconn, bool enable)$/;"	f
ofconn_set_master_election_id	.\ofproto\connmgr.c	/^ofconn_set_master_election_id(struct ofconn *ofconn, uint64_t id)$/;"	f
ofconn_set_miss_send_len	.\ofproto\connmgr.c	/^ofconn_set_miss_send_len(struct ofconn *ofconn, int miss_send_len)$/;"	f
ofconn_set_packet_in_format	.\ofproto\connmgr.c	/^ofconn_set_packet_in_format(struct ofconn *ofconn,$/;"	f
ofconn_set_protocol	.\ofproto\connmgr.c	/^ofconn_set_protocol(struct ofconn *ofconn, enum ofputil_protocol protocol)$/;"	f
ofconn_set_rate_limit	.\ofproto\connmgr.c	/^ofconn_set_rate_limit(struct ofconn *ofconn, int rate, int burst)$/;"	f	file:
ofconn_set_role	.\ofproto\connmgr.c	/^ofconn_set_role(struct ofconn *ofconn, enum ofp12_controller_role role)$/;"	f
ofconn_type	.\ofproto\connmgr.h	/^enum ofconn_type {$/;"	g
ofconn_wait	.\ofproto\connmgr.c	/^ofconn_wait(struct ofconn *ofconn, bool handling_openflow)$/;"	f	file:
ofconn_wants_packet_in_on_miss	.\ofproto\connmgr.c	/^ofconn_wants_packet_in_on_miss(struct ofconn *ofconn,$/;"	f	file:
ofctl	.\utilities\ovs-ofctl.c	/^VLOG_DEFINE_THIS_MODULE(ofctl);$/;"	v
ofctl_add_flow	.\utilities\ovs-ofctl.c	/^ofctl_add_flow(int argc, char *argv[])$/;"	f	file:
ofctl_add_flows	.\utilities\ovs-ofctl.c	/^ofctl_add_flows(int argc, char *argv[])$/;"	f	file:
ofctl_add_group	.\utilities\ovs-ofctl.c	/^ofctl_add_group(int argc, char *argv[])$/;"	f	file:
ofctl_add_groups	.\utilities\ovs-ofctl.c	/^ofctl_add_groups(int argc, char *argv[])$/;"	f	file:
ofctl_add_meter	.\utilities\ovs-ofctl.c	/^ofctl_add_meter(int argc OVS_UNUSED, char *argv[])$/;"	f	file:
ofctl_barrier	.\utilities\ovs-ofctl.c	/^ofctl_barrier(struct unixctl_conn *conn, int argc OVS_UNUSED,$/;"	f	file:
ofctl_benchmark	.\utilities\ovs-ofctl.c	/^ofctl_benchmark(int argc OVS_UNUSED, char *argv[])$/;"	f	file:
ofctl_block	.\utilities\ovs-ofctl.c	/^ofctl_block(struct unixctl_conn *conn, int argc OVS_UNUSED,$/;"	f	file:
ofctl_check_vlan	.\utilities\ovs-ofctl.c	/^ofctl_check_vlan(int argc OVS_UNUSED, char *argv[])$/;"	f	file:
ofctl_del_flows	.\utilities\ovs-ofctl.c	/^ofctl_del_flows(int argc, char *argv[])$/;"	f	file:
ofctl_del_groups	.\utilities\ovs-ofctl.c	/^ofctl_del_groups(int argc, char *argv[])$/;"	f	file:
ofctl_del_meters	.\utilities\ovs-ofctl.c	/^ofctl_del_meters(int argc, char *argv[])$/;"	f	file:
ofctl_diff_flows	.\utilities\ovs-ofctl.c	/^ofctl_diff_flows(int argc OVS_UNUSED, char *argv[])$/;"	f	file:
ofctl_dump_aggregate	.\utilities\ovs-ofctl.c	/^ofctl_dump_aggregate(int argc, char *argv[])$/;"	f	file:
ofctl_dump_desc	.\utilities\ovs-ofctl.c	/^ofctl_dump_desc(int argc OVS_UNUSED, char *argv[])$/;"	f	file:
ofctl_dump_flows	.\utilities\ovs-ofctl.c	/^ofctl_dump_flows(int argc, char *argv[])$/;"	f	file:
ofctl_dump_flows__	.\utilities\ovs-ofctl.c	/^ofctl_dump_flows__(int argc, char *argv[], bool aggregate)$/;"	f	file:
ofctl_dump_group_desc	.\utilities\ovs-ofctl.c	/^ofctl_dump_group_desc(int argc OVS_UNUSED, char *argv[])$/;"	f	file:
ofctl_dump_group_features	.\utilities\ovs-ofctl.c	/^ofctl_dump_group_features(int argc OVS_UNUSED, char *argv[])$/;"	f	file:
ofctl_dump_group_stats	.\utilities\ovs-ofctl.c	/^ofctl_dump_group_stats(int argc, char *argv[])$/;"	f	file:
ofctl_dump_meters	.\utilities\ovs-ofctl.c	/^ofctl_dump_meters(int argc, char *argv[])$/;"	f	file:
ofctl_dump_ports	.\utilities\ovs-ofctl.c	/^ofctl_dump_ports(int argc, char *argv[])$/;"	f	file:
ofctl_dump_ports_desc	.\utilities\ovs-ofctl.c	/^ofctl_dump_ports_desc(int argc OVS_UNUSED, char *argv[])$/;"	f	file:
ofctl_dump_table_features	.\utilities\ovs-ofctl.c	/^ofctl_dump_table_features(int argc OVS_UNUSED, char *argv[])$/;"	f	file:
ofctl_dump_tables	.\utilities\ovs-ofctl.c	/^ofctl_dump_tables(int argc OVS_UNUSED, char *argv[])$/;"	f	file:
ofctl_encode_error_reply	.\utilities\ovs-ofctl.c	/^ofctl_encode_error_reply(int argc OVS_UNUSED, char *argv[])$/;"	f	file:
ofctl_encode_hello	.\utilities\ovs-ofctl.c	/^ofctl_encode_hello(int argc OVS_UNUSED, char *argv[])$/;"	f	file:
ofctl_exit	.\utilities\ovs-ofctl.c	/^ofctl_exit(struct unixctl_conn *conn, int argc OVS_UNUSED,$/;"	f	file:
ofctl_flow_mod	.\utilities\ovs-ofctl.c	/^ofctl_flow_mod(int argc, char *argv[], uint16_t command)$/;"	f	file:
ofctl_flow_mod__	.\utilities\ovs-ofctl.c	/^ofctl_flow_mod__(const char *remote, struct ofputil_flow_mod *fms,$/;"	f	file:
ofctl_flow_mod_file	.\utilities\ovs-ofctl.c	/^ofctl_flow_mod_file(int argc OVS_UNUSED, char *argv[], uint16_t command)$/;"	f	file:
ofctl_get_frags	.\utilities\ovs-ofctl.c	/^ofctl_get_frags(int argc OVS_UNUSED, char *argv[])$/;"	f	file:
ofctl_group_mod	.\utilities\ovs-ofctl.c	/^ofctl_group_mod(int argc, char *argv[], uint16_t command)$/;"	f	file:
ofctl_group_mod__	.\utilities\ovs-ofctl.c	/^ofctl_group_mod__(const char *remote, struct ofputil_group_mod *gms,$/;"	f	file:
ofctl_group_mod_file	.\utilities\ovs-ofctl.c	/^ofctl_group_mod_file(int argc OVS_UNUSED, char *argv[], uint16_t command)$/;"	f	file:
ofctl_help	.\utilities\ovs-ofctl.c	/^ofctl_help(int argc OVS_UNUSED, char *argv[] OVS_UNUSED)$/;"	f	file:
ofctl_meter_features	.\utilities\ovs-ofctl.c	/^ofctl_meter_features(int argc OVS_UNUSED, char *argv[])$/;"	f	file:
ofctl_meter_mod__	.\utilities\ovs-ofctl.c	/^ofctl_meter_mod__(const char *bridge, const char *str, int command)$/;"	f	file:
ofctl_meter_request__	.\utilities\ovs-ofctl.c	/^ofctl_meter_request__(const char *bridge, const char *str,$/;"	f	file:
ofctl_meter_stats	.\utilities\ovs-ofctl.c	/^ofctl_meter_stats(int argc, char *argv[])$/;"	f	file:
ofctl_mod_flows	.\utilities\ovs-ofctl.c	/^ofctl_mod_flows(int argc, char *argv[])$/;"	f	file:
ofctl_mod_group	.\utilities\ovs-ofctl.c	/^ofctl_mod_group(int argc, char *argv[])$/;"	f	file:
ofctl_mod_meter	.\utilities\ovs-ofctl.c	/^ofctl_mod_meter(int argc OVS_UNUSED, char *argv[])$/;"	f	file:
ofctl_mod_port	.\utilities\ovs-ofctl.c	/^ofctl_mod_port(int argc OVS_UNUSED, char *argv[])$/;"	f	file:
ofctl_mod_table	.\utilities\ovs-ofctl.c	/^ofctl_mod_table(int argc OVS_UNUSED, char *argv[])$/;"	f	file:
ofctl_monitor	.\utilities\ovs-ofctl.c	/^ofctl_monitor(int argc, char *argv[])$/;"	f	file:
ofctl_ofp_parse	.\utilities\ovs-ofctl.c	/^ofctl_ofp_parse(int argc OVS_UNUSED, char *argv[])$/;"	f	file:
ofctl_ofp_parse_pcap	.\utilities\ovs-ofctl.c	/^ofctl_ofp_parse_pcap(int argc OVS_UNUSED, char *argv[])$/;"	f	file:
ofctl_ofp_print	.\utilities\ovs-ofctl.c	/^ofctl_ofp_print(int argc, char *argv[])$/;"	f	file:
ofctl_packet_out	.\utilities\ovs-ofctl.c	/^ofctl_packet_out(int argc, char *argv[])$/;"	f	file:
ofctl_parse_flow	.\utilities\ovs-ofctl.c	/^ofctl_parse_flow(int argc OVS_UNUSED, char *argv[])$/;"	f	file:
ofctl_parse_flows	.\utilities\ovs-ofctl.c	/^ofctl_parse_flows(int argc OVS_UNUSED, char *argv[])$/;"	f	file:
ofctl_parse_flows__	.\utilities\ovs-ofctl.c	/^ofctl_parse_flows__(struct ofputil_flow_mod *fms, size_t n_fms,$/;"	f	file:
ofctl_parse_nxm	.\utilities\ovs-ofctl.c	/^ofctl_parse_nxm(int argc OVS_UNUSED, char *argv[] OVS_UNUSED)$/;"	f	file:
ofctl_parse_nxm__	.\utilities\ovs-ofctl.c	/^ofctl_parse_nxm__(bool oxm, enum ofp_version version)$/;"	f	file:
ofctl_parse_ofp10_actions	.\utilities\ovs-ofctl.c	/^ofctl_parse_ofp10_actions(int argc OVS_UNUSED, char *argv[] OVS_UNUSED)$/;"	f	file:
ofctl_parse_ofp10_match	.\utilities\ovs-ofctl.c	/^ofctl_parse_ofp10_match(int argc OVS_UNUSED, char *argv[] OVS_UNUSED)$/;"	f	file:
ofctl_parse_ofp11_actions	.\utilities\ovs-ofctl.c	/^ofctl_parse_ofp11_actions(int argc OVS_UNUSED, char *argv[] OVS_UNUSED)$/;"	f	file:
ofctl_parse_ofp11_instructions	.\utilities\ovs-ofctl.c	/^ofctl_parse_ofp11_instructions(int argc OVS_UNUSED, char *argv[] OVS_UNUSED)$/;"	f	file:
ofctl_parse_ofp11_match	.\utilities\ovs-ofctl.c	/^ofctl_parse_ofp11_match(int argc OVS_UNUSED, char *argv[] OVS_UNUSED)$/;"	f	file:
ofctl_parse_oxm	.\utilities\ovs-ofctl.c	/^ofctl_parse_oxm(int argc OVS_UNUSED, char *argv[])$/;"	f	file:
ofctl_parse_pcap	.\utilities\ovs-ofctl.c	/^ofctl_parse_pcap(int argc OVS_UNUSED, char *argv[])$/;"	f	file:
ofctl_ping	.\utilities\ovs-ofctl.c	/^ofctl_ping(int argc, char *argv[])$/;"	f	file:
ofctl_print_error	.\utilities\ovs-ofctl.c	/^ofctl_print_error(int argc OVS_UNUSED, char *argv[])$/;"	f	file:
ofctl_probe	.\utilities\ovs-ofctl.c	/^ofctl_probe(int argc OVS_UNUSED, char *argv[])$/;"	f	file:
ofctl_queue_get_config	.\utilities\ovs-ofctl.c	/^ofctl_queue_get_config(int argc OVS_UNUSED, char *argv[])$/;"	f	file:
ofctl_queue_stats	.\utilities\ovs-ofctl.c	/^ofctl_queue_stats(int argc, char *argv[])$/;"	f	file:
ofctl_replace_flows	.\utilities\ovs-ofctl.c	/^ofctl_replace_flows(int argc OVS_UNUSED, char *argv[])$/;"	f	file:
ofctl_send	.\utilities\ovs-ofctl.c	/^ofctl_send(struct unixctl_conn *conn, int argc,$/;"	f	file:
ofctl_set_frags	.\utilities\ovs-ofctl.c	/^ofctl_set_frags(int argc OVS_UNUSED, char *argv[])$/;"	f	file:
ofctl_set_output_file	.\utilities\ovs-ofctl.c	/^ofctl_set_output_file(struct unixctl_conn *conn, int argc OVS_UNUSED,$/;"	f	file:
ofctl_show	.\utilities\ovs-ofctl.c	/^ofctl_show(int argc OVS_UNUSED, char *argv[])$/;"	f	file:
ofctl_snoop	.\utilities\ovs-ofctl.c	/^ofctl_snoop(int argc OVS_UNUSED, char *argv[])$/;"	f	file:
ofctl_unblock	.\utilities\ovs-ofctl.c	/^ofctl_unblock(struct unixctl_conn *conn, int argc OVS_UNUSED,$/;"	f	file:
offset	.\include\openflow\nicira-ext.h	/^    ovs_be16 offset;                \/* Bit offset into the field. *\/$/;"	m	struct:nx_action_stack
offset	.\lib\dpif-netdev.c	/^    uint32_t offset;$/;"	m	struct:dp_netdev_flow_iter	file:
offset	.\lib\dpif-netdev.c	/^    uint32_t offset;$/;"	m	struct:dp_netdev_port_state	file:
offset	.\ofproto\ofproto-dpif.c	/^    uint32_t offset;$/;"	m	struct:port_dump_state	file:
offset	.\ovsdb\log.c	/^    off_t offset;$/;"	m	struct:ovsdb_log	file:
offset	.\tests\test-sflow.c	/^    } offset;$/;"	m	struct:sflow_xdr	typeref:struct:sflow_xdr::__anon160	file:
offset_stats	.\datapath\vport.h	/^	struct ovs_vport_stats offset_stats;$/;"	m	struct:vport	typeref:struct:vport::ovs_vport_stats
offsetof	.\lib\flow.c	/^                  == offsetof(struct flow, ipv6_dst));$/;"	v
offsetof	.\lib\flow.c	/^                  == offsetof(struct flow, nw_tos) \/ 4);$/;"	v
offsetof	.\lib\flow.c	/^                  == offsetof(struct flow, pad) \/ 4);$/;"	v
offsetof	.\lib\flow.c	/^                  == offsetof(struct flow, tp_dst) \/ 4);$/;"	v
offsetof	.\lib\flow.c	/^                  == offsetof(struct flow, vlan_tci) \/ 4 );$/;"	v
ofgroup	.\ofproto\ofproto-provider.h	/^struct ofgroup {$/;"	s
ofmonitor	.\ofproto\connmgr.h	/^struct ofmonitor {$/;"	s
ofmonitor_pause	.\ofproto\connmgr.c	/^COVERAGE_DEFINE(ofmonitor_pause);$/;"	v
ofmonitor_resume	.\ofproto\connmgr.c	/^COVERAGE_DEFINE(ofmonitor_resume);$/;"	v
ofmonitor_run	.\ofproto\connmgr.c	/^ofmonitor_run(struct connmgr *mgr)$/;"	f	file:
ofmonitor_wait	.\ofproto\connmgr.c	/^ofmonitor_wait(struct connmgr *mgr)$/;"	f	file:
ofmsg_rl	.\lib\vconn.c	/^static struct vlog_rate_limit ofmsg_rl = VLOG_RATE_LIMIT_INIT(600, 600);$/;"	v	typeref:struct:vlog_rate_limit	file:
ofoperation	.\ofproto\ofproto.c	/^struct ofoperation {$/;"	s	file:
ofoperation_complete	.\ofproto\ofproto.c	/^ofoperation_complete(struct ofoperation *op, enum ofperr error)$/;"	f
ofoperation_type	.\ofproto\ofproto.c	/^enum ofoperation_type {$/;"	g	file:
ofopgroup	.\ofproto\ofproto.c	/^struct ofopgroup {$/;"	s	file:
ofp10_action_enqueue	.\include\openflow\openflow-1.0.h	/^struct ofp10_action_enqueue {$/;"	s
ofp10_action_output	.\include\openflow\openflow-1.0.h	/^struct ofp10_action_output {$/;"	s
ofp10_action_type	.\include\openflow\openflow-1.0.h	/^enum ofp10_action_type {$/;"	g
ofp10_capabilities	.\include\openflow\openflow-1.0.h	/^enum ofp10_capabilities {$/;"	g
ofp10_flow_mod	.\include\openflow\openflow-1.0.h	/^struct ofp10_flow_mod {$/;"	s
ofp10_flow_mod_flags	.\include\openflow\openflow-1.0.h	/^enum ofp10_flow_mod_flags {$/;"	g
ofp10_flow_removed	.\include\openflow\openflow-1.0.h	/^struct ofp10_flow_removed {$/;"	s
ofp10_flow_stats	.\include\openflow\openflow-1.0.h	/^struct ofp10_flow_stats {$/;"	s
ofp10_flow_stats_request	.\include\openflow\openflow-1.0.h	/^struct ofp10_flow_stats_request {$/;"	s
ofp10_flow_wildcards	.\include\openflow\openflow-1.0.h	/^enum ofp10_flow_wildcards {$/;"	g
ofp10_match	.\include\openflow\openflow-1.0.h	/^struct ofp10_match {$/;"	s
ofp10_match_print	.\lib\ofp-print.c	/^ofp10_match_print(struct ds *f, const struct ofp10_match *om, int verbosity)$/;"	f
ofp10_match_to_string	.\lib\ofp-print.c	/^ofp10_match_to_string(const struct ofp10_match *om, int verbosity)$/;"	f
ofp10_packet_in	.\include\openflow\openflow-1.0.h	/^struct ofp10_packet_in {$/;"	s
ofp10_packet_out	.\include\openflow\openflow-1.0.h	/^struct ofp10_packet_out {$/;"	s
ofp10_packet_queue	.\include\openflow\openflow-1.0.h	/^struct ofp10_packet_queue {$/;"	s
ofp10_phy_port	.\include\openflow\openflow-1.0.h	/^struct ofp10_phy_port {$/;"	s
ofp10_port_config	.\include\openflow\openflow-1.0.h	/^enum ofp10_port_config {$/;"	g
ofp10_port_features	.\include\openflow\openflow-1.0.h	/^enum ofp10_port_features {$/;"	g
ofp10_port_mod	.\include\openflow\openflow-1.0.h	/^struct ofp10_port_mod {$/;"	s
ofp10_port_state	.\include\openflow\openflow-1.0.h	/^enum ofp10_port_state {$/;"	g
ofp10_port_stats	.\include\openflow\openflow-1.0.h	/^struct ofp10_port_stats {$/;"	s
ofp10_port_stats_request	.\include\openflow\openflow-1.0.h	/^struct ofp10_port_stats_request {$/;"	s
ofp10_queue_get_config_reply	.\include\openflow\openflow-1.0.h	/^struct ofp10_queue_get_config_reply {$/;"	s
ofp10_queue_get_config_request	.\include\openflow\openflow-1.0.h	/^struct ofp10_queue_get_config_request {$/;"	s
ofp10_queue_stats	.\include\openflow\openflow-1.0.h	/^struct ofp10_queue_stats {$/;"	s
ofp10_queue_stats_request	.\include\openflow\openflow-1.0.h	/^struct ofp10_queue_stats_request {$/;"	s
ofp10_stats_msg	.\include\openflow\openflow-1.0.h	/^struct ofp10_stats_msg {$/;"	s
ofp10_table_stats	.\include\openflow\openflow-1.0.h	/^struct ofp10_table_stats {$/;"	s
ofp10_vendor_stats_msg	.\include\openflow\openflow-1.0.h	/^struct ofp10_vendor_stats_msg {$/;"	s
ofp11_action_group	.\include\openflow\openflow-1.1.h	/^struct ofp11_action_group {$/;"	s
ofp11_action_mpls_label	.\include\openflow\openflow-1.1.h	/^struct ofp11_action_mpls_label {$/;"	s
ofp11_action_mpls_tc	.\include\openflow\openflow-1.1.h	/^struct ofp11_action_mpls_tc {$/;"	s
ofp11_action_mpls_ttl	.\include\openflow\openflow-1.1.h	/^struct ofp11_action_mpls_ttl {$/;"	s
ofp11_action_nw_ecn	.\include\openflow\openflow-1.1.h	/^struct ofp11_action_nw_ecn {$/;"	s
ofp11_action_nw_ttl	.\include\openflow\openflow-1.1.h	/^struct ofp11_action_nw_ttl {$/;"	s
ofp11_action_output	.\include\openflow\openflow-1.1.h	/^struct ofp11_action_output {$/;"	s
ofp11_action_pop_mpls	.\include\openflow\openflow-1.1.h	/^struct ofp11_action_pop_mpls {$/;"	s
ofp11_action_push	.\include\openflow\openflow-1.1.h	/^struct ofp11_action_push {$/;"	s
ofp11_action_set_queue	.\include\openflow\openflow-1.1.h	/^struct ofp11_action_set_queue {$/;"	s
ofp11_action_type	.\include\openflow\openflow-1.1.h	/^enum ofp11_action_type {$/;"	g
ofp11_bucket	.\include\openflow\openflow-1.1.h	/^struct ofp11_bucket {$/;"	s
ofp11_bucket_counter	.\include\openflow\openflow-1.1.h	/^struct ofp11_bucket_counter {$/;"	s
ofp11_capabilities	.\include\openflow\openflow-1.1.h	/^enum ofp11_capabilities {$/;"	g
ofp11_flow_match_fields	.\include\openflow\openflow-1.1.h	/^enum ofp11_flow_match_fields {$/;"	g
ofp11_flow_mod	.\include\openflow\openflow-1.1.h	/^struct ofp11_flow_mod {$/;"	s
ofp11_flow_removed	.\include\openflow\openflow-1.1.h	/^struct ofp11_flow_removed {$/;"	s
ofp11_flow_stats	.\include\openflow\openflow-1.1.h	/^struct ofp11_flow_stats {$/;"	s
ofp11_flow_stats_request	.\include\openflow\openflow-1.1.h	/^struct ofp11_flow_stats_request {$/;"	s
ofp11_flow_wildcards	.\include\openflow\openflow-1.1.h	/^enum ofp11_flow_wildcards {$/;"	g
ofp11_group	.\include\openflow\openflow-1.1.h	/^enum ofp11_group {$/;"	g
ofp11_group_desc_stats	.\include\openflow\openflow-1.1.h	/^struct ofp11_group_desc_stats {$/;"	s
ofp11_group_mod	.\include\openflow\openflow-1.1.h	/^struct ofp11_group_mod {$/;"	s
ofp11_group_mod_command	.\include\openflow\openflow-1.1.h	/^enum ofp11_group_mod_command {$/;"	g
ofp11_group_stats	.\include\openflow\openflow-1.1.h	/^struct ofp11_group_stats {$/;"	s
ofp11_group_stats_request	.\include\openflow\openflow-1.1.h	/^struct ofp11_group_stats_request {$/;"	s
ofp11_group_type	.\include\openflow\openflow-1.1.h	/^enum ofp11_group_type {$/;"	g
ofp11_instruction	.\include\openflow\openflow-1.1.h	/^struct ofp11_instruction {$/;"	s
ofp11_instruction_actions	.\include\openflow\openflow-1.1.h	/^struct ofp11_instruction_actions {$/;"	s
ofp11_instruction_experimenter	.\include\openflow\openflow-1.1.h	/^struct ofp11_instruction_experimenter {$/;"	s
ofp11_instruction_goto_table	.\include\openflow\openflow-1.1.h	/^struct ofp11_instruction_goto_table {$/;"	s
ofp11_instruction_type	.\include\openflow\openflow-1.1.h	/^enum ofp11_instruction_type {$/;"	g
ofp11_instruction_write_metadata	.\include\openflow\openflow-1.1.h	/^struct ofp11_instruction_write_metadata {$/;"	s
ofp11_match	.\include\openflow\openflow-1.1.h	/^struct ofp11_match {$/;"	s
ofp11_match_header	.\include\openflow\openflow-1.1.h	/^struct ofp11_match_header {$/;"	s
ofp11_mpls_label	.\lib\ofp-actions.c	/^    struct ofp11_action_mpls_label ofp11_mpls_label;$/;"	m	union:ofp_action	typeref:struct:ofp_action::ofp11_action_mpls_label	file:
ofp11_mpls_tc	.\lib\ofp-actions.c	/^    struct ofp11_action_mpls_tc ofp11_mpls_tc;$/;"	m	union:ofp_action	typeref:struct:ofp_action::ofp11_action_mpls_tc	file:
ofp11_mpls_ttl	.\lib\ofp-actions.c	/^    struct ofp11_action_mpls_ttl ofp11_mpls_ttl;$/;"	m	union:ofp_action	typeref:struct:ofp_action::ofp11_action_mpls_ttl	file:
ofp11_output	.\lib\ofp-actions.c	/^    struct ofp11_action_output ofp11_output;$/;"	m	union:ofp_action	typeref:struct:ofp_action::ofp11_action_output	file:
ofp11_packet_in	.\include\openflow\openflow-1.1.h	/^struct ofp11_packet_in {$/;"	s
ofp11_packet_out	.\include\openflow\openflow-1.1.h	/^struct ofp11_packet_out {$/;"	s
ofp11_pop_mpls	.\lib\ofp-actions.c	/^    struct ofp11_action_pop_mpls ofp11_pop_mpls;$/;"	m	union:ofp_action	typeref:struct:ofp_action::ofp11_action_pop_mpls	file:
ofp11_port	.\include\openflow\openflow-1.1.h	/^struct ofp11_port {$/;"	s
ofp11_port_features	.\include\openflow\openflow-1.1.h	/^enum ofp11_port_features {$/;"	g
ofp11_port_mod	.\include\openflow\openflow-1.1.h	/^struct ofp11_port_mod {$/;"	s
ofp11_port_state	.\include\openflow\openflow-1.1.h	/^enum ofp11_port_state {$/;"	g
ofp11_port_stats	.\include\openflow\openflow-1.1.h	/^struct ofp11_port_stats {$/;"	s
ofp11_port_stats_request	.\include\openflow\openflow-1.1.h	/^struct ofp11_port_stats_request {$/;"	s
ofp11_port_t	.\include\openvswitch\types.h	/^typedef uint32_t OVS_BITWISE ofp11_port_t;$/;"	t
ofp11_queue_get_config_reply	.\include\openflow\openflow-1.1.h	/^struct ofp11_queue_get_config_reply {$/;"	s
ofp11_queue_get_config_request	.\include\openflow\openflow-1.1.h	/^struct ofp11_queue_get_config_request {$/;"	s
ofp11_queue_stats	.\include\openflow\openflow-1.1.h	/^struct ofp11_queue_stats {$/;"	s
ofp11_queue_stats_request	.\include\openflow\openflow-1.1.h	/^struct ofp11_queue_stats_request {$/;"	s
ofp11_set_queue	.\lib\ofp-actions.c	/^    struct ofp11_action_set_queue ofp11_set_queue;$/;"	m	union:ofp_action	typeref:struct:ofp_action::ofp11_action_set_queue	file:
ofp11_stats_msg	.\include\openflow\openflow-1.1.h	/^struct ofp11_stats_msg {$/;"	s
ofp11_table_mod	.\include\openflow\openflow-1.1.h	/^struct ofp11_table_mod {$/;"	s
ofp11_table_stats	.\include\openflow\openflow-1.1.h	/^struct ofp11_table_stats {$/;"	s
ofp11_vendor_stats_msg	.\include\openflow\openflow-1.1.h	/^struct ofp11_vendor_stats_msg {$/;"	s
ofp11_vlan_id	.\include\openflow\openflow-1.1.h	/^enum ofp11_vlan_id {$/;"	g
ofp12_action_set_field	.\include\openflow\openflow-1.2.h	/^struct ofp12_action_set_field {$/;"	s
ofp12_action_type	.\include\openflow\openflow-1.2.h	/^enum ofp12_action_type {$/;"	g
ofp12_capabilities	.\include\openflow\openflow-1.2.h	/^enum ofp12_capabilities {$/;"	g
ofp12_controller_max_len	.\include\openflow\openflow-1.2.h	/^enum ofp12_controller_max_len {$/;"	g
ofp12_controller_role	.\include\openflow\openflow-1.2.h	/^enum ofp12_controller_role {$/;"	g
ofp12_controller_role_to_str	.\vswitchd\bridge.c	/^ofp12_controller_role_to_str(enum ofp12_controller_role role)$/;"	f	file:
ofp12_experimenter_stats_header	.\include\openflow\openflow-1.2.h	/^struct ofp12_experimenter_stats_header {$/;"	s
ofp12_flow_mod_flags	.\include\openflow\openflow-1.2.h	/^enum ofp12_flow_mod_flags {$/;"	g
ofp12_flow_removed	.\include\openflow\openflow-1.2.h	/^struct ofp12_flow_removed {$/;"	s
ofp12_group_capabilities	.\include\openflow\openflow-1.2.h	/^enum ofp12_group_capabilities {$/;"	g
ofp12_group_features_stats	.\include\openflow\openflow-1.2.h	/^struct ofp12_group_features_stats {$/;"	s
ofp12_ipv6exthdr_flags	.\include\openflow\openflow-1.2.h	/^enum ofp12_ipv6exthdr_flags {$/;"	g
ofp12_oxm_class	.\include\openflow\openflow-1.2.h	/^enum ofp12_oxm_class {$/;"	g
ofp12_oxm_experimenter_header	.\include\openflow\openflow-1.2.h	/^struct ofp12_oxm_experimenter_header {$/;"	s
ofp12_packet_in	.\include\openflow\openflow-1.2.h	/^struct ofp12_packet_in {$/;"	s
ofp12_packet_queue	.\include\openflow\openflow-1.2.h	/^struct ofp12_packet_queue {$/;"	s
ofp12_role_request	.\include\openflow\openflow-1.2.h	/^struct ofp12_role_request {$/;"	s
ofp12_table_stats	.\include\openflow\openflow-1.2.h	/^struct ofp12_table_stats {$/;"	s
ofp12_vlan_id	.\include\openflow\openflow-1.2.h	/^enum ofp12_vlan_id {$/;"	g
ofp13_action_self_learning	.\include\openflow\openflow-1.3.h	/^struct ofp13_action_self_learning {$/;"	s
ofp13_action_to_string	.\lib\ofp-print.c	/^ofp13_action_to_string(uint32_t bit)$/;"	f	file:
ofp13_action_type	.\include\openflow\openflow-1.3.h	/^enum ofp13_action_type {$/;"	g
ofp13_async_config	.\include\openflow\openflow-1.3.h	/^struct ofp13_async_config {$/;"	s	struct:ofp13_action_self_learning
ofp13_flow_mod_flags	.\include\openflow\openflow-1.3.h	/^enum ofp13_flow_mod_flags {$/;"	g	struct:ofp13_action_self_learning
ofp13_group_stats	.\include\openflow\openflow-1.3.h	/^struct ofp13_group_stats {$/;"	s	struct:ofp13_action_self_learning
ofp13_instruction_meter	.\include\openflow\openflow-1.3.h	/^struct ofp13_instruction_meter {$/;"	s
ofp13_instruction_type	.\include\openflow\openflow-1.3.h	/^enum ofp13_instruction_type {$/;"	g
ofp13_meter	.\include\openflow\openflow-1.3.h	/^enum ofp13_meter {$/;"	g	struct:ofp13_action_self_learning
ofp13_meter_band_drop	.\include\openflow\openflow-1.3.h	/^struct ofp13_meter_band_drop {$/;"	s	struct:ofp13_action_self_learning
ofp13_meter_band_dscp_remark	.\include\openflow\openflow-1.3.h	/^struct ofp13_meter_band_dscp_remark {$/;"	s	struct:ofp13_action_self_learning
ofp13_meter_band_experimenter	.\include\openflow\openflow-1.3.h	/^struct ofp13_meter_band_experimenter {$/;"	s	struct:ofp13_action_self_learning
ofp13_meter_band_header	.\include\openflow\openflow-1.3.h	/^struct ofp13_meter_band_header {$/;"	s	struct:ofp13_action_self_learning
ofp13_meter_band_stats	.\include\openflow\openflow-1.3.h	/^struct ofp13_meter_band_stats {$/;"	s	struct:ofp13_action_self_learning
ofp13_meter_band_type	.\include\openflow\openflow-1.3.h	/^enum ofp13_meter_band_type {$/;"	g	struct:ofp13_action_self_learning
ofp13_meter_config	.\include\openflow\openflow-1.3.h	/^struct ofp13_meter_config {$/;"	s	struct:ofp13_action_self_learning
ofp13_meter_features	.\include\openflow\openflow-1.3.h	/^struct ofp13_meter_features {$/;"	s	struct:ofp13_action_self_learning
ofp13_meter_flags	.\include\openflow\openflow-1.3.h	/^enum ofp13_meter_flags {$/;"	g	struct:ofp13_action_self_learning
ofp13_meter_mod	.\include\openflow\openflow-1.3.h	/^struct ofp13_meter_mod {$/;"	s	struct:ofp13_action_self_learning
ofp13_meter_mod_command	.\include\openflow\openflow-1.3.h	/^enum ofp13_meter_mod_command {$/;"	g	struct:ofp13_action_self_learning
ofp13_meter_multipart_request	.\include\openflow\openflow-1.3.h	/^struct ofp13_meter_multipart_request {$/;"	s	struct:ofp13_action_self_learning
ofp13_meter_stats	.\include\openflow\openflow-1.3.h	/^struct ofp13_meter_stats {$/;"	s	struct:ofp13_action_self_learning
ofp13_multipart_request_flags	.\include\openflow\openflow-1.3.h	/^enum ofp13_multipart_request_flags {$/;"	g	struct:ofp13_action_self_learning
ofp13_packet_in	.\include\openflow\openflow-1.3.h	/^struct ofp13_packet_in {$/;"	s	struct:ofp13_action_self_learning
ofp13_port_stats	.\include\openflow\openflow-1.3.h	/^struct ofp13_port_stats {$/;"	s	struct:ofp13_action_self_learning
ofp13_queue_stats	.\include\openflow\openflow-1.3.h	/^struct ofp13_queue_stats {$/;"	s	struct:ofp13_action_self_learning
ofp13_table_config	.\include\openflow\openflow-1.3.h	/^enum ofp13_table_config {$/;"	g	struct:ofp13_action_self_learning
ofp13_table_feature_prop_actions	.\include\openflow\openflow-1.3.h	/^struct ofp13_table_feature_prop_actions {$/;"	s	struct:ofp13_action_self_learning
ofp13_table_feature_prop_experimenter	.\include\openflow\openflow-1.3.h	/^struct ofp13_table_feature_prop_experimenter {$/;"	s	struct:ofp13_action_self_learning
ofp13_table_feature_prop_header	.\include\openflow\openflow-1.3.h	/^struct ofp13_table_feature_prop_header {$/;"	s	struct:ofp13_action_self_learning
ofp13_table_feature_prop_instructions	.\include\openflow\openflow-1.3.h	/^struct ofp13_table_feature_prop_instructions {$/;"	s	struct:ofp13_action_self_learning
ofp13_table_feature_prop_next_tables	.\include\openflow\openflow-1.3.h	/^struct ofp13_table_feature_prop_next_tables {$/;"	s	struct:ofp13_action_self_learning
ofp13_table_feature_prop_oxm	.\include\openflow\openflow-1.3.h	/^struct ofp13_table_feature_prop_oxm {$/;"	s	struct:ofp13_action_self_learning
ofp13_table_feature_prop_type	.\include\openflow\openflow-1.3.h	/^enum ofp13_table_feature_prop_type {$/;"	g	struct:ofp13_action_self_learning
ofp13_table_features	.\include\openflow\openflow-1.3.h	/^struct ofp13_table_features {$/;"	s	struct:ofp13_action_self_learning
ofp13_table_stats	.\include\openflow\openflow-1.3.h	/^struct ofp13_table_stats {$/;"	s	struct:ofp13_action_self_learning
ofp14_async_config	.\include\openflow\openflow-1.4.h	/^struct ofp14_async_config {$/;"	s
ofp14_async_config_prop_experimenter	.\include\openflow\openflow-1.4.h	/^struct ofp14_async_config_prop_experimenter {$/;"	s
ofp14_async_config_prop_header	.\include\openflow\openflow-1.4.h	/^struct ofp14_async_config_prop_header {$/;"	s
ofp14_async_config_prop_reasons	.\include\openflow\openflow-1.4.h	/^struct ofp14_async_config_prop_reasons {$/;"	s
ofp14_async_config_prop_type	.\include\openflow\openflow-1.4.h	/^enum ofp14_async_config_prop_type {$/;"	g
ofp14_bundle_ctrl_msg	.\include\openflow\openflow-1.4.h	/^struct ofp14_bundle_ctrl_msg {$/;"	s
ofp14_bundle_ctrl_type	.\include\openflow\openflow-1.4.h	/^enum ofp14_bundle_ctrl_type {$/;"	g
ofp14_bundle_flags	.\include\openflow\openflow-1.4.h	/^enum ofp14_bundle_flags {$/;"	g
ofp14_controller_role_reason	.\include\openflow\openflow-1.4.h	/^enum ofp14_controller_role_reason {$/;"	g
ofp14_port	.\include\openflow\openflow-1.4.h	/^struct ofp14_port {$/;"	s
ofp14_port_desc_prop_ethernet	.\include\openflow\openflow-1.4.h	/^struct ofp14_port_desc_prop_ethernet {$/;"	s
ofp14_port_mod	.\include\openflow\openflow-1.4.h	/^struct ofp14_port_mod {$/;"	s
ofp14_port_mod_prop_ethernet	.\include\openflow\openflow-1.4.h	/^struct ofp14_port_mod_prop_ethernet {$/;"	s
ofp14_port_mod_prop_type	.\include\openflow\openflow-1.4.h	/^enum ofp14_port_mod_prop_type {$/;"	g
ofp14_port_stats	.\include\openflow\openflow-1.4.h	/^struct ofp14_port_stats {$/;"	s
ofp14_port_stats_prop_ethernet	.\include\openflow\openflow-1.4.h	/^struct ofp14_port_stats_prop_ethernet {$/;"	s
ofp14_port_stats_prop_type	.\include\openflow\openflow-1.4.h	/^enum ofp14_port_stats_prop_type {$/;"	g
ofp14_queue_stats	.\include\openflow\openflow-1.4.h	/^struct ofp14_queue_stats {$/;"	s
ofp14_role_prop_experimenter	.\include\openflow\openflow-1.4.h	/^struct ofp14_role_prop_experimenter {$/;"	s
ofp14_role_prop_header	.\include\openflow\openflow-1.4.h	/^struct ofp14_role_prop_header {$/;"	s
ofp14_role_prop_type	.\include\openflow\openflow-1.4.h	/^enum ofp14_role_prop_type {$/;"	g
ofp14_role_status	.\include\openflow\openflow-1.4.h	/^struct ofp14_role_status {$/;"	s
ofp14_table_mod	.\include\openflow\openflow-1.4.h	/^struct ofp14_table_mod {$/;"	s
ofp14_table_mod_prop_eviction	.\include\openflow\openflow-1.4.h	/^struct ofp14_table_mod_prop_eviction {$/;"	s
ofp14_table_mod_prop_eviction_flag	.\include\openflow\openflow-1.4.h	/^enum ofp14_table_mod_prop_eviction_flag {$/;"	g
ofp14_table_mod_prop_type	.\include\openflow\openflow-1.4.h	/^enum ofp14_table_mod_prop_type {$/;"	g
ofp14_table_mod_prop_vacancy	.\include\openflow\openflow-1.4.h	/^struct ofp14_table_mod_prop_vacancy {$/;"	s
ofp_action	.\lib\ofp-actions.c	/^union ofp_action {$/;"	u	file:
ofp_action_dl_addr	.\include\openflow\openflow-common.h	/^struct ofp_action_dl_addr {$/;"	s
ofp_action_header	.\include\openflow\openflow-common.h	/^struct ofp_action_header {$/;"	s
ofp_action_nw_addr	.\include\openflow\openflow-common.h	/^struct ofp_action_nw_addr {$/;"	s
ofp_action_nw_tos	.\include\openflow\openflow-common.h	/^struct ofp_action_nw_tos {$/;"	s
ofp_action_tp_port	.\include\openflow\openflow-common.h	/^struct ofp_action_tp_port {$/;"	s
ofp_action_vendor_header	.\include\openflow\openflow-common.h	/^struct ofp_action_vendor_header {$/;"	s
ofp_action_vlan_pcp	.\include\openflow\openflow-common.h	/^struct ofp_action_vlan_pcp {$/;"	s
ofp_action_vlan_vid	.\include\openflow\openflow-common.h	/^struct ofp_action_vlan_vid {$/;"	s
ofp_actions	.\lib\ofp-actions.c	/^VLOG_DEFINE_THIS_MODULE(ofp_actions);$/;"	v
ofp_aggregate_stats_reply	.\include\openflow\openflow-common.h	/^struct ofp_aggregate_stats_reply {$/;"	s
ofp_bundle	.\ofproto\bundles.c	/^struct ofp_bundle {$/;"	s	file:
ofp_bundle_add_message	.\ofproto\bundles.c	/^ofp_bundle_add_message(struct ofconn *ofconn, struct ofputil_bundle_add_msg *badd)$/;"	f
ofp_bundle_close	.\ofproto\bundles.c	/^ofp_bundle_close(struct ofconn *ofconn, uint32_t id, uint16_t flags)$/;"	f
ofp_bundle_commit	.\ofproto\bundles.c	/^ofp_bundle_commit(struct ofconn *ofconn, uint32_t id, uint16_t flags)$/;"	f
ofp_bundle_create	.\ofproto\bundles.c	/^ofp_bundle_create(uint32_t id, uint16_t flags)$/;"	f	file:
ofp_bundle_discard	.\ofproto\bundles.c	/^ofp_bundle_discard(struct ofconn *ofconn, uint32_t id)$/;"	f
ofp_bundle_find	.\ofproto\bundles.c	/^ofp_bundle_find(struct hmap *bundles, uint32_t id)$/;"	f	file:
ofp_bundle_open	.\ofproto\bundles.c	/^ofp_bundle_open(struct ofconn *ofconn, uint32_t id, uint16_t flags)$/;"	f
ofp_bundle_remove	.\ofproto\bundles.c	/^ofp_bundle_remove(struct ofconn *ofconn, struct ofp_bundle *item)$/;"	f	file:
ofp_bundle_remove_all	.\ofproto\bundles.c	/^ofp_bundle_remove_all(struct ofconn *ofconn)$/;"	f
ofp_capabilities	.\include\openflow\openflow-common.h	/^enum ofp_capabilities {$/;"	g
ofp_config_flags	.\include\openflow\openflow-common.h	/^enum ofp_config_flags {$/;"	g
ofp_desc_stats	.\include\openflow\openflow-common.h	/^struct ofp_desc_stats {$/;"	s
ofp_error_msg	.\include\openflow\openflow-common.h	/^struct ofp_error_msg {$/;"	s
ofp_errors	.\lib\ofp-errors.c	/^VLOG_DEFINE_THIS_MODULE(ofp_errors);$/;"	v
ofp_flow_mod_command	.\include\openflow\openflow-common.h	/^enum ofp_flow_mod_command {$/;"	g
ofp_flow_mod_flags	.\include\openflow\openflow-common.h	/^enum ofp_flow_mod_flags {$/;"	g
ofp_flow_removed_reason	.\include\openflow\openflow-common.h	/^enum ofp_flow_removed_reason {$/;"	g
ofp_flow_removed_reason_to_string	.\lib\ofp-print.c	/^ofp_flow_removed_reason_to_string(enum ofp_flow_removed_reason reason,$/;"	f	file:
ofp_group	.\include\openflow\openflow-common.h	/^enum ofp_group {$/;"	g
ofp_group_capabilities	.\include\openflow\openflow-common.h	/^enum ofp_group_capabilities {$/;"	g
ofp_header	.\include\openflow\openflow-common.h	/^struct ofp_header {$/;"	s
ofp_header_to_string__	.\lib\ofp-print.c	/^ofp_header_to_string__(const struct ofp_header *oh, enum ofpraw raw,$/;"	f	file:
ofp_hello_elem_header	.\include\openflow\openflow-common.h	/^struct ofp_hello_elem_header {$/;"	s
ofp_hello_elem_type	.\include\openflow\openflow-common.h	/^enum ofp_hello_elem_type {$/;"	g
ofp_is_stat	.\lib\ofp-msgs.c	/^ofp_is_stat(enum ofp_version version, uint8_t type)$/;"	f	file:
ofp_is_stat_reply	.\lib\ofp-msgs.c	/^ofp_is_stat_reply(enum ofp_version version, uint8_t type)$/;"	f	file:
ofp_is_stat_request	.\lib\ofp-msgs.c	/^ofp_is_stat_request(enum ofp_version version, uint8_t type)$/;"	f	file:
ofp_match_type	.\include\openflow\openflow-common.h	/^enum ofp_match_type {$/;"	g
ofp_msgs	.\lib\ofp-msgs.c	/^VLOG_DEFINE_THIS_MODULE(ofp_msgs);$/;"	v
ofp_node	.\ofproto\ofproto-dpif-xlate.c	/^    struct hmap_node ofp_node;       \/* Node in parent xbridge 'xports' map. *\/$/;"	m	struct:xport	typeref:struct:xport::hmap_node	file:
ofp_packet_in_reason	.\include\openflow\openflow-common.h	/^enum ofp_packet_in_reason {$/;"	g
ofp_packet_to_string	.\lib\ofp-print.c	/^ofp_packet_to_string(const void *data, size_t len)$/;"	f
ofp_port	.\lib\mac-learning.h	/^        ofp_port_t ofp_port;$/;"	m	union:mac_entry::__anon52
ofp_port	.\lib\packets.h	/^    ofp_port_t ofp_port;$/;"	m	union:flow_in_port
ofp_port	.\ofproto\bond.c	/^    ofp_port_t  ofp_port;       \/* Open flow port number *\/$/;"	m	struct:bond_slave	file:
ofp_port	.\ofproto\ofproto-dpif-xlate.c	/^    ofp_port_t ofp_port;             \/* Key in parent xbridge 'xports' map. *\/$/;"	m	struct:xport	file:
ofp_port	.\ofproto\ofproto-provider.h	/^    ofp_port_t ofp_port;        \/* OpenFlow port number. *\/$/;"	m	struct:ofport
ofp_port	.\ofproto\ofproto.c	/^    ofp_port_t ofp_port;        \/* OpenFlow port number. *\/$/;"	m	struct:ofport_usage	file:
ofp_port	.\ofproto\ofproto.h	/^    ofp_port_t ofp_port;        \/* OpenFlow port number. *\/$/;"	m	struct:iface_hint
ofp_port	.\ofproto\ofproto.h	/^    ofp_port_t ofp_port;        \/* OpenFlow port number. *\/$/;"	m	struct:ofproto_port
ofp_port	.\vswitchd\bridge.c	/^    ofp_port_t ofp_port;        \/* OpenFlow port number. *\/$/;"	m	struct:iface	file:
ofp_port_config	.\include\openflow\openflow-common.h	/^enum ofp_port_config {$/;"	g
ofp_port_desc_prop_type	.\include\openflow\openflow-1.4.h	/^enum ofp_port_desc_prop_type {$/;"	g
ofp_port_features	.\include\openflow\openflow-common.h	/^enum ofp_port_features {$/;"	g
ofp_port_node	.\vswitchd\bridge.c	/^    struct hmap_node ofp_port_node; \/* In struct bridge's "ifaces" hmap. *\/$/;"	m	struct:iface	typeref:struct:iface::hmap_node	file:
ofp_port_reason	.\include\openflow\openflow-common.h	/^enum ofp_port_reason {$/;"	g
ofp_port_reason_to_string	.\lib\ofp-print.c	/^ofp_port_reason_to_string(enum ofp_port_reason reason,$/;"	f	file:
ofp_port_state	.\include\openflow\openflow-common.h	/^enum ofp_port_state {$/;"	g
ofp_port_status	.\include\openflow\openflow-common.h	/^struct ofp_port_status {$/;"	s
ofp_port_t	.\include\openvswitch\types.h	/^typedef uint16_t OVS_BITWISE ofp_port_t;$/;"	t
ofp_port_to_odp_port	.\ofproto\ofproto-dpif-xlate.c	/^ofp_port_to_odp_port(const struct xbridge *xbridge, ofp_port_t ofp_port)$/;"	f	file:
ofp_port_to_odp_port	.\ofproto\ofproto-dpif.c	/^ofp_port_to_odp_port(const struct ofproto_dpif *ofproto, ofp_port_t ofp_port)$/;"	f	file:
ofp_print	.\lib\ofp-print.c	/^ofp_print(FILE *stream, const void *oh, size_t len, int verbosity)$/;"	f
ofp_print_aggregate_stats_reply	.\lib\ofp-print.c	/^ofp_print_aggregate_stats_reply(struct ds *string, const struct ofp_header *oh)$/;"	f	file:
ofp_print_bit_names	.\lib\ofp-print.c	/^ofp_print_bit_names(struct ds *string, uint32_t bits,$/;"	f	file:
ofp_print_bundle_add	.\lib\ofp-print.c	/^ofp_print_bundle_add(struct ds *s, const struct ofp_header *oh, int verbosity)$/;"	f	file:
ofp_print_bundle_ctrl	.\lib\ofp-print.c	/^ofp_print_bundle_ctrl(struct ds *s, const struct ofp_header *oh)$/;"	f	file:
ofp_print_duration	.\lib\ofp-print.c	/^ofp_print_duration(struct ds *string, unsigned int sec, unsigned int nsec)$/;"	f	file:
ofp_print_echo	.\lib\ofp-print.c	/^ofp_print_echo(struct ds *string, const struct ofp_header *oh, int verbosity)$/;"	f	file:
ofp_print_error	.\lib\ofp-print.c	/^ofp_print_error(struct ds *string, enum ofperr error)$/;"	f	file:
ofp_print_error_msg	.\lib\ofp-print.c	/^ofp_print_error_msg(struct ds *string, const struct ofp_header *oh)$/;"	f	file:
ofp_print_flow_flags	.\lib\ofp-print.c	/^ofp_print_flow_flags(struct ds *s, enum ofputil_flow_mod_flags flags)$/;"	f	file:
ofp_print_flow_mod	.\lib\ofp-print.c	/^ofp_print_flow_mod(struct ds *s, const struct ofp_header *oh, int verbosity)$/;"	f	file:
ofp_print_flow_removed	.\lib\ofp-print.c	/^ofp_print_flow_removed(struct ds *string, const struct ofp_header *oh)$/;"	f	file:
ofp_print_flow_stats	.\lib\ofp-print.c	/^ofp_print_flow_stats(struct ds *string, struct ofputil_flow_stats *fs)$/;"	f
ofp_print_flow_stats_reply	.\lib\ofp-print.c	/^ofp_print_flow_stats_reply(struct ds *string, const struct ofp_header *oh)$/;"	f	file:
ofp_print_flow_stats_request	.\lib\ofp-print.c	/^ofp_print_flow_stats_request(struct ds *string, const struct ofp_header *oh)$/;"	f	file:
ofp_print_group	.\lib\ofp-print.c	/^ofp_print_group(struct ds *s, uint32_t group_id, uint8_t type,$/;"	f	file:
ofp_print_group_desc	.\lib\ofp-print.c	/^ofp_print_group_desc(struct ds *s, const struct ofp_header *oh)$/;"	f	file:
ofp_print_group_features	.\lib\ofp-print.c	/^ofp_print_group_features(struct ds *string, const struct ofp_header *oh)$/;"	f	file:
ofp_print_group_mod	.\lib\ofp-print.c	/^ofp_print_group_mod(struct ds *s, const struct ofp_header *oh)$/;"	f	file:
ofp_print_group_stats	.\lib\ofp-print.c	/^ofp_print_group_stats(struct ds *s, const struct ofp_header *oh)$/;"	f	file:
ofp_print_hello	.\lib\ofp-print.c	/^ofp_print_hello(struct ds *string, const struct ofp_header *oh)$/;"	f	file:
ofp_print_meter_band	.\lib\ofp-print.c	/^ofp_print_meter_band(struct ds *s, uint16_t flags,$/;"	f	file:
ofp_print_meter_config	.\lib\ofp-print.c	/^ofp_print_meter_config(struct ds *s, const struct ofputil_meter_config *mc)$/;"	f	file:
ofp_print_meter_config_reply	.\lib\ofp-print.c	/^ofp_print_meter_config_reply(struct ds *s, const struct ofp_header *oh)$/;"	f	file:
ofp_print_meter_features_reply	.\lib\ofp-print.c	/^ofp_print_meter_features_reply(struct ds *s, const struct ofp_header *oh)$/;"	f	file:
ofp_print_meter_flags	.\lib\ofp-print.c	/^ofp_print_meter_flags(struct ds *s, uint16_t flags)$/;"	f	file:
ofp_print_meter_mod	.\lib\ofp-print.c	/^ofp_print_meter_mod(struct ds *s, const struct ofp_header *oh)$/;"	f	file:
ofp_print_meter_stats	.\lib\ofp-print.c	/^ofp_print_meter_stats(struct ds *s, const struct ofputil_meter_stats *ms)$/;"	f	file:
ofp_print_meter_stats_reply	.\lib\ofp-print.c	/^ofp_print_meter_stats_reply(struct ds *s, const struct ofp_header *oh)$/;"	f	file:
ofp_print_meter_stats_request	.\lib\ofp-print.c	/^ofp_print_meter_stats_request(struct ds *s, const struct ofp_header *oh)$/;"	f	file:
ofp_print_nxst_flow_monitor_reply	.\lib\ofp-print.c	/^ofp_print_nxst_flow_monitor_reply(struct ds *string,$/;"	f	file:
ofp_print_nxst_flow_monitor_request	.\lib\ofp-print.c	/^ofp_print_nxst_flow_monitor_request(struct ds *string,$/;"	f	file:
ofp_print_nxt_flow_mod_table_id	.\lib\ofp-print.c	/^ofp_print_nxt_flow_mod_table_id(struct ds *string,$/;"	f	file:
ofp_print_nxt_flow_monitor_cancel	.\lib\ofp-print.c	/^ofp_print_nxt_flow_monitor_cancel(struct ds *string,$/;"	f	file:
ofp_print_nxt_set_async_config	.\lib\ofp-print.c	/^ofp_print_nxt_set_async_config(struct ds *string,$/;"	f	file:
ofp_print_nxt_set_controller_id	.\lib\ofp-print.c	/^ofp_print_nxt_set_controller_id(struct ds *string,$/;"	f	file:
ofp_print_nxt_set_flow_format	.\lib\ofp-print.c	/^ofp_print_nxt_set_flow_format(struct ds *string,$/;"	f	file:
ofp_print_nxt_set_packet_in_format	.\lib\ofp-print.c	/^ofp_print_nxt_set_packet_in_format(struct ds *string,$/;"	f	file:
ofp_print_ofpst_desc_reply	.\lib\ofp-print.c	/^ofp_print_ofpst_desc_reply(struct ds *string, const struct ofp_header *oh)$/;"	f	file:
ofp_print_ofpst_group_desc_request	.\lib\ofp-print.c	/^ofp_print_ofpst_group_desc_request(struct ds *string,$/;"	f	file:
ofp_print_ofpst_group_request	.\lib\ofp-print.c	/^ofp_print_ofpst_group_request(struct ds *string, const struct ofp_header *oh)$/;"	f	file:
ofp_print_ofpst_port_desc_reply	.\lib\ofp-print.c	/^ofp_print_ofpst_port_desc_reply(struct ds *string,$/;"	f	file:
ofp_print_ofpst_port_desc_request	.\lib\ofp-print.c	/^ofp_print_ofpst_port_desc_request(struct ds *string,$/;"	f	file:
ofp_print_ofpst_port_reply	.\lib\ofp-print.c	/^ofp_print_ofpst_port_reply(struct ds *string, const struct ofp_header *oh,$/;"	f	file:
ofp_print_ofpst_port_request	.\lib\ofp-print.c	/^ofp_print_ofpst_port_request(struct ds *string, const struct ofp_header *oh)$/;"	f	file:
ofp_print_ofpst_queue_reply	.\lib\ofp-print.c	/^ofp_print_ofpst_queue_reply(struct ds *string, const struct ofp_header *oh,$/;"	f	file:
ofp_print_ofpst_queue_request	.\lib\ofp-print.c	/^ofp_print_ofpst_queue_request(struct ds *string, const struct ofp_header *oh)$/;"	f	file:
ofp_print_ofpst_table_reply	.\lib\ofp-print.c	/^ofp_print_ofpst_table_reply(struct ds *string, const struct ofp_header *oh,$/;"	f	file:
ofp_print_ofpst_table_reply10	.\lib\ofp-print.c	/^ofp_print_ofpst_table_reply10(struct ds *string, const struct ofp_header *oh,$/;"	f	file:
ofp_print_ofpst_table_reply11	.\lib\ofp-print.c	/^ofp_print_ofpst_table_reply11(struct ds *string, const struct ofp_header *oh,$/;"	f	file:
ofp_print_ofpst_table_reply12	.\lib\ofp-print.c	/^ofp_print_ofpst_table_reply12(struct ds *string, const struct ofp_header *oh,$/;"	f	file:
ofp_print_ofpst_table_reply13	.\lib\ofp-print.c	/^ofp_print_ofpst_table_reply13(struct ds *string, const struct ofp_header *oh,$/;"	f	file:
ofp_print_one_ofpst_table_reply	.\lib\ofp-print.c	/^ofp_print_one_ofpst_table_reply(struct ds *string, enum ofp_version ofp_version,$/;"	f	file:
ofp_print_packet	.\lib\ofp-print.c	/^ofp_print_packet(FILE *stream, const void *data, size_t len)$/;"	f
ofp_print_packet_in	.\lib\ofp-print.c	/^ofp_print_packet_in(struct ds *string, const struct ofp_header *oh,$/;"	f	file:
ofp_print_packet_out	.\lib\ofp-print.c	/^ofp_print_packet_out(struct ds *string, const struct ofp_header *oh,$/;"	f	file:
ofp_print_phy_port	.\lib\ofp-print.c	/^ofp_print_phy_port(struct ds *string, const struct ofputil_phy_port *port)$/;"	f	file:
ofp_print_phy_ports	.\lib\ofp-print.c	/^ofp_print_phy_ports(struct ds *string, uint8_t ofp_version,$/;"	f	file:
ofp_print_port_config	.\lib\ofp-print.c	/^ofp_print_port_config(struct ds *string, enum ofputil_port_config config)$/;"	f	file:
ofp_print_port_features	.\lib\ofp-print.c	/^ofp_print_port_features(struct ds *string, enum netdev_features features)$/;"	f	file:
ofp_print_port_mod	.\lib\ofp-print.c	/^ofp_print_port_mod(struct ds *string, const struct ofp_header *oh)$/;"	f	file:
ofp_print_port_state	.\lib\ofp-print.c	/^ofp_print_port_state(struct ds *string, enum ofputil_port_state state)$/;"	f	file:
ofp_print_port_status	.\lib\ofp-print.c	/^ofp_print_port_status(struct ds *string, const struct ofp_header *oh)$/;"	f	file:
ofp_print_queue_get_config_reply	.\lib\ofp-print.c	/^ofp_print_queue_get_config_reply(struct ds *string,$/;"	f	file:
ofp_print_queue_get_config_request	.\lib\ofp-print.c	/^ofp_print_queue_get_config_request(struct ds *string,$/;"	f	file:
ofp_print_queue_name	.\lib\ofp-print.c	/^ofp_print_queue_name(struct ds *string, uint32_t queue_id)$/;"	f	file:
ofp_print_role_generic	.\lib\ofp-print.c	/^ofp_print_role_generic(struct ds *string, enum ofp12_controller_role role,$/;"	f	file:
ofp_print_role_message	.\lib\ofp-print.c	/^ofp_print_role_message(struct ds *string, const struct ofp_header *oh)$/;"	f	file:
ofp_print_role_status_message	.\lib\ofp-print.c	/^ofp_print_role_status_message(struct ds *string, const struct ofp_header *oh)$/;"	f	file:
ofp_print_stats_reply	.\lib\ofp-print.c	/^ofp_print_stats_reply(struct ds *string, const struct ofp_header *oh)$/;"	f	file:
ofp_print_stats_request	.\lib\ofp-print.c	/^ofp_print_stats_request(struct ds *string, const struct ofp_header *oh)$/;"	f	file:
ofp_print_switch_config	.\lib\ofp-print.c	/^ofp_print_switch_config(struct ds *string, const struct ofp_switch_config *osc)$/;"	f	file:
ofp_print_switch_features	.\lib\ofp-print.c	/^ofp_print_switch_features(struct ds *string, const struct ofp_header *oh)$/;"	f	file:
ofp_print_table_features	.\lib\ofp-print.c	/^ofp_print_table_features(struct ds *s, const struct ofp_header *oh)$/;"	f	file:
ofp_print_table_miss_config	.\lib\ofp-print.c	/^ofp_print_table_miss_config(struct ds *string, const uint32_t config)$/;"	f	file:
ofp_print_table_mod	.\lib\ofp-print.c	/^ofp_print_table_mod(struct ds *string, const struct ofp_header *oh)$/;"	f	file:
ofp_print_version	.\lib\ofp-print.c	/^ofp_print_version(const struct ofp_header *oh,$/;"	f
ofp_prop_header	.\lib\ofp-util.c	/^struct ofp_prop_header {$/;"	s	file:
ofp_queue_prop_header	.\include\openflow\openflow-common.h	/^struct ofp_queue_prop_header {$/;"	s
ofp_queue_prop_rate	.\include\openflow\openflow-common.h	/^struct ofp_queue_prop_rate {$/;"	s
ofp_queue_properties	.\include\openflow\openflow-common.h	/^enum ofp_queue_properties {$/;"	g
ofp_requests	.\ofproto\ofproto-provider.h	/^    struct simap ofp_requests;  \/* OpenFlow port number requests. *\/$/;"	m	struct:ofproto	typeref:struct:ofproto::simap
ofp_stats_reply_flags	.\include\openflow\openflow-common.h	/^enum ofp_stats_reply_flags {$/;"	g
ofp_switch_config	.\include\openflow\openflow-common.h	/^struct ofp_switch_config {$/;"	s
ofp_switch_features	.\include\openflow\openflow-common.h	/^struct ofp_switch_features {$/;"	s
ofp_table	.\include\openflow\openflow-common.h	/^enum ofp_table {$/;"	g
ofp_table_config	.\include\openflow\openflow-common.h	/^enum ofp_table_config {$/;"	g
ofp_to_string	.\lib\ofp-print.c	/^ofp_to_string(const void *oh_, size_t len, int verbosity)$/;"	f
ofp_to_string__	.\lib\ofp-print.c	/^ofp_to_string__(const struct ofp_header *oh, enum ofpraw raw,$/;"	f	file:
ofp_util	.\lib\ofp-util.c	/^VLOG_DEFINE_THIS_MODULE(ofp_util);$/;"	v
ofp_vendor_header	.\include\openflow\openflow-common.h	/^struct ofp_vendor_header {$/;"	s
ofp_version	.\include\openflow\openflow-common.h	/^enum ofp_version {$/;"	g
ofp_version_usage	.\lib\ofp-version-opt.c	/^ofp_version_usage(void)$/;"	f
ofpact	.\lib\ofp-actions.h	/^    struct ofpact ofpact;$/;"	m	struct:ofpact_bundle	typeref:struct:ofpact_bundle::ofpact
ofpact	.\lib\ofp-actions.h	/^    struct ofpact ofpact;$/;"	m	struct:ofpact_cnt_ids	typeref:struct:ofpact_cnt_ids::ofpact
ofpact	.\lib\ofp-actions.h	/^    struct ofpact ofpact;$/;"	m	struct:ofpact_controller	typeref:struct:ofpact_controller::ofpact
ofpact	.\lib\ofp-actions.h	/^    struct ofpact ofpact;$/;"	m	struct:ofpact_dscp	typeref:struct:ofpact_dscp::ofpact
ofpact	.\lib\ofp-actions.h	/^    struct ofpact ofpact;$/;"	m	struct:ofpact_ecn	typeref:struct:ofpact_ecn::ofpact
ofpact	.\lib\ofp-actions.h	/^    struct ofpact ofpact;$/;"	m	struct:ofpact_enqueue	typeref:struct:ofpact_enqueue::ofpact
ofpact	.\lib\ofp-actions.h	/^    struct ofpact ofpact;$/;"	m	struct:ofpact_fin_timeout	typeref:struct:ofpact_fin_timeout::ofpact
ofpact	.\lib\ofp-actions.h	/^    struct ofpact ofpact;$/;"	m	struct:ofpact_goto_table	typeref:struct:ofpact_goto_table::ofpact
ofpact	.\lib\ofp-actions.h	/^    struct ofpact ofpact;$/;"	m	struct:ofpact_group	typeref:struct:ofpact_group::ofpact
ofpact	.\lib\ofp-actions.h	/^    struct ofpact ofpact;$/;"	m	struct:ofpact_ip_ttl	typeref:struct:ofpact_ip_ttl::ofpact
ofpact	.\lib\ofp-actions.h	/^    struct ofpact ofpact;$/;"	m	struct:ofpact_ipv4	typeref:struct:ofpact_ipv4::ofpact
ofpact	.\lib\ofp-actions.h	/^    struct ofpact ofpact;$/;"	m	struct:ofpact_l4_port	typeref:struct:ofpact_l4_port::ofpact
ofpact	.\lib\ofp-actions.h	/^    struct ofpact ofpact;$/;"	m	struct:ofpact_learn	typeref:struct:ofpact_learn::ofpact
ofpact	.\lib\ofp-actions.h	/^    struct ofpact ofpact;$/;"	m	struct:ofpact_mac	typeref:struct:ofpact_mac::ofpact
ofpact	.\lib\ofp-actions.h	/^    struct ofpact ofpact;$/;"	m	struct:ofpact_metadata	typeref:struct:ofpact_metadata::ofpact
ofpact	.\lib\ofp-actions.h	/^    struct ofpact ofpact;$/;"	m	struct:ofpact_meter	typeref:struct:ofpact_meter::ofpact
ofpact	.\lib\ofp-actions.h	/^    struct ofpact ofpact;$/;"	m	struct:ofpact_mpls_label	typeref:struct:ofpact_mpls_label::ofpact
ofpact	.\lib\ofp-actions.h	/^    struct ofpact ofpact;$/;"	m	struct:ofpact_mpls_tc	typeref:struct:ofpact_mpls_tc::ofpact
ofpact	.\lib\ofp-actions.h	/^    struct ofpact ofpact;$/;"	m	struct:ofpact_mpls_ttl	typeref:struct:ofpact_mpls_ttl::ofpact
ofpact	.\lib\ofp-actions.h	/^    struct ofpact ofpact;$/;"	m	struct:ofpact_multipath	typeref:struct:ofpact_multipath::ofpact
ofpact	.\lib\ofp-actions.h	/^    struct ofpact ofpact;$/;"	m	struct:ofpact_nest	typeref:struct:ofpact_nest::ofpact
ofpact	.\lib\ofp-actions.h	/^    struct ofpact ofpact;$/;"	m	struct:ofpact_note	typeref:struct:ofpact_note::ofpact
ofpact	.\lib\ofp-actions.h	/^    struct ofpact ofpact;$/;"	m	struct:ofpact_null	typeref:struct:ofpact_null::ofpact
ofpact	.\lib\ofp-actions.h	/^    struct ofpact ofpact;$/;"	m	struct:ofpact_output	typeref:struct:ofpact_output::ofpact
ofpact	.\lib\ofp-actions.h	/^    struct ofpact ofpact;$/;"	m	struct:ofpact_output_reg	typeref:struct:ofpact_output_reg::ofpact
ofpact	.\lib\ofp-actions.h	/^    struct ofpact ofpact;$/;"	m	struct:ofpact_pop_mpls	typeref:struct:ofpact_pop_mpls::ofpact
ofpact	.\lib\ofp-actions.h	/^    struct ofpact ofpact;$/;"	m	struct:ofpact_push_mpls	typeref:struct:ofpact_push_mpls::ofpact
ofpact	.\lib\ofp-actions.h	/^    struct ofpact ofpact;$/;"	m	struct:ofpact_queue	typeref:struct:ofpact_queue::ofpact
ofpact	.\lib\ofp-actions.h	/^    struct ofpact ofpact;$/;"	m	struct:ofpact_reg_load	typeref:struct:ofpact_reg_load::ofpact
ofpact	.\lib\ofp-actions.h	/^    struct ofpact ofpact;$/;"	m	struct:ofpact_reg_move	typeref:struct:ofpact_reg_move::ofpact
ofpact	.\lib\ofp-actions.h	/^    struct ofpact ofpact;$/;"	m	struct:ofpact_resubmit	typeref:struct:ofpact_resubmit::ofpact
ofpact	.\lib\ofp-actions.h	/^    struct ofpact ofpact;$/;"	m	struct:ofpact_sample	typeref:struct:ofpact_sample::ofpact
ofpact	.\lib\ofp-actions.h	/^    struct ofpact ofpact;$/;"	m	struct:ofpact_set_field	typeref:struct:ofpact_set_field::ofpact
ofpact	.\lib\ofp-actions.h	/^    struct ofpact ofpact;$/;"	m	struct:ofpact_stack	typeref:struct:ofpact_stack::ofpact
ofpact	.\lib\ofp-actions.h	/^    struct ofpact ofpact;$/;"	m	struct:ofpact_tunnel	typeref:struct:ofpact_tunnel::ofpact
ofpact	.\lib\ofp-actions.h	/^    struct ofpact ofpact;$/;"	m	struct:ofpact_vlan_pcp	typeref:struct:ofpact_vlan_pcp::ofpact
ofpact	.\lib\ofp-actions.h	/^    struct ofpact ofpact;$/;"	m	struct:ofpact_vlan_vid	typeref:struct:ofpact_vlan_vid::ofpact
ofpact	.\lib\ofp-actions.h	/^struct ofpact {$/;"	s
ofpact_bundle	.\lib\ofp-actions.h	/^struct ofpact_bundle {$/;"	s
ofpact_check__	.\lib\ofp-actions.c	/^ofpact_check__(enum ofputil_protocol *usable_protocols, struct ofpact *a,$/;"	f	file:
ofpact_check_output_port	.\lib\ofp-actions.c	/^ofpact_check_output_port(ofp_port_t port, ofp_port_t max_ports)$/;"	f
ofpact_cnt_ids	.\lib\ofp-actions.h	/^struct ofpact_cnt_ids {$/;"	s
ofpact_controller	.\lib\ofp-actions.h	/^struct ofpact_controller {$/;"	s
ofpact_controller_to_nxast	.\lib\ofp-actions.c	/^ofpact_controller_to_nxast(const struct ofpact_controller *oc,$/;"	f	file:
ofpact_copy	.\lib\ofp-actions.c	/^ofpact_copy(struct ofpbuf *out, const struct ofpact *a)$/;"	f	file:
ofpact_dec_ttl_to_nxast	.\lib\ofp-actions.c	/^ofpact_dec_ttl_to_nxast(const struct ofpact_cnt_ids *oc_ids,$/;"	f	file:
ofpact_dec_ttl_to_openflow11	.\lib\ofp-actions.c	/^ofpact_dec_ttl_to_openflow11(const struct ofpact_cnt_ids *dec_ttl,$/;"	f	file:
ofpact_dscp	.\lib\ofp-actions.h	/^struct ofpact_dscp {$/;"	s
ofpact_ecn	.\lib\ofp-actions.h	/^struct ofpact_ecn {$/;"	s
ofpact_end	.\lib\ofp-actions.h	/^ofpact_end(const struct ofpact *ofpacts, size_t ofpacts_len)$/;"	f
ofpact_enqueue	.\lib\ofp-actions.h	/^struct ofpact_enqueue {$/;"	s
ofpact_enqueue_to_openflow10	.\lib\ofp-actions.c	/^ofpact_enqueue_to_openflow10(const struct ofpact_enqueue *enqueue,$/;"	f	file:
ofpact_fin_timeout	.\lib\ofp-actions.h	/^struct ofpact_fin_timeout {$/;"	s
ofpact_fin_timeout_to_nxast	.\lib\ofp-actions.c	/^ofpact_fin_timeout_to_nxast(const struct ofpact_fin_timeout *fin_timeout,$/;"	f	file:
ofpact_format	.\lib\ofp-actions.c	/^ofpact_format(const struct ofpact *a, struct ds *s)$/;"	f	file:
ofpact_from_nxast	.\lib\ofp-actions.c	/^ofpact_from_nxast(const union ofp_action *a, enum ofputil_action_code code,$/;"	f	file:
ofpact_from_openflow10	.\lib\ofp-actions.c	/^ofpact_from_openflow10(const union ofp_action *a,$/;"	f	file:
ofpact_from_openflow11	.\lib\ofp-actions.c	/^ofpact_from_openflow11(const union ofp_action *a, enum ofp_version version,$/;"	f	file:
ofpact_goto_table	.\lib\ofp-actions.h	/^struct ofpact_goto_table {$/;"	s
ofpact_group	.\lib\ofp-actions.h	/^struct ofpact_group {$/;"	s
ofpact_init	.\lib\ofp-actions.c	/^ofpact_init(struct ofpact *ofpact, enum ofpact_type type, size_t len)$/;"	f
ofpact_ip_ttl	.\lib\ofp-actions.h	/^struct ofpact_ip_ttl {$/;"	s
ofpact_ipv4	.\lib\ofp-actions.h	/^struct ofpact_ipv4 {$/;"	s
ofpact_is_allowed_in_actions_set	.\lib\ofp-actions.c	/^ofpact_is_allowed_in_actions_set(const struct ofpact *a)$/;"	f	file:
ofpact_is_set_action	.\lib\ofp-actions.c	/^ofpact_is_set_action(const struct ofpact *a)$/;"	f	file:
ofpact_l4_port	.\lib\ofp-actions.h	/^struct ofpact_l4_port {$/;"	s
ofpact_learn	.\lib\ofp-actions.h	/^struct ofpact_learn {$/;"	s
ofpact_learn_spec	.\lib\ofp-actions.h	/^struct ofpact_learn_spec {$/;"	s
ofpact_mac	.\lib\ofp-actions.h	/^struct ofpact_mac {$/;"	s
ofpact_metadata	.\lib\ofp-actions.h	/^struct ofpact_metadata {$/;"	s
ofpact_meter	.\lib\ofp-actions.h	/^struct ofpact_meter {$/;"	s
ofpact_mpls_label	.\lib\ofp-actions.h	/^struct ofpact_mpls_label {$/;"	s
ofpact_mpls_tc	.\lib\ofp-actions.h	/^struct ofpact_mpls_tc {$/;"	s
ofpact_mpls_ttl	.\lib\ofp-actions.h	/^struct ofpact_mpls_ttl {$/;"	s
ofpact_multipath	.\lib\ofp-actions.h	/^struct ofpact_multipath {$/;"	s
ofpact_nest	.\lib\ofp-actions.h	/^struct ofpact_nest {$/;"	s
ofpact_nest_get_action_len	.\lib\ofp-actions.h	/^ofpact_nest_get_action_len(const struct ofpact_nest *on)$/;"	f
ofpact_next	.\lib\ofp-actions.h	/^ofpact_next(const struct ofpact *ofpact)$/;"	f
ofpact_note	.\lib\ofp-actions.h	/^struct ofpact_note {$/;"	s
ofpact_note_to_nxast	.\lib\ofp-actions.c	/^ofpact_note_to_nxast(const struct ofpact_note *note, struct ofpbuf *out)$/;"	f	file:
ofpact_null	.\lib\ofp-actions.h	/^struct ofpact_null {$/;"	s
ofpact_output	.\lib\ofp-actions.h	/^struct ofpact_output {$/;"	s
ofpact_output_reg	.\lib\ofp-actions.h	/^struct ofpact_output_reg {$/;"	s
ofpact_output_reg_to_nxast	.\lib\ofp-actions.c	/^ofpact_output_reg_to_nxast(const struct ofpact_output_reg *output_reg,$/;"	f	file:
ofpact_output_to_openflow10	.\lib\ofp-actions.c	/^ofpact_output_to_openflow10(const struct ofpact_output *output,$/;"	f	file:
ofpact_output_to_openflow11	.\lib\ofp-actions.c	/^ofpact_output_to_openflow11(const struct ofpact_output *output,$/;"	f	file:
ofpact_outputs_to_port	.\lib\ofp-actions.c	/^ofpact_outputs_to_port(const struct ofpact *ofpact, ofp_port_t port)$/;"	f	file:
ofpact_pad	.\lib\ofp-actions.c	/^ofpact_pad(struct ofpbuf *ofpacts)$/;"	f
ofpact_pop_mpls	.\lib\ofp-actions.h	/^struct ofpact_pop_mpls {$/;"	s
ofpact_push_mpls	.\lib\ofp-actions.h	/^struct ofpact_push_mpls {$/;"	s
ofpact_put	.\lib\ofp-actions.c	/^ofpact_put(struct ofpbuf *ofpacts, enum ofpact_type type, size_t len)$/;"	f
ofpact_queue	.\lib\ofp-actions.h	/^struct ofpact_queue {$/;"	s
ofpact_reg_load	.\lib\ofp-actions.h	/^struct ofpact_reg_load {$/;"	s
ofpact_reg_move	.\lib\ofp-actions.h	/^struct ofpact_reg_move {$/;"	s
ofpact_resubmit	.\lib\ofp-actions.h	/^struct ofpact_resubmit {$/;"	s
ofpact_resubmit_to_nxast	.\lib\ofp-actions.c	/^ofpact_resubmit_to_nxast(const struct ofpact_resubmit *resubmit,$/;"	f	file:
ofpact_sample	.\lib\ofp-actions.h	/^struct ofpact_sample {$/;"	s
ofpact_sample_to_nxast	.\lib\ofp-actions.c	/^ofpact_sample_to_nxast(const struct ofpact_sample *os,$/;"	f	file:
ofpact_set_field	.\lib\ofp-actions.h	/^struct ofpact_set_field {$/;"	s
ofpact_set_tunnel_to_nxast	.\lib\ofp-actions.c	/^ofpact_set_tunnel_to_nxast(const struct ofpact_tunnel *tunnel,$/;"	f	file:
ofpact_stack	.\lib\ofp-actions.h	/^struct ofpact_stack {$/;"	s
ofpact_to_nxast	.\lib\ofp-actions.c	/^ofpact_to_nxast(const struct ofpact *a, struct ofpbuf *out)$/;"	f	file:
ofpact_to_openflow10	.\lib\ofp-actions.c	/^ofpact_to_openflow10(const struct ofpact *a, struct ofpbuf *out)$/;"	f	file:
ofpact_to_openflow11	.\lib\ofp-actions.c	/^ofpact_to_openflow11(const struct ofpact *a, struct ofpbuf *out)$/;"	f	file:
ofpact_to_openflow12	.\lib\ofp-actions.c	/^ofpact_to_openflow12(const struct ofpact *a, struct ofpbuf *out)$/;"	f	file:
ofpact_tunnel	.\lib\ofp-actions.h	/^struct ofpact_tunnel {$/;"	s
ofpact_type	.\lib\ofp-actions.h	/^enum OVS_PACKED_ENUM ofpact_type {$/;"	g
ofpact_update_len	.\lib\ofp-actions.c	/^ofpact_update_len(struct ofpbuf *ofpacts, struct ofpact *ofpact)$/;"	f
ofpact_vlan_pcp	.\lib\ofp-actions.h	/^struct ofpact_vlan_pcp {$/;"	s
ofpact_vlan_vid	.\lib\ofp-actions.h	/^struct ofpact_vlan_vid {$/;"	s
ofpact_write_metadata_to_nxast	.\lib\ofp-actions.c	/^ofpact_write_metadata_to_nxast(const struct ofpact_metadata *om,$/;"	f	file:
ofpacts	.\lib\ofp-util.h	/^    const struct ofpact *ofpacts;$/;"	m	struct:ofputil_flow_stats	typeref:struct:ofputil_flow_stats::ofpact
ofpacts	.\lib\ofp-util.h	/^    const struct ofpact *ofpacts;$/;"	m	struct:ofputil_flow_update	typeref:struct:ofputil_flow_update::ofpact
ofpacts	.\lib\ofp-util.h	/^    struct ofpact *ofpacts;     \/* Actions. *\/$/;"	m	struct:ofputil_packet_out	typeref:struct:ofputil_packet_out::ofpact
ofpacts	.\lib\ofp-util.h	/^    struct ofpact *ofpacts;     \/* Series of "struct ofpact"s. *\/$/;"	m	struct:ofputil_bucket	typeref:struct:ofputil_bucket::ofpact
ofpacts	.\lib\ofp-util.h	/^    struct ofpact *ofpacts;  \/* Series of "struct ofpact"s. *\/$/;"	m	struct:ofputil_flow_mod	typeref:struct:ofputil_flow_mod::ofpact
ofpacts	.\ofproto\ofproto-dpif-xlate.c	/^            struct ofpbuf *ofpacts;$/;"	m	struct:xc_entry::__anon136::__anon141	typeref:struct:xc_entry::__anon136::__anon141::ofpbuf	file:
ofpacts	.\ofproto\ofproto-dpif-xlate.h	/^    const struct ofpact *ofpacts;$/;"	m	struct:xlate_in	typeref:struct:xlate_in::ofpact
ofpacts	.\ofproto\ofproto-provider.h	/^    struct ofpact ofpacts[];      \/* Sequence of "struct ofpacts". *\/$/;"	m	struct:rule_actions	typeref:struct:rule_actions::ofpact
ofpacts	.\utilities\ovs-ofctl.c	/^    struct ofpact *ofpacts;$/;"	m	struct:fte_version	typeref:struct:fte_version::ofpact	file:
ofpacts_check	.\lib\ofp-actions.c	/^ofpacts_check(struct ofpact ofpacts[], size_t ofpacts_len,$/;"	f
ofpacts_check_consistency	.\lib\ofp-actions.c	/^ofpacts_check_consistency(struct ofpact ofpacts[], size_t ofpacts_len,$/;"	f
ofpacts_copy_all	.\lib\ofp-actions.c	/^ofpacts_copy_all(struct ofpbuf *out, const struct ofpbuf *in,$/;"	f	file:
ofpacts_copy_last	.\lib\ofp-actions.c	/^ofpacts_copy_last(struct ofpbuf *out, const struct ofpbuf *in,$/;"	f	file:
ofpacts_equal	.\lib\ofp-actions.c	/^ofpacts_equal(const struct ofpact *a, size_t a_len,$/;"	f
ofpacts_execute_action_set	.\lib\ofp-actions.c	/^ofpacts_execute_action_set(struct ofpbuf *action_list,$/;"	f
ofpacts_format	.\lib\ofp-actions.c	/^ofpacts_format(const struct ofpact *ofpacts, size_t ofpacts_len,$/;"	f
ofpacts_from_openflow	.\lib\ofp-actions.c	/^ofpacts_from_openflow(const union ofp_action *in, size_t n_in,$/;"	f	file:
ofpacts_from_openflow11_for_action_set	.\lib\ofp-actions.c	/^ofpacts_from_openflow11_for_action_set(const union ofp_action *in,$/;"	f	file:
ofpacts_get_meter	.\lib\ofp-actions.c	/^ofpacts_get_meter(const struct ofpact ofpacts[], size_t ofpacts_len)$/;"	f
ofpacts_len	.\lib\ofp-util.h	/^    size_t ofpacts_len;         \/* Length of ofpacts, in bytes. *\/$/;"	m	struct:ofputil_bucket
ofpacts_len	.\lib\ofp-util.h	/^    size_t ofpacts_len;         \/* Size of ofpacts in bytes. *\/$/;"	m	struct:ofputil_packet_out
ofpacts_len	.\lib\ofp-util.h	/^    size_t ofpacts_len;      \/* Length of ofpacts, in bytes. *\/$/;"	m	struct:ofputil_flow_mod
ofpacts_len	.\lib\ofp-util.h	/^    size_t ofpacts_len;$/;"	m	struct:ofputil_flow_stats
ofpacts_len	.\lib\ofp-util.h	/^    size_t ofpacts_len;$/;"	m	struct:ofputil_flow_update
ofpacts_len	.\ofproto\ofproto-dpif-xlate.h	/^    size_t ofpacts_len;$/;"	m	struct:xlate_in
ofpacts_len	.\ofproto\ofproto-provider.h	/^    uint32_t ofpacts_len;         \/* Size of 'ofpacts', in bytes. *\/$/;"	m	struct:rule_actions
ofpacts_len	.\utilities\ovs-ofctl.c	/^    size_t ofpacts_len;$/;"	m	struct:fte_version	file:
ofpacts_output_to_group	.\lib\ofp-actions.c	/^ofpacts_output_to_group(const struct ofpact *ofpacts, size_t ofpacts_len,$/;"	f
ofpacts_output_to_port	.\lib\ofp-actions.c	/^ofpacts_output_to_port(const struct ofpact *ofpacts, size_t ofpacts_len,$/;"	f
ofpacts_pull_openflow_actions	.\lib\ofp-actions.c	/^ofpacts_pull_openflow_actions(struct ofpbuf *openflow,$/;"	f
ofpacts_pull_openflow_instructions	.\lib\ofp-actions.c	/^ofpacts_pull_openflow_instructions(struct ofpbuf *openflow,$/;"	f
ofpacts_put_openflow_actions	.\lib\ofp-actions.c	/^ofpacts_put_openflow_actions(const struct ofpact ofpacts[], size_t ofpacts_len,$/;"	f
ofpacts_put_openflow_instructions	.\lib\ofp-actions.c	/^ofpacts_put_openflow_instructions(const struct ofpact ofpacts[],$/;"	f
ofpacts_update_instruction_actions	.\lib\ofp-actions.c	/^ofpacts_update_instruction_actions(struct ofpbuf *openflow, size_t ofs)$/;"	f	file:
ofpacts_verify	.\lib\ofp-actions.c	/^ofpacts_verify(const struct ofpact ofpacts[], size_t ofpacts_len)$/;"	f
ofpbuf	.\lib\ofpbuf.h	/^struct ofpbuf {$/;"	s
ofpbuf_adjust_layer_offset	.\lib\ofpbuf.c	/^ofpbuf_adjust_layer_offset(uint16_t *offset, int increment)$/;"	f	file:
ofpbuf_at	.\lib\ofpbuf.h	/^static inline void *ofpbuf_at(const struct ofpbuf *b, size_t offset,$/;"	f
ofpbuf_at_assert	.\lib\ofpbuf.h	/^static inline void *ofpbuf_at_assert(const struct ofpbuf *b, size_t offset,$/;"	f
ofpbuf_base	.\lib\ofpbuf.h	/^static inline void * ofpbuf_base(const struct ofpbuf *b)$/;"	f
ofpbuf_clear	.\lib\ofpbuf.h	/^static inline void ofpbuf_clear(struct ofpbuf *b)$/;"	f
ofpbuf_clone	.\lib\ofpbuf.c	/^ofpbuf_clone(const struct ofpbuf *buffer)$/;"	f
ofpbuf_clone_data	.\lib\ofpbuf.c	/^ofpbuf_clone_data(const void *data, size_t size)$/;"	f
ofpbuf_clone_data_with_headroom	.\lib\ofpbuf.c	/^ofpbuf_clone_data_with_headroom(const void *data, size_t size, size_t headroom)$/;"	f
ofpbuf_clone_with_headroom	.\lib\ofpbuf.c	/^ofpbuf_clone_with_headroom(const struct ofpbuf *buffer, size_t headroom)$/;"	f
ofpbuf_copy__	.\lib\ofpbuf.c	/^ofpbuf_copy__(struct ofpbuf *b, uint8_t *new_base,$/;"	f	file:
ofpbuf_data	.\lib\ofpbuf.h	/^static inline void * ofpbuf_data(const struct ofpbuf *b)$/;"	f
ofpbuf_delete	.\lib\ofpbuf.h	/^static inline void ofpbuf_delete(struct ofpbuf *b)$/;"	f
ofpbuf_end	.\lib\ofpbuf.h	/^static inline void *ofpbuf_end(const struct ofpbuf *b)$/;"	f
ofpbuf_equal	.\lib\ofpbuf.h	/^static inline bool ofpbuf_equal(const struct ofpbuf *a, const struct ofpbuf *b)$/;"	f
ofpbuf_from_list	.\lib\ofpbuf.h	/^static inline struct ofpbuf *ofpbuf_from_list(const struct list *list)$/;"	f
ofpbuf_get_icmp_payload	.\lib\ofpbuf.h	/^static inline const void *ofpbuf_get_icmp_payload(const struct ofpbuf *b)$/;"	f
ofpbuf_get_sctp_payload	.\lib\ofpbuf.h	/^static inline const void *ofpbuf_get_sctp_payload(const struct ofpbuf *b)$/;"	f
ofpbuf_get_tcp_payload	.\lib\ofpbuf.h	/^static inline const void *ofpbuf_get_tcp_payload(const struct ofpbuf *b)$/;"	f
ofpbuf_get_udp_payload	.\lib\ofpbuf.h	/^static inline const void *ofpbuf_get_udp_payload(const struct ofpbuf *b)$/;"	f
ofpbuf_get_uninit_pointer	.\lib\ofpbuf.h	/^static inline void *ofpbuf_get_uninit_pointer(struct ofpbuf *b)$/;"	f
ofpbuf_headroom	.\lib\ofpbuf.h	/^static inline size_t ofpbuf_headroom(const struct ofpbuf *b)$/;"	f
ofpbuf_init	.\lib\ofpbuf.c	/^ofpbuf_init(struct ofpbuf *b, size_t size)$/;"	f
ofpbuf_init__	.\lib\ofpbuf.c	/^ofpbuf_init__(struct ofpbuf *b, size_t allocated, enum ofpbuf_source source)$/;"	f	file:
ofpbuf_init_dpdk	.\lib\ofpbuf.c	/^ofpbuf_init_dpdk(struct ofpbuf *b, size_t allocated)$/;"	f
ofpbuf_l2	.\lib\ofpbuf.h	/^static inline void * ofpbuf_l2(const struct ofpbuf *b)$/;"	f
ofpbuf_l2_5	.\lib\ofpbuf.h	/^static inline void * ofpbuf_l2_5(const struct ofpbuf *b)$/;"	f
ofpbuf_l3	.\lib\ofpbuf.h	/^static inline void * ofpbuf_l3(const struct ofpbuf *b)$/;"	f
ofpbuf_l4	.\lib\ofpbuf.h	/^static inline void * ofpbuf_l4(const struct ofpbuf *b)$/;"	f
ofpbuf_l4_size	.\lib\ofpbuf.h	/^static inline size_t ofpbuf_l4_size(const struct ofpbuf *b)$/;"	f
ofpbuf_list_delete	.\lib\ofpbuf.c	/^ofpbuf_list_delete(struct list *list)$/;"	f
ofpbuf_new	.\lib\ofpbuf.c	/^ofpbuf_new(size_t size)$/;"	f
ofpbuf_new_with_headroom	.\lib\ofpbuf.c	/^ofpbuf_new_with_headroom(size_t size, size_t headroom)$/;"	f
ofpbuf_padto	.\lib\ofpbuf.c	/^ofpbuf_padto(struct ofpbuf *b, size_t length)$/;"	f
ofpbuf_prealloc_headroom	.\lib\ofpbuf.c	/^ofpbuf_prealloc_headroom(struct ofpbuf *b, size_t size)$/;"	f
ofpbuf_prealloc_tailroom	.\lib\ofpbuf.c	/^ofpbuf_prealloc_tailroom(struct ofpbuf *b, size_t size)$/;"	f
ofpbuf_pull	.\lib\ofpbuf.h	/^static inline void *ofpbuf_pull(struct ofpbuf *b, size_t size)$/;"	f
ofpbuf_push	.\lib\ofpbuf.c	/^ofpbuf_push(struct ofpbuf *b, const void *p, size_t size)$/;"	f
ofpbuf_push_uninit	.\lib\ofpbuf.c	/^ofpbuf_push_uninit(struct ofpbuf *b, size_t size)$/;"	f
ofpbuf_push_zeros	.\lib\ofpbuf.c	/^ofpbuf_push_zeros(struct ofpbuf *b, size_t size)$/;"	f
ofpbuf_put	.\lib\ofpbuf.c	/^ofpbuf_put(struct ofpbuf *b, const void *p, size_t size)$/;"	f
ofpbuf_put_hex	.\lib\ofpbuf.c	/^ofpbuf_put_hex(struct ofpbuf *b, const char *s, size_t *n)$/;"	f
ofpbuf_put_uninit	.\lib\ofpbuf.c	/^ofpbuf_put_uninit(struct ofpbuf *b, size_t size)$/;"	f
ofpbuf_put_zeros	.\lib\ofpbuf.c	/^ofpbuf_put_zeros(struct ofpbuf *b, size_t size)$/;"	f
ofpbuf_reinit	.\lib\ofpbuf.c	/^ofpbuf_reinit(struct ofpbuf *b, size_t size)$/;"	f
ofpbuf_reserve	.\lib\ofpbuf.c	/^ofpbuf_reserve(struct ofpbuf *b, size_t size)$/;"	f
ofpbuf_reserve_with_tailroom	.\lib\ofpbuf.c	/^ofpbuf_reserve_with_tailroom(struct ofpbuf *b, size_t headroom,$/;"	f
ofpbuf_resize__	.\lib\ofpbuf.c	/^ofpbuf_resize__(struct ofpbuf *b, size_t new_headroom, size_t new_tailroom)$/;"	f	file:
ofpbuf_resize_l2	.\lib\ofpbuf.c	/^ofpbuf_resize_l2(struct ofpbuf *b, int increment)$/;"	f
ofpbuf_resize_l2_5	.\lib\ofpbuf.c	/^ofpbuf_resize_l2_5(struct ofpbuf *b, int increment)$/;"	f
ofpbuf_set_base	.\lib\ofpbuf.h	/^static inline void ofpbuf_set_base(struct ofpbuf *b, void *d)$/;"	f
ofpbuf_set_data	.\lib\ofpbuf.h	/^static inline void ofpbuf_set_data(struct ofpbuf *b, void *d)$/;"	f
ofpbuf_set_frame	.\lib\ofpbuf.h	/^static inline void ofpbuf_set_frame(struct ofpbuf *b, void *packet)$/;"	f
ofpbuf_set_l2_5	.\lib\ofpbuf.h	/^static inline void ofpbuf_set_l2_5(struct ofpbuf *b, void *l2_5)$/;"	f
ofpbuf_set_l3	.\lib\ofpbuf.h	/^static inline void ofpbuf_set_l3(struct ofpbuf *b, void *l3)$/;"	f
ofpbuf_set_l4	.\lib\ofpbuf.h	/^static inline void ofpbuf_set_l4(struct ofpbuf *b, void *l4)$/;"	f
ofpbuf_set_size	.\lib\ofpbuf.h	/^static inline void ofpbuf_set_size(struct ofpbuf *b, uint32_t v)$/;"	f
ofpbuf_shift	.\lib\ofpbuf.c	/^ofpbuf_shift(struct ofpbuf *b, int delta)$/;"	f
ofpbuf_size	.\lib\ofpbuf.h	/^static inline uint32_t ofpbuf_size(const struct ofpbuf *b)$/;"	f
ofpbuf_source	.\lib\ofpbuf.h	/^enum OVS_PACKED_ENUM ofpbuf_source {$/;"	g
ofpbuf_steal_data	.\lib\ofpbuf.c	/^ofpbuf_steal_data(struct ofpbuf *b)$/;"	f
ofpbuf_tail	.\lib\ofpbuf.h	/^static inline void *ofpbuf_tail(const struct ofpbuf *b)$/;"	f
ofpbuf_tailroom	.\lib\ofpbuf.h	/^static inline size_t ofpbuf_tailroom(const struct ofpbuf *b)$/;"	f
ofpbuf_to_string	.\lib\ofpbuf.c	/^ofpbuf_to_string(const struct ofpbuf *b, size_t maxbytes)$/;"	f
ofpbuf_trim	.\lib\ofpbuf.c	/^ofpbuf_trim(struct ofpbuf *b)$/;"	f
ofpbuf_try_pull	.\lib\ofpbuf.h	/^static inline void *ofpbuf_try_pull(struct ofpbuf *b, size_t size)$/;"	f
ofpbuf_uninit	.\lib\ofpbuf.c	/^ofpbuf_uninit(struct ofpbuf *b)$/;"	f
ofpbuf_use	.\lib\ofpbuf.c	/^ofpbuf_use(struct ofpbuf *b, void *base, size_t allocated)$/;"	f
ofpbuf_use__	.\lib\ofpbuf.c	/^ofpbuf_use__(struct ofpbuf *b, void *base, size_t allocated,$/;"	f	file:
ofpbuf_use_const	.\lib\ofpbuf.c	/^ofpbuf_use_const(struct ofpbuf *b, const void *data, size_t size)$/;"	f
ofpbuf_use_stack	.\lib\ofpbuf.c	/^ofpbuf_use_stack(struct ofpbuf *b, void *base, size_t allocated)$/;"	f
ofpbuf_use_stub	.\lib\ofpbuf.c	/^ofpbuf_use_stub(struct ofpbuf *b, void *base, size_t allocated)$/;"	f
ofperr	.\lib\ofp-errors.h	/^enum ofperr {$/;"	g
ofperr_decode	.\lib\ofp-errors.c	/^ofperr_decode(enum ofp_version version,$/;"	f	file:
ofperr_decode_msg	.\lib\ofp-errors.c	/^ofperr_decode_msg(const struct ofp_header *oh, struct ofpbuf *payload)$/;"	f
ofperr_domain_from_version	.\lib\ofp-errors.c	/^ofperr_domain_from_version(enum ofp_version version)$/;"	f	file:
ofperr_domain_get_name	.\lib\ofp-errors.c	/^ofperr_domain_get_name(enum ofp_version version)$/;"	f
ofperr_encode_hello	.\lib\ofp-errors.c	/^ofperr_encode_hello(enum ofperr error, enum ofp_version ofp_version,$/;"	f
ofperr_encode_msg__	.\lib\ofp-errors.c	/^ofperr_encode_msg__(enum ofperr error, enum ofp_version ofp_version,$/;"	f	file:
ofperr_encode_reply	.\lib\ofp-errors.c	/^ofperr_encode_reply(enum ofperr error, const struct ofp_header *oh)$/;"	f
ofperr_from_name	.\lib\ofp-errors.c	/^ofperr_from_name(const char *name)$/;"	f
ofperr_get_code	.\lib\ofp-errors.c	/^ofperr_get_code(enum ofperr error, enum ofp_version version)$/;"	f
ofperr_get_description	.\lib\ofp-errors.c	/^ofperr_get_description(enum ofperr error)$/;"	f
ofperr_get_name	.\lib\ofp-errors.c	/^ofperr_get_name(enum ofperr error)$/;"	f
ofperr_get_triplet__	.\lib\ofp-errors.c	/^ofperr_get_triplet__(enum ofperr error, const struct ofperr_domain *domain)$/;"	f	file:
ofperr_get_type	.\lib\ofp-errors.c	/^ofperr_get_type(enum ofperr error, enum ofp_version version)$/;"	f
ofperr_get_vendor	.\lib\ofp-errors.c	/^ofperr_get_vendor(enum ofperr error, enum ofp_version version)$/;"	f
ofperr_is_valid	.\lib\ofp-errors.c	/^ofperr_is_valid(enum ofperr error)$/;"	f
ofperr_to_string	.\lib\ofp-errors.c	/^ofperr_to_string(enum ofperr error)$/;"	f
ofphdrs	.\lib\ofp-msgs.c	/^struct ofphdrs {$/;"	s	file:
ofphdrs_decode	.\lib\ofp-msgs.c	/^ofphdrs_decode(struct ofphdrs *hdrs,$/;"	f	file:
ofphdrs_decode_assert	.\lib\ofp-msgs.c	/^ofphdrs_decode_assert(struct ofphdrs *hdrs,$/;"	f	file:
ofphdrs_equal	.\lib\ofp-msgs.c	/^ofphdrs_equal(const struct ofphdrs *a, const struct ofphdrs *b)$/;"	f	file:
ofphdrs_hash	.\lib\ofp-msgs.c	/^ofphdrs_hash(const struct ofphdrs *hdrs)$/;"	f	file:
ofphdrs_is_stat	.\lib\ofp-msgs.c	/^ofphdrs_is_stat(const struct ofphdrs *hdrs)$/;"	f	file:
ofphdrs_len	.\lib\ofp-msgs.c	/^ofphdrs_len(const struct ofphdrs *hdrs)$/;"	f
ofpmp_append	.\lib\ofp-msgs.c	/^ofpmp_append(struct list *replies, size_t len)$/;"	f
ofpmp_decode_raw	.\lib\ofp-msgs.c	/^ofpmp_decode_raw(struct list *replies)$/;"	f
ofpmp_flags	.\lib\ofp-msgs.c	/^ofpmp_flags(const struct ofp_header *oh)$/;"	f
ofpmp_flags__	.\lib\ofp-msgs.c	/^ofpmp_flags__(const struct ofp_header *oh)$/;"	f	file:
ofpmp_init	.\lib\ofp-msgs.c	/^ofpmp_init(struct list *replies, const struct ofp_header *request)$/;"	f
ofpmp_more	.\lib\ofp-msgs.c	/^ofpmp_more(const struct ofp_header *oh)$/;"	f
ofpmp_postappend	.\lib\ofp-msgs.c	/^ofpmp_postappend(struct list *replies, size_t start_ofs)$/;"	f
ofpmp_reserve	.\lib\ofp-msgs.c	/^ofpmp_reserve(struct list *replies, size_t len)$/;"	f
ofpmp_version	.\lib\ofp-msgs.c	/^ofpmp_version(struct list *replies)$/;"	f
ofpmsg_body	.\lib\ofp-msgs.c	/^ofpmsg_body(const struct ofp_header *oh)$/;"	f
ofpmsg_is_stat_request	.\lib\ofp-msgs.c	/^ofpmsg_is_stat_request(const struct ofp_header *oh)$/;"	f
ofpmsg_update_length	.\lib\ofp-msgs.c	/^ofpmsg_update_length(struct ofpbuf *buf)$/;"	f
ofpmsgs_init	.\lib\ofp-msgs.c	/^ofpmsgs_init(void)$/;"	f	file:
ofport	.\lib\vswitch-idl.h	/^	int64_t *ofport;$/;"	m	struct:ovsrec_interface
ofport	.\ofproto\ofproto-dpif-monitor.c	/^    const struct ofport_dpif *ofport; \/* The corresponding ofport. *\/$/;"	m	struct:mport	typeref:struct:mport::ofport_dpif	file:
ofport	.\ofproto\ofproto-dpif-monitor.c	/^    const struct ofport_dpif *ofport;$/;"	m	struct:send_soon_entry	typeref:struct:send_soon_entry::ofport_dpif	file:
ofport	.\ofproto\ofproto-dpif-sflow.c	/^    struct ofport *ofport;      \/* To retrive port stats. *\/$/;"	m	struct:dpif_sflow_port	typeref:struct:dpif_sflow_port::ofport	file:
ofport	.\ofproto\ofproto-dpif-xlate.c	/^    struct ofport_dpif *ofport;      \/* Key in global 'xports map. *\/$/;"	m	struct:xport	typeref:struct:xport::ofport_dpif	file:
ofport	.\ofproto\ofproto-provider.h	/^struct ofport {$/;"	s
ofport	.\ofproto\ofproto.c	/^    struct ofport *ofport;$/;"	m	struct:queue_stats_cbdata	typeref:struct:queue_stats_cbdata::ofport	file:
ofport	.\ofproto\tunnel.c	/^    const struct ofport_dpif *ofport;$/;"	m	struct:tnl_port	typeref:struct:tnl_port::ofport_dpif	file:
ofport_destroy	.\ofproto\ofproto.c	/^ofport_destroy(struct ofport *port)$/;"	f	file:
ofport_destroy__	.\ofproto\ofproto.c	/^ofport_destroy__(struct ofport *port)$/;"	f	file:
ofport_dpif	.\ofproto\ofproto-dpif.c	/^struct ofport_dpif {$/;"	s	file:
ofport_dpif_cast	.\ofproto\ofproto-dpif.c	/^ofport_dpif_cast(const struct ofport *ofport)$/;"	f	file:
ofport_equal	.\ofproto\ofproto.c	/^ofport_equal(const struct ofputil_phy_port *a,$/;"	f	file:
ofport_get_usage	.\ofproto\ofproto.c	/^ofport_get_usage(const struct ofproto *ofproto, ofp_port_t ofp_port)$/;"	f	file:
ofport_install	.\ofproto\ofproto.c	/^ofport_install(struct ofproto *p,$/;"	f	file:
ofport_map__	.\ofproto\tunnel.c	/^static struct hmap ofport_map__ = HMAP_INITIALIZER(&ofport_map__);$/;"	v	typeref:struct:hmap	file:
ofport_modified	.\ofproto\ofproto.c	/^ofport_modified(struct ofport *port, struct ofputil_phy_port *pp)$/;"	f	file:
ofport_node	.\ofproto\tunnel.c	/^    struct hmap_node ofport_node;$/;"	m	struct:tnl_port	typeref:struct:tnl_port::hmap_node	file:
ofport_open	.\ofproto\ofproto.c	/^ofport_open(struct ofproto *ofproto,$/;"	f	file:
ofport_remove	.\ofproto\ofproto.c	/^ofport_remove(struct ofport *ofport)$/;"	f	file:
ofport_remove_usage	.\ofproto\ofproto.c	/^ofport_remove_usage(struct ofproto *ofproto, ofp_port_t ofp_port)$/;"	f	file:
ofport_remove_with_name	.\ofproto\ofproto.c	/^ofport_remove_with_name(struct ofproto *ofproto, const char *name)$/;"	f	file:
ofport_request	.\lib\vswitch-idl.h	/^	int64_t *ofport_request;$/;"	m	struct:ovsrec_interface
ofport_set_usage	.\ofproto\ofproto.c	/^ofport_set_usage(struct ofproto *ofproto, ofp_port_t ofp_port,$/;"	f	file:
ofport_update_peer	.\ofproto\ofproto-dpif.c	/^ofport_update_peer(struct ofport_dpif *ofport)$/;"	f	file:
ofport_usage	.\ofproto\ofproto-provider.h	/^    struct hmap ofport_usage;   \/* Map ofport to last used time. *\/$/;"	m	struct:ofproto	typeref:struct:ofproto::hmap
ofport_usage	.\ofproto\ofproto.c	/^struct ofport_usage {$/;"	s	file:
ofpp_none_bundle	.\ofproto\ofproto-dpif-xlate.c	/^static struct xbundle ofpp_none_bundle = {$/;"	v	typeref:struct:xbundle	file:
ofpraw	.\lib\ofp-msgs.h	/^enum ofpraw {$/;"	g
ofpraw_alloc	.\lib\ofp-msgs.c	/^ofpraw_alloc(enum ofpraw raw, uint8_t version, size_t extra_tailroom)$/;"	f
ofpraw_alloc_reply	.\lib\ofp-msgs.c	/^ofpraw_alloc_reply(enum ofpraw raw, const struct ofp_header *request,$/;"	f
ofpraw_alloc_stats_reply	.\lib\ofp-msgs.c	/^ofpraw_alloc_stats_reply(const struct ofp_header *request,$/;"	f
ofpraw_alloc_xid	.\lib\ofp-msgs.c	/^ofpraw_alloc_xid(enum ofpraw raw, uint8_t version, ovs_be32 xid,$/;"	f
ofpraw_decode	.\lib\ofp-msgs.c	/^ofpraw_decode(enum ofpraw *raw, const struct ofp_header *oh)$/;"	f
ofpraw_decode_assert	.\lib\ofp-msgs.c	/^ofpraw_decode_assert(const struct ofp_header *oh)$/;"	f
ofpraw_decode_partial	.\lib\ofp-msgs.c	/^ofpraw_decode_partial(enum ofpraw *raw,$/;"	f
ofpraw_from_ofphdrs	.\lib\ofp-msgs.c	/^ofpraw_from_ofphdrs(enum ofpraw *raw, const struct ofphdrs *hdrs)$/;"	f	file:
ofpraw_get_name	.\lib\ofp-msgs.c	/^ofpraw_get_name(enum ofpraw raw)$/;"	f
ofpraw_pull	.\lib\ofp-msgs.c	/^ofpraw_pull(enum ofpraw *rawp, struct ofpbuf *msg)$/;"	f
ofpraw_pull_assert	.\lib\ofp-msgs.c	/^ofpraw_pull_assert(struct ofpbuf *msg)$/;"	f
ofpraw_put	.\lib\ofp-msgs.c	/^ofpraw_put(enum ofpraw raw, uint8_t version, struct ofpbuf *buf)$/;"	f
ofpraw_put__	.\lib\ofp-msgs.c	/^ofpraw_put__(enum ofpraw raw, uint8_t version, ovs_be32 xid,$/;"	f	file:
ofpraw_put_reply	.\lib\ofp-msgs.c	/^ofpraw_put_reply(enum ofpraw raw, const struct ofp_header *request,$/;"	f
ofpraw_put_stats_reply	.\lib\ofp-msgs.c	/^ofpraw_put_stats_reply(const struct ofp_header *request, struct ofpbuf *buf)$/;"	f
ofpraw_put_xid	.\lib\ofp-msgs.c	/^ofpraw_put_xid(enum ofpraw raw, uint8_t version, ovs_be32 xid,$/;"	f
ofpraw_stats_request_to_reply	.\lib\ofp-msgs.c	/^ofpraw_stats_request_to_reply(enum ofpraw raw, uint8_t version)$/;"	f
ofproto	.\ofproto\bond.c	/^    struct ofproto_dpif *ofproto; \/* The bridge this bond belongs to. *\/$/;"	m	struct:bond	typeref:struct:bond::ofproto_dpif	file:
ofproto	.\ofproto\connmgr.c	/^    struct ofproto *ofproto;$/;"	m	struct:connmgr	typeref:struct:connmgr::ofproto	file:
ofproto	.\ofproto\fail-open.c	/^    struct ofproto *ofproto;$/;"	m	struct:fail_open	typeref:struct:fail_open::ofproto	file:
ofproto	.\ofproto\in-band.c	/^    struct ofproto *ofproto;$/;"	m	struct:in_band	typeref:struct:in_band::ofproto	file:
ofproto	.\ofproto\ofproto-dpif-upcall.c	/^    struct ofproto_dpif *ofproto;$/;"	m	struct:flow_miss	typeref:struct:flow_miss::ofproto_dpif	file:
ofproto	.\ofproto\ofproto-dpif-xlate.c	/^            struct ofproto_dpif *ofproto;$/;"	m	struct:xc_entry::__anon136::__anon141	typeref:struct:xc_entry::__anon136::__anon141::ofproto_dpif	file:
ofproto	.\ofproto\ofproto-dpif-xlate.c	/^            struct ofproto_dpif *ofproto;$/;"	m	struct:xc_entry::__anon136::__anon142	typeref:struct:xc_entry::__anon136::__anon142::ofproto_dpif	file:
ofproto	.\ofproto\ofproto-dpif-xlate.c	/^    struct ofproto_dpif *ofproto; \/* Key in global 'xbridges' map. *\/$/;"	m	struct:xbridge	typeref:struct:xbridge::ofproto_dpif	file:
ofproto	.\ofproto\ofproto-dpif-xlate.h	/^    struct ofproto_dpif *ofproto;$/;"	m	struct:xlate_in	typeref:struct:xlate_in::ofproto_dpif
ofproto	.\ofproto\ofproto-dpif.c	/^    struct ofproto_dpif *ofproto; \/* Owning ofproto. *\/$/;"	m	struct:ofbundle	typeref:struct:ofbundle::ofproto_dpif	file:
ofproto	.\ofproto\ofproto-provider.h	/^    struct ofproto *const ofproto; \/* The ofproto that contains this rule. *\/$/;"	m	struct:rule
ofproto	.\ofproto\ofproto-provider.h	/^    struct ofproto *ofproto;    \/* The ofproto that contains this group. *\/$/;"	m	struct:ofgroup	typeref:struct:ofgroup::ofproto
ofproto	.\ofproto\ofproto-provider.h	/^    struct ofproto *ofproto;    \/* The ofproto that contains this port. *\/$/;"	m	struct:ofport	typeref:struct:ofport::ofproto
ofproto	.\ofproto\ofproto-provider.h	/^struct ofproto {$/;"	s
ofproto	.\ofproto\ofproto.c	/^    struct ofproto *ofproto;    \/* Owning ofproto. *\/$/;"	m	struct:ofopgroup	typeref:struct:ofopgroup::ofproto	file:
ofproto	.\ofproto\ofproto.c	/^VLOG_DEFINE_THIS_MODULE(ofproto);$/;"	v
ofproto	.\ofproto\ofproto.h	/^    const struct ofproto *ofproto;$/;"	m	struct:ofproto_port_dump	typeref:struct:ofproto_port_dump::ofproto
ofproto	.\vswitchd\bridge.c	/^    struct ofproto *ofproto;    \/* OpenFlow switch. *\/$/;"	m	struct:bridge	typeref:struct:bridge::ofproto	file:
ofproto_band	.\ofproto\ofproto.h	/^enum ofproto_band {$/;"	g
ofproto_bundle_register	.\ofproto\ofproto.c	/^ofproto_bundle_register(struct ofproto *ofproto, void *aux,$/;"	f
ofproto_bundle_settings	.\ofproto\ofproto.h	/^struct ofproto_bundle_settings {$/;"	s
ofproto_bundle_unregister	.\ofproto\ofproto.c	/^ofproto_bundle_unregister(struct ofproto *ofproto, void *aux)$/;"	f
ofproto_cfm_status	.\ofproto\ofproto.h	/^struct ofproto_cfm_status {$/;"	s
ofproto_check_ofpacts	.\ofproto\ofproto.c	/^ofproto_check_ofpacts(struct ofproto *ofproto,$/;"	f	file:
ofproto_class	.\ofproto\ofproto-provider.h	/^    const struct ofproto_class *ofproto_class;$/;"	m	struct:ofproto	typeref:struct:ofproto::ofproto_class
ofproto_class	.\ofproto\ofproto-provider.h	/^struct ofproto_class {$/;"	s
ofproto_class_find__	.\ofproto\ofproto.c	/^ofproto_class_find__(const char *type)$/;"	f	file:
ofproto_class_register	.\ofproto\ofproto.c	/^ofproto_class_register(const struct ofproto_class *new_class)$/;"	f
ofproto_class_unregister	.\ofproto\ofproto.c	/^ofproto_class_unregister(const struct ofproto_class *class)$/;"	f
ofproto_classes	.\ofproto\ofproto.c	/^static const struct ofproto_class **ofproto_classes;$/;"	v	typeref:struct:ofproto_class	file:
ofproto_configure_table	.\ofproto\ofproto.c	/^ofproto_configure_table(struct ofproto *ofproto, int table_id,$/;"	f
ofproto_controller	.\ofproto\ofproto.h	/^struct ofproto_controller {$/;"	s
ofproto_controller_info	.\ofproto\ofproto.h	/^struct ofproto_controller_info {$/;"	s
ofproto_create	.\ofproto\ofproto.c	/^ofproto_create(const char *datapath_name, const char *datapath_type,$/;"	f
ofproto_delete	.\ofproto\ofproto.c	/^ofproto_delete(const char *name, const char *type)$/;"	f
ofproto_dpif	.\ofproto\ofproto-dpif.c	/^VLOG_DEFINE_THIS_MODULE(ofproto_dpif);$/;"	v
ofproto_dpif	.\ofproto\ofproto-dpif.c	/^struct ofproto_dpif {$/;"	s	file:
ofproto_dpif_add_internal_flow	.\ofproto\ofproto-dpif.c	/^ofproto_dpif_add_internal_flow(struct ofproto_dpif *ofproto,$/;"	f
ofproto_dpif_alloc_recirc_id	.\ofproto\ofproto-dpif.c	/^ofproto_dpif_alloc_recirc_id(struct ofproto_dpif *ofproto)$/;"	f
ofproto_dpif_cast	.\ofproto\ofproto-dpif.c	/^ofproto_dpif_cast(const struct ofproto *ofproto)$/;"	f	file:
ofproto_dpif_class	.\ofproto\ofproto-dpif.c	/^const struct ofproto_class ofproto_dpif_class = {$/;"	v	typeref:struct:ofproto_class
ofproto_dpif_contains_flow	.\ofproto\ofproto-dpif.c	/^ofproto_dpif_contains_flow(const struct ofproto_dpif *ofproto,$/;"	f	file:
ofproto_dpif_delete_internal_flow	.\ofproto\ofproto-dpif.c	/^ofproto_dpif_delete_internal_flow(struct ofproto_dpif *ofproto,$/;"	f
ofproto_dpif_execute_actions	.\ofproto\ofproto-dpif.c	/^ofproto_dpif_execute_actions(struct ofproto_dpif *ofproto,$/;"	f
ofproto_dpif_expired	.\ofproto\ofproto-dpif.c	/^COVERAGE_DEFINE(ofproto_dpif_expired);$/;"	v
ofproto_dpif_flow_mod	.\ofproto\ofproto-dpif.c	/^ofproto_dpif_flow_mod(struct ofproto_dpif *ofproto,$/;"	f
ofproto_dpif_free_recirc_id	.\ofproto\ofproto-dpif.c	/^ofproto_dpif_free_recirc_id(struct ofproto_dpif *ofproto, uint32_t recirc_id)$/;"	f
ofproto_dpif_get_enable_recirc	.\ofproto\ofproto-dpif.c	/^ofproto_dpif_get_enable_recirc(const struct ofproto_dpif *ofproto)$/;"	f
ofproto_dpif_get_max_mpls_depth	.\ofproto\ofproto-dpif.c	/^ofproto_dpif_get_max_mpls_depth(const struct ofproto_dpif *ofproto)$/;"	f
ofproto_dpif_lookup	.\ofproto\ofproto-dpif.c	/^ofproto_dpif_lookup(const char *name)$/;"	f	file:
ofproto_dpif_mirror	.\ofproto\ofproto-dpif-mirror.c	/^VLOG_DEFINE_THIS_MODULE(ofproto_dpif_mirror);$/;"	v
ofproto_dpif_monitor	.\ofproto\ofproto-dpif-monitor.c	/^VLOG_DEFINE_THIS_MODULE(ofproto_dpif_monitor);$/;"	v
ofproto_dpif_monitor_port_send_soon	.\ofproto\ofproto-dpif-monitor.c	/^ofproto_dpif_monitor_port_send_soon(const struct ofport_dpif *ofport)$/;"	f
ofproto_dpif_monitor_port_update	.\ofproto\ofproto-dpif-monitor.c	/^ofproto_dpif_monitor_port_update(const struct ofport_dpif *ofport,$/;"	f
ofproto_dpif_send_packet	.\ofproto\ofproto-dpif.c	/^ofproto_dpif_send_packet(const struct ofport_dpif *ofport, struct ofpbuf *packet)$/;"	f
ofproto_dpif_send_packet_in	.\ofproto\ofproto-dpif.c	/^ofproto_dpif_send_packet_in(struct ofproto_dpif *ofproto,$/;"	f
ofproto_dpif_unixctl_init	.\ofproto\ofproto-dpif.c	/^ofproto_dpif_unixctl_init(void)$/;"	f	file:
ofproto_dpif_upcall	.\ofproto\ofproto-dpif-upcall.c	/^VLOG_DEFINE_THIS_MODULE(ofproto_dpif_upcall);$/;"	v
ofproto_dpif_wants_packet_in_on_miss	.\ofproto\ofproto-dpif.c	/^ofproto_dpif_wants_packet_in_on_miss(struct ofproto_dpif *ofproto)$/;"	f
ofproto_dpif_xlate	.\ofproto\ofproto-dpif-xlate.c	/^VLOG_DEFINE_THIS_MODULE(ofproto_dpif_xlate);$/;"	v
ofproto_enumerate_names	.\ofproto\ofproto.c	/^ofproto_enumerate_names(const char *type, struct sset *names)$/;"	f
ofproto_enumerate_types	.\ofproto\ofproto.c	/^ofproto_enumerate_types(struct sset *types)$/;"	f
ofproto_evict	.\ofproto\ofproto.c	/^ofproto_evict(struct ofproto *ofproto)$/;"	f	file:
ofproto_fail_mode	.\ofproto\ofproto.h	/^enum ofproto_fail_mode {$/;"	g
ofproto_flow_limit	.\ofproto\ofproto.c	/^unsigned ofproto_flow_limit = OFPROTO_FLOW_LIMIT_DEFAULT;$/;"	v
ofproto_flush	.\ofproto\ofproto.c	/^COVERAGE_DEFINE(ofproto_flush);$/;"	v
ofproto_flush_flows	.\ofproto\ofproto.c	/^ofproto_flush_flows(struct ofproto *ofproto)$/;"	f
ofproto_free_ofproto_controller_info	.\ofproto\ofproto.c	/^ofproto_free_ofproto_controller_info(struct shash *info)$/;"	f
ofproto_get_all_flows	.\ofproto\ofproto.c	/^ofproto_get_all_flows(struct ofproto *p, struct ds *results)$/;"	f
ofproto_get_datapath_id	.\ofproto\ofproto.c	/^ofproto_get_datapath_id(const struct ofproto *ofproto)$/;"	f
ofproto_get_flow_restore_wait	.\ofproto\ofproto.c	/^ofproto_get_flow_restore_wait(void)$/;"	f
ofproto_get_memory_usage	.\ofproto\ofproto.c	/^ofproto_get_memory_usage(const struct ofproto *ofproto, struct simap *usage)$/;"	f
ofproto_get_n_tables	.\ofproto\ofproto.c	/^ofproto_get_n_tables(const struct ofproto *ofproto)$/;"	f
ofproto_get_n_visible_tables	.\ofproto\ofproto.c	/^ofproto_get_n_visible_tables(const struct ofproto *ofproto)$/;"	f
ofproto_get_netflow_ids	.\ofproto\ofproto.c	/^ofproto_get_netflow_ids(const struct ofproto *ofproto,$/;"	f
ofproto_get_ofproto_controller_info	.\ofproto\ofproto.c	/^ofproto_get_ofproto_controller_info(const struct ofproto *ofproto,$/;"	f
ofproto_get_port	.\ofproto\ofproto.c	/^ofproto_get_port(const struct ofproto *ofproto, ofp_port_t ofp_port)$/;"	f
ofproto_get_snoops	.\ofproto\ofproto.c	/^ofproto_get_snoops(const struct ofproto *ofproto, struct sset *snoops)$/;"	f
ofproto_get_stp_status	.\ofproto\ofproto.c	/^ofproto_get_stp_status(struct ofproto *ofproto,$/;"	f
ofproto_get_vlan_usage	.\ofproto\ofproto.c	/^ofproto_get_vlan_usage(struct ofproto *ofproto, unsigned long int *vlan_bitmap)$/;"	f
ofproto_has_snoops	.\ofproto\ofproto.c	/^ofproto_has_snoops(const struct ofproto *ofproto)$/;"	f
ofproto_has_vlan_usage_changed	.\ofproto\ofproto.c	/^ofproto_has_vlan_usage_changed(const struct ofproto *ofproto)$/;"	f
ofproto_init	.\ofproto\ofproto.c	/^ofproto_init(const struct shash *iface_hints)$/;"	f
ofproto_init_max_ports	.\ofproto\ofproto.c	/^ofproto_init_max_ports(struct ofproto *ofproto, uint16_t max_ports)$/;"	f
ofproto_init_tables	.\ofproto\ofproto.c	/^ofproto_init_tables(struct ofproto *ofproto, int n_tables)$/;"	f
ofproto_ipfix_bridge_exporter_options	.\ofproto\ofproto.h	/^struct ofproto_ipfix_bridge_exporter_options {$/;"	s
ofproto_ipfix_bridge_exporter_options_clone	.\ofproto\ofproto-dpif-ipfix.c	/^ofproto_ipfix_bridge_exporter_options_clone($/;"	f	file:
ofproto_ipfix_bridge_exporter_options_destroy	.\ofproto\ofproto-dpif-ipfix.c	/^ofproto_ipfix_bridge_exporter_options_destroy($/;"	f	file:
ofproto_ipfix_bridge_exporter_options_equal	.\ofproto\ofproto-dpif-ipfix.c	/^ofproto_ipfix_bridge_exporter_options_equal($/;"	f	file:
ofproto_ipfix_flow_exporter_options	.\ofproto\ofproto.h	/^struct ofproto_ipfix_flow_exporter_options {$/;"	s
ofproto_ipfix_flow_exporter_options_clone	.\ofproto\ofproto-dpif-ipfix.c	/^ofproto_ipfix_flow_exporter_options_clone($/;"	f	file:
ofproto_ipfix_flow_exporter_options_destroy	.\ofproto\ofproto-dpif-ipfix.c	/^ofproto_ipfix_flow_exporter_options_destroy($/;"	f	file:
ofproto_ipfix_flow_exporter_options_equal	.\ofproto\ofproto-dpif-ipfix.c	/^ofproto_ipfix_flow_exporter_options_equal($/;"	f	file:
ofproto_is_alive	.\ofproto\ofproto.c	/^ofproto_is_alive(const struct ofproto *p)$/;"	f
ofproto_is_mirror_output_bundle	.\ofproto\ofproto.c	/^ofproto_is_mirror_output_bundle(const struct ofproto *ofproto, void *aux)$/;"	f
ofproto_libofproto_la_CFLAGS	.\ofproto\automake.mk	/^ofproto_libofproto_la_CFLAGS = $(AM_CFLAGS)$/;"	m
ofproto_libofproto_la_CPPFLAGS	.\ofproto\automake.mk	/^ofproto_libofproto_la_CPPFLAGS = $(AM_CPPFLAGS)$/;"	m
ofproto_libofproto_la_LDFLAGS	.\ofproto\automake.mk	/^ofproto_libofproto_la_LDFLAGS = -release $(VERSION)$/;"	m
ofproto_libofproto_la_LIBADD	.\ofproto\automake.mk	/^ofproto_libofproto_la_LIBADD = lib\/libsflow.la$/;"	m
ofproto_libofproto_la_SOURCES	.\ofproto\automake.mk	/^ofproto_libofproto_la_SOURCES = \\$/;"	m
ofproto_lookup	.\ofproto\ofproto.c	/^ofproto_lookup(const char *name)$/;"	f
ofproto_max_idle	.\ofproto\ofproto.c	/^unsigned ofproto_max_idle = OFPROTO_MAX_IDLE_DEFAULT;$/;"	v
ofproto_meter_id	.\lib\ofp-util.h	/^typedef struct { uint32_t uint32; } ofproto_meter_id;$/;"	t	typeref:struct:__anon77
ofproto_mirror_get_stats	.\ofproto\ofproto.c	/^ofproto_mirror_get_stats(struct ofproto *ofproto, void *aux,$/;"	f
ofproto_mirror_register	.\ofproto\ofproto.c	/^ofproto_mirror_register(struct ofproto *ofproto, void *aux,$/;"	f
ofproto_mirror_settings	.\ofproto\ofproto.h	/^struct ofproto_mirror_settings {$/;"	s
ofproto_mirror_unregister	.\ofproto\ofproto.c	/^ofproto_mirror_unregister(struct ofproto *ofproto, void *aux)$/;"	f
ofproto_mutex	.\ofproto\connmgr.c	/^    OVS_REQUIRES(ofproto_mutex);$/;"	v
ofproto_mutex	.\ofproto\connmgr.c	/^static void ofconn_destroy(struct ofconn *) OVS_REQUIRES(ofproto_mutex);$/;"	v
ofproto_mutex	.\ofproto\connmgr.c	/^static void ofconn_flush(struct ofconn *) OVS_REQUIRES(ofproto_mutex);$/;"	v
ofproto_mutex	.\ofproto\connmgr.c	/^static void update_fail_open(struct connmgr *) OVS_EXCLUDED(ofproto_mutex);$/;"	v
ofproto_mutex	.\ofproto\connmgr.h	/^    OVS_REQUIRES(ofproto_mutex);$/;"	v
ofproto_mutex	.\ofproto\connmgr.h	/^void ofmonitor_flush(struct connmgr *) OVS_REQUIRES(ofproto_mutex);$/;"	v
ofproto_mutex	.\ofproto\fail-open.h	/^void fail_open_destroy(struct fail_open *) OVS_EXCLUDED(ofproto_mutex);$/;"	v
ofproto_mutex	.\ofproto\fail-open.h	/^void fail_open_flushed(struct fail_open *) OVS_EXCLUDED(ofproto_mutex);$/;"	v
ofproto_mutex	.\ofproto\fail-open.h	/^void fail_open_maybe_recover(struct fail_open *) OVS_EXCLUDED(ofproto_mutex);$/;"	v
ofproto_mutex	.\ofproto\ofproto-provider.h	/^    OVS_EXCLUDED(ofproto_mutex);$/;"	v
ofproto_mutex	.\ofproto\ofproto-provider.h	/^    OVS_REQUIRES(ofproto_mutex);$/;"	v
ofproto_mutex	.\ofproto\ofproto-provider.h	/^void rule_collection_ref(struct rule_collection *) OVS_REQUIRES(ofproto_mutex);$/;"	v
ofproto_mutex	.\ofproto\ofproto.c	/^    OVS_EXCLUDED(ofproto_mutex);$/;"	v
ofproto_mutex	.\ofproto\ofproto.c	/^    OVS_REQUIRES(ofproto_mutex);$/;"	v
ofproto_mutex	.\ofproto\ofproto.c	/^static void ofport_destroy__(struct ofport *) OVS_EXCLUDED(ofproto_mutex);$/;"	v
ofproto_mutex	.\ofproto\ofproto.c	/^static void ofproto_evict(struct ofproto *) OVS_EXCLUDED(ofproto_mutex);$/;"	v
ofproto_mutex	.\ofproto\ofproto.c	/^static void oftable_remove_rule(struct rule *rule) OVS_REQUIRES(ofproto_mutex);$/;"	v
ofproto_mutex	.\ofproto\ofproto.c	/^static void run_rule_executes(struct ofproto *) OVS_EXCLUDED(ofproto_mutex);$/;"	v
ofproto_mutex	.\ofproto\ofproto.c	/^struct ovs_mutex ofproto_mutex = OVS_MUTEX_INITIALIZER;$/;"	v	typeref:struct:ovs_mutex
ofproto_node	.\ofproto\ofproto.c	/^    struct list ofproto_node;   \/* In ofproto's "pending" list. *\/$/;"	m	struct:ofopgroup	typeref:struct:ofopgroup::list	file:
ofproto_normalize_type	.\ofproto\ofproto.c	/^ofproto_normalize_type(const char *type)$/;"	f
ofproto_packet_in	.\ofproto\connmgr.h	/^struct ofproto_packet_in {$/;"	s
ofproto_packet_in_miss_type	.\ofproto\connmgr.h	/^enum ofproto_packet_in_miss_type {$/;"	g
ofproto_packet_out	.\ofproto\ofproto.c	/^COVERAGE_DEFINE(ofproto_packet_out);$/;"	v
ofproto_parse_name	.\ofproto\names.c	/^ofproto_parse_name(const char *ofproto_name, char **name, char **type)$/;"	f
ofproto_port	.\ofproto\ofproto.h	/^struct ofproto_port {$/;"	s
ofproto_port_add	.\ofproto\ofproto.c	/^ofproto_port_add(struct ofproto *ofproto, struct netdev *netdev,$/;"	f
ofproto_port_clear_cfm	.\ofproto\ofproto.c	/^ofproto_port_clear_cfm(struct ofproto *ofproto, ofp_port_t ofp_port)$/;"	f
ofproto_port_clone	.\ofproto\ofproto.c	/^ofproto_port_clone(struct ofproto_port *port, const struct ofproto_port *old)$/;"	f
ofproto_port_del	.\ofproto\ofproto.c	/^ofproto_port_del(struct ofproto *ofproto, ofp_port_t ofp_port)$/;"	f
ofproto_port_destroy	.\ofproto\ofproto.c	/^ofproto_port_destroy(struct ofproto_port *ofproto_port)$/;"	f
ofproto_port_dump	.\ofproto\ofproto.h	/^struct ofproto_port_dump {$/;"	s
ofproto_port_dump_done	.\ofproto\ofproto.c	/^ofproto_port_dump_done(struct ofproto_port_dump *dump)$/;"	f
ofproto_port_dump_next	.\ofproto\ofproto.c	/^ofproto_port_dump_next(struct ofproto_port_dump *dump,$/;"	f
ofproto_port_dump_start	.\ofproto\ofproto.c	/^ofproto_port_dump_start(struct ofproto_port_dump *dump,$/;"	f
ofproto_port_from_dpif_port	.\ofproto\ofproto-dpif.c	/^ofproto_port_from_dpif_port(struct ofproto_dpif *ofproto,$/;"	f	file:
ofproto_port_get_bfd_status	.\ofproto\ofproto.c	/^ofproto_port_get_bfd_status(struct ofproto *ofproto, ofp_port_t ofp_port,$/;"	f
ofproto_port_get_cfm_status	.\ofproto\ofproto.c	/^ofproto_port_get_cfm_status(const struct ofproto *ofproto, ofp_port_t ofp_port,$/;"	f
ofproto_port_get_stats	.\ofproto\ofproto.c	/^ofproto_port_get_stats(const struct ofport *port, struct netdev_stats *stats)$/;"	f
ofproto_port_get_stp_stats	.\ofproto\ofproto.c	/^ofproto_port_get_stp_stats(struct ofproto *ofproto, ofp_port_t ofp_port,$/;"	f
ofproto_port_get_stp_status	.\ofproto\ofproto.c	/^ofproto_port_get_stp_status(struct ofproto *ofproto, ofp_port_t ofp_port,$/;"	f
ofproto_port_is_lacp_current	.\ofproto\ofproto.c	/^ofproto_port_is_lacp_current(struct ofproto *ofproto, ofp_port_t ofp_port)$/;"	f
ofproto_port_open_type	.\ofproto\ofproto.c	/^ofproto_port_open_type(const char *datapath_type, const char *port_type)$/;"	f
ofproto_port_query_by_name	.\ofproto\ofproto.c	/^ofproto_port_query_by_name(const struct ofproto *ofproto, const char *devname,$/;"	f
ofproto_port_queue	.\ofproto\ofproto.h	/^struct ofproto_port_queue {$/;"	s
ofproto_port_set_bfd	.\ofproto\ofproto.c	/^ofproto_port_set_bfd(struct ofproto *ofproto, ofp_port_t ofp_port,$/;"	f
ofproto_port_set_cfm	.\ofproto\ofproto.c	/^ofproto_port_set_cfm(struct ofproto *ofproto, ofp_port_t ofp_port,$/;"	f
ofproto_port_set_queues	.\ofproto\ofproto.c	/^ofproto_port_set_queues(struct ofproto *ofproto, ofp_port_t ofp_port,$/;"	f
ofproto_port_set_realdev	.\ofproto\ofproto.c	/^ofproto_port_set_realdev(struct ofproto *ofproto, ofp_port_t vlandev_ofp_port,$/;"	f
ofproto_port_set_state	.\ofproto\ofproto.c	/^ofproto_port_set_state(struct ofport *port, enum ofputil_port_state state)$/;"	f
ofproto_port_set_stp	.\ofproto\ofproto.c	/^ofproto_port_set_stp(struct ofproto *ofproto, ofp_port_t ofp_port,$/;"	f
ofproto_port_stp_settings	.\ofproto\ofproto.h	/^struct ofproto_port_stp_settings {$/;"	s
ofproto_port_stp_stats	.\ofproto\ofproto.h	/^struct ofproto_port_stp_stats {$/;"	s
ofproto_port_stp_status	.\ofproto\ofproto.h	/^struct ofproto_port_stp_status {$/;"	s
ofproto_port_unregister	.\ofproto\ofproto.c	/^ofproto_port_unregister(struct ofproto *ofproto, ofp_port_t ofp_port)$/;"	f
ofproto_queue_req	.\ofproto\ofproto.c	/^COVERAGE_DEFINE(ofproto_queue_req);$/;"	v
ofproto_reconnect_controllers	.\ofproto\ofproto.c	/^ofproto_reconnect_controllers(struct ofproto *ofproto)$/;"	f
ofproto_recv_openflow	.\ofproto\ofproto.c	/^COVERAGE_DEFINE(ofproto_recv_openflow);$/;"	v
ofproto_reinit_ports	.\ofproto\ofproto.c	/^COVERAGE_DEFINE(ofproto_reinit_ports);$/;"	v
ofproto_rule_is_hidden	.\ofproto\ofproto.c	/^ofproto_rule_is_hidden(const struct rule *rule)$/;"	f	file:
ofproto_rule_ref	.\ofproto\ofproto.c	/^ofproto_rule_ref(struct rule *rule)$/;"	f
ofproto_rule_unref	.\ofproto\ofproto.c	/^ofproto_rule_unref(struct rule *rule)$/;"	f
ofproto_run	.\ofproto\ofproto.c	/^ofproto_run(struct ofproto *p)$/;"	f
ofproto_set_controllers	.\ofproto\ofproto.c	/^ofproto_set_controllers(struct ofproto *p,$/;"	f
ofproto_set_datapath_id	.\ofproto\ofproto.c	/^ofproto_set_datapath_id(struct ofproto *p, uint64_t datapath_id)$/;"	f
ofproto_set_dp_desc	.\ofproto\ofproto.c	/^ofproto_set_dp_desc(struct ofproto *p, const char *dp_desc)$/;"	f
ofproto_set_extra_in_band_remotes	.\ofproto\ofproto.c	/^ofproto_set_extra_in_band_remotes(struct ofproto *ofproto,$/;"	f
ofproto_set_fail_mode	.\ofproto\ofproto.c	/^ofproto_set_fail_mode(struct ofproto *p, enum ofproto_fail_mode fail_mode)$/;"	f
ofproto_set_flood_vlans	.\ofproto\ofproto.c	/^ofproto_set_flood_vlans(struct ofproto *ofproto, unsigned long *flood_vlans)$/;"	f
ofproto_set_flow_limit	.\ofproto\ofproto.c	/^ofproto_set_flow_limit(unsigned limit)$/;"	f
ofproto_set_flow_restore_wait	.\ofproto\ofproto.c	/^ofproto_set_flow_restore_wait(bool flow_restore_wait_db)$/;"	f
ofproto_set_forward_bpdu	.\ofproto\ofproto.c	/^ofproto_set_forward_bpdu(struct ofproto *ofproto, bool forward_bpdu)$/;"	f
ofproto_set_in_band_queue	.\ofproto\ofproto.c	/^ofproto_set_in_band_queue(struct ofproto *ofproto, int queue_id)$/;"	f
ofproto_set_ipfix	.\ofproto\ofproto.c	/^ofproto_set_ipfix(struct ofproto *ofproto,$/;"	f
ofproto_set_mac_table_config	.\ofproto\ofproto.c	/^ofproto_set_mac_table_config(struct ofproto *ofproto, unsigned idle_time,$/;"	f
ofproto_set_max_idle	.\ofproto\ofproto.c	/^ofproto_set_max_idle(unsigned max_idle)$/;"	f
ofproto_set_netflow	.\ofproto\ofproto.c	/^ofproto_set_netflow(struct ofproto *ofproto,$/;"	f
ofproto_set_sflow	.\ofproto\ofproto.c	/^ofproto_set_sflow(struct ofproto *ofproto,$/;"	f
ofproto_set_snoops	.\ofproto\ofproto.c	/^ofproto_set_snoops(struct ofproto *ofproto, const struct sset *snoops)$/;"	f
ofproto_set_stp	.\ofproto\ofproto.c	/^ofproto_set_stp(struct ofproto *ofproto,$/;"	f
ofproto_set_threads	.\ofproto\ofproto.c	/^ofproto_set_threads(int n_handlers_, int n_revalidators_)$/;"	f
ofproto_sflow_options	.\ofproto\ofproto.h	/^struct ofproto_sflow_options {$/;"	s
ofproto_sflow_options_clone	.\ofproto\ofproto-dpif-sflow.c	/^ofproto_sflow_options_clone(const struct ofproto_sflow_options *old)$/;"	f	file:
ofproto_sflow_options_destroy	.\ofproto\ofproto-dpif-sflow.c	/^ofproto_sflow_options_destroy(struct ofproto_sflow_options *options)$/;"	f	file:
ofproto_sflow_options_equal	.\ofproto\ofproto-dpif-sflow.c	/^ofproto_sflow_options_equal(const struct ofproto_sflow_options *a,$/;"	f	file:
ofproto_state	.\ofproto\ofproto.c	/^enum ofproto_state {$/;"	g	file:
ofproto_stp_settings	.\ofproto\ofproto.h	/^struct ofproto_stp_settings {$/;"	s
ofproto_stp_status	.\ofproto\ofproto.h	/^struct ofproto_stp_status {$/;"	s
ofproto_table_config	.\ofproto\ofproto.h	/^enum ofproto_table_config {$/;"	g
ofproto_table_get_config	.\ofproto\ofproto.c	/^ofproto_table_get_config(const struct ofproto *ofproto, uint8_t table_id)$/;"	f
ofproto_table_settings	.\ofproto\ofproto.h	/^struct ofproto_table_settings {$/;"	s
ofproto_trace	.\ofproto\ofproto-dpif.c	/^ofproto_trace(struct ofproto_dpif *ofproto, struct flow *flow,$/;"	f	file:
ofproto_type_get_memory_usage	.\ofproto\ofproto.c	/^ofproto_type_get_memory_usage(const char *datapath_type, struct simap *usage)$/;"	f
ofproto_type_run	.\ofproto\ofproto.c	/^ofproto_type_run(const char *datapath_type)$/;"	f
ofproto_type_wait	.\ofproto\ofproto.c	/^ofproto_type_wait(const char *datapath_type)$/;"	f
ofproto_unixctl_dpif_dump_dps	.\ofproto\ofproto-dpif.c	/^ofproto_unixctl_dpif_dump_dps(struct unixctl_conn *conn, int argc OVS_UNUSED,$/;"	f	file:
ofproto_unixctl_dpif_dump_flows	.\ofproto\ofproto-dpif.c	/^ofproto_unixctl_dpif_dump_flows(struct unixctl_conn *conn,$/;"	f	file:
ofproto_unixctl_dpif_show	.\ofproto\ofproto-dpif.c	/^ofproto_unixctl_dpif_show(struct unixctl_conn *conn, int argc OVS_UNUSED,$/;"	f	file:
ofproto_unixctl_fdb_flush	.\ofproto\ofproto-dpif.c	/^ofproto_unixctl_fdb_flush(struct unixctl_conn *conn, int argc,$/;"	f	file:
ofproto_unixctl_fdb_show	.\ofproto\ofproto-dpif.c	/^ofproto_unixctl_fdb_show(struct unixctl_conn *conn, int argc OVS_UNUSED,$/;"	f	file:
ofproto_unixctl_init	.\ofproto\ofproto.c	/^ofproto_unixctl_init(void)$/;"	f	file:
ofproto_unixctl_list	.\ofproto\ofproto.c	/^ofproto_unixctl_list(struct unixctl_conn *conn, int argc OVS_UNUSED,$/;"	f	file:
ofproto_unixctl_trace	.\ofproto\ofproto-dpif.c	/^ofproto_unixctl_trace(struct unixctl_conn *conn, int argc, const char *argv[],$/;"	f	file:
ofproto_unixctl_trace_actions	.\ofproto\ofproto-dpif.c	/^ofproto_unixctl_trace_actions(struct unixctl_conn *conn, int argc,$/;"	f	file:
ofproto_update_port	.\ofproto\ofproto.c	/^COVERAGE_DEFINE(ofproto_update_port);$/;"	v
ofproto_wait	.\ofproto\ofproto.c	/^ofproto_wait(struct ofproto *p)$/;"	f
ofptype	.\lib\ofp-msgs.h	/^enum ofptype {$/;"	g
ofptype_decode	.\lib\ofp-msgs.c	/^ofptype_decode(enum ofptype *typep, const struct ofp_header *oh)$/;"	f
ofptype_from_ofpraw	.\lib\ofp-msgs.c	/^ofptype_from_ofpraw(enum ofpraw raw)$/;"	f
ofptype_pull	.\lib\ofp-msgs.c	/^ofptype_pull(enum ofptype *typep, struct ofpbuf *buf)$/;"	f
ofputil_action_bit_translation	.\lib\ofp-util.c	/^struct ofputil_action_bit_translation {$/;"	s	file:
ofputil_action_bitmap	.\lib\ofp-util.h	/^enum ofputil_action_bitmap {$/;"	g
ofputil_action_bitmap_to_name	.\lib\ofp-print.c	/^ofputil_action_bitmap_to_name(uint32_t bit)$/;"	f	file:
ofputil_action_code	.\lib\ofp-util.h	/^enum OVS_PACKED_ENUM ofputil_action_code {$/;"	g
ofputil_action_code_from_name	.\lib\ofp-util.c	/^ofputil_action_code_from_name(const char *name)$/;"	f
ofputil_action_code_from_ofp13_action	.\lib\ofp-util.c	/^ofputil_action_code_from_ofp13_action(enum ofp13_action_type type)$/;"	f
ofputil_action_name_from_code	.\lib\ofp-util.c	/^ofputil_action_name_from_code(enum ofputil_action_code code)$/;"	f
ofputil_aggregate_stats	.\lib\ofp-util.h	/^struct ofputil_aggregate_stats {$/;"	s
ofputil_append_flow_monitor_request	.\lib\ofp-util.c	/^ofputil_append_flow_monitor_request($/;"	f
ofputil_append_flow_stats_reply	.\lib\ofp-util.c	/^ofputil_append_flow_stats_reply(const struct ofputil_flow_stats *fs,$/;"	f
ofputil_append_flow_update	.\lib\ofp-util.c	/^ofputil_append_flow_update(const struct ofputil_flow_update *update,$/;"	f
ofputil_append_group_desc_reply	.\lib\ofp-util.c	/^ofputil_append_group_desc_reply(const struct ofputil_group_desc *gds,$/;"	f
ofputil_append_group_stats	.\lib\ofp-util.c	/^ofputil_append_group_stats(struct list *replies,$/;"	f
ofputil_append_meter_config	.\lib\ofp-util.c	/^ofputil_append_meter_config(struct list *replies,$/;"	f
ofputil_append_meter_stats	.\lib\ofp-util.c	/^ofputil_append_meter_stats(struct list *replies,$/;"	f
ofputil_append_ofp14_port_stats	.\lib\ofp-util.c	/^ofputil_append_ofp14_port_stats(const struct ofputil_port_stats *ops,$/;"	f	file:
ofputil_append_port_desc_stats_reply	.\lib\ofp-util.c	/^ofputil_append_port_desc_stats_reply(const struct ofputil_phy_port *pp,$/;"	f
ofputil_append_port_stat	.\lib\ofp-util.c	/^ofputil_append_port_stat(struct list *replies,$/;"	f
ofputil_append_queue_get_config_reply	.\lib\ofp-util.c	/^ofputil_append_queue_get_config_reply(struct ofpbuf *reply,$/;"	f
ofputil_append_queue_stat	.\lib\ofp-util.c	/^ofputil_append_queue_stat(struct list *replies,$/;"	f
ofputil_bit	.\lib\ofp-util.c	/^    enum ofputil_action_bitmap ofputil_bit;$/;"	m	struct:ofputil_action_bit_translation	typeref:enum:ofputil_action_bit_translation::ofputil_action_bitmap	file:
ofputil_bucket	.\lib\ofp-util.h	/^struct ofputil_bucket {$/;"	s
ofputil_bucket_has_liveness	.\lib\ofp-util.h	/^ofputil_bucket_has_liveness(const struct ofputil_bucket *bucket)$/;"	f
ofputil_bucket_list_destroy	.\lib\ofp-util.c	/^ofputil_bucket_list_destroy(struct list *buckets)$/;"	f
ofputil_bundle_add_msg	.\lib\ofp-util.h	/^struct ofputil_bundle_add_msg {$/;"	s
ofputil_bundle_ctrl_msg	.\lib\ofp-util.h	/^struct ofputil_bundle_ctrl_msg {$/;"	s
ofputil_capabilities	.\lib\ofp-util.h	/^enum ofputil_capabilities {$/;"	g
ofputil_capabilities_mask	.\lib\ofp-util.c	/^ofputil_capabilities_mask(enum ofp_version ofp_version)$/;"	f	file:
ofputil_capabilities_to_name	.\lib\ofp-print.c	/^ofputil_capabilities_to_name(uint32_t bit)$/;"	f	file:
ofputil_count_port_stats	.\lib\ofp-util.c	/^ofputil_count_port_stats(const struct ofp_header *oh)$/;"	f
ofputil_count_queue_stats	.\lib\ofp-util.c	/^ofputil_count_queue_stats(const struct ofp_header *oh)$/;"	f
ofputil_decode_aggregate_stats_reply	.\lib\ofp-util.c	/^ofputil_decode_aggregate_stats_reply(struct ofputil_aggregate_stats *stats,$/;"	f
ofputil_decode_bundle_add	.\lib\ofp-util.c	/^ofputil_decode_bundle_add(const struct ofp_header *oh,$/;"	f
ofputil_decode_bundle_ctrl	.\lib\ofp-util.c	/^ofputil_decode_bundle_ctrl(const struct ofp_header *oh,$/;"	f
ofputil_decode_flow_mod	.\lib\ofp-util.c	/^ofputil_decode_flow_mod(struct ofputil_flow_mod *fm,$/;"	f
ofputil_decode_flow_mod_flags	.\lib\ofp-util.c	/^ofputil_decode_flow_mod_flags(ovs_be16 raw_flags_,$/;"	f	file:
ofputil_decode_flow_monitor_cancel	.\lib\ofp-util.c	/^ofputil_decode_flow_monitor_cancel(const struct ofp_header *oh)$/;"	f
ofputil_decode_flow_monitor_request	.\lib\ofp-util.c	/^ofputil_decode_flow_monitor_request(struct ofputil_flow_monitor_request *rq,$/;"	f
ofputil_decode_flow_removed	.\lib\ofp-util.c	/^ofputil_decode_flow_removed(struct ofputil_flow_removed *fr,$/;"	f
ofputil_decode_flow_stats_reply	.\lib\ofp-util.c	/^ofputil_decode_flow_stats_reply(struct ofputil_flow_stats *fs,$/;"	f
ofputil_decode_flow_stats_request	.\lib\ofp-util.c	/^ofputil_decode_flow_stats_request(struct ofputil_flow_stats_request *fsr,$/;"	f
ofputil_decode_flow_update	.\lib\ofp-util.c	/^ofputil_decode_flow_update(struct ofputil_flow_update *update,$/;"	f
ofputil_decode_group_desc_reply	.\lib\ofp-util.c	/^ofputil_decode_group_desc_reply(struct ofputil_group_desc *gd,$/;"	f
ofputil_decode_group_desc_request	.\lib\ofp-util.c	/^ofputil_decode_group_desc_request(const struct ofp_header *oh)$/;"	f
ofputil_decode_group_features_reply	.\lib\ofp-util.c	/^ofputil_decode_group_features_reply(const struct ofp_header *oh,$/;"	f
ofputil_decode_group_mod	.\lib\ofp-util.c	/^ofputil_decode_group_mod(const struct ofp_header *oh,$/;"	f
ofputil_decode_group_stats_reply	.\lib\ofp-util.c	/^ofputil_decode_group_stats_reply(struct ofpbuf *msg,$/;"	f
ofputil_decode_group_stats_request	.\lib\ofp-util.c	/^ofputil_decode_group_stats_request(const struct ofp_header *request,$/;"	f
ofputil_decode_hello	.\lib\ofp-util.c	/^ofputil_decode_hello(const struct ofp_header *oh, uint32_t *allowed_versions)$/;"	f
ofputil_decode_hello_bitmap	.\lib\ofp-util.c	/^ofputil_decode_hello_bitmap(const struct ofp_hello_elem_header *oheh,$/;"	f	file:
ofputil_decode_meter_config	.\lib\ofp-util.c	/^ofputil_decode_meter_config(struct ofpbuf *msg,$/;"	f
ofputil_decode_meter_features	.\lib\ofp-util.c	/^ofputil_decode_meter_features(const struct ofp_header *oh,$/;"	f
ofputil_decode_meter_mod	.\lib\ofp-util.c	/^ofputil_decode_meter_mod(const struct ofp_header *oh,$/;"	f
ofputil_decode_meter_request	.\lib\ofp-util.c	/^ofputil_decode_meter_request(const struct ofp_header *oh, uint32_t *meter_id)$/;"	f
ofputil_decode_meter_stats	.\lib\ofp-util.c	/^ofputil_decode_meter_stats(struct ofpbuf *msg,$/;"	f
ofputil_decode_nxst_flow_request	.\lib\ofp-util.c	/^ofputil_decode_nxst_flow_request(struct ofputil_flow_stats_request *fsr,$/;"	f	file:
ofputil_decode_ofp10_phy_port	.\lib\ofp-util.c	/^ofputil_decode_ofp10_phy_port(struct ofputil_phy_port *pp,$/;"	f	file:
ofputil_decode_ofp11_port	.\lib\ofp-util.c	/^ofputil_decode_ofp11_port(struct ofputil_phy_port *pp,$/;"	f	file:
ofputil_decode_ofpst10_flow_request	.\lib\ofp-util.c	/^ofputil_decode_ofpst10_flow_request(struct ofputil_flow_stats_request *fsr,$/;"	f	file:
ofputil_decode_ofpst11_flow_request	.\lib\ofp-util.c	/^ofputil_decode_ofpst11_flow_request(struct ofputil_flow_stats_request *fsr,$/;"	f	file:
ofputil_decode_packet_in	.\lib\ofp-util.c	/^ofputil_decode_packet_in(struct ofputil_packet_in *pin,$/;"	f
ofputil_decode_packet_in_finish	.\lib\ofp-util.c	/^ofputil_decode_packet_in_finish(struct ofputil_packet_in *pin,$/;"	f	file:
ofputil_decode_packet_out	.\lib\ofp-util.c	/^ofputil_decode_packet_out(struct ofputil_packet_out *po,$/;"	f
ofputil_decode_port_desc_stats_request	.\lib\ofp-util.c	/^ofputil_decode_port_desc_stats_request(const struct ofp_header *request,$/;"	f
ofputil_decode_port_mod	.\lib\ofp-util.c	/^ofputil_decode_port_mod(const struct ofp_header *oh,$/;"	f
ofputil_decode_port_stats	.\lib\ofp-util.c	/^ofputil_decode_port_stats(struct ofputil_port_stats *ps, struct ofpbuf *msg)$/;"	f
ofputil_decode_port_stats_request	.\lib\ofp-util.c	/^ofputil_decode_port_stats_request(const struct ofp_header *request,$/;"	f
ofputil_decode_port_status	.\lib\ofp-util.c	/^ofputil_decode_port_status(const struct ofp_header *oh,$/;"	f
ofputil_decode_queue_get_config_reply	.\lib\ofp-util.c	/^ofputil_decode_queue_get_config_reply(struct ofpbuf *reply, ofp_port_t *port)$/;"	f
ofputil_decode_queue_get_config_request	.\lib\ofp-util.c	/^ofputil_decode_queue_get_config_request(const struct ofp_header *oh,$/;"	f
ofputil_decode_queue_stats	.\lib\ofp-util.c	/^ofputil_decode_queue_stats(struct ofputil_queue_stats *qs, struct ofpbuf *msg)$/;"	f
ofputil_decode_queue_stats_request	.\lib\ofp-util.c	/^ofputil_decode_queue_stats_request(const struct ofp_header *request,$/;"	f
ofputil_decode_role_message	.\lib\ofp-util.c	/^ofputil_decode_role_message(const struct ofp_header *oh,$/;"	f
ofputil_decode_role_status	.\lib\ofp-util.c	/^ofputil_decode_role_status(const struct ofp_header *oh,$/;"	f
ofputil_decode_switch_features	.\lib\ofp-util.c	/^ofputil_decode_switch_features(const struct ofp_header *oh,$/;"	f
ofputil_decode_table_features	.\lib\ofp-util.c	/^ofputil_decode_table_features(struct ofpbuf *msg,$/;"	f
ofputil_decode_table_mod	.\lib\ofp-util.c	/^ofputil_decode_table_mod(const struct ofp_header *oh,$/;"	f
ofputil_dl_type_from_openflow	.\lib\ofp-util.c	/^ofputil_dl_type_from_openflow(ovs_be16 ofp_dl_type)$/;"	f
ofputil_dl_type_to_openflow	.\lib\ofp-util.c	/^ofputil_dl_type_to_openflow(ovs_be16 flow_dl_type)$/;"	f
ofputil_encode_aggregate_stats_reply	.\lib\ofp-util.c	/^ofputil_encode_aggregate_stats_reply($/;"	f
ofputil_encode_barrier_request	.\lib\ofp-util.c	/^ofputil_encode_barrier_request(enum ofp_version ofp_version)$/;"	f
ofputil_encode_bundle_add	.\lib\ofp-util.c	/^ofputil_encode_bundle_add(enum ofp_version ofp_version,$/;"	f
ofputil_encode_bundle_ctrl_reply	.\lib\ofp-util.c	/^ofputil_encode_bundle_ctrl_reply(const struct ofp_header *oh,$/;"	f
ofputil_encode_dump_ports_request	.\lib\ofp-util.c	/^ofputil_encode_dump_ports_request(enum ofp_version ofp_version, ofp_port_t port)$/;"	f
ofputil_encode_flow_mod	.\lib\ofp-util.c	/^ofputil_encode_flow_mod(const struct ofputil_flow_mod *fm,$/;"	f
ofputil_encode_flow_mod_flags	.\lib\ofp-util.c	/^ofputil_encode_flow_mod_flags(enum ofputil_flow_mod_flags flags,$/;"	f	file:
ofputil_encode_flow_monitor_cancel	.\lib\ofp-util.c	/^ofputil_encode_flow_monitor_cancel(uint32_t id)$/;"	f
ofputil_encode_flow_removed	.\lib\ofp-util.c	/^ofputil_encode_flow_removed(const struct ofputil_flow_removed *fr,$/;"	f
ofputil_encode_flow_stats_request	.\lib\ofp-util.c	/^ofputil_encode_flow_stats_request(const struct ofputil_flow_stats_request *fsr,$/;"	f
ofputil_encode_group_desc_request	.\lib\ofp-util.c	/^ofputil_encode_group_desc_request(enum ofp_version ofp_version,$/;"	f
ofputil_encode_group_features_reply	.\lib\ofp-util.c	/^ofputil_encode_group_features_reply($/;"	f
ofputil_encode_group_features_request	.\lib\ofp-util.c	/^ofputil_encode_group_features_request(enum ofp_version ofp_version)$/;"	f
ofputil_encode_group_mod	.\lib\ofp-util.c	/^ofputil_encode_group_mod(enum ofp_version ofp_version,$/;"	f
ofputil_encode_group_stats_request	.\lib\ofp-util.c	/^ofputil_encode_group_stats_request(enum ofp_version ofp_version,$/;"	f
ofputil_encode_hello	.\lib\ofp-util.c	/^ofputil_encode_hello(uint32_t allowed_versions)$/;"	f
ofputil_encode_meter_features_reply	.\lib\ofp-util.c	/^ofputil_encode_meter_features_reply(const struct ofputil_meter_features *mf,$/;"	f
ofputil_encode_meter_mod	.\lib\ofp-util.c	/^ofputil_encode_meter_mod(enum ofp_version ofp_version,$/;"	f
ofputil_encode_meter_request	.\lib\ofp-util.c	/^ofputil_encode_meter_request(enum ofp_version ofp_version,$/;"	f
ofputil_encode_nx_packet_in	.\lib\ofp-util.c	/^ofputil_encode_nx_packet_in(const struct ofputil_packet_in *pin)$/;"	f	file:
ofputil_encode_nx_set_flow_format	.\lib\ofp-util.c	/^ofputil_encode_nx_set_flow_format(enum nx_flow_format nxff)$/;"	f
ofputil_encode_ofp10_packet_in	.\lib\ofp-util.c	/^ofputil_encode_ofp10_packet_in(const struct ofputil_packet_in *pin)$/;"	f	file:
ofputil_encode_ofp10_phy_port	.\lib\ofp-util.c	/^ofputil_encode_ofp10_phy_port(const struct ofputil_phy_port *pp,$/;"	f	file:
ofputil_encode_ofp11_packet_in	.\lib\ofp-util.c	/^ofputil_encode_ofp11_packet_in(const struct ofputil_packet_in *pin)$/;"	f	file:
ofputil_encode_ofp11_port	.\lib\ofp-util.c	/^ofputil_encode_ofp11_port(const struct ofputil_phy_port *pp,$/;"	f	file:
ofputil_encode_ofp12_packet_in	.\lib\ofp-util.c	/^ofputil_encode_ofp12_packet_in(const struct ofputil_packet_in *pin,$/;"	f	file:
ofputil_encode_packet_in	.\lib\ofp-util.c	/^ofputil_encode_packet_in(const struct ofputil_packet_in *pin,$/;"	f
ofputil_encode_packet_out	.\lib\ofp-util.c	/^ofputil_encode_packet_out(const struct ofputil_packet_out *po,$/;"	f
ofputil_encode_port_desc_stats_request	.\lib\ofp-util.c	/^ofputil_encode_port_desc_stats_request(enum ofp_version ofp_version,$/;"	f
ofputil_encode_port_mod	.\lib\ofp-util.c	/^ofputil_encode_port_mod(const struct ofputil_port_mod *pm,$/;"	f
ofputil_encode_port_status	.\lib\ofp-util.c	/^ofputil_encode_port_status(const struct ofputil_port_status *ps,$/;"	f
ofputil_encode_queue_get_config_reply	.\lib\ofp-util.c	/^ofputil_encode_queue_get_config_reply(const struct ofp_header *oh)$/;"	f
ofputil_encode_queue_get_config_request	.\lib\ofp-util.c	/^ofputil_encode_queue_get_config_request(enum ofp_version version,$/;"	f
ofputil_encode_queue_stats_request	.\lib\ofp-util.c	/^ofputil_encode_queue_stats_request(enum ofp_version ofp_version,$/;"	f
ofputil_encode_role_reply	.\lib\ofp-util.c	/^ofputil_encode_role_reply(const struct ofp_header *request,$/;"	f
ofputil_encode_role_status	.\lib\ofp-util.c	/^ofputil_encode_role_status(const struct ofputil_role_status *status,$/;"	f
ofputil_encode_set_protocol	.\lib\ofp-util.c	/^ofputil_encode_set_protocol(enum ofputil_protocol current,$/;"	f
ofputil_encode_switch_features	.\lib\ofp-util.c	/^ofputil_encode_switch_features(const struct ofputil_switch_features *features,$/;"	f
ofputil_encode_table_features_request	.\lib\ofp-util.c	/^ofputil_encode_table_features_request(enum ofp_version ofp_version)$/;"	f
ofputil_encode_table_mod	.\lib\ofp-util.c	/^ofputil_encode_table_mod(const struct ofputil_table_mod *pm,$/;"	f
ofputil_encode_table_stats_reply	.\lib\ofp-util.c	/^ofputil_encode_table_stats_reply(const struct ofp12_table_stats stats[], int n,$/;"	f
ofputil_flow_dump_protocols	.\lib\ofp-util.c	/^enum ofputil_protocol ofputil_flow_dump_protocols[] = {$/;"	v	typeref:enum:ofputil_protocol
ofputil_flow_mod	.\lib\ofp-util.h	/^struct ofputil_flow_mod {$/;"	s
ofputil_flow_mod_flag	.\lib\ofp-util.c	/^struct ofputil_flow_mod_flag {$/;"	s	file:
ofputil_flow_mod_flags	.\lib\ofp-util.c	/^static const struct ofputil_flow_mod_flag ofputil_flow_mod_flags[] = {$/;"	v	typeref:struct:ofputil_flow_mod_flag	file:
ofputil_flow_mod_flags	.\lib\ofp-util.h	/^enum ofputil_flow_mod_flags {$/;"	g
ofputil_flow_monitor_request	.\lib\ofp-util.h	/^struct ofputil_flow_monitor_request {$/;"	s
ofputil_flow_removed	.\lib\ofp-util.h	/^struct ofputil_flow_removed {$/;"	s
ofputil_flow_stats	.\lib\ofp-util.h	/^struct ofputil_flow_stats {$/;"	s
ofputil_flow_stats_request	.\lib\ofp-util.h	/^struct ofputil_flow_stats_request {$/;"	s
ofputil_flow_update	.\lib\ofp-util.h	/^struct ofputil_flow_update {$/;"	s
ofputil_format_group	.\lib\ofp-util.c	/^ofputil_format_group(uint32_t group_id, struct ds *s)$/;"	f
ofputil_format_port	.\lib\ofp-util.c	/^ofputil_format_port(ofp_port_t port, struct ds *s)$/;"	f
ofputil_format_version	.\lib\ofp-util.c	/^ofputil_format_version(struct ds *msg, enum ofp_version version)$/;"	f
ofputil_format_version_bitmap	.\lib\ofp-util.c	/^ofputil_format_version_bitmap(struct ds *msg, uint32_t bitmap)$/;"	f
ofputil_format_version_bitmap__	.\lib\ofp-util.c	/^ofputil_format_version_bitmap__(struct ds *msg, uint32_t bitmap,$/;"	f	file:
ofputil_format_version_bitmap_names	.\lib\ofp-util.c	/^ofputil_format_version_bitmap_names(struct ds *msg, uint32_t bitmap)$/;"	f
ofputil_format_version_name	.\lib\ofp-util.c	/^ofputil_format_version_name(struct ds *msg, enum ofp_version version)$/;"	f
ofputil_frag_handling_from_string	.\lib\ofp-util.c	/^ofputil_frag_handling_from_string(const char *s, enum ofp_config_flags *flags)$/;"	f
ofputil_frag_handling_to_string	.\lib\ofp-util.c	/^ofputil_frag_handling_to_string(enum ofp_config_flags flags)$/;"	f
ofputil_group_bucket_counters_to_ofp11	.\lib\ofp-util.c	/^ofputil_group_bucket_counters_to_ofp11(const struct ofputil_group_stats *gs,$/;"	f	file:
ofputil_group_desc	.\lib\ofp-util.h	/^struct ofputil_group_desc {$/;"	s
ofputil_group_features	.\lib\ofp-util.h	/^struct ofputil_group_features {$/;"	s
ofputil_group_from_string	.\lib\ofp-util.c	/^ofputil_group_from_string(const char *s, uint32_t *group_idp)$/;"	f
ofputil_group_mod	.\lib\ofp-util.h	/^struct ofputil_group_mod {$/;"	s
ofputil_group_stats	.\lib\ofp-util.h	/^struct ofputil_group_stats {$/;"	s
ofputil_group_stats_to_ofp11	.\lib\ofp-util.c	/^ofputil_group_stats_to_ofp11(const struct ofputil_group_stats *gs,$/;"	f	file:
ofputil_group_stats_to_ofp13	.\lib\ofp-util.c	/^ofputil_group_stats_to_ofp13(const struct ofputil_group_stats *gs,$/;"	f	file:
ofputil_group_to_string	.\lib\ofp-util.c	/^ofputil_group_to_string(uint32_t group_id,$/;"	f
ofputil_make_flow_mod_table_id	.\lib\ofp-util.c	/^ofputil_make_flow_mod_table_id(bool flow_mod_table_id)$/;"	f
ofputil_make_set_packet_in_format	.\lib\ofp-util.c	/^ofputil_make_set_packet_in_format(enum ofp_version ofp_version,$/;"	f
ofputil_match_from_ofp10_match	.\lib\ofp-util.c	/^ofputil_match_from_ofp10_match(const struct ofp10_match *ofmatch,$/;"	f
ofputil_match_from_ofp11_match	.\lib\ofp-util.c	/^ofputil_match_from_ofp11_match(const struct ofp11_match *ofmatch,$/;"	f
ofputil_match_to_ofp10_match	.\lib\ofp-util.c	/^ofputil_match_to_ofp10_match(const struct match *match,$/;"	f
ofputil_match_to_ofp11_match	.\lib\ofp-util.c	/^ofputil_match_to_ofp11_match(const struct match *match,$/;"	f
ofputil_match_typical_len	.\lib\ofp-util.c	/^ofputil_match_typical_len(enum ofputil_protocol protocol)$/;"	f
ofputil_meter_band	.\lib\ofp-util.h	/^struct ofputil_meter_band {$/;"	s
ofputil_meter_band_stats	.\lib\ofp-util.h	/^struct ofputil_meter_band_stats {$/;"	s
ofputil_meter_band_types_to_name	.\lib\ofp-print.c	/^ofputil_meter_band_types_to_name(uint32_t bit)$/;"	f	file:
ofputil_meter_capabilities_to_name	.\lib\ofp-print.c	/^ofputil_meter_capabilities_to_name(uint32_t bit)$/;"	f	file:
ofputil_meter_config	.\lib\ofp-util.h	/^struct ofputil_meter_config {$/;"	s
ofputil_meter_features	.\lib\ofp-util.h	/^struct ofputil_meter_features {$/;"	s
ofputil_meter_mod	.\lib\ofp-util.h	/^struct ofputil_meter_mod {$/;"	s
ofputil_meter_request_type	.\lib\ofp-util.h	/^enum ofputil_meter_request_type {$/;"	g
ofputil_meter_stats	.\lib\ofp-util.h	/^struct ofputil_meter_stats {$/;"	s
ofputil_n_flow_dump_protocols	.\lib\ofp-util.c	/^size_t ofputil_n_flow_dump_protocols = ARRAY_SIZE(ofputil_flow_dump_protocols);$/;"	v
ofputil_netmask_to_wcbits	.\lib\ofp-util.c	/^ofputil_netmask_to_wcbits(ovs_be32 netmask)$/;"	f
ofputil_normalize_match	.\lib\ofp-util.c	/^ofputil_normalize_match(struct match *match)$/;"	f
ofputil_normalize_match__	.\lib\ofp-util.c	/^ofputil_normalize_match__(struct match *match, bool may_log)$/;"	f	file:
ofputil_normalize_match_quiet	.\lib\ofp-util.c	/^ofputil_normalize_match_quiet(struct match *match)$/;"	f
ofputil_nx_flow_format_is_valid	.\lib\ofp-util.c	/^ofputil_nx_flow_format_is_valid(enum nx_flow_format flow_format)$/;"	f
ofputil_nx_flow_format_to_protocol	.\lib\ofp-util.c	/^ofputil_nx_flow_format_to_protocol(enum nx_flow_format flow_format)$/;"	f
ofputil_nx_flow_format_to_string	.\lib\ofp-util.c	/^ofputil_nx_flow_format_to_string(enum nx_flow_format flow_format)$/;"	f
ofputil_packet_in	.\lib\ofp-util.h	/^struct ofputil_packet_in {$/;"	s
ofputil_packet_in_format_from_string	.\lib\ofp-util.c	/^ofputil_packet_in_format_from_string(const char *s)$/;"	f
ofputil_packet_in_format_is_valid	.\lib\ofp-util.c	/^ofputil_packet_in_format_is_valid(enum nx_packet_in_format packet_in_format)$/;"	f
ofputil_packet_in_format_to_string	.\lib\ofp-util.c	/^ofputil_packet_in_format_to_string(enum nx_packet_in_format packet_in_format)$/;"	f
ofputil_packet_in_reason_from_string	.\lib\ofp-util.c	/^ofputil_packet_in_reason_from_string(const char *s,$/;"	f
ofputil_packet_in_reason_to_string	.\lib\ofp-util.c	/^ofputil_packet_in_reason_to_string(enum ofp_packet_in_reason reason,$/;"	f
ofputil_packet_in_to_match	.\lib\ofp-util.c	/^ofputil_packet_in_to_match(const struct ofputil_packet_in *pin,$/;"	f	file:
ofputil_packet_out	.\lib\ofp-util.h	/^struct ofputil_packet_out {$/;"	s
ofputil_parse_key_value	.\lib\ofp-util.c	/^ofputil_parse_key_value(char **stringp, char **keyp, char **valuep)$/;"	f
ofputil_phy_port	.\lib\ofp-util.h	/^struct ofputil_phy_port {$/;"	s
ofputil_port_config	.\lib\ofp-util.h	/^enum ofputil_port_config {$/;"	g
ofputil_port_config_to_name	.\lib\ofp-print.c	/^ofputil_port_config_to_name(uint32_t bit)$/;"	f	file:
ofputil_port_from_ofp11	.\lib\ofp-util.c	/^ofputil_port_from_ofp11(ovs_be32 ofp11_port, ofp_port_t *ofp10_port)$/;"	f
ofputil_port_from_string	.\lib\ofp-util.c	/^ofputil_port_from_string(const char *s, ofp_port_t *portp)$/;"	f
ofputil_port_mod	.\lib\ofp-util.h	/^struct ofputil_port_mod {$/;"	s
ofputil_port_state	.\lib\ofp-util.h	/^enum ofputil_port_state {$/;"	g
ofputil_port_state_to_name	.\lib\ofp-print.c	/^ofputil_port_state_to_name(uint32_t bit)$/;"	f	file:
ofputil_port_stats	.\lib\ofp-util.h	/^struct ofputil_port_stats {$/;"	s
ofputil_port_stats_from_ofp10	.\lib\ofp-util.c	/^ofputil_port_stats_from_ofp10(struct ofputil_port_stats *ops,$/;"	f	file:
ofputil_port_stats_from_ofp11	.\lib\ofp-util.c	/^ofputil_port_stats_from_ofp11(struct ofputil_port_stats *ops,$/;"	f	file:
ofputil_port_stats_from_ofp13	.\lib\ofp-util.c	/^ofputil_port_stats_from_ofp13(struct ofputil_port_stats *ops,$/;"	f	file:
ofputil_port_stats_to_ofp10	.\lib\ofp-util.c	/^ofputil_port_stats_to_ofp10(const struct ofputil_port_stats *ops,$/;"	f	file:
ofputil_port_stats_to_ofp11	.\lib\ofp-util.c	/^ofputil_port_stats_to_ofp11(const struct ofputil_port_stats *ops,$/;"	f	file:
ofputil_port_stats_to_ofp13	.\lib\ofp-util.c	/^ofputil_port_stats_to_ofp13(const struct ofputil_port_stats *ops,$/;"	f	file:
ofputil_port_status	.\lib\ofp-util.h	/^struct ofputil_port_status {$/;"	s
ofputil_port_to_ofp11	.\lib\ofp-util.c	/^ofputil_port_to_ofp11(ofp_port_t ofp10_port)$/;"	f
ofputil_port_to_string	.\lib\ofp-util.c	/^ofputil_port_to_string(ofp_port_t port,$/;"	f
ofputil_protocol	.\lib\ofp-util.h	/^enum ofputil_protocol {$/;"	g
ofputil_protocol_from_ofp_version	.\lib\ofp-util.c	/^ofputil_protocol_from_ofp_version(enum ofp_version version)$/;"	f
ofputil_protocol_from_string__	.\lib\ofp-util.c	/^ofputil_protocol_from_string__(const char *s, size_t n)$/;"	f	file:
ofputil_protocol_is_valid	.\lib\ofp-util.c	/^ofputil_protocol_is_valid(enum ofputil_protocol protocol)$/;"	f
ofputil_protocol_set_base	.\lib\ofp-util.c	/^ofputil_protocol_set_base(enum ofputil_protocol cur,$/;"	f
ofputil_protocol_set_tid	.\lib\ofp-util.c	/^ofputil_protocol_set_tid(enum ofputil_protocol protocol, bool enable)$/;"	f
ofputil_protocol_to_base	.\lib\ofp-util.c	/^ofputil_protocol_to_base(enum ofputil_protocol protocol)$/;"	f
ofputil_protocol_to_ofp_version	.\lib\ofp-util.c	/^ofputil_protocol_to_ofp_version(enum ofputil_protocol protocol)$/;"	f
ofputil_protocol_to_string	.\lib\ofp-util.c	/^ofputil_protocol_to_string(enum ofputil_protocol protocol)$/;"	f
ofputil_protocols_from_ofp_version	.\lib\ofp-util.c	/^ofputil_protocols_from_ofp_version(enum ofp_version version)$/;"	f
ofputil_protocols_from_string	.\lib\ofp-util.c	/^ofputil_protocols_from_string(const char *s)$/;"	f
ofputil_protocols_from_version_bitmap	.\lib\ofp-util.c	/^ofputil_protocols_from_version_bitmap(uint32_t bitmap)$/;"	f
ofputil_protocols_to_string	.\lib\ofp-util.c	/^ofputil_protocols_to_string(enum ofputil_protocol protocols)$/;"	f
ofputil_protocols_to_version_bitmap	.\lib\ofp-util.c	/^ofputil_protocols_to_version_bitmap(enum ofputil_protocol protocols)$/;"	f
ofputil_pull_band_stats	.\lib\ofp-util.c	/^ofputil_pull_band_stats(struct ofpbuf *msg, size_t len, uint16_t *n_bands,$/;"	f	file:
ofputil_pull_bands	.\lib\ofp-util.c	/^ofputil_pull_bands(struct ofpbuf *msg, size_t len, uint16_t *n_bands,$/;"	f	file:
ofputil_pull_buckets	.\lib\ofp-util.c	/^ofputil_pull_buckets(struct ofpbuf *msg, size_t buckets_length,$/;"	f	file:
ofputil_pull_ofp11_match	.\lib\ofp-util.c	/^ofputil_pull_ofp11_match(struct ofpbuf *buf, struct match *match,$/;"	f
ofputil_pull_ofp14_port	.\lib\ofp-util.c	/^ofputil_pull_ofp14_port(struct ofputil_phy_port *pp, struct ofpbuf *msg)$/;"	f	file:
ofputil_pull_ofp14_port_stats	.\lib\ofp-util.c	/^ofputil_pull_ofp14_port_stats(struct ofputil_port_stats *ops,$/;"	f	file:
ofputil_pull_ofp14_queue_stats	.\lib\ofp-util.c	/^ofputil_pull_ofp14_queue_stats(struct ofputil_queue_stats *oqs,$/;"	f	file:
ofputil_pull_phy_port	.\lib\ofp-util.c	/^ofputil_pull_phy_port(enum ofp_version ofp_version, struct ofpbuf *b,$/;"	f
ofputil_pull_property	.\lib\ofp-util.c	/^ofputil_pull_property(struct ofpbuf *msg, struct ofpbuf *property,$/;"	f	file:
ofputil_pull_queue_get_config_reply	.\lib\ofp-util.c	/^ofputil_pull_queue_get_config_reply(struct ofpbuf *reply,$/;"	f
ofputil_put_action	.\lib\ofp-util.c	/^ofputil_put_action(enum ofputil_action_code code, struct ofpbuf *buf)$/;"	f
ofputil_put_bands	.\lib\ofp-util.c	/^ofputil_put_bands(uint16_t n_bands, const struct ofputil_meter_band *mb,$/;"	f	file:
ofputil_put_ofp10_table_stats	.\lib\ofp-util.c	/^ofputil_put_ofp10_table_stats(const struct ofp12_table_stats *in,$/;"	f	file:
ofputil_put_ofp11_match	.\lib\ofp-util.c	/^ofputil_put_ofp11_match(struct ofpbuf *b, const struct match *match,$/;"	f
ofputil_put_ofp11_table_stats	.\lib\ofp-util.c	/^ofputil_put_ofp11_table_stats(const struct ofp12_table_stats *in,$/;"	f	file:
ofputil_put_ofp12_table_stats	.\lib\ofp-util.c	/^ofputil_put_ofp12_table_stats(const struct ofp12_table_stats *in,$/;"	f	file:
ofputil_put_ofp13_table_stats	.\lib\ofp-util.c	/^ofputil_put_ofp13_table_stats(const struct ofp12_table_stats *in,$/;"	f	file:
ofputil_put_ofp14_port	.\lib\ofp-util.c	/^ofputil_put_ofp14_port(const struct ofputil_phy_port *pp,$/;"	f	file:
ofputil_put_phy_port	.\lib\ofp-util.c	/^ofputil_put_phy_port(enum ofp_version ofp_version,$/;"	f	file:
ofputil_put_switch_features_port	.\lib\ofp-util.c	/^ofputil_put_switch_features_port(const struct ofputil_phy_port *pp,$/;"	f
ofputil_queue_config	.\lib\ofp-util.h	/^struct ofputil_queue_config {$/;"	s
ofputil_queue_stats	.\lib\ofp-util.h	/^struct ofputil_queue_stats {$/;"	s
ofputil_queue_stats_from_ofp10	.\lib\ofp-util.c	/^ofputil_queue_stats_from_ofp10(struct ofputil_queue_stats *oqs,$/;"	f	file:
ofputil_queue_stats_from_ofp11	.\lib\ofp-util.c	/^ofputil_queue_stats_from_ofp11(struct ofputil_queue_stats *oqs,$/;"	f	file:
ofputil_queue_stats_from_ofp13	.\lib\ofp-util.c	/^ofputil_queue_stats_from_ofp13(struct ofputil_queue_stats *oqs,$/;"	f	file:
ofputil_queue_stats_request	.\lib\ofp-util.h	/^struct ofputil_queue_stats_request {$/;"	s
ofputil_queue_stats_to_ofp10	.\lib\ofp-util.c	/^ofputil_queue_stats_to_ofp10(const struct ofputil_queue_stats *oqs,$/;"	f	file:
ofputil_queue_stats_to_ofp11	.\lib\ofp-util.c	/^ofputil_queue_stats_to_ofp11(const struct ofputil_queue_stats *oqs,$/;"	f	file:
ofputil_queue_stats_to_ofp13	.\lib\ofp-util.c	/^ofputil_queue_stats_to_ofp13(const struct ofputil_queue_stats *oqs,$/;"	f	file:
ofputil_queue_stats_to_ofp14	.\lib\ofp-util.c	/^ofputil_queue_stats_to_ofp14(const struct ofputil_queue_stats *oqs,$/;"	f	file:
ofputil_role_request	.\lib\ofp-util.h	/^struct ofputil_role_request {$/;"	s
ofputil_role_status	.\lib\ofp-util.h	/^struct ofputil_role_status {$/;"	s
ofputil_start_flow_update	.\lib\ofp-util.c	/^ofputil_start_flow_update(struct list *replies)$/;"	f
ofputil_switch_features	.\lib\ofp-util.h	/^struct ofputil_switch_features {$/;"	s
ofputil_switch_features_has_ports	.\lib\ofp-util.c	/^ofputil_switch_features_has_ports(struct ofpbuf *b)$/;"	f
ofputil_table_action_features	.\lib\ofp-util.h	/^        struct ofputil_table_action_features {$/;"	s	struct:ofputil_table_features::ofputil_table_instruction_features
ofputil_table_features	.\lib\ofp-util.h	/^struct ofputil_table_features {$/;"	s
ofputil_table_instruction_features	.\lib\ofp-util.h	/^    struct ofputil_table_instruction_features {$/;"	s	struct:ofputil_table_features
ofputil_table_mod	.\lib\ofp-util.h	/^struct ofputil_table_mod {$/;"	s
ofputil_tid_command	.\lib\ofp-util.c	/^ofputil_tid_command(const struct ofputil_flow_mod *fm,$/;"	f	file:
ofputil_version_from_string	.\lib\ofp-util.c	/^ofputil_version_from_string(const char *s)$/;"	f
ofputil_version_to_string	.\lib\ofp-util.c	/^ofputil_version_to_string(enum ofp_version ofp_version)$/;"	f
ofputil_versions_from_string	.\lib\ofp-util.c	/^ofputil_versions_from_string(const char *s)$/;"	f
ofputil_versions_from_strings	.\lib\ofp-util.c	/^ofputil_versions_from_strings(char ** const s, size_t count)$/;"	f
ofputil_wcbits_to_netmask	.\lib\ofp-util.c	/^ofputil_wcbits_to_netmask(int wcbits)$/;"	f
ofputil_wildcard_from_ofpfw10	.\lib\ofp-util.c	/^ofputil_wildcard_from_ofpfw10(uint32_t ofpfw, struct flow_wildcards *wc)$/;"	f
ofs	.\lib\meta-flow.h	/^    unsigned int ofs;           \/* Bit offset. *\/$/;"	m	struct:mf_subfield
ofs	.\tests\test-classifier.c	/^    int ofs;                    \/* Offset in struct flow. *\/$/;"	m	struct:cls_field	file:
ofs_nbits	.\include\openflow\nicira-ext.h	/^    ovs_be16 ofs_nbits;             \/* (ofs << 6) | (n_bits - 1). *\/$/;"	m	struct:nx_action_reg_load
ofs_nbits	.\include\openflow\nicira-ext.h	/^    ovs_be16 ofs_nbits;         \/* (ofs << 6) | (n_bits - 1). *\/$/;"	m	struct:nx_action_bundle
ofs_nbits	.\include\openflow\nicira-ext.h	/^    ovs_be16 ofs_nbits;         \/* (ofs << 6) | (n_bits - 1). *\/$/;"	m	struct:nx_action_multipath
ofs_nbits	.\include\openflow\nicira-ext.h	/^    ovs_be16 ofs_nbits;         \/* (ofs << 6) | (n_bits - 1). *\/$/;"	m	struct:nx_action_output_reg
ofservice	.\ofproto\connmgr.c	/^struct ofservice {$/;"	s	file:
ofservice_create	.\ofproto\connmgr.c	/^ofservice_create(struct connmgr *mgr, const char *target,$/;"	f	file:
ofservice_destroy	.\ofproto\connmgr.c	/^ofservice_destroy(struct connmgr *mgr, struct ofservice *ofservice)$/;"	f	file:
ofservice_lookup	.\ofproto\connmgr.c	/^ofservice_lookup(struct connmgr *mgr, const char *target)$/;"	f	file:
ofservice_reconfigure	.\ofproto\connmgr.c	/^ofservice_reconfigure(struct ofservice *ofservice,$/;"	f	file:
oftable	.\ofproto\ofproto-provider.h	/^struct oftable {$/;"	s
oftable_destroy	.\ofproto\ofproto.c	/^oftable_destroy(struct oftable *table)$/;"	f	file:
oftable_flags	.\ofproto\ofproto-provider.h	/^enum oftable_flags {$/;"	g
oftable_init	.\ofproto\ofproto.c	/^oftable_init(struct oftable *table)$/;"	f	file:
oftable_is_modifiable	.\ofproto\ofproto.c	/^oftable_is_modifiable(const struct oftable *table,$/;"	f	file:
oftable_set_name	.\ofproto\ofproto.c	/^oftable_set_name(struct oftable *table, const char *name)$/;"	f	file:
ogf	.\ofproto\ofproto-provider.h	/^    struct ofputil_group_features ogf;$/;"	m	struct:ofproto	typeref:struct:ofproto::ofputil_group_features
old	.\lib\ovsdb-idl-provider.h	/^    struct ovsdb_datum *old;    \/* Committed data (null if orphaned). *\/$/;"	m	struct:ovsdb_idl_row	typeref:struct:ovsdb_idl_row::ovsdb_datum
old	.\ovsdb\jsonrpc-server.c	/^    struct ovsdb_datum *old;    \/* Old data, NULL for an inserted row. *\/$/;"	m	struct:ovsdb_jsonrpc_monitor_row	typeref:struct:ovsdb_jsonrpc_monitor_row::ovsdb_datum	file:
old	.\ovsdb\transaction.c	/^    struct ovsdb_row *old;      \/* The old row. *\/$/;"	m	struct:ovsdb_txn_row	typeref:struct:ovsdb_txn_row::ovsdb_row	file:
older	.\lib\timeval.c	/^    struct cpu_usage older;$/;"	m	struct:cpu_tracker	typeref:struct:cpu_tracker::cpu_usage	file:
omh	.\include\openflow\openflow-1.1.h	/^    struct ofp11_match_header omh;$/;"	m	struct:ofp11_match	typeref:struct:ofp11_match::ofp11_match_header
one	.\lib\hindex.h	/^    struct hindex_node *one;$/;"	m	struct:hindex	typeref:struct:hindex::hindex_node
one	.\lib\hmap.h	/^    struct hmap_node *one;$/;"	m	struct:hmap	typeref:struct:hmap::hmap_node
oneline	.\utilities\ovs-vsctl.c	/^static bool oneline;$/;"	v	file:
oneline	.\vtep\vtep-ctl.c	/^static bool oneline;$/;"	v	file:
op	.\lib\dhcp.h	/^    uint8_t op;                 \/* DHCP_BOOTREQUEST or DHCP_BOOTREPLY. *\/$/;"	m	struct:dhcp_header
op	.\ofproto\bond.c	/^    enum bond_op op;$/;"	m	struct:bond_pr_rule_op	typeref:enum:bond_pr_rule_op::bond_op	file:
op	.\ofproto\in-band.c	/^    enum in_band_op op;$/;"	m	struct:in_band_rule	typeref:enum:in_band_rule::in_band_op	file:
op	.\ofproto\ofproto-dpif-upcall.c	/^    struct dpif_op op;            \/* Flow del operation. *\/$/;"	m	struct:dump_op	typeref:struct:dump_op::dpif_op	file:
op	.\ofproto\ofproto-dpif.c	/^    struct ofoperation *op;$/;"	m	struct:dpif_completion	typeref:struct:dpif_completion::ofoperation	file:
op_backoff	.\ofproto\connmgr.c	/^    long long int op_backoff;        \/* Earliest time to report ops again. *\/$/;"	m	struct:ofconn	file:
op_index	.\lib\ovsdb-idl.c	/^    int op_index;               \/* Index into transaction's operation array. *\/$/;"	m	struct:ovsdb_idl_txn_insert	file:
open	.\lib\dpif-provider.h	/^    int (*open)(const struct dpif_class *dpif_class,$/;"	m	struct:dpif_class
open	.\lib\stream-provider.h	/^    int (*open)(const char *name, char *suffix, struct stream **streamp,$/;"	m	struct:stream_class
open	.\lib\vconn-provider.h	/^    int (*open)(const char *name, uint32_t allowed_versions,$/;"	m	struct:vconn_class
open	.\python\ovs\jsonrpc.py	/^    def open(name):$/;"	m	class:Session
open	.\python\ovs\stream.py	/^    def open(name):$/;"	m	class:PassiveStream
open	.\python\ovs\stream.py	/^    def open(name, dscp=DSCP_DEFAULT):$/;"	m	class:Stream
open_block	.\python\ovs\stream.py	/^    def open_block((error, stream)):$/;"	m	class:Stream
open_db	.\ovsdb\ovsdb-server.c	/^open_db(struct server_config *config, const char *filename)$/;"	f	file:
open_dpif	.\lib\dpif-linux.c	/^open_dpif(const struct dpif_linux_dp *dp, struct dpif **dpifp)$/;"	f	file:
open_dpif_backer	.\ofproto\ofproto-dpif.c	/^open_dpif_backer(const char *type, struct dpif_backer **backerp)$/;"	f	file:
open_jsonrpc	.\ovsdb\ovsdb-client.c	/^open_jsonrpc(const char *server)$/;"	f	file:
open_pif_ifcfg	.\xenserver\opt_xensource_libexec_InterfaceReconfigureBridge.py	/^def open_pif_ifcfg(pif):$/;"	f
open_target	.\utilities\ovs-ofctl.c	/^enum open_target { MGMT, SNOOP };$/;"	g	file:
open_unreliably	.\python\ovs\jsonrpc.py	/^    def open_unreliably(jsonrpc):$/;"	m	class:Session
open_vconn	.\utilities\ovs-ofctl.c	/^open_vconn(const char *name, struct vconn **vconnp)$/;"	f	file:
open_vconn__	.\utilities\ovs-ofctl.c	/^open_vconn__(const char *name, enum open_target target,$/;"	f	file:
open_vconn_for_flow_mod	.\utilities\ovs-ofctl.c	/^open_vconn_for_flow_mod(const char *remote, struct vconn **vconnp,$/;"	f	file:
open_vconn_socket	.\utilities\ovs-ofctl.c	/^open_vconn_socket(const char *name, struct vconn **vconnp)$/;"	f	file:
openflow_from_hex	.\utilities\ovs-ofctl.c	/^openflow_from_hex(const char *hex, struct ofpbuf **msgp)$/;"	f	file:
openlog	.\include\windows\syslog.h	/^openlog(const char *ident OVS_UNUSED, int option OVS_UNUSED,$/;"	f
openvswitch_extras	.\datapath\Modules.mk	/^openvswitch_extras = \\$/;"	m
openvswitch_handle_frame_hook_t	.\datapath\linux\compat\include\linux\netdevice.h	/^typedef struct sk_buff *(openvswitch_handle_frame_hook_t)(struct sk_buff *skb);$/;"	t	typeref:struct:openvswitch_handle_frame_hook_t
openvswitch_headers	.\datapath\Modules.mk	/^openvswitch_headers = \\$/;"	m
openvswitch_sources	.\datapath\Modules.mk	/^openvswitch_sources = \\$/;"	m
operate	.\lib\dpif-provider.h	/^    void (*operate)(struct dpif *dpif, struct dpif_op **ops, size_t n_ops);$/;"	m	struct:dpif_class
opgroups	.\ofproto\connmgr.c	/^    struct list opgroups;       \/* Contains pending "ofopgroups", if any. *\/$/;"	m	struct:ofconn	typeref:struct:ofconn::list	file:
ops	.\datapath\linux\compat\include\net\genetlink.h	/^	const struct genl_ops * ops;            \/* private *\/$/;"	m	struct:rpl_genl_family	typeref:struct:rpl_genl_family::genl_ops
ops	.\datapath\linux\compat\include\net\net_namespace.h	/^	struct pernet_operations ops;$/;"	m	struct:rpl_pernet_operations	typeref:struct:rpl_pernet_operations::pernet_operations
ops	.\datapath\vport.h	/^	const struct vport_ops *ops;$/;"	m	struct:vport	typeref:struct:vport::vport_ops
ops	.\lib\netdev-linux.c	/^    const struct tc_ops *ops;$/;"	m	struct:tc	typeref:struct:tc::tc_ops	file:
ops	.\ofproto\ofproto.c	/^    struct list ops;            \/* List of "struct ofoperation"s. *\/$/;"	m	struct:ofopgroup	typeref:struct:ofopgroup::list	file:
optarg	.\lib\getopt_long.c	/^char    *optarg;		\/* argument associated with option *\/$/;"	v
opterr	.\lib\getopt_long.c	/^int	opterr = 1;		\/* if error message should be printed *\/$/;"	v
optind	.\lib\getopt_long.c	/^int	optind = 1;		\/* index into parent argv vector *\/$/;"	v
option	.\include\windows\getopt.h	/^struct option {$/;"	s
optional	.\lib\netlink.h	/^    bool optional;$/;"	m	struct:nl_policy
optional_argument	.\include\windows\getopt.h	43;"	d
options	.\datapath\vport.h	/^	struct nlattr *options;$/;"	m	struct:vport_parms	typeref:struct:vport_parms::nlattr
options	.\lib\dpif-linux.h	/^    const struct nlattr *options;          \/* OVS_VPORT_ATTR_OPTIONS. *\/$/;"	m	struct:dpif_linux_vport	typeref:struct:dpif_linux_vport::nlattr
options	.\lib\vswitch-idl.h	/^	struct smap options;$/;"	m	struct:ovsrec_interface	typeref:struct:ovsrec_interface::smap
options	.\ofproto\ofproto-dpif-ipfix.c	/^    struct ofproto_ipfix_bridge_exporter_options *options;$/;"	m	struct:dpif_ipfix_bridge_exporter	typeref:struct:dpif_ipfix_bridge_exporter::ofproto_ipfix_bridge_exporter_options	file:
options	.\ofproto\ofproto-dpif-ipfix.c	/^    struct ofproto_ipfix_flow_exporter_options *options;$/;"	m	struct:dpif_ipfix_flow_exporter	typeref:struct:dpif_ipfix_flow_exporter::ofproto_ipfix_flow_exporter_options	file:
options	.\ofproto\ofproto-dpif-sflow.c	/^    struct ofproto_sflow_options *options;$/;"	m	struct:dpif_sflow	typeref:struct:dpif_sflow::ofproto_sflow_options	file:
options	.\utilities\ovs-dev.py	/^options = None$/;"	v
options	.\utilities\ovs-vsctl.c	/^    const char *options;$/;"	m	struct:vsctl_command_syntax	file:
options	.\utilities\ovs-vsctl.c	/^    struct shash options;$/;"	m	struct:vsctl_command	typeref:struct:vsctl_command::shash	file:
options	.\utilities\ovs-vsctl.c	/^    struct shash options;$/;"	m	struct:vsctl_context	typeref:struct:vsctl_context::shash	file:
options	.\vtep\vtep-ctl.c	/^    const char *options;$/;"	m	struct:vtep_ctl_command_syntax	file:
options	.\vtep\vtep-ctl.c	/^    struct shash options;$/;"	m	struct:vtep_ctl_command	typeref:struct:vtep_ctl_command::shash	file:
options	.\vtep\vtep-ctl.c	/^    struct shash options;$/;"	m	struct:vtep_ctl_context	typeref:struct:vtep_ctl_context::shash	file:
options_len	.\lib\dpif-linux.h	/^    size_t options_len;$/;"	m	struct:dpif_linux_vport
optopt	.\lib\getopt_long.c	/^int	optopt = '?';		\/* character checked for validity *\/$/;"	v
optparse	.\utilities\ovs-dev.py	/^import optparse$/;"	i
optreset	.\lib\getopt_long.c	/^int	optreset;		\/* reset getopt *\/$/;"	v
opup	.\lib\cfm.c	/^    bool opup;             \/* Operational State. *\/$/;"	m	struct:cfm	file:
opup	.\lib\cfm.c	/^    bool opup;           \/* Operational State. *\/$/;"	m	struct:remote_mp	file:
opup	.\lib\cfm.h	/^    bool opup;                  \/* Operational State. *\/$/;"	m	struct:cfm_settings
order	.\utilities\ovs-ofctl.c	/^    enum sort_order order;$/;"	m	struct:sort_criterion	typeref:enum:sort_criterion::sort_order	file:
orig_len	.\lib\pcap-file.c	/^    uint32_t orig_len;       \/* actual length of packet *\/$/;"	m	struct:pcaprec_hdr	file:
orig_skb_priority	.\ofproto\ofproto-dpif-xlate.c	/^    uint32_t orig_skb_priority; \/* Priority when packet arrived. *\/$/;"	m	struct:xlate_ctx	file:
orig_tunnel_ip_dst	.\ofproto\ofproto-dpif-xlate.c	/^    ovs_be32 orig_tunnel_ip_dst;$/;"	m	struct:xlate_ctx	file:
os	.\python\compat\uuid.py	/^        import os$/;"	i
os	.\python\compat\uuid.py	/^    import os$/;"	i
os	.\python\compat\uuid.py	/^    import os, re$/;"	i
os	.\python\ovs\daemon.py	/^import os$/;"	i
os	.\python\ovs\dirs.py	/^import os$/;"	i
os	.\python\ovs\fatal_signal.py	/^import os$/;"	i
os	.\python\ovs\jsonrpc.py	/^import os$/;"	i
os	.\python\ovs\process.py	/^import os$/;"	i
os	.\python\ovs\reconnect.py	/^import os$/;"	i
os	.\python\ovs\socket_util.py	/^import os$/;"	i
os	.\python\ovs\socket_util.py	/^import os.path$/;"	i
os	.\python\ovs\stream.py	/^import os$/;"	i
os	.\python\ovs\unixctl\client.py	/^import os$/;"	i
os	.\python\ovs\unixctl\server.py	/^import os$/;"	i
os	.\python\ovs\util.py	/^import os$/;"	i
os	.\python\ovs\util.py	/^import os.path$/;"	i
os	.\python\ovs\vlog.py	/^import os$/;"	i
os	.\python\ovstest\util.py	/^import os$/;"	i
os	.\tests\test-jsonrpc.py	/^import os$/;"	i
os	.\tests\test-ovsdb.py	/^import os$/;"	i
os	.\tests\test-unix-socket.py	/^import os$/;"	i
os	.\utilities\ovs-dev.py	/^import os$/;"	i
os	.\xenserver\opt_xensource_libexec_InterfaceReconfigure.py	/^import os$/;"	i
os	.\xenserver\opt_xensource_libexec_InterfaceReconfigureVswitch.py	/^import os$/;"	i
os	.\xenserver\usr_lib_xsconsole_plugins-base_XSFeatureVSwitch.py	/^import os$/;"	i
osm	.\include\openflow\openflow-1.0.h	/^    struct ofp10_stats_msg osm; \/* Type OFPST_VENDOR. *\/$/;"	m	struct:ofp10_vendor_stats_msg	typeref:struct:ofp10_vendor_stats_msg::ofp10_stats_msg
osm	.\include\openflow\openflow-1.1.h	/^    struct ofp11_stats_msg osm; \/* Type OFPST_VENDOR. *\/$/;"	m	struct:ofp11_vendor_stats_msg	typeref:struct:ofp11_vendor_stats_msg::ofp11_stats_msg
other_config	.\lib\vswitch-idl.h	/^	struct smap other_config;$/;"	m	struct:ovsrec_bridge	typeref:struct:ovsrec_bridge::smap
other_config	.\lib\vswitch-idl.h	/^	struct smap other_config;$/;"	m	struct:ovsrec_controller	typeref:struct:ovsrec_controller::smap
other_config	.\lib\vswitch-idl.h	/^	struct smap other_config;$/;"	m	struct:ovsrec_interface	typeref:struct:ovsrec_interface::smap
other_config	.\lib\vswitch-idl.h	/^	struct smap other_config;$/;"	m	struct:ovsrec_manager	typeref:struct:ovsrec_manager::smap
other_config	.\lib\vswitch-idl.h	/^	struct smap other_config;$/;"	m	struct:ovsrec_open_vswitch	typeref:struct:ovsrec_open_vswitch::smap
other_config	.\lib\vswitch-idl.h	/^	struct smap other_config;$/;"	m	struct:ovsrec_port	typeref:struct:ovsrec_port::smap
other_config	.\lib\vswitch-idl.h	/^	struct smap other_config;$/;"	m	struct:ovsrec_qos	typeref:struct:ovsrec_qos::smap
other_config	.\lib\vswitch-idl.h	/^	struct smap other_config;$/;"	m	struct:ovsrec_queue	typeref:struct:ovsrec_queue::smap
other_config	.\lib\vtep-idl.h	/^	struct smap other_config;$/;"	m	struct:vteprec_manager	typeref:struct:vteprec_manager::smap
other_tc_load	.\lib\netdev-linux.c	/^other_tc_load(struct netdev *netdev_, struct ofpbuf *nlmsg OVS_UNUSED)$/;"	f	file:
out	.\ofproto\ofproto-dpif-mirror.c	/^    struct mbundle *out;        \/* Output port or NULL. *\/$/;"	m	struct:mirror	typeref:struct:mirror::mbundle	file:
out_bundle	.\ofproto\ofproto.h	/^    void *out_bundle;           \/* A registered ofbundle handle or NULL. *\/$/;"	m	struct:ofproto_mirror_settings
out_group	.\include\openflow\openflow-1.1.h	/^    ovs_be32 out_group;          \/* For OFPFC_DELETE* commands, require$/;"	m	struct:ofp11_flow_mod
out_group	.\include\openflow\openflow-1.1.h	/^    ovs_be32 out_group;       \/* Require matching entries to include this$/;"	m	struct:ofp11_flow_stats_request
out_group	.\lib\ofp-util.h	/^    uint32_t out_group;$/;"	m	struct:ofputil_flow_mod
out_group	.\lib\ofp-util.h	/^    uint32_t out_group;$/;"	m	struct:ofputil_flow_stats_request
out_group	.\ofproto\ofproto.c	/^    uint32_t out_group;$/;"	m	struct:rule_criteria	file:
out_key	.\lib\netdev.h	/^    ovs_be64 out_key;$/;"	m	struct:netdev_tunnel_config
out_key_flow	.\lib\netdev.h	/^    bool out_key_flow;$/;"	m	struct:netdev_tunnel_config
out_key_present	.\lib\netdev.h	/^    bool out_key_present;$/;"	m	struct:netdev_tunnel_config
out_of_memory	.\lib\util.c	/^out_of_memory(void)$/;"	f
out_ofport	.\ofproto\bond.c	/^    ofp_port_t out_ofport;$/;"	m	struct:bond_pr_rule_op	file:
out_port	.\include\openflow\nicira-ext.h	/^    ovs_be16 out_port;            \/* For OFPFC_DELETE* commands, require$/;"	m	struct:nx_flow_mod
out_port	.\include\openflow\nicira-ext.h	/^    ovs_be16 out_port;          \/* Required output port, if not OFPP_NONE. *\/$/;"	m	struct:nx_flow_monitor_request
out_port	.\include\openflow\nicira-ext.h	/^    ovs_be16 out_port;        \/* Require matching entries to include this$/;"	m	struct:nx_aggregate_stats_request
out_port	.\include\openflow\nicira-ext.h	/^    ovs_be16 out_port;        \/* Require matching entries to include this$/;"	m	struct:nx_flow_stats_request
out_port	.\include\openflow\openflow-1.0.h	/^    ovs_be16 out_port;            \/* For OFPFC_DELETE* commands, require$/;"	m	struct:ofp10_flow_mod
out_port	.\include\openflow\openflow-1.0.h	/^    ovs_be16 out_port;        \/* Require matching entries to include this$/;"	m	struct:ofp10_flow_stats_request
out_port	.\include\openflow\openflow-1.1.h	/^    ovs_be32 out_port;           \/* For OFPFC_DELETE* commands, require$/;"	m	struct:ofp11_flow_mod
out_port	.\include\openflow\openflow-1.1.h	/^    ovs_be32 out_port;        \/* Require matching entries to include this$/;"	m	struct:ofp11_flow_stats_request
out_port	.\lib\ofp-util.h	/^    ofp_port_t out_port;$/;"	m	struct:ofputil_flow_mod
out_port	.\lib\ofp-util.h	/^    ofp_port_t out_port;$/;"	m	struct:ofputil_flow_monitor_request
out_port	.\lib\ofp-util.h	/^    ofp_port_t out_port;$/;"	m	struct:ofputil_flow_stats_request
out_port	.\ofproto\connmgr.h	/^    ofp_port_t out_port;$/;"	m	struct:ofmonitor
out_port	.\ofproto\ofproto.c	/^    ofp_port_t out_port;$/;"	m	struct:rule_criteria	file:
out_stack	.\lib\sflow.h	/^    SFLLabelStack out_stack;$/;"	m	struct:_SFLExtended_mpls
out_vlan	.\ofproto\ofproto-dpif-mirror.c	/^    int out_vlan;               \/* Output VLAN or -1. *\/$/;"	m	struct:mirror	file:
out_vlan	.\ofproto\ofproto.h	/^    uint16_t out_vlan;          \/* Output VLAN, only if out_bundle is NULL. *\/$/;"	m	struct:ofproto_mirror_settings
output	.\lib\jsonrpc.c	/^    struct list output;         \/* Contains "struct ofpbuf"s. *\/$/;"	m	struct:jsonrpc	typeref:struct:jsonrpc::list	file:
output	.\lib\netflow.h	/^    ovs_be16 output;               \/* Output interface index. *\/$/;"	m	struct:netflow_v5_record
output	.\lib\odp-util.h	/^        uint32_t output;        \/* SFL_FLOW_SAMPLE_TYPE 'output' value. *\/$/;"	m	struct:user_action_cookie::__anon69
output	.\lib\sflow.h	/^    u_int32_t output;               \/* SNMP ifIndex of output interface,$/;"	m	struct:_SFLFlow_sample
output	.\lib\sflow.h	/^    u_int32_t output;               \/* SNMP ifIndex of output interface,$/;"	m	struct:_SFLFlow_sample_expanded
output	.\tests\flowgen.pl	/^sub output {$/;"	s
output	.\tests\test-sha1.c	/^    const uint8_t output[20];$/;"	m	struct:test_vector	file:
output	.\utilities\ovs-vsctl.c	/^    struct ds output;$/;"	m	struct:vsctl_command	typeref:struct:vsctl_command::ds	file:
output	.\utilities\ovs-vsctl.c	/^    struct ds output;$/;"	m	struct:vsctl_context	typeref:struct:vsctl_context::ds	file:
output	.\vtep\vtep-ctl.c	/^    struct ds output;$/;"	m	struct:vtep_ctl_command	typeref:struct:vtep_ctl_command::ds	file:
output	.\vtep\vtep-ctl.c	/^    struct ds output;$/;"	m	struct:vtep_ctl_context	typeref:struct:vtep_ctl_context::ds	file:
output10	.\lib\ofp-actions.c	/^    struct ofp10_action_output output10;$/;"	m	union:ofp_action	typeref:struct:ofp_action::ofp10_action_output	file:
outputFormat	.\lib\sflow.h	/^    u_int32_t outputFormat;         \/* EXPANDED *\/$/;"	m	struct:_SFLFlow_sample_expanded
outputPort	.\tests\test-sflow.c	/^    uint32_t outputPort;$/;"	m	struct:sflow_xdr	file:
outputPortFormat	.\tests\test-sflow.c	/^    uint32_t outputPortFormat;$/;"	m	struct:sflow_xdr	file:
output_count	.\lib\jsonrpc.c	/^    size_t output_count;        \/* Number of elements in "output". *\/$/;"	m	struct:jsonrpc	file:
output_from_openflow10	.\lib\ofp-actions.c	/^output_from_openflow10(const struct ofp10_action_output *oao,$/;"	f	file:
output_from_openflow11	.\lib\ofp-actions.c	/^output_from_openflow11(const struct ofp11_action_output *oao,$/;"	f	file:
output_group	.\tests\ovsdb-monitor-sort.pl	/^sub output_group {$/;"	s
output_iface	.\ofproto\netflow.c	/^    ofp_port_t output_iface;      \/* Output interface index. *\/$/;"	m	struct:netflow_flow	file:
output_normal	.\ofproto\ofproto-dpif-xlate.c	/^output_normal(struct xlate_ctx *ctx, const struct xbundle *out_xbundle,$/;"	f	file:
output_port	.\lib\vswitch-idl.h	/^	struct ovsrec_port *output_port;$/;"	m	struct:ovsrec_mirror	typeref:struct:ovsrec_mirror::ovsrec_port
output_reg	.\lib\ofp-actions.c	/^    struct nx_action_output_reg output_reg;$/;"	m	union:ofp_action	typeref:struct:ofp_action::nx_action_output_reg	file:
output_reg_from_openflow	.\lib\ofp-actions.c	/^output_reg_from_openflow(const struct nx_action_output_reg *naor,$/;"	f	file:
output_sorted	.\utilities\ovs-vsctl.c	/^output_sorted(struct svec *svec, struct ds *output)$/;"	f	file:
output_sorted	.\vtep\vtep-ctl.c	/^output_sorted(struct svec *svec, struct ds *output)$/;"	f	file:
output_userspace	.\datapath\actions.c	/^static int output_userspace(struct datapath *dp, struct sk_buff *skb,$/;"	f	file:
output_vlan	.\lib\vswitch-idl.h	/^	int64_t *output_vlan;$/;"	m	struct:ovsrec_mirror
output_vlan_to_vid	.\ofproto\ofproto-dpif-xlate.c	/^output_vlan_to_vid(const struct xbundle *out_xbundle, uint16_t vlan)$/;"	f	file:
outstanding_txns	.\lib\ovsdb-idl.c	/^    struct hmap outstanding_txns;$/;"	m	struct:ovsdb_idl	typeref:struct:ovsdb_idl::hmap	file:
overflow_policy	.\lib\vswitch-idl.h	/^	char *overflow_policy;$/;"	m	struct:ovsrec_flow_table
overwrite_pidfile	.\lib\daemon-unix.c	/^static bool overwrite_pidfile;$/;"	v	file:
ovs	.\python\ovs\daemon.py	/^import ovs.dirs$/;"	i
ovs	.\python\ovs\daemon.py	/^import ovs.fatal_signal$/;"	i
ovs	.\python\ovs\daemon.py	/^import ovs.process$/;"	i
ovs	.\python\ovs\daemon.py	/^import ovs.socket_util$/;"	i
ovs	.\python\ovs\daemon.py	/^import ovs.timeval$/;"	i
ovs	.\python\ovs\daemon.py	/^import ovs.util$/;"	i
ovs	.\python\ovs\daemon.py	/^import ovs.vlog$/;"	i
ovs	.\python\ovs\db\data.py	/^import ovs.db.parser$/;"	i
ovs	.\python\ovs\db\data.py	/^import ovs.db.types$/;"	i
ovs	.\python\ovs\db\data.py	/^import ovs.json$/;"	i
ovs	.\python\ovs\db\data.py	/^import ovs.jsonrpc$/;"	i
ovs	.\python\ovs\db\data.py	/^import ovs.ovsuuid$/;"	i
ovs	.\python\ovs\db\data.py	/^import ovs.poller$/;"	i
ovs	.\python\ovs\db\data.py	/^import ovs.socket_util$/;"	i
ovs	.\python\ovs\db\error.py	/^import ovs.json$/;"	i
ovs	.\python\ovs\db\idl.py	/^import ovs.db.parser$/;"	i
ovs	.\python\ovs\db\idl.py	/^import ovs.db.schema$/;"	i
ovs	.\python\ovs\db\idl.py	/^import ovs.jsonrpc$/;"	i
ovs	.\python\ovs\db\idl.py	/^import ovs.ovsuuid$/;"	i
ovs	.\python\ovs\db\idl.py	/^import ovs.poller$/;"	i
ovs	.\python\ovs\db\idl.py	/^import ovs.vlog$/;"	i
ovs	.\python\ovs\db\schema.py	/^import ovs.db.parser$/;"	i
ovs	.\python\ovs\db\types.py	/^import ovs.db.data$/;"	i
ovs	.\python\ovs\db\types.py	/^import ovs.db.parser$/;"	i
ovs	.\python\ovs\db\types.py	/^import ovs.ovsuuid$/;"	i
ovs	.\python\ovs\fatal_signal.py	/^import ovs.vlog$/;"	i
ovs	.\python\ovs\jsonrpc.py	/^import ovs.json$/;"	i
ovs	.\python\ovs\jsonrpc.py	/^import ovs.poller$/;"	i
ovs	.\python\ovs\jsonrpc.py	/^import ovs.reconnect$/;"	i
ovs	.\python\ovs\jsonrpc.py	/^import ovs.stream$/;"	i
ovs	.\python\ovs\jsonrpc.py	/^import ovs.timeval$/;"	i
ovs	.\python\ovs\jsonrpc.py	/^import ovs.util$/;"	i
ovs	.\python\ovs\jsonrpc.py	/^import ovs.vlog$/;"	i
ovs	.\python\ovs\ovsuuid.py	/^import ovs.db.parser$/;"	i
ovs	.\python\ovs\poller.py	/^import ovs.timeval$/;"	i
ovs	.\python\ovs\poller.py	/^import ovs.vlog$/;"	i
ovs	.\python\ovs\reconnect.py	/^import ovs.util$/;"	i
ovs	.\python\ovs\reconnect.py	/^import ovs.vlog$/;"	i
ovs	.\python\ovs\socket_util.py	/^import ovs.fatal_signal$/;"	i
ovs	.\python\ovs\socket_util.py	/^import ovs.poller$/;"	i
ovs	.\python\ovs\socket_util.py	/^import ovs.vlog$/;"	i
ovs	.\python\ovs\stream.py	/^import ovs.poller$/;"	i
ovs	.\python\ovs\stream.py	/^import ovs.socket_util$/;"	i
ovs	.\python\ovs\stream.py	/^import ovs.vlog$/;"	i
ovs	.\python\ovs\unixctl\__init__.py	/^import ovs.util$/;"	i
ovs	.\python\ovs\unixctl\client.py	/^import ovs.jsonrpc$/;"	i
ovs	.\python\ovs\unixctl\client.py	/^import ovs.stream$/;"	i
ovs	.\python\ovs\unixctl\client.py	/^import ovs.util$/;"	i
ovs	.\python\ovs\unixctl\server.py	/^import ovs.dirs$/;"	i
ovs	.\python\ovs\unixctl\server.py	/^import ovs.jsonrpc$/;"	i
ovs	.\python\ovs\unixctl\server.py	/^import ovs.stream$/;"	i
ovs	.\python\ovs\unixctl\server.py	/^import ovs.unixctl$/;"	i
ovs	.\python\ovs\unixctl\server.py	/^import ovs.util$/;"	i
ovs	.\python\ovs\unixctl\server.py	/^import ovs.version$/;"	i
ovs	.\python\ovs\unixctl\server.py	/^import ovs.vlog$/;"	i
ovs	.\python\ovs\vlog.py	/^import ovs.dirs$/;"	i
ovs	.\python\ovs\vlog.py	/^import ovs.unixctl$/;"	i
ovs	.\python\ovs\vlog.py	/^import ovs.util$/;"	i
ovs	.\tests\appctl.py	/^import ovs.daemon$/;"	i
ovs	.\tests\appctl.py	/^import ovs.unixctl$/;"	i
ovs	.\tests\appctl.py	/^import ovs.unixctl.client$/;"	i
ovs	.\tests\appctl.py	/^import ovs.util$/;"	i
ovs	.\tests\appctl.py	/^import ovs.vlog$/;"	i
ovs	.\tests\test-daemon.py	/^import ovs.daemon$/;"	i
ovs	.\tests\test-daemon.py	/^import ovs.util$/;"	i
ovs	.\tests\test-json.py	/^import ovs.json$/;"	i
ovs	.\tests\test-jsonrpc.py	/^import ovs.daemon$/;"	i
ovs	.\tests\test-jsonrpc.py	/^import ovs.json$/;"	i
ovs	.\tests\test-jsonrpc.py	/^import ovs.jsonrpc$/;"	i
ovs	.\tests\test-jsonrpc.py	/^import ovs.poller$/;"	i
ovs	.\tests\test-jsonrpc.py	/^import ovs.stream$/;"	i
ovs	.\tests\test-ovsdb.py	/^import ovs.db.idl$/;"	i
ovs	.\tests\test-ovsdb.py	/^import ovs.db.schema$/;"	i
ovs	.\tests\test-ovsdb.py	/^import ovs.ovsuuid$/;"	i
ovs	.\tests\test-ovsdb.py	/^import ovs.poller$/;"	i
ovs	.\tests\test-ovsdb.py	/^import ovs.util$/;"	i
ovs	.\tests\test-reconnect.py	/^import ovs.reconnect$/;"	i
ovs	.\tests\test-unix-socket.py	/^import ovs.socket_util$/;"	i
ovs	.\tests\test-unixctl.py	/^import ovs.daemon$/;"	i
ovs	.\tests\test-unixctl.py	/^import ovs.unixctl$/;"	i
ovs	.\tests\test-unixctl.py	/^import ovs.unixctl.server$/;"	i
ovs	.\tests\test-vlog.py	/^import ovs.vlog$/;"	i
ovs	.\utilities\ovs-vsctl.c	/^    const struct ovsrec_open_vswitch *ovs;$/;"	m	struct:vsctl_context	typeref:struct:vsctl_context::ovsrec_open_vswitch	file:
ovs_16aligned_be32	.\include\openvswitch\types.h	/^} ovs_16aligned_be32;$/;"	t	typeref:struct:__anon22
ovs_16aligned_in6_addr	.\lib\packets.h	/^union ovs_16aligned_in6_addr {$/;"	u
ovs_16aligned_ip6_frag	.\lib\packets.h	/^struct ovs_16aligned_ip6_frag {$/;"	s
ovs_16aligned_ip6_hdr	.\lib\packets.h	/^struct ovs_16aligned_ip6_hdr {$/;"	s
ovs_16aligned_ip6_hdrctl	.\lib\packets.h	/^        struct ovs_16aligned_ip6_hdrctl {$/;"	s	union:ovs_16aligned_ip6_hdr::__anon90
ovs_16aligned_u32	.\include\openvswitch\types.h	/^} ovs_16aligned_u32;$/;"	t	typeref:struct:__anon21
ovs_32aligned_be64	.\include\openvswitch\types.h	/^} ovs_32aligned_be64;$/;"	t	typeref:struct:__anon24
ovs_32aligned_u64	.\include\openvswitch\types.h	/^} ovs_32aligned_u64;$/;"	t	typeref:struct:__anon23
ovs_abort	.\lib\util.c	/^ovs_abort(int err_no, const char *format, ...)$/;"	f
ovs_abort_valist	.\lib\util.c	/^ovs_abort_valist(int err_no, const char *format, va_list args)$/;"	f
ovs_action_attr	.\include\linux\openvswitch.h	/^enum ovs_action_attr {$/;"	g
ovs_action_hash	.\include\linux\openvswitch.h	/^struct ovs_action_hash {$/;"	s
ovs_action_push_mpls	.\include\linux\openvswitch.h	/^struct ovs_action_push_mpls {$/;"	s
ovs_action_push_vlan	.\include\linux\openvswitch.h	/^struct ovs_action_push_vlan {$/;"	s
ovs_assert	.\lib\util.h	74;"	d
ovs_assert	.\lib\vlog.c	48;"	d	file:
ovs_assert	.\lib\vlog.c	49;"	d	file:
ovs_assert_failure	.\lib\util.c	/^ovs_assert_failure(const char *where, const char *function,$/;"	f
ovs_barrier	.\lib\ovs-thread.h	/^struct ovs_barrier {$/;"	s
ovs_barrier_block	.\lib\ovs-thread.c	/^ovs_barrier_block(struct ovs_barrier *barrier)$/;"	f
ovs_barrier_destroy	.\lib\ovs-thread.c	/^ovs_barrier_destroy(struct ovs_barrier *barrier)$/;"	f
ovs_barrier_init	.\lib\ovs-thread.c	/^ovs_barrier_init(struct ovs_barrier *barrier, uint32_t size)$/;"	f
ovs_be16	.\include\openvswitch\types.h	/^typedef __be16 ovs_be16;$/;"	t
ovs_be32	.\include\openvswitch\types.h	/^typedef __be32 ovs_be32;$/;"	t
ovs_be64	.\include\openvswitch\types.h	/^typedef __be64 ovs_be64;$/;"	t
ovs_datapath_attr	.\include\linux\openvswitch.h	/^enum ovs_datapath_attr {$/;"	g
ovs_datapath_cmd	.\include\linux\openvswitch.h	/^enum ovs_datapath_cmd {$/;"	g
ovs_datapath_family	.\lib\dpif-linux.c	/^static int ovs_datapath_family;$/;"	v	file:
ovs_delete_bridge	.\utilities\ovs-vsctl.c	/^ovs_delete_bridge(const struct ovsrec_open_vswitch *ovs,$/;"	f	file:
ovs_dp_change	.\datapath\datapath.c	/^static void ovs_dp_change(struct datapath *dp, struct nlattr **a)$/;"	f	file:
ovs_dp_cmd_alloc_info	.\datapath\datapath.c	/^static struct sk_buff *ovs_dp_cmd_alloc_info(struct genl_info *info)$/;"	f	file:
ovs_dp_cmd_del	.\datapath\datapath.c	/^static int ovs_dp_cmd_del(struct sk_buff *skb, struct genl_info *info)$/;"	f	file:
ovs_dp_cmd_dump	.\datapath\datapath.c	/^static int ovs_dp_cmd_dump(struct sk_buff *skb, struct netlink_callback *cb)$/;"	f	file:
ovs_dp_cmd_fill_info	.\datapath\datapath.c	/^static int ovs_dp_cmd_fill_info(struct datapath *dp, struct sk_buff *skb,$/;"	f	file:
ovs_dp_cmd_get	.\datapath\datapath.c	/^static int ovs_dp_cmd_get(struct sk_buff *skb, struct genl_info *info)$/;"	f	file:
ovs_dp_cmd_msg_size	.\datapath\datapath.c	/^static size_t ovs_dp_cmd_msg_size(void)$/;"	f	file:
ovs_dp_cmd_new	.\datapath\datapath.c	/^static int ovs_dp_cmd_new(struct sk_buff *skb, struct genl_info *info)$/;"	f	file:
ovs_dp_cmd_set	.\datapath\datapath.c	/^static int ovs_dp_cmd_set(struct sk_buff *skb, struct genl_info *info)$/;"	f	file:
ovs_dp_datapath_multicast_group	.\datapath\datapath.c	/^static struct genl_multicast_group ovs_dp_datapath_multicast_group = {$/;"	v	typeref:struct:genl_multicast_group	file:
ovs_dp_detach_port	.\datapath\datapath.c	/^void ovs_dp_detach_port(struct vport *p)$/;"	f
ovs_dp_device_notifier	.\datapath\dp_notify.c	/^struct notifier_block ovs_dp_device_notifier = {$/;"	v	typeref:struct:notifier_block
ovs_dp_flow_multicast_group	.\datapath\datapath.c	/^static struct genl_multicast_group ovs_dp_flow_multicast_group = {$/;"	v	typeref:struct:genl_multicast_group	file:
ovs_dp_get_net	.\datapath\datapath.h	/^static inline struct net *ovs_dp_get_net(struct datapath *dp)$/;"	f
ovs_dp_megaflow_stats	.\include\linux\openvswitch.h	/^struct ovs_dp_megaflow_stats {$/;"	s
ovs_dp_name	.\datapath\datapath.c	/^const char *ovs_dp_name(const struct datapath *dp)$/;"	f
ovs_dp_notify_wq	.\datapath\dp_notify.c	/^void ovs_dp_notify_wq(struct work_struct *work)$/;"	f
ovs_dp_process_packet_with_key	.\datapath\datapath.c	/^void ovs_dp_process_packet_with_key(struct sk_buff *skb,$/;"	f
ovs_dp_process_received_packet	.\datapath\datapath.c	/^void ovs_dp_process_received_packet(struct vport *p, struct sk_buff *skb)$/;"	f
ovs_dp_reset_user_features	.\datapath\datapath.c	/^static void ovs_dp_reset_user_features(struct sk_buff *skb, struct genl_info *info)$/;"	f	file:
ovs_dp_set_net	.\datapath\datapath.h	/^static inline void ovs_dp_set_net(struct datapath *dp, struct net *net)$/;"	f
ovs_dp_stats	.\include\linux\openvswitch.h	/^struct ovs_dp_stats {$/;"	s
ovs_dp_upcall	.\datapath\datapath.c	/^int ovs_dp_upcall(struct datapath *dp, struct sk_buff *skb,$/;"	f
ovs_dp_vport_multicast_group	.\datapath\datapath.c	/^struct genl_multicast_group ovs_dp_vport_multicast_group = {$/;"	v	typeref:struct:genl_multicast_group
ovs_error	.\lib\util.c	/^ovs_error(int err_no, const char *format, ...)$/;"	f
ovs_error	.\python\ovs\util.py	/^def ovs_error(err_no, message, vlog=None):$/;"	f
ovs_error_valist	.\lib\util.c	/^ovs_error_valist(int err_no, const char *format, va_list args)$/;"	f
ovs_execute_actions	.\datapath\actions.c	/^int ovs_execute_actions(struct datapath *dp, struct sk_buff *skb, bool recirc)$/;"	f
ovs_exit_net	.\datapath\datapath.c	/^static void __net_exit ovs_exit_net(struct net *net)$/;"	f	file:
ovs_fatal	.\lib\util.c	/^ovs_fatal(int err_no, const char *format, ...)$/;"	f
ovs_fatal	.\python\ovs\util.py	/^def ovs_fatal(*args, **kwargs):$/;"	f
ovs_fatal	.\utilities\ovs-vsctl.c	56;"	d	file:
ovs_fatal	.\vtep\vtep-ctl.c	56;"	d	file:
ovs_fatal_valist	.\lib\util.c	/^ovs_fatal_valist(int err_no, const char *format, va_list args)$/;"	f
ovs_flow_alloc	.\datapath\flow_table.c	/^struct sw_flow *ovs_flow_alloc(void)$/;"	f
ovs_flow_attr	.\include\linux\openvswitch.h	/^enum ovs_flow_attr {$/;"	g
ovs_flow_cmd	.\include\linux\openvswitch.h	/^enum ovs_flow_cmd {$/;"	g
ovs_flow_cmd_alloc_info	.\datapath\datapath.c	/^static struct sk_buff *ovs_flow_cmd_alloc_info(const struct sw_flow_actions *acts,$/;"	f	file:
ovs_flow_cmd_build_info	.\datapath\datapath.c	/^static struct sk_buff *ovs_flow_cmd_build_info(const struct sw_flow *flow,$/;"	f	file:
ovs_flow_cmd_del	.\datapath\datapath.c	/^static int ovs_flow_cmd_del(struct sk_buff *skb, struct genl_info *info)$/;"	f	file:
ovs_flow_cmd_dump	.\datapath\datapath.c	/^static int ovs_flow_cmd_dump(struct sk_buff *skb, struct netlink_callback *cb)$/;"	f	file:
ovs_flow_cmd_fill_info	.\datapath\datapath.c	/^static int ovs_flow_cmd_fill_info(const struct sw_flow *flow, int dp_ifindex,$/;"	f	file:
ovs_flow_cmd_get	.\datapath\datapath.c	/^static int ovs_flow_cmd_get(struct sk_buff *skb, struct genl_info *info)$/;"	f	file:
ovs_flow_cmd_msg_size	.\datapath\datapath.c	/^static size_t ovs_flow_cmd_msg_size(const struct sw_flow_actions *acts)$/;"	f	file:
ovs_flow_cmd_new	.\datapath\datapath.c	/^static int ovs_flow_cmd_new(struct sk_buff *skb, struct genl_info *info)$/;"	f	file:
ovs_flow_cmd_set	.\datapath\datapath.c	/^static int ovs_flow_cmd_set(struct sk_buff *skb, struct genl_info *info)$/;"	f	file:
ovs_flow_cmp_unmasked_key	.\datapath\flow_table.c	/^bool ovs_flow_cmp_unmasked_key(const struct sw_flow *flow,$/;"	f
ovs_flow_exit	.\datapath\flow_table.c	/^void ovs_flow_exit(void)$/;"	f
ovs_flow_family	.\lib\dpif-linux.c	/^static int ovs_flow_family;$/;"	v	file:
ovs_flow_free	.\datapath\flow_table.c	/^void ovs_flow_free(struct sw_flow *flow, bool deferred)$/;"	f
ovs_flow_hash	.\datapath\flow.h	/^	u32 ovs_flow_hash;		\/* Datapath computed hash value.  *\/$/;"	m	struct:sw_flow_key
ovs_flow_init	.\datapath\flow_table.c	/^int ovs_flow_init(void)$/;"	f
ovs_flow_key_extract	.\datapath\flow.c	/^int ovs_flow_key_extract(struct sk_buff *skb, struct sw_flow_key *key)$/;"	f
ovs_flow_key_extract_recirc	.\datapath\flow.c	/^int ovs_flow_key_extract_recirc(u32 recirc_id,$/;"	f
ovs_flow_key_extract_userspace	.\datapath\flow.c	/^int ovs_flow_key_extract_userspace(const struct nlattr *attr,$/;"	f
ovs_flow_mask_key	.\datapath\flow_table.c	/^void ovs_flow_mask_key(struct sw_flow_key *dst, const struct sw_flow_key *src,$/;"	f
ovs_flow_stats	.\include\linux\openvswitch.h	/^struct ovs_flow_stats {$/;"	s
ovs_flow_stats_clear	.\datapath\flow.c	/^void ovs_flow_stats_clear(struct sw_flow *flow)$/;"	f
ovs_flow_stats_get	.\datapath\flow.c	/^void ovs_flow_stats_get(const struct sw_flow *flow,$/;"	f
ovs_flow_stats_update	.\datapath\flow.c	/^void ovs_flow_stats_update(struct sw_flow *flow, __be16 tcp_flags,$/;"	f
ovs_flow_tbl_count	.\datapath\flow_table.c	/^int ovs_flow_tbl_count(struct flow_table *table)$/;"	f
ovs_flow_tbl_destroy	.\datapath\flow_table.c	/^void ovs_flow_tbl_destroy(struct flow_table *table)$/;"	f
ovs_flow_tbl_dump_next	.\datapath\flow_table.c	/^struct sw_flow *ovs_flow_tbl_dump_next(struct table_instance *ti,$/;"	f
ovs_flow_tbl_flush	.\datapath\flow_table.c	/^int ovs_flow_tbl_flush(struct flow_table *flow_table)$/;"	f
ovs_flow_tbl_init	.\datapath\flow_table.c	/^int ovs_flow_tbl_init(struct flow_table *table)$/;"	f
ovs_flow_tbl_insert	.\datapath\flow_table.c	/^int ovs_flow_tbl_insert(struct flow_table *table, struct sw_flow *flow,$/;"	f
ovs_flow_tbl_lookup	.\datapath\flow_table.c	/^struct sw_flow *ovs_flow_tbl_lookup(struct flow_table *tbl,$/;"	f
ovs_flow_tbl_lookup_exact	.\datapath\flow_table.c	/^struct sw_flow *ovs_flow_tbl_lookup_exact(struct flow_table *tbl,$/;"	f
ovs_flow_tbl_lookup_stats	.\datapath\flow_table.c	/^struct sw_flow *ovs_flow_tbl_lookup_stats(struct flow_table *tbl,$/;"	f
ovs_flow_tbl_num_masks	.\datapath\flow_table.c	/^int ovs_flow_tbl_num_masks(const struct flow_table *table)$/;"	f
ovs_flow_tbl_remove	.\datapath\flow_table.c	/^void ovs_flow_tbl_remove(struct flow_table *table, struct sw_flow *flow)$/;"	f
ovs_flow_tun_key_init	.\datapath\flow.h	/^static inline void ovs_flow_tun_key_init(struct ovs_key_ipv4_tunnel *tun_key,$/;"	f
ovs_flow_used_time	.\datapath\flow.c	/^u64 ovs_flow_used_time(unsigned long flow_jiffies)$/;"	f
ovs_format_message	.\lib\util.c	/^ovs_format_message(int error)$/;"	f
ovs_frag_type	.\include\linux\openvswitch.h	/^enum ovs_frag_type {$/;"	g
ovs_frag_type_from_string	.\lib\odp-util.c	/^ovs_frag_type_from_string(const char *s, enum ovs_frag_type *type)$/;"	f	file:
ovs_frag_type_to_string	.\lib\odp-util.c	/^ovs_frag_type_to_string(enum ovs_frag_type type)$/;"	f	file:
ovs_get_physical_interface	.\python\ovstest\vswitch.py	/^def ovs_get_physical_interface(bridge):$/;"	f
ovs_gre64_vport_ops	.\datapath\vport-gre.c	/^const struct vport_ops ovs_gre64_vport_ops = {$/;"	v	typeref:struct:vport_ops
ovs_gre_vport_ops	.\datapath\vport-gre.c	/^const struct vport_ops ovs_gre_vport_ops = {$/;"	v	typeref:struct:vport_ops
ovs_gso_cb	.\datapath\linux\compat\gso.h	/^struct ovs_gso_cb {$/;"	s
ovs_hash_alg	.\include\linux\openvswitch.h	/^enum ovs_hash_alg {$/;"	g
ovs_header	.\include\linux\openvswitch.h	/^struct ovs_header {$/;"	s
ovs_hex_dump	.\lib\util.c	/^ovs_hex_dump(FILE *stream, const void *buf_, size_t size,$/;"	f
ovs_init_net	.\datapath\datapath.c	/^static int __net_init ovs_init_net(struct net *net)$/;"	f	file:
ovs_initialize_args	.\python\ovstest\args.py	/^def ovs_initialize_args():$/;"	f
ovs_insert_bridge	.\utilities\ovs-vsctl.c	/^ovs_insert_bridge(const struct ovsrec_open_vswitch *ovs,$/;"	f	file:
ovs_instruction_name_from_type	.\lib\ofp-actions.c	/^ovs_instruction_name_from_type(enum ovs_instruction_type type)$/;"	f
ovs_instruction_type	.\lib\ofp-actions.h	/^enum ovs_instruction_type {$/;"	g
ovs_instruction_type_from_inst_type	.\lib\ofp-actions.c	/^ovs_instruction_type_from_inst_type(enum ovs_instruction_type *instruction_type,$/;"	f
ovs_instruction_type_from_name	.\lib\ofp-actions.c	/^ovs_instruction_type_from_name(const char *name)$/;"	f
ovs_instruction_type_from_ofpact_type	.\lib\ofp-actions.c	/^ovs_instruction_type_from_ofpact_type(enum ofpact_type type)$/;"	f
ovs_internal_dev_get_vport	.\datapath\vport-internal_dev.c	/^struct vport *ovs_internal_dev_get_vport(struct net_device *netdev)$/;"	f
ovs_internal_vport_ops	.\datapath\vport-internal_dev.c	/^const struct vport_ops ovs_internal_vport_ops = {$/;"	v	typeref:struct:vport_ops
ovs_is_internal_dev	.\datapath\vport-internal_dev.c	/^int ovs_is_internal_dev(const struct net_device *netdev)$/;"	f
ovs_key_arp	.\include\linux\openvswitch.h	/^struct ovs_key_arp {$/;"	s
ovs_key_attr	.\include\linux\openvswitch.h	/^enum ovs_key_attr {$/;"	g
ovs_key_attr_to_string	.\lib\odp-util.c	/^ovs_key_attr_to_string(enum ovs_key_attr attr, char *namebuf, size_t bufsize)$/;"	f	file:
ovs_key_ethernet	.\include\linux\openvswitch.h	/^struct ovs_key_ethernet {$/;"	s
ovs_key_from_nlattrs	.\datapath\flow_netlink.c	/^static int ovs_key_from_nlattrs(struct sw_flow_match *match, u64 attrs,$/;"	f	file:
ovs_key_icmp	.\include\linux\openvswitch.h	/^struct ovs_key_icmp {$/;"	s
ovs_key_icmpv6	.\include\linux\openvswitch.h	/^struct ovs_key_icmpv6 {$/;"	s
ovs_key_ipv4	.\include\linux\openvswitch.h	/^struct ovs_key_ipv4 {$/;"	s
ovs_key_ipv4_tunnel	.\datapath\flow.h	/^struct ovs_key_ipv4_tunnel {$/;"	s
ovs_key_ipv6	.\include\linux\openvswitch.h	/^struct ovs_key_ipv6 {$/;"	s
ovs_key_lens	.\datapath\flow_netlink.c	/^static const int ovs_key_lens[OVS_KEY_ATTR_MAX + 1] = {$/;"	v	file:
ovs_key_mpls	.\include\linux\openvswitch.h	/^struct ovs_key_mpls {$/;"	s
ovs_key_nd	.\include\linux\openvswitch.h	/^struct ovs_key_nd {$/;"	s
ovs_key_sctp	.\include\linux\openvswitch.h	/^struct ovs_key_sctp {$/;"	s
ovs_key_tcp	.\include\linux\openvswitch.h	/^struct ovs_key_tcp {$/;"	s
ovs_key_udp	.\include\linux\openvswitch.h	/^struct ovs_key_udp {$/;"	s
ovs_lasterror_to_string	.\lib\util.c	/^ovs_lasterror_to_string(void)$/;"	f
ovs_lisp_vport_ops	.\datapath\vport-lisp.c	/^const struct vport_ops ovs_lisp_vport_ops = {$/;"	v	typeref:struct:vport_ops
ovs_lock	.\datapath\datapath.c	/^void ovs_lock(void)$/;"	f
ovs_lookup_vport	.\datapath\datapath.c	/^struct vport *ovs_lookup_vport(const struct datapath *dp, u16 port_no)$/;"	f
ovs_match_init	.\datapath\flow_netlink.c	/^void ovs_match_init(struct sw_flow_match *match,$/;"	f
ovs_must_notify	.\datapath\datapath.c	/^static bool ovs_must_notify(struct genl_info *info,$/;"	f	file:
ovs_mutex	.\lib\ovs-thread.h	/^struct OVS_LOCKABLE ovs_mutex {$/;"	s
ovs_mutex_cond_wait	.\lib\ovs-thread.c	/^ovs_mutex_cond_wait(pthread_cond_t *cond, const struct ovs_mutex *mutex_)$/;"	f
ovs_mutex_init	.\lib\ovs-thread.c	/^ovs_mutex_init(const struct ovs_mutex *mutex)$/;"	f
ovs_mutex_init__	.\lib\ovs-thread.c	/^ovs_mutex_init__(const struct ovs_mutex *l_, int type)$/;"	f	file:
ovs_mutex_init_adaptive	.\lib\ovs-thread.c	/^ovs_mutex_init_adaptive(const struct ovs_mutex *mutex)$/;"	f
ovs_mutex_init_recursive	.\lib\ovs-thread.c	/^ovs_mutex_init_recursive(const struct ovs_mutex *mutex)$/;"	f
ovs_mutex_lock	.\lib\ovs-thread.h	68;"	d
ovs_mutex_trylock	.\lib\ovs-thread.h	73;"	d
ovs_name	.\lib\netdev-linux.c	/^    const char *ovs_name;$/;"	m	struct:tc_ops	file:
ovs_net	.\datapath\datapath.h	/^struct ovs_net {$/;"	s
ovs_net_ops	.\datapath\datapath.c	/^static struct pernet_operations ovs_net_ops = {$/;"	v	typeref:struct:pernet_operations	file:
ovs_netdev_detach_dev	.\datapath\vport-netdev.c	/^void ovs_netdev_detach_dev(struct vport *vport)$/;"	f
ovs_netdev_get_name	.\datapath\vport-netdev.c	/^const char *ovs_netdev_get_name(const struct vport *vport)$/;"	f
ovs_netdev_get_vport	.\datapath\vport-netdev.c	/^struct vport *ovs_netdev_get_vport(struct net_device *dev)$/;"	f
ovs_netdev_vport_ops	.\datapath\vport-netdev.c	/^const struct vport_ops ovs_netdev_vport_ops = {$/;"	v	typeref:struct:vport_ops
ovs_nla_alloc_flow_actions	.\datapath\flow_netlink.c	/^struct sw_flow_actions *ovs_nla_alloc_flow_actions(int size)$/;"	f
ovs_nla_copy_actions	.\datapath\flow_netlink.c	/^int ovs_nla_copy_actions(const struct nlattr *attr,$/;"	f
ovs_nla_free_flow_actions	.\datapath\flow_netlink.c	/^void ovs_nla_free_flow_actions(struct sw_flow_actions *sf_acts)$/;"	f
ovs_nla_get_flow_metadata	.\datapath\flow_netlink.c	/^int ovs_nla_get_flow_metadata(const struct nlattr *attr,$/;"	f
ovs_nla_get_match	.\datapath\flow_netlink.c	/^int ovs_nla_get_match(struct sw_flow_match *match,$/;"	f
ovs_nla_put_actions	.\datapath\flow_netlink.c	/^int ovs_nla_put_actions(const struct nlattr *attr, int len, struct sk_buff *skb)$/;"	f
ovs_nla_put_flow	.\datapath\flow_netlink.c	/^int ovs_nla_put_flow(const struct sw_flow_key *swkey,$/;"	f
ovs_notify	.\datapath\datapath.c	/^static void ovs_notify(struct genl_family *family, struct genl_multicast_group *grp,$/;"	f	file:
ovs_packet_attr	.\include\linux\openvswitch.h	/^enum ovs_packet_attr {$/;"	g
ovs_packet_cmd	.\include\linux\openvswitch.h	/^enum ovs_packet_cmd {$/;"	g
ovs_packet_cmd_execute	.\datapath\datapath.c	/^static int ovs_packet_cmd_execute(struct sk_buff *skb, struct genl_info *info)$/;"	f	file:
ovs_packet_family	.\lib\dpif-linux.c	/^static int ovs_packet_family;$/;"	v	file:
ovs_pcap_open	.\lib\pcap-file.c	/^ovs_pcap_open(const char *file_name, const char *mode)$/;"	f
ovs_pcap_read	.\lib\pcap-file.c	/^ovs_pcap_read(FILE *file, struct ofpbuf **bufp, long long int *when)$/;"	f
ovs_pcap_read_header	.\lib\pcap-file.c	/^ovs_pcap_read_header(FILE *file)$/;"	f
ovs_pcap_write	.\lib\pcap-file.c	/^ovs_pcap_write(FILE *file, struct ofpbuf *buf)$/;"	f
ovs_pcap_write_header	.\lib\pcap-file.c	/^ovs_pcap_write_header(FILE *file)$/;"	f
ovs_prefetch_range	.\lib\util.h	/^ovs_prefetch_range(const void *start, size_t size)$/;"	f
ovs_print_version	.\lib\util.c	/^ovs_print_version(uint8_t min_ofp, uint8_t max_ofp)$/;"	f
ovs_pyfiles	.\python\automake.mk	/^ovs_pyfiles = \\$/;"	m
ovs_rcu	.\lib\ovs-rcu.c	/^VLOG_DEFINE_THIS_MODULE(ovs_rcu);$/;"	v
ovs_refcount	.\lib\ovs-atomic.h	/^struct ovs_refcount {$/;"	s
ovs_refcount_init	.\lib\ovs-atomic.h	/^ovs_refcount_init(struct ovs_refcount *refcount)$/;"	f
ovs_refcount_read	.\lib\ovs-atomic.h	/^ovs_refcount_read(const struct ovs_refcount *refcount_)$/;"	f
ovs_refcount_ref	.\lib\ovs-atomic.h	/^ovs_refcount_ref(struct ovs_refcount *refcount)$/;"	f
ovs_refcount_unref	.\lib\ovs-atomic.h	/^ovs_refcount_unref(struct ovs_refcount *refcount)$/;"	f
ovs_retval_to_string	.\lib\util.c	/^ovs_retval_to_string(int retval)$/;"	f
ovs_retval_to_string	.\python\ovs\util.py	/^def ovs_retval_to_string(retval):$/;"	f
ovs_rte_pktmbuf_init	.\lib\netdev-dpdk.c	/^ovs_rte_pktmbuf_init(struct rte_mempool *mp,$/;"	f	file:
ovs_rwlock	.\lib\ovs-thread.h	/^struct OVS_LOCKABLE ovs_rwlock {$/;"	s
ovs_rwlock_init	.\lib\ovs-thread.c	/^ovs_rwlock_init(const struct ovs_rwlock *l_)$/;"	f
ovs_rwlock_rdlock	.\lib\ovs-thread.h	142;"	d
ovs_rwlock_tryrdlock	.\lib\ovs-thread.h	147;"	d
ovs_rwlock_trywrlock	.\lib\ovs-thread.h	137;"	d
ovs_rwlock_wrlock	.\lib\ovs-thread.h	132;"	d
ovs_sample_attr	.\include\linux\openvswitch.h	/^enum ovs_sample_attr {$/;"	g
ovs_scan	.\lib\util.c	/^ovs_scan(const char *s, const char *format, ...)$/;"	f
ovs_skb_cb	.\datapath\datapath.h	/^struct ovs_skb_cb {$/;"	s
ovs_skb_postpush_rcsum	.\datapath\vport.h	/^static inline void ovs_skb_postpush_rcsum(struct sk_buff *skb,$/;"	f
ovs_snprintf	.\lib\stdio.c	/^ovs_snprintf(char *s, size_t n, const char *format, ... )$/;"	f
ovs_strerror	.\lib\util.c	/^ovs_strerror(int error)$/;"	f
ovs_strlcpy	.\lib\util.c	/^ovs_strlcpy(char *dst, const char *src, size_t size)$/;"	f
ovs_strzcpy	.\lib\util.c	/^ovs_strzcpy(char *dst, const char *src, size_t size)$/;"	f
ovs_thread	.\lib\ovs-thread.c	/^VLOG_DEFINE_THIS_MODULE(ovs_thread);$/;"	v
ovs_thread_create	.\lib\ovs-thread.c	/^ovs_thread_create(const char *name, void *(*start)(void *), void *arg)$/;"	f
ovs_thread_stats_next_bucket	.\lib\ovs-thread.c	/^ovs_thread_stats_next_bucket(const struct ovsthread_stats *stats, size_t i)$/;"	f
ovs_to_odp_frag	.\lib\odp-util.c	/^ovs_to_odp_frag(uint8_t nw_frag)$/;"	f	file:
ovs_to_odp_frag_mask	.\lib\odp-util.c	/^ovs_to_odp_frag_mask(uint8_t nw_frag_mask)$/;"	f	file:
ovs_tunnel_key_attr	.\include\linux\openvswitch.h	/^enum ovs_tunnel_key_attr {$/;"	g
ovs_unlock	.\datapath\datapath.c	/^void ovs_unlock(void)$/;"	f
ovs_userspace_attr	.\include\linux\openvswitch.h	/^enum ovs_userspace_attr {$/;"	g
ovs_version	.\lib\vswitch-idl.h	/^	char *ovs_version;$/;"	m	struct:ovsrec_open_vswitch
ovs_vport_add	.\datapath\vport.c	/^struct vport *ovs_vport_add(const struct vport_parms *parms)$/;"	f
ovs_vport_alloc	.\datapath\vport.c	/^struct vport *ovs_vport_alloc(int priv_size, const struct vport_ops *ops,$/;"	f
ovs_vport_attr	.\include\linux\openvswitch.h	/^enum ovs_vport_attr {$/;"	g
ovs_vport_cmd	.\include\linux\openvswitch.h	/^enum ovs_vport_cmd {$/;"	g
ovs_vport_cmd_alloc_info	.\datapath\datapath.c	/^static struct sk_buff *ovs_vport_cmd_alloc_info(void)$/;"	f	file:
ovs_vport_cmd_build_info	.\datapath\datapath.c	/^struct sk_buff *ovs_vport_cmd_build_info(struct vport *vport, u32 portid,$/;"	f
ovs_vport_cmd_del	.\datapath\datapath.c	/^static int ovs_vport_cmd_del(struct sk_buff *skb, struct genl_info *info)$/;"	f	file:
ovs_vport_cmd_dump	.\datapath\datapath.c	/^static int ovs_vport_cmd_dump(struct sk_buff *skb, struct netlink_callback *cb)$/;"	f	file:
ovs_vport_cmd_fill_info	.\datapath\datapath.c	/^static int ovs_vport_cmd_fill_info(struct vport *vport, struct sk_buff *skb,$/;"	f	file:
ovs_vport_cmd_get	.\datapath\datapath.c	/^static int ovs_vport_cmd_get(struct sk_buff *skb, struct genl_info *info)$/;"	f	file:
ovs_vport_cmd_new	.\datapath\datapath.c	/^static int ovs_vport_cmd_new(struct sk_buff *skb, struct genl_info *info)$/;"	f	file:
ovs_vport_cmd_set	.\datapath\datapath.c	/^static int ovs_vport_cmd_set(struct sk_buff *skb, struct genl_info *info)$/;"	f	file:
ovs_vport_deferred_free	.\datapath\vport.c	/^void ovs_vport_deferred_free(struct vport *vport)$/;"	f
ovs_vport_del	.\datapath\vport.c	/^void ovs_vport_del(struct vport *vport)$/;"	f
ovs_vport_exit	.\datapath\vport.c	/^void ovs_vport_exit(void)$/;"	f
ovs_vport_family	.\lib\dpif-linux.c	/^static int ovs_vport_family;$/;"	v	file:
ovs_vport_find_upcall_portid	.\datapath\vport.c	/^u32 ovs_vport_find_upcall_portid(const struct vport *p, struct sk_buff *skb)$/;"	f
ovs_vport_free	.\datapath\vport.c	/^void ovs_vport_free(struct vport *vport)$/;"	f
ovs_vport_get_options	.\datapath\vport.c	/^int ovs_vport_get_options(const struct vport *vport, struct sk_buff *skb)$/;"	f
ovs_vport_get_stats	.\datapath\vport.c	/^void ovs_vport_get_stats(struct vport *vport, struct ovs_vport_stats *stats)$/;"	f
ovs_vport_get_upcall_portids	.\datapath\vport.c	/^int ovs_vport_get_upcall_portids(const struct vport *vport,$/;"	f
ovs_vport_init	.\datapath\vport.c	/^int ovs_vport_init(void)$/;"	f
ovs_vport_locate	.\datapath\vport.c	/^struct vport *ovs_vport_locate(struct net *net, const char *name)$/;"	f
ovs_vport_mcgroup	.\lib\dpif-linux.c	/^static unsigned int ovs_vport_mcgroup;$/;"	v	file:
ovs_vport_ovsl	.\datapath\datapath.h	/^static inline struct vport *ovs_vport_ovsl(const struct datapath *dp, int port_no)$/;"	f
ovs_vport_ovsl_rcu	.\datapath\datapath.h	/^static inline struct vport *ovs_vport_ovsl_rcu(const struct datapath *dp, int port_no)$/;"	f
ovs_vport_rcu	.\datapath\datapath.h	/^static inline struct vport *ovs_vport_rcu(const struct datapath *dp, int port_no)$/;"	f
ovs_vport_receive	.\datapath\vport.c	/^void ovs_vport_receive(struct vport *vport, struct sk_buff *skb,$/;"	f
ovs_vport_record_error	.\datapath\vport.c	/^static void ovs_vport_record_error(struct vport *vport,$/;"	f	file:
ovs_vport_send	.\datapath\vport.c	/^int ovs_vport_send(struct vport *vport, struct sk_buff *skb)$/;"	f
ovs_vport_set_options	.\datapath\vport.c	/^int ovs_vport_set_options(struct vport *vport, struct nlattr *options)$/;"	f
ovs_vport_set_stats	.\datapath\vport.c	/^void ovs_vport_set_stats(struct vport *vport, struct ovs_vport_stats *stats)$/;"	f
ovs_vport_set_upcall_portids	.\datapath\vport.c	/^int ovs_vport_set_upcall_portids(struct vport *vport,  struct nlattr *ids)$/;"	f
ovs_vport_stats	.\include\linux\openvswitch.h	/^struct ovs_vport_stats {$/;"	s
ovs_vport_type	.\include\linux\openvswitch.h	/^enum ovs_vport_type {$/;"	g
ovs_vsctl	.\debian\ifupdown.sh	/^ovs_vsctl() {$/;"	f
ovs_vsctl_add_bridge	.\python\ovstest\vswitch.py	/^def ovs_vsctl_add_bridge(bridge):$/;"	f
ovs_vsctl_add_port_to_bridge	.\python\ovstest\vswitch.py	/^def ovs_vsctl_add_port_to_bridge(bridge, iface):$/;"	f
ovs_vsctl_del_bridge	.\python\ovstest\vswitch.py	/^def ovs_vsctl_del_bridge(bridge):$/;"	f
ovs_vsctl_del_pbridge	.\python\ovstest\vswitch.py	/^def ovs_vsctl_del_pbridge(bridge, iface):$/;"	f
ovs_vsctl_del_port_from_bridge	.\python\ovstest\vswitch.py	/^def ovs_vsctl_del_port_from_bridge(port):$/;"	f
ovs_vsctl_is_ovs_bridge	.\python\ovstest\vswitch.py	/^def ovs_vsctl_is_ovs_bridge(bridge):$/;"	f
ovs_vsctl_set	.\python\ovstest\vswitch.py	/^def ovs_vsctl_set(table, record, column, key, value):$/;"	f
ovs_vsnprintf	.\lib\stdio.c	/^ovs_vsnprintf(char *s, size_t n, const char *format, va_list args)$/;"	f
ovs_vswitchd_exit	.\vswitchd\ovs-vswitchd.c	/^ovs_vswitchd_exit(struct unixctl_conn *conn, int argc OVS_UNUSED,$/;"	f	file:
ovs_vswitchd_exit	.\vswitchd\ovs-vswitchd.c	/^static unixctl_cb_func ovs_vswitchd_exit;$/;"	v	file:
ovs_vxlan_vport_ops	.\datapath\vport-vxlan.c	/^const struct vport_ops ovs_vxlan_vport_ops = {$/;"	v	typeref:struct:vport_ops
ovsdb	.\ovsdb\ovsdb.h	/^struct ovsdb {$/;"	s
ovsdb_add_replica	.\ovsdb\ovsdb.c	/^ovsdb_add_replica(struct ovsdb *db, struct ovsdb_replica *r)$/;"	f
ovsdb_atom	.\lib\ovsdb-data.h	/^union ovsdb_atom {$/;"	u
ovsdb_atom_check_constraints	.\lib\ovsdb-data.c	/^ovsdb_atom_check_constraints(const union ovsdb_atom *atom,$/;"	f
ovsdb_atom_clone	.\lib\ovsdb-data.c	/^ovsdb_atom_clone(union ovsdb_atom *new, const union ovsdb_atom *old,$/;"	f
ovsdb_atom_compare_3way	.\lib\ovsdb-data.c	/^ovsdb_atom_compare_3way(const union ovsdb_atom *a,$/;"	f
ovsdb_atom_default	.\lib\ovsdb-data.c	/^ovsdb_atom_default(enum ovsdb_atomic_type type)$/;"	f
ovsdb_atom_destroy	.\lib\ovsdb-data.h	/^ovsdb_atom_destroy(union ovsdb_atom *atom, enum ovsdb_atomic_type type)$/;"	f
ovsdb_atom_equals	.\lib\ovsdb-data.h	/^static inline bool ovsdb_atom_equals(const union ovsdb_atom *a,$/;"	f
ovsdb_atom_from_json	.\lib\ovsdb-data.c	/^ovsdb_atom_from_json(union ovsdb_atom *atom,$/;"	f
ovsdb_atom_from_json__	.\lib\ovsdb-data.c	/^ovsdb_atom_from_json__(union ovsdb_atom *atom,$/;"	f	file:
ovsdb_atom_from_string	.\lib\ovsdb-data.c	/^ovsdb_atom_from_string(union ovsdb_atom *atom,$/;"	f
ovsdb_atom_from_string__	.\lib\ovsdb-data.c	/^ovsdb_atom_from_string__(union ovsdb_atom *atom,$/;"	f	file:
ovsdb_atom_hash	.\lib\ovsdb-data.c	/^ovsdb_atom_hash(const union ovsdb_atom *atom, enum ovsdb_atomic_type type,$/;"	f
ovsdb_atom_init_default	.\lib\ovsdb-data.c	/^ovsdb_atom_init_default(union ovsdb_atom *atom, enum ovsdb_atomic_type type)$/;"	f
ovsdb_atom_is_default	.\lib\ovsdb-data.c	/^ovsdb_atom_is_default(const union ovsdb_atom *atom,$/;"	f
ovsdb_atom_needs_destruction	.\lib\ovsdb-data.h	/^ovsdb_atom_needs_destruction(enum ovsdb_atomic_type type)$/;"	f
ovsdb_atom_parse_uuid	.\lib\ovsdb-data.c	/^ovsdb_atom_parse_uuid(struct uuid *uuid, const struct json *json,$/;"	f	file:
ovsdb_atom_swap	.\lib\ovsdb-data.c	/^ovsdb_atom_swap(union ovsdb_atom *a, union ovsdb_atom *b)$/;"	f
ovsdb_atom_to_bare	.\lib\ovsdb-data.c	/^ovsdb_atom_to_bare(const union ovsdb_atom *atom, enum ovsdb_atomic_type type,$/;"	f
ovsdb_atom_to_json	.\lib\ovsdb-data.c	/^ovsdb_atom_to_json(const union ovsdb_atom *atom, enum ovsdb_atomic_type type)$/;"	f
ovsdb_atom_to_string	.\lib\ovsdb-data.c	/^ovsdb_atom_to_string(const union ovsdb_atom *atom, enum ovsdb_atomic_type type,$/;"	f
ovsdb_atomic_type	.\lib\ovsdb-types.h	/^enum ovsdb_atomic_type {$/;"	g
ovsdb_atomic_type_from_json	.\lib\ovsdb-types.c	/^ovsdb_atomic_type_from_json(enum ovsdb_atomic_type *type,$/;"	f
ovsdb_atomic_type_from_string	.\lib\ovsdb-types.c	/^ovsdb_atomic_type_from_string(const char *string, enum ovsdb_atomic_type *type)$/;"	f
ovsdb_atomic_type_is_valid	.\lib\ovsdb-types.h	/^ovsdb_atomic_type_is_valid(enum ovsdb_atomic_type atomic_type)$/;"	f
ovsdb_atomic_type_to_json	.\lib\ovsdb-types.c	/^ovsdb_atomic_type_to_json(enum ovsdb_atomic_type type)$/;"	f
ovsdb_atomic_type_to_string	.\lib\ovsdb-types.c	/^ovsdb_atomic_type_to_string(enum ovsdb_atomic_type type)$/;"	f
ovsdb_base_type	.\lib\ovsdb-types.h	/^struct ovsdb_base_type {$/;"	s
ovsdb_base_type_clear_constraints	.\lib\ovsdb-types.c	/^ovsdb_base_type_clear_constraints(struct ovsdb_base_type *base)$/;"	f
ovsdb_base_type_clone	.\lib\ovsdb-types.c	/^ovsdb_base_type_clone(struct ovsdb_base_type *dst,$/;"	f
ovsdb_base_type_destroy	.\lib\ovsdb-types.c	/^ovsdb_base_type_destroy(struct ovsdb_base_type *base)$/;"	f
ovsdb_base_type_from_json	.\lib\ovsdb-types.c	/^ovsdb_base_type_from_json(struct ovsdb_base_type *base,$/;"	f
ovsdb_base_type_get_enum_type	.\lib\ovsdb-types.c	/^ovsdb_base_type_get_enum_type(enum ovsdb_atomic_type atomic_type)$/;"	f
ovsdb_base_type_has_constraints	.\lib\ovsdb-types.c	/^ovsdb_base_type_has_constraints(const struct ovsdb_base_type *base)$/;"	f
ovsdb_base_type_init	.\lib\ovsdb-types.c	/^ovsdb_base_type_init(struct ovsdb_base_type *base, enum ovsdb_atomic_type type)$/;"	f
ovsdb_base_type_is_ref	.\lib\ovsdb-types.h	/^ovsdb_base_type_is_ref(const struct ovsdb_base_type *base)$/;"	f
ovsdb_base_type_is_strong_ref	.\lib\ovsdb-types.h	/^ovsdb_base_type_is_strong_ref(const struct ovsdb_base_type *base)$/;"	f
ovsdb_base_type_is_valid	.\lib\ovsdb-types.c	/^ovsdb_base_type_is_valid(const struct ovsdb_base_type *base)$/;"	f
ovsdb_base_type_is_weak_ref	.\lib\ovsdb-types.h	/^ovsdb_base_type_is_weak_ref(const struct ovsdb_base_type *base)$/;"	f
ovsdb_base_type_to_json	.\lib\ovsdb-types.c	/^ovsdb_base_type_to_json(const struct ovsdb_base_type *base)$/;"	f
ovsdb_clause	.\ovsdb\condition.h	/^struct ovsdb_clause {$/;"	s
ovsdb_clause_evaluate	.\ovsdb\condition.c	/^ovsdb_clause_evaluate(const struct ovsdb_row *row,$/;"	f	file:
ovsdb_clause_free	.\ovsdb\condition.c	/^ovsdb_clause_free(struct ovsdb_clause *clause)$/;"	f	file:
ovsdb_clause_from_json	.\ovsdb\condition.c	/^ovsdb_clause_from_json(const struct ovsdb_table_schema *ts,$/;"	f	file:
ovsdb_clause_to_json	.\ovsdb\condition.c	/^ovsdb_clause_to_json(const struct ovsdb_clause *clause)$/;"	f	file:
ovsdb_client	.\ovsdb\ovsdb-client.c	/^VLOG_DEFINE_THIS_MODULE(ovsdb_client);$/;"	v
ovsdb_client_block	.\ovsdb\ovsdb-client.c	/^ovsdb_client_block(struct unixctl_conn *conn, int argc OVS_UNUSED,$/;"	f	file:
ovsdb_client_command	.\ovsdb\ovsdb-client.c	/^struct ovsdb_client_command {$/;"	s	file:
ovsdb_client_exit	.\ovsdb\ovsdb-client.c	/^ovsdb_client_exit(struct unixctl_conn *conn, int argc OVS_UNUSED,$/;"	f	file:
ovsdb_client_unblock	.\ovsdb\ovsdb-client.c	/^ovsdb_client_unblock(struct unixctl_conn *conn, int argc OVS_UNUSED,$/;"	f	file:
ovsdb_column	.\ovsdb\column.h	/^struct ovsdb_column {$/;"	s
ovsdb_column_clone	.\ovsdb\column.c	/^ovsdb_column_clone(const struct ovsdb_column *old)$/;"	f
ovsdb_column_create	.\ovsdb\column.c	/^ovsdb_column_create(const char *name,$/;"	f
ovsdb_column_destroy	.\ovsdb\column.c	/^ovsdb_column_destroy(struct ovsdb_column *column)$/;"	f
ovsdb_column_from_json	.\ovsdb\column.c	/^ovsdb_column_from_json(const struct json *json, const char *name,$/;"	f
ovsdb_column_set	.\ovsdb\column.h	/^struct ovsdb_column_set {$/;"	s
ovsdb_column_set_add	.\ovsdb\column.c	/^ovsdb_column_set_add(struct ovsdb_column_set *set,$/;"	f
ovsdb_column_set_add_all	.\ovsdb\column.c	/^ovsdb_column_set_add_all(struct ovsdb_column_set *set,$/;"	f
ovsdb_column_set_clone	.\ovsdb\column.c	/^ovsdb_column_set_clone(struct ovsdb_column_set *new,$/;"	f
ovsdb_column_set_contains	.\ovsdb\column.c	/^ovsdb_column_set_contains(const struct ovsdb_column_set *set,$/;"	f
ovsdb_column_set_destroy	.\ovsdb\column.c	/^ovsdb_column_set_destroy(struct ovsdb_column_set *set)$/;"	f
ovsdb_column_set_equals	.\ovsdb\column.c	/^ovsdb_column_set_equals(const struct ovsdb_column_set *a,$/;"	f
ovsdb_column_set_from_json	.\ovsdb\column.c	/^ovsdb_column_set_from_json(const struct json *json,$/;"	f
ovsdb_column_set_init	.\ovsdb\column.c	/^ovsdb_column_set_init(struct ovsdb_column_set *set)$/;"	f
ovsdb_column_set_to_json	.\ovsdb\column.c	/^ovsdb_column_set_to_json(const struct ovsdb_column_set *set)$/;"	f
ovsdb_column_set_to_string	.\ovsdb\column.c	/^ovsdb_column_set_to_string(const struct ovsdb_column_set *set)$/;"	f
ovsdb_column_to_json	.\ovsdb\column.c	/^ovsdb_column_to_json(const struct ovsdb_column *column)$/;"	f
ovsdb_condition	.\ovsdb\condition.h	/^struct ovsdb_condition {$/;"	s
ovsdb_condition_destroy	.\ovsdb\condition.c	/^ovsdb_condition_destroy(struct ovsdb_condition *cnd)$/;"	f
ovsdb_condition_evaluate	.\ovsdb\condition.c	/^ovsdb_condition_evaluate(const struct ovsdb_row *row,$/;"	f
ovsdb_condition_from_json	.\ovsdb\condition.c	/^ovsdb_condition_from_json(const struct ovsdb_table_schema *ts,$/;"	f
ovsdb_condition_to_json	.\ovsdb\condition.c	/^ovsdb_condition_to_json(const struct ovsdb_condition *cnd)$/;"	f
ovsdb_create	.\ovsdb\ovsdb.c	/^ovsdb_create(struct ovsdb_schema *schema)$/;"	f
ovsdb_datum	.\lib\ovsdb-data.h	/^struct ovsdb_datum {$/;"	s
ovsdb_datum_add_unsafe	.\lib\ovsdb-data.c	/^ovsdb_datum_add_unsafe(struct ovsdb_datum *datum,$/;"	f
ovsdb_datum_check_constraints	.\lib\ovsdb-data.c	/^ovsdb_datum_check_constraints(const struct ovsdb_datum *datum,$/;"	f
ovsdb_datum_clone	.\lib\ovsdb-data.c	/^ovsdb_datum_clone(struct ovsdb_datum *new, const struct ovsdb_datum *old,$/;"	f
ovsdb_datum_compare_3way	.\lib\ovsdb-data.c	/^ovsdb_datum_compare_3way(const struct ovsdb_datum *a,$/;"	f
ovsdb_datum_conforms_to_type	.\lib\ovsdb-data.h	/^ovsdb_datum_conforms_to_type(const struct ovsdb_datum *datum,$/;"	f
ovsdb_datum_default	.\lib\ovsdb-data.c	/^ovsdb_datum_default(const struct ovsdb_type *type)$/;"	f
ovsdb_datum_destroy	.\lib\ovsdb-data.c	/^ovsdb_datum_destroy(struct ovsdb_datum *datum, const struct ovsdb_type *type)$/;"	f
ovsdb_datum_equals	.\lib\ovsdb-data.c	/^ovsdb_datum_equals(const struct ovsdb_datum *a,$/;"	f
ovsdb_datum_excludes_all	.\lib\ovsdb-data.c	/^ovsdb_datum_excludes_all(const struct ovsdb_datum *a,$/;"	f
ovsdb_datum_find	.\lib\ovsdb-data.c	/^ovsdb_datum_find(const struct ovsdb_datum *a, int i,$/;"	f	file:
ovsdb_datum_find_key	.\lib\ovsdb-data.c	/^ovsdb_datum_find_key(const struct ovsdb_datum *datum,$/;"	f
ovsdb_datum_find_key_value	.\lib\ovsdb-data.c	/^ovsdb_datum_find_key_value(const struct ovsdb_datum *datum,$/;"	f
ovsdb_datum_from_json	.\lib\ovsdb-data.c	/^ovsdb_datum_from_json(struct ovsdb_datum *datum,$/;"	f
ovsdb_datum_from_json__	.\lib\ovsdb-data.c	/^ovsdb_datum_from_json__(struct ovsdb_datum *datum,$/;"	f	file:
ovsdb_datum_from_smap	.\lib\ovsdb-data.c	/^ovsdb_datum_from_smap(struct ovsdb_datum *datum, struct smap *smap)$/;"	f
ovsdb_datum_from_string	.\lib\ovsdb-data.c	/^ovsdb_datum_from_string(struct ovsdb_datum *datum,$/;"	f
ovsdb_datum_hash	.\lib\ovsdb-data.c	/^ovsdb_datum_hash(const struct ovsdb_datum *datum,$/;"	f
ovsdb_datum_includes_all	.\lib\ovsdb-data.c	/^ovsdb_datum_includes_all(const struct ovsdb_datum *a,$/;"	f
ovsdb_datum_init_default	.\lib\ovsdb-data.c	/^ovsdb_datum_init_default(struct ovsdb_datum *datum,$/;"	f
ovsdb_datum_init_empty	.\lib\ovsdb-data.c	/^ovsdb_datum_init_empty(struct ovsdb_datum *datum)$/;"	f
ovsdb_datum_is_default	.\lib\ovsdb-data.c	/^ovsdb_datum_is_default(const struct ovsdb_datum *datum,$/;"	f
ovsdb_datum_reallocate	.\lib\ovsdb-data.c	/^ovsdb_datum_reallocate(struct ovsdb_datum *a, const struct ovsdb_type *type,$/;"	f	file:
ovsdb_datum_remove_unsafe	.\lib\ovsdb-data.c	/^ovsdb_datum_remove_unsafe(struct ovsdb_datum *datum, size_t idx,$/;"	f
ovsdb_datum_sort	.\lib\ovsdb-data.c	/^ovsdb_datum_sort(struct ovsdb_datum *datum, enum ovsdb_atomic_type key_type)$/;"	f
ovsdb_datum_sort__	.\lib\ovsdb-data.c	/^ovsdb_datum_sort__(struct ovsdb_datum *datum, enum ovsdb_atomic_type key_type,$/;"	f	file:
ovsdb_datum_sort_assert	.\lib\ovsdb-data.c	/^ovsdb_datum_sort_assert(struct ovsdb_datum *datum,$/;"	f
ovsdb_datum_sort_cbdata	.\lib\ovsdb-data.c	/^struct ovsdb_datum_sort_cbdata {$/;"	s	file:
ovsdb_datum_sort_compare_cb	.\lib\ovsdb-data.c	/^ovsdb_datum_sort_compare_cb(size_t a, size_t b, void *cbdata_)$/;"	f	file:
ovsdb_datum_sort_swap_cb	.\lib\ovsdb-data.c	/^ovsdb_datum_sort_swap_cb(size_t a, size_t b, void *cbdata_)$/;"	f	file:
ovsdb_datum_sort_unique	.\lib\ovsdb-data.c	/^ovsdb_datum_sort_unique(struct ovsdb_datum *datum,$/;"	f
ovsdb_datum_subtract	.\lib\ovsdb-data.c	/^ovsdb_datum_subtract(struct ovsdb_datum *a, const struct ovsdb_type *a_type,$/;"	f
ovsdb_datum_swap	.\lib\ovsdb-data.c	/^ovsdb_datum_swap(struct ovsdb_datum *a, struct ovsdb_datum *b)$/;"	f
ovsdb_datum_to_bare	.\lib\ovsdb-data.c	/^ovsdb_datum_to_bare(const struct ovsdb_datum *datum,$/;"	f
ovsdb_datum_to_json	.\lib\ovsdb-data.c	/^ovsdb_datum_to_json(const struct ovsdb_datum *datum,$/;"	f
ovsdb_datum_to_string	.\lib\ovsdb-data.c	/^ovsdb_datum_to_string(const struct ovsdb_datum *datum,$/;"	f
ovsdb_datum_union	.\lib\ovsdb-data.c	/^ovsdb_datum_union(struct ovsdb_datum *a, const struct ovsdb_datum *b,$/;"	f
ovsdb_destroy	.\ovsdb\ovsdb.c	/^ovsdb_destroy(struct ovsdb *db)$/;"	f
ovsdb_error	.\lib\ovsdb-error.c	/^VLOG_DEFINE_THIS_MODULE(ovsdb_error);$/;"	v
ovsdb_error	.\lib\ovsdb-error.c	/^ovsdb_error(const char *tag, const char *details, ...)$/;"	f
ovsdb_error	.\lib\ovsdb-error.c	/^struct ovsdb_error {$/;"	s	file:
ovsdb_error_assert	.\lib\ovsdb-error.c	/^ovsdb_error_assert(struct ovsdb_error *error)$/;"	f
ovsdb_error_clone	.\lib\ovsdb-error.c	/^ovsdb_error_clone(const struct ovsdb_error *old)$/;"	f
ovsdb_error_destroy	.\lib\ovsdb-error.c	/^ovsdb_error_destroy(struct ovsdb_error *error)$/;"	f
ovsdb_error_get_tag	.\lib\ovsdb-error.c	/^ovsdb_error_get_tag(const struct ovsdb_error *error)$/;"	f
ovsdb_error_to_json	.\lib\ovsdb-error.c	/^ovsdb_error_to_json(const struct ovsdb_error *error)$/;"	f
ovsdb_error_to_string	.\lib\ovsdb-error.c	/^ovsdb_error_to_string(const struct ovsdb_error *error)$/;"	f
ovsdb_error_valist	.\lib\ovsdb-error.c	/^ovsdb_error_valist(const char *tag, const char *details, va_list args)$/;"	f	file:
ovsdb_execute	.\ovsdb\execution.c	/^ovsdb_execute(struct ovsdb *db, const struct ovsdb_session *session,$/;"	f
ovsdb_execute_abort	.\ovsdb\execution.c	/^ovsdb_execute_abort(struct ovsdb_execution *x OVS_UNUSED,$/;"	f	file:
ovsdb_execute_abort	.\ovsdb\execution.c	/^static ovsdb_operation_executor ovsdb_execute_abort;$/;"	v	file:
ovsdb_execute_assert	.\ovsdb\execution.c	/^ovsdb_execute_assert(struct ovsdb_execution *x, struct ovsdb_parser *parser,$/;"	f	file:
ovsdb_execute_assert	.\ovsdb\execution.c	/^static ovsdb_operation_executor ovsdb_execute_assert;$/;"	v	file:
ovsdb_execute_comment	.\ovsdb\execution.c	/^ovsdb_execute_comment(struct ovsdb_execution *x, struct ovsdb_parser *parser,$/;"	f	file:
ovsdb_execute_comment	.\ovsdb\execution.c	/^static ovsdb_operation_executor ovsdb_execute_comment;$/;"	v	file:
ovsdb_execute_commit	.\ovsdb\execution.c	/^ovsdb_execute_commit(struct ovsdb_execution *x, struct ovsdb_parser *parser,$/;"	f	file:
ovsdb_execute_commit	.\ovsdb\execution.c	/^static ovsdb_operation_executor ovsdb_execute_commit;$/;"	v	file:
ovsdb_execute_delete	.\ovsdb\execution.c	/^ovsdb_execute_delete(struct ovsdb_execution *x, struct ovsdb_parser *parser,$/;"	f	file:
ovsdb_execute_delete	.\ovsdb\execution.c	/^static ovsdb_operation_executor ovsdb_execute_delete;$/;"	v	file:
ovsdb_execute_insert	.\ovsdb\execution.c	/^ovsdb_execute_insert(struct ovsdb_execution *x, struct ovsdb_parser *parser,$/;"	f	file:
ovsdb_execute_insert	.\ovsdb\execution.c	/^static ovsdb_operation_executor ovsdb_execute_insert;$/;"	v	file:
ovsdb_execute_mutate	.\ovsdb\execution.c	/^ovsdb_execute_mutate(struct ovsdb_execution *x, struct ovsdb_parser *parser,$/;"	f	file:
ovsdb_execute_mutate	.\ovsdb\execution.c	/^static ovsdb_operation_executor ovsdb_execute_mutate;$/;"	v	file:
ovsdb_execute_select	.\ovsdb\execution.c	/^ovsdb_execute_select(struct ovsdb_execution *x, struct ovsdb_parser *parser,$/;"	f	file:
ovsdb_execute_select	.\ovsdb\execution.c	/^static ovsdb_operation_executor ovsdb_execute_select;$/;"	v	file:
ovsdb_execute_update	.\ovsdb\execution.c	/^ovsdb_execute_update(struct ovsdb_execution *x, struct ovsdb_parser *parser,$/;"	f	file:
ovsdb_execute_update	.\ovsdb\execution.c	/^static ovsdb_operation_executor ovsdb_execute_update;$/;"	v	file:
ovsdb_execute_wait	.\ovsdb\execution.c	/^ovsdb_execute_wait(struct ovsdb_execution *x, struct ovsdb_parser *parser,$/;"	f	file:
ovsdb_execute_wait	.\ovsdb\execution.c	/^static ovsdb_operation_executor ovsdb_execute_wait;$/;"	v	file:
ovsdb_execute_wait_query_cb	.\ovsdb\execution.c	/^ovsdb_execute_wait_query_cb(const struct ovsdb_row *row, void *aux_)$/;"	f	file:
ovsdb_execution	.\ovsdb\execution.c	/^struct ovsdb_execution {$/;"	s	file:
ovsdb_file	.\ovsdb\file.c	/^VLOG_DEFINE_THIS_MODULE(ovsdb_file);$/;"	v
ovsdb_file	.\ovsdb\file.c	/^struct ovsdb_file {$/;"	s	file:
ovsdb_file_cast	.\ovsdb\file.c	/^ovsdb_file_cast(struct ovsdb_replica *replica)$/;"	f	file:
ovsdb_file_change_cb	.\ovsdb\file.c	/^ovsdb_file_change_cb(const struct ovsdb_row *old,$/;"	f	file:
ovsdb_file_class	.\ovsdb\file.c	/^static const struct ovsdb_replica_class ovsdb_file_class = {$/;"	v	typeref:struct:ovsdb_replica_class	file:
ovsdb_file_class	.\ovsdb\file.c	/^static const struct ovsdb_replica_class ovsdb_file_class;$/;"	v	typeref:struct:ovsdb_replica_class	file:
ovsdb_file_commit	.\ovsdb\file.c	/^ovsdb_file_commit(struct ovsdb_replica *replica,$/;"	f	file:
ovsdb_file_compact	.\ovsdb\file.c	/^ovsdb_file_compact(struct ovsdb_file *file)$/;"	f
ovsdb_file_create	.\ovsdb\file.c	/^ovsdb_file_create(struct ovsdb *db, struct ovsdb_log *log,$/;"	f	file:
ovsdb_file_destroy	.\ovsdb\file.c	/^ovsdb_file_destroy(struct ovsdb_replica *replica)$/;"	f	file:
ovsdb_file_open	.\ovsdb\file.c	/^ovsdb_file_open(const char *file_name, bool read_only,$/;"	f
ovsdb_file_open__	.\ovsdb\file.c	/^ovsdb_file_open__(const char *file_name,$/;"	f	file:
ovsdb_file_open_as_schema	.\ovsdb\file.c	/^ovsdb_file_open_as_schema(const char *file_name,$/;"	f
ovsdb_file_open_log	.\ovsdb\file.c	/^ovsdb_file_open_log(const char *file_name, enum ovsdb_log_open_mode open_mode,$/;"	f	file:
ovsdb_file_read_schema	.\ovsdb\file.c	/^ovsdb_file_read_schema(const char *file_name, struct ovsdb_schema **schemap)$/;"	f
ovsdb_file_save_copy	.\ovsdb\file.c	/^ovsdb_file_save_copy(const char *file_name, int locking,$/;"	f
ovsdb_file_save_copy__	.\ovsdb\file.c	/^ovsdb_file_save_copy__(const char *file_name, int locking,$/;"	f	file:
ovsdb_file_txn	.\ovsdb\file.c	/^struct ovsdb_file_txn {$/;"	s	file:
ovsdb_file_txn_add_row	.\ovsdb\file.c	/^ovsdb_file_txn_add_row(struct ovsdb_file_txn *ftxn,$/;"	f	file:
ovsdb_file_txn_commit	.\ovsdb\file.c	/^ovsdb_file_txn_commit(struct json *json, const char *comment,$/;"	f	file:
ovsdb_file_txn_from_json	.\ovsdb\file.c	/^ovsdb_file_txn_from_json(struct ovsdb *db, const struct json *json,$/;"	f	file:
ovsdb_file_txn_init	.\ovsdb\file.c	/^ovsdb_file_txn_init(struct ovsdb_file_txn *ftxn)$/;"	f	file:
ovsdb_file_txn_row_from_json	.\ovsdb\file.c	/^ovsdb_file_txn_row_from_json(struct ovsdb_txn *txn, struct ovsdb_table *table,$/;"	f	file:
ovsdb_file_txn_table_from_json	.\ovsdb\file.c	/^ovsdb_file_txn_table_from_json(struct ovsdb_txn *txn,$/;"	f	file:
ovsdb_file_update_row_from_json	.\ovsdb\file.c	/^ovsdb_file_update_row_from_json(struct ovsdb_row *row, bool converting,$/;"	f	file:
ovsdb_function	.\ovsdb\condition.h	/^enum ovsdb_function {$/;"	g
ovsdb_function_from_string	.\ovsdb\condition.c	/^ovsdb_function_from_string(const char *name, enum ovsdb_function *function)$/;"	f
ovsdb_function_to_string	.\ovsdb\condition.c	/^ovsdb_function_to_string(enum ovsdb_function function)$/;"	f
ovsdb_get_memory_usage	.\ovsdb\ovsdb.c	/^ovsdb_get_memory_usage(const struct ovsdb *db, struct simap *usage)$/;"	f
ovsdb_get_table	.\ovsdb\ovsdb.c	/^ovsdb_get_table(const struct ovsdb *db, const char *name)$/;"	f
ovsdb_idl	.\lib\ovsdb-idl.c	/^VLOG_DEFINE_THIS_MODULE(ovsdb_idl);$/;"	v
ovsdb_idl	.\lib\ovsdb-idl.c	/^struct ovsdb_idl {$/;"	s	file:
ovsdb_idl_add_column	.\lib\ovsdb-idl.c	/^ovsdb_idl_add_column(struct ovsdb_idl *idl,$/;"	f
ovsdb_idl_add_table	.\lib\ovsdb-idl.c	/^ovsdb_idl_add_table(struct ovsdb_idl *idl,$/;"	f
ovsdb_idl_arc	.\lib\ovsdb-idl.c	/^struct ovsdb_idl_arc {$/;"	s	file:
ovsdb_idl_class	.\lib\ovsdb-idl-provider.h	/^struct ovsdb_idl_class {$/;"	s
ovsdb_idl_clear	.\lib\ovsdb-idl.c	/^ovsdb_idl_clear(struct ovsdb_idl *idl)$/;"	f	file:
ovsdb_idl_column	.\lib\ovsdb-idl-provider.h	/^struct ovsdb_idl_column {$/;"	s
ovsdb_idl_create	.\lib\ovsdb-idl.c	/^ovsdb_idl_create(const char *remote, const struct ovsdb_idl_class *class,$/;"	f
ovsdb_idl_delete_row	.\lib\ovsdb-idl.c	/^ovsdb_idl_delete_row(struct ovsdb_idl_row *row)$/;"	f	file:
ovsdb_idl_destroy	.\lib\ovsdb-idl.c	/^ovsdb_idl_destroy(struct ovsdb_idl *idl)$/;"	f
ovsdb_idl_enable_reconnect	.\lib\ovsdb-idl.c	/^ovsdb_idl_enable_reconnect(struct ovsdb_idl *idl)$/;"	f
ovsdb_idl_first_row	.\lib\ovsdb-idl.c	/^ovsdb_idl_first_row(const struct ovsdb_idl *idl,$/;"	f
ovsdb_idl_force_reconnect	.\lib\ovsdb-idl.c	/^ovsdb_idl_force_reconnect(struct ovsdb_idl *idl)$/;"	f
ovsdb_idl_get	.\lib\ovsdb-idl.c	/^ovsdb_idl_get(const struct ovsdb_idl_row *row,$/;"	f
ovsdb_idl_get_last_error	.\lib\ovsdb-idl.c	/^ovsdb_idl_get_last_error(const struct ovsdb_idl *idl)$/;"	f
ovsdb_idl_get_mode	.\lib\ovsdb-idl.c	/^ovsdb_idl_get_mode(struct ovsdb_idl *idl,$/;"	f	file:
ovsdb_idl_get_row	.\lib\ovsdb-idl.c	/^ovsdb_idl_get_row(struct ovsdb_idl_table *table, const struct uuid *uuid)$/;"	f	file:
ovsdb_idl_get_row_arc	.\lib\ovsdb-idl.c	/^ovsdb_idl_get_row_arc(struct ovsdb_idl_row *src,$/;"	f
ovsdb_idl_get_row_for_uuid	.\lib\ovsdb-idl.c	/^ovsdb_idl_get_row_for_uuid(const struct ovsdb_idl *idl,$/;"	f
ovsdb_idl_get_seqno	.\lib\ovsdb-idl.c	/^ovsdb_idl_get_seqno(const struct ovsdb_idl *idl)$/;"	f
ovsdb_idl_has_ever_connected	.\lib\ovsdb-idl.c	/^ovsdb_idl_has_ever_connected(const struct ovsdb_idl *idl)$/;"	f
ovsdb_idl_has_lock	.\lib\ovsdb-idl.c	/^ovsdb_idl_has_lock(const struct ovsdb_idl *idl)$/;"	f
ovsdb_idl_insert_row	.\lib\ovsdb-idl.c	/^ovsdb_idl_insert_row(struct ovsdb_idl_row *row, const struct json *row_json)$/;"	f	file:
ovsdb_idl_is_alive	.\lib\ovsdb-idl.c	/^ovsdb_idl_is_alive(const struct ovsdb_idl *idl)$/;"	f
ovsdb_idl_is_lock_contended	.\lib\ovsdb-idl.c	/^ovsdb_idl_is_lock_contended(const struct ovsdb_idl *idl)$/;"	f
ovsdb_idl_modify_row	.\lib\ovsdb-idl.c	/^ovsdb_idl_modify_row(struct ovsdb_idl_row *row, const struct json *row_json)$/;"	f	file:
ovsdb_idl_next_row	.\lib\ovsdb-idl.c	/^ovsdb_idl_next_row(const struct ovsdb_idl_row *row)$/;"	f
ovsdb_idl_omit	.\lib\ovsdb-idl.c	/^ovsdb_idl_omit(struct ovsdb_idl *idl, const struct ovsdb_idl_column *column)$/;"	f
ovsdb_idl_omit_alert	.\lib\ovsdb-idl.c	/^ovsdb_idl_omit_alert(struct ovsdb_idl *idl,$/;"	f
ovsdb_idl_parse_lock_notify	.\lib\ovsdb-idl.c	/^ovsdb_idl_parse_lock_notify(struct ovsdb_idl *idl,$/;"	f	file:
ovsdb_idl_parse_lock_reply	.\lib\ovsdb-idl.c	/^ovsdb_idl_parse_lock_reply(struct ovsdb_idl *idl, const struct json *result)$/;"	f	file:
ovsdb_idl_parse_update	.\lib\ovsdb-idl.c	/^ovsdb_idl_parse_update(struct ovsdb_idl *idl, const struct json *table_updates)$/;"	f	file:
ovsdb_idl_parse_update__	.\lib\ovsdb-idl.c	/^ovsdb_idl_parse_update__(struct ovsdb_idl *idl,$/;"	f	file:
ovsdb_idl_process_update	.\lib\ovsdb-idl.c	/^ovsdb_idl_process_update(struct ovsdb_idl_table *table,$/;"	f	file:
ovsdb_idl_read	.\lib\ovsdb-idl.c	/^ovsdb_idl_read(const struct ovsdb_idl_row *row,$/;"	f
ovsdb_idl_row	.\lib\ovsdb-idl-provider.h	/^struct ovsdb_idl_row {$/;"	s
ovsdb_idl_row_clear_arcs	.\lib\ovsdb-idl.c	/^ovsdb_idl_row_clear_arcs(struct ovsdb_idl_row *row, bool destroy_dsts)$/;"	f	file:
ovsdb_idl_row_clear_new	.\lib\ovsdb-idl.c	/^ovsdb_idl_row_clear_new(struct ovsdb_idl_row *row)$/;"	f	file:
ovsdb_idl_row_clear_old	.\lib\ovsdb-idl.c	/^ovsdb_idl_row_clear_old(struct ovsdb_idl_row *row)$/;"	f	file:
ovsdb_idl_row_create	.\lib\ovsdb-idl.c	/^ovsdb_idl_row_create(struct ovsdb_idl_table *table, const struct uuid *uuid)$/;"	f	file:
ovsdb_idl_row_create__	.\lib\ovsdb-idl.c	/^ovsdb_idl_row_create__(const struct ovsdb_idl_table_class *class)$/;"	f	file:
ovsdb_idl_row_destroy	.\lib\ovsdb-idl.c	/^ovsdb_idl_row_destroy(struct ovsdb_idl_row *row)$/;"	f	file:
ovsdb_idl_row_exists	.\lib\ovsdb-idl.c	/^ovsdb_idl_row_exists(const struct ovsdb_idl_row *row)$/;"	f	file:
ovsdb_idl_row_is_orphan	.\lib\ovsdb-idl.c	/^ovsdb_idl_row_is_orphan(const struct ovsdb_idl_row *row)$/;"	f	file:
ovsdb_idl_row_is_synthetic	.\lib\ovsdb-idl.c	/^ovsdb_idl_row_is_synthetic(const struct ovsdb_idl_row *row)$/;"	f
ovsdb_idl_row_parse	.\lib\ovsdb-idl.c	/^ovsdb_idl_row_parse(struct ovsdb_idl_row *row)$/;"	f	file:
ovsdb_idl_row_reparse_backrefs	.\lib\ovsdb-idl.c	/^ovsdb_idl_row_reparse_backrefs(struct ovsdb_idl_row *row)$/;"	f	file:
ovsdb_idl_row_unparse	.\lib\ovsdb-idl.c	/^ovsdb_idl_row_unparse(struct ovsdb_idl_row *row)$/;"	f	file:
ovsdb_idl_row_update	.\lib\ovsdb-idl.c	/^ovsdb_idl_row_update(struct ovsdb_idl_row *row, const struct json *row_json)$/;"	f	file:
ovsdb_idl_run	.\lib\ovsdb-idl.c	/^ovsdb_idl_run(struct ovsdb_idl *idl)$/;"	f
ovsdb_idl_send_lock_request	.\lib\ovsdb-idl.c	/^ovsdb_idl_send_lock_request(struct ovsdb_idl *idl)$/;"	f	file:
ovsdb_idl_send_lock_request__	.\lib\ovsdb-idl.c	/^ovsdb_idl_send_lock_request__(struct ovsdb_idl *idl, const char *method,$/;"	f	file:
ovsdb_idl_send_monitor_request	.\lib\ovsdb-idl.c	/^ovsdb_idl_send_monitor_request(struct ovsdb_idl *idl)$/;"	f	file:
ovsdb_idl_send_unlock_request	.\lib\ovsdb-idl.c	/^ovsdb_idl_send_unlock_request(struct ovsdb_idl *idl)$/;"	f	file:
ovsdb_idl_set_lock	.\lib\ovsdb-idl.c	/^ovsdb_idl_set_lock(struct ovsdb_idl *idl, const char *lock_name)$/;"	f
ovsdb_idl_table	.\lib\ovsdb-idl-provider.h	/^struct ovsdb_idl_table {$/;"	s
ovsdb_idl_table_class	.\lib\ovsdb-idl-provider.h	/^struct ovsdb_idl_table_class {$/;"	s
ovsdb_idl_table_from_class	.\lib\ovsdb-idl.c	/^ovsdb_idl_table_from_class(const struct ovsdb_idl *idl,$/;"	f	file:
ovsdb_idl_txn	.\lib\ovsdb-idl.c	/^struct ovsdb_idl_txn {$/;"	s	file:
ovsdb_idl_txn_abort	.\lib\ovsdb-idl.c	/^ovsdb_idl_txn_abort(struct ovsdb_idl_txn *txn)$/;"	f
ovsdb_idl_txn_abort_all	.\lib\ovsdb-idl.c	/^ovsdb_idl_txn_abort_all(struct ovsdb_idl *idl)$/;"	f	file:
ovsdb_idl_txn_add_comment	.\lib\ovsdb-idl.c	/^ovsdb_idl_txn_add_comment(struct ovsdb_idl_txn *txn, const char *s, ...)$/;"	f
ovsdb_idl_txn_commit	.\lib\ovsdb-idl.c	/^ovsdb_idl_txn_commit(struct ovsdb_idl_txn *txn)$/;"	f
ovsdb_idl_txn_commit_block	.\lib\ovsdb-idl.c	/^ovsdb_idl_txn_commit_block(struct ovsdb_idl_txn *txn)$/;"	f
ovsdb_idl_txn_complete	.\lib\ovsdb-idl.c	/^ovsdb_idl_txn_complete(struct ovsdb_idl_txn *txn,$/;"	f	file:
ovsdb_idl_txn_create	.\lib\ovsdb-idl.c	/^ovsdb_idl_txn_create(struct ovsdb_idl *idl)$/;"	f
ovsdb_idl_txn_delete	.\lib\ovsdb-idl.c	/^ovsdb_idl_txn_delete(const struct ovsdb_idl_row *row_)$/;"	f
ovsdb_idl_txn_destroy	.\lib\ovsdb-idl.c	/^ovsdb_idl_txn_destroy(struct ovsdb_idl_txn *txn)$/;"	f
ovsdb_idl_txn_disassemble	.\lib\ovsdb-idl.c	/^ovsdb_idl_txn_disassemble(struct ovsdb_idl_txn *txn)$/;"	f	file:
ovsdb_idl_txn_find	.\lib\ovsdb-idl.c	/^ovsdb_idl_txn_find(struct ovsdb_idl *idl, const struct json *id)$/;"	f	file:
ovsdb_idl_txn_get	.\lib\ovsdb-idl.c	/^ovsdb_idl_txn_get(const struct ovsdb_idl_row *row)$/;"	f
ovsdb_idl_txn_get_error	.\lib\ovsdb-idl.c	/^ovsdb_idl_txn_get_error(const struct ovsdb_idl_txn *txn)$/;"	f
ovsdb_idl_txn_get_idl	.\lib\ovsdb-idl.c	/^ovsdb_idl_txn_get_idl (struct ovsdb_idl_txn *txn)$/;"	f
ovsdb_idl_txn_get_increment_new_value	.\lib\ovsdb-idl.c	/^ovsdb_idl_txn_get_increment_new_value(const struct ovsdb_idl_txn *txn)$/;"	f
ovsdb_idl_txn_get_insert_uuid	.\lib\ovsdb-idl.c	/^ovsdb_idl_txn_get_insert_uuid(const struct ovsdb_idl_txn *txn,$/;"	f
ovsdb_idl_txn_get_row	.\lib\ovsdb-idl.c	/^ovsdb_idl_txn_get_row(const struct ovsdb_idl_txn *txn, const struct uuid *uuid)$/;"	f	file:
ovsdb_idl_txn_increment	.\lib\ovsdb-idl.c	/^ovsdb_idl_txn_increment(struct ovsdb_idl_txn *txn,$/;"	f
ovsdb_idl_txn_insert	.\lib\ovsdb-idl.c	/^ovsdb_idl_txn_insert(struct ovsdb_idl_txn *txn,$/;"	f
ovsdb_idl_txn_insert	.\lib\ovsdb-idl.c	/^struct ovsdb_idl_txn_insert {$/;"	s	file:
ovsdb_idl_txn_process_inc_reply	.\lib\ovsdb-idl.c	/^ovsdb_idl_txn_process_inc_reply(struct ovsdb_idl_txn *txn,$/;"	f	file:
ovsdb_idl_txn_process_insert_reply	.\lib\ovsdb-idl.c	/^ovsdb_idl_txn_process_insert_reply(struct ovsdb_idl_txn_insert *insert,$/;"	f	file:
ovsdb_idl_txn_process_reply	.\lib\ovsdb-idl.c	/^ovsdb_idl_txn_process_reply(struct ovsdb_idl *idl,$/;"	f	file:
ovsdb_idl_txn_set_dry_run	.\lib\ovsdb-idl.c	/^ovsdb_idl_txn_set_dry_run(struct ovsdb_idl_txn *txn)$/;"	f
ovsdb_idl_txn_set_error_json	.\lib\ovsdb-idl.c	/^ovsdb_idl_txn_set_error_json(struct ovsdb_idl_txn *txn,$/;"	f	file:
ovsdb_idl_txn_status	.\lib\ovsdb-idl.h	/^enum ovsdb_idl_txn_status {$/;"	g
ovsdb_idl_txn_status_to_string	.\lib\ovsdb-idl.c	/^ovsdb_idl_txn_status_to_string(enum ovsdb_idl_txn_status status)$/;"	f
ovsdb_idl_txn_verify	.\lib\ovsdb-idl.c	/^ovsdb_idl_txn_verify(const struct ovsdb_idl_row *row_,$/;"	f
ovsdb_idl_txn_wait	.\lib\ovsdb-idl.c	/^ovsdb_idl_txn_wait(const struct ovsdb_idl_txn *txn)$/;"	f
ovsdb_idl_txn_write	.\lib\ovsdb-idl.c	/^ovsdb_idl_txn_write(const struct ovsdb_idl_row *row,$/;"	f
ovsdb_idl_txn_write__	.\lib\ovsdb-idl.c	/^ovsdb_idl_txn_write__(const struct ovsdb_idl_row *row_,$/;"	f	file:
ovsdb_idl_txn_write_clone	.\lib\ovsdb-idl.c	/^ovsdb_idl_txn_write_clone(const struct ovsdb_idl_row *row,$/;"	f
ovsdb_idl_update_has_lock	.\lib\ovsdb-idl.c	/^ovsdb_idl_update_has_lock(struct ovsdb_idl *idl, bool new_has_lock)$/;"	f	file:
ovsdb_idl_verify_write_only	.\lib\ovsdb-idl.c	/^ovsdb_idl_verify_write_only(struct ovsdb_idl *idl)$/;"	f
ovsdb_idl_wait	.\lib\ovsdb-idl.c	/^ovsdb_idl_wait(struct ovsdb_idl *idl)$/;"	f
ovsdb_index_search	.\ovsdb\transaction.c	/^ovsdb_index_search(struct hmap *index, struct ovsdb_row *row, size_t i,$/;"	f	file:
ovsdb_integer_constraints	.\lib\ovsdb-types.h	/^        struct ovsdb_integer_constraints {$/;"	s	union:ovsdb_base_type::__anon86
ovsdb_internal_error	.\lib\ovsdb-error.c	/^ovsdb_internal_error(struct ovsdb_error *inner_error,$/;"	f
ovsdb_io_error	.\lib\ovsdb-error.c	/^ovsdb_io_error(int errno_, const char *details, ...)$/;"	f
ovsdb_jsonrpc_add_monitor_column	.\ovsdb\jsonrpc-server.c	/^ovsdb_jsonrpc_add_monitor_column(struct ovsdb_jsonrpc_monitor_table *mt,$/;"	f	file:
ovsdb_jsonrpc_default_options	.\ovsdb\jsonrpc-server.c	/^ovsdb_jsonrpc_default_options(const char *target)$/;"	f
ovsdb_jsonrpc_lookup_db	.\ovsdb\jsonrpc-server.c	/^ovsdb_jsonrpc_lookup_db(const struct ovsdb_jsonrpc_session *s,$/;"	f	file:
ovsdb_jsonrpc_monitor	.\ovsdb\jsonrpc-server.c	/^struct ovsdb_jsonrpc_monitor {$/;"	s	file:
ovsdb_jsonrpc_monitor_aux	.\ovsdb\jsonrpc-server.c	/^struct ovsdb_jsonrpc_monitor_aux {$/;"	s	file:
ovsdb_jsonrpc_monitor_cancel	.\ovsdb\jsonrpc-server.c	/^ovsdb_jsonrpc_monitor_cancel(struct ovsdb_jsonrpc_session *s,$/;"	f	file:
ovsdb_jsonrpc_monitor_cast	.\ovsdb\jsonrpc-server.c	/^ovsdb_jsonrpc_monitor_cast(struct ovsdb_replica *replica)$/;"	f	file:
ovsdb_jsonrpc_monitor_change_cb	.\ovsdb\jsonrpc-server.c	/^ovsdb_jsonrpc_monitor_change_cb(const struct ovsdb_row *old,$/;"	f	file:
ovsdb_jsonrpc_monitor_column	.\ovsdb\jsonrpc-server.c	/^struct ovsdb_jsonrpc_monitor_column {$/;"	s	file:
ovsdb_jsonrpc_monitor_commit	.\ovsdb\jsonrpc-server.c	/^ovsdb_jsonrpc_monitor_commit(struct ovsdb_replica *replica,$/;"	f	file:
ovsdb_jsonrpc_monitor_compose_row_update	.\ovsdb\jsonrpc-server.c	/^ovsdb_jsonrpc_monitor_compose_row_update($/;"	f	file:
ovsdb_jsonrpc_monitor_compose_table_update	.\ovsdb\jsonrpc-server.c	/^ovsdb_jsonrpc_monitor_compose_table_update($/;"	f	file:
ovsdb_jsonrpc_monitor_create	.\ovsdb\jsonrpc-server.c	/^ovsdb_jsonrpc_monitor_create(struct ovsdb_jsonrpc_session *s, struct ovsdb *db,$/;"	f	file:
ovsdb_jsonrpc_monitor_destroy	.\ovsdb\jsonrpc-server.c	/^ovsdb_jsonrpc_monitor_destroy(struct ovsdb_replica *replica)$/;"	f	file:
ovsdb_jsonrpc_monitor_find	.\ovsdb\jsonrpc-server.c	/^ovsdb_jsonrpc_monitor_find(struct ovsdb_jsonrpc_session *s,$/;"	f
ovsdb_jsonrpc_monitor_flush_all	.\ovsdb\jsonrpc-server.c	/^ovsdb_jsonrpc_monitor_flush_all(struct ovsdb_jsonrpc_session *s)$/;"	f	file:
ovsdb_jsonrpc_monitor_get_initial	.\ovsdb\jsonrpc-server.c	/^ovsdb_jsonrpc_monitor_get_initial(const struct ovsdb_jsonrpc_monitor *m)$/;"	f	file:
ovsdb_jsonrpc_monitor_init_aux	.\ovsdb\jsonrpc-server.c	/^ovsdb_jsonrpc_monitor_init_aux(struct ovsdb_jsonrpc_monitor_aux *aux,$/;"	f	file:
ovsdb_jsonrpc_monitor_needs_flush	.\ovsdb\jsonrpc-server.c	/^ovsdb_jsonrpc_monitor_needs_flush(struct ovsdb_jsonrpc_session *s)$/;"	f	file:
ovsdb_jsonrpc_monitor_remove_all	.\ovsdb\jsonrpc-server.c	/^ovsdb_jsonrpc_monitor_remove_all(struct ovsdb_jsonrpc_session *s)$/;"	f	file:
ovsdb_jsonrpc_monitor_row	.\ovsdb\jsonrpc-server.c	/^struct ovsdb_jsonrpc_monitor_row {$/;"	s	file:
ovsdb_jsonrpc_monitor_row_destroy	.\ovsdb\jsonrpc-server.c	/^ovsdb_jsonrpc_monitor_row_destroy(const struct ovsdb_jsonrpc_monitor_table *mt,$/;"	f	file:
ovsdb_jsonrpc_monitor_row_find	.\ovsdb\jsonrpc-server.c	/^ovsdb_jsonrpc_monitor_row_find(const struct ovsdb_jsonrpc_monitor_table *mt,$/;"	f	file:
ovsdb_jsonrpc_monitor_selection	.\ovsdb\jsonrpc-server.c	/^enum ovsdb_jsonrpc_monitor_selection {$/;"	g	file:
ovsdb_jsonrpc_monitor_table	.\ovsdb\jsonrpc-server.c	/^struct ovsdb_jsonrpc_monitor_table {$/;"	s	file:
ovsdb_jsonrpc_options	.\ovsdb\jsonrpc-server.h	/^struct ovsdb_jsonrpc_options {$/;"	s
ovsdb_jsonrpc_parse_monitor_request	.\ovsdb\jsonrpc-server.c	/^ovsdb_jsonrpc_parse_monitor_request(struct ovsdb_jsonrpc_monitor_table *mt,$/;"	f	file:
ovsdb_jsonrpc_remote	.\ovsdb\jsonrpc-server.c	/^struct ovsdb_jsonrpc_remote {$/;"	s	file:
ovsdb_jsonrpc_remote_status	.\ovsdb\jsonrpc-server.h	/^struct ovsdb_jsonrpc_remote_status {$/;"	s
ovsdb_jsonrpc_replica_class	.\ovsdb\jsonrpc-server.c	/^static const struct ovsdb_replica_class ovsdb_jsonrpc_replica_class = {$/;"	v	typeref:struct:ovsdb_replica_class	file:
ovsdb_jsonrpc_replica_class	.\ovsdb\jsonrpc-server.c	/^static const struct ovsdb_replica_class ovsdb_jsonrpc_replica_class;$/;"	v	typeref:struct:ovsdb_replica_class	file:
ovsdb_jsonrpc_server	.\ovsdb\jsonrpc-server.c	/^VLOG_DEFINE_THIS_MODULE(ovsdb_jsonrpc_server);$/;"	v
ovsdb_jsonrpc_server	.\ovsdb\jsonrpc-server.c	/^struct ovsdb_jsonrpc_server {$/;"	s	file:
ovsdb_jsonrpc_server_add_db	.\ovsdb\jsonrpc-server.c	/^ovsdb_jsonrpc_server_add_db(struct ovsdb_jsonrpc_server *svr, struct ovsdb *db)$/;"	f
ovsdb_jsonrpc_server_add_remote	.\ovsdb\jsonrpc-server.c	/^ovsdb_jsonrpc_server_add_remote(struct ovsdb_jsonrpc_server *svr,$/;"	f	file:
ovsdb_jsonrpc_server_create	.\ovsdb\jsonrpc-server.c	/^ovsdb_jsonrpc_server_create(void)$/;"	f
ovsdb_jsonrpc_server_del_remote	.\ovsdb\jsonrpc-server.c	/^ovsdb_jsonrpc_server_del_remote(struct shash_node *node)$/;"	f	file:
ovsdb_jsonrpc_server_destroy	.\ovsdb\jsonrpc-server.c	/^ovsdb_jsonrpc_server_destroy(struct ovsdb_jsonrpc_server *svr)$/;"	f
ovsdb_jsonrpc_server_free_remote_status	.\ovsdb\jsonrpc-server.c	/^ovsdb_jsonrpc_server_free_remote_status($/;"	f
ovsdb_jsonrpc_server_get_memory_usage	.\ovsdb\jsonrpc-server.c	/^ovsdb_jsonrpc_server_get_memory_usage(const struct ovsdb_jsonrpc_server *svr,$/;"	f
ovsdb_jsonrpc_server_get_remote_status	.\ovsdb\jsonrpc-server.c	/^ovsdb_jsonrpc_server_get_remote_status($/;"	f
ovsdb_jsonrpc_server_reconnect	.\ovsdb\jsonrpc-server.c	/^ovsdb_jsonrpc_server_reconnect(struct ovsdb_jsonrpc_server *svr)$/;"	f
ovsdb_jsonrpc_server_remove_db	.\ovsdb\jsonrpc-server.c	/^ovsdb_jsonrpc_server_remove_db(struct ovsdb_jsonrpc_server *svr,$/;"	f
ovsdb_jsonrpc_server_run	.\ovsdb\jsonrpc-server.c	/^ovsdb_jsonrpc_server_run(struct ovsdb_jsonrpc_server *svr)$/;"	f
ovsdb_jsonrpc_server_set_remotes	.\ovsdb\jsonrpc-server.c	/^ovsdb_jsonrpc_server_set_remotes(struct ovsdb_jsonrpc_server *svr,$/;"	f
ovsdb_jsonrpc_server_wait	.\ovsdb\jsonrpc-server.c	/^ovsdb_jsonrpc_server_wait(struct ovsdb_jsonrpc_server *svr)$/;"	f
ovsdb_jsonrpc_session	.\ovsdb\jsonrpc-server.c	/^struct ovsdb_jsonrpc_session {$/;"	s	file:
ovsdb_jsonrpc_session_close	.\ovsdb\jsonrpc-server.c	/^ovsdb_jsonrpc_session_close(struct ovsdb_jsonrpc_session *s)$/;"	f	file:
ovsdb_jsonrpc_session_close_all	.\ovsdb\jsonrpc-server.c	/^ovsdb_jsonrpc_session_close_all(struct ovsdb_jsonrpc_remote *remote)$/;"	f	file:
ovsdb_jsonrpc_session_create	.\ovsdb\jsonrpc-server.c	/^ovsdb_jsonrpc_session_create(struct ovsdb_jsonrpc_remote *remote,$/;"	f	file:
ovsdb_jsonrpc_session_get_memory_usage	.\ovsdb\jsonrpc-server.c	/^ovsdb_jsonrpc_session_get_memory_usage(const struct ovsdb_jsonrpc_session *s,$/;"	f	file:
ovsdb_jsonrpc_session_get_memory_usage_all	.\ovsdb\jsonrpc-server.c	/^ovsdb_jsonrpc_session_get_memory_usage_all($/;"	f	file:
ovsdb_jsonrpc_session_get_status	.\ovsdb\jsonrpc-server.c	/^ovsdb_jsonrpc_session_get_status(const struct ovsdb_jsonrpc_remote *remote,$/;"	f	file:
ovsdb_jsonrpc_session_got_notify	.\ovsdb\jsonrpc-server.c	/^ovsdb_jsonrpc_session_got_notify(struct ovsdb_jsonrpc_session *s,$/;"	f	file:
ovsdb_jsonrpc_session_got_request	.\ovsdb\jsonrpc-server.c	/^ovsdb_jsonrpc_session_got_request(struct ovsdb_jsonrpc_session *s,$/;"	f	file:
ovsdb_jsonrpc_session_lock	.\ovsdb\jsonrpc-server.c	/^ovsdb_jsonrpc_session_lock(struct ovsdb_jsonrpc_session *s,$/;"	f	file:
ovsdb_jsonrpc_session_notify	.\ovsdb\jsonrpc-server.c	/^ovsdb_jsonrpc_session_notify(struct ovsdb_session *session,$/;"	f	file:
ovsdb_jsonrpc_session_parse_lock_name	.\ovsdb\jsonrpc-server.c	/^ovsdb_jsonrpc_session_parse_lock_name(const struct jsonrpc_msg *request,$/;"	f	file:
ovsdb_jsonrpc_session_reconnect_all	.\ovsdb\jsonrpc-server.c	/^ovsdb_jsonrpc_session_reconnect_all(struct ovsdb_jsonrpc_remote *remote)$/;"	f	file:
ovsdb_jsonrpc_session_run	.\ovsdb\jsonrpc-server.c	/^ovsdb_jsonrpc_session_run(struct ovsdb_jsonrpc_session *s)$/;"	f	file:
ovsdb_jsonrpc_session_run_all	.\ovsdb\jsonrpc-server.c	/^ovsdb_jsonrpc_session_run_all(struct ovsdb_jsonrpc_remote *remote)$/;"	f	file:
ovsdb_jsonrpc_session_send	.\ovsdb\jsonrpc-server.c	/^ovsdb_jsonrpc_session_send(struct ovsdb_jsonrpc_session *s,$/;"	f	file:
ovsdb_jsonrpc_session_set_all_options	.\ovsdb\jsonrpc-server.c	/^ovsdb_jsonrpc_session_set_all_options($/;"	f	file:
ovsdb_jsonrpc_session_set_options	.\ovsdb\jsonrpc-server.c	/^ovsdb_jsonrpc_session_set_options(struct ovsdb_jsonrpc_session *session,$/;"	f	file:
ovsdb_jsonrpc_session_unlock	.\ovsdb\jsonrpc-server.c	/^ovsdb_jsonrpc_session_unlock(struct ovsdb_jsonrpc_session *s,$/;"	f	file:
ovsdb_jsonrpc_session_unlock__	.\ovsdb\jsonrpc-server.c	/^ovsdb_jsonrpc_session_unlock__(struct ovsdb_lock_waiter *waiter)$/;"	f	file:
ovsdb_jsonrpc_session_unlock_all	.\ovsdb\jsonrpc-server.c	/^ovsdb_jsonrpc_session_unlock_all(struct ovsdb_jsonrpc_session *s)$/;"	f	file:
ovsdb_jsonrpc_session_wait	.\ovsdb\jsonrpc-server.c	/^ovsdb_jsonrpc_session_wait(struct ovsdb_jsonrpc_session *s)$/;"	f	file:
ovsdb_jsonrpc_session_wait_all	.\ovsdb\jsonrpc-server.c	/^ovsdb_jsonrpc_session_wait_all(struct ovsdb_jsonrpc_remote *remote)$/;"	f	file:
ovsdb_jsonrpc_trigger	.\ovsdb\jsonrpc-server.c	/^struct ovsdb_jsonrpc_trigger {$/;"	s	file:
ovsdb_jsonrpc_trigger_complete	.\ovsdb\jsonrpc-server.c	/^ovsdb_jsonrpc_trigger_complete(struct ovsdb_jsonrpc_trigger *t)$/;"	f	file:
ovsdb_jsonrpc_trigger_complete_all	.\ovsdb\jsonrpc-server.c	/^ovsdb_jsonrpc_trigger_complete_all(struct ovsdb_jsonrpc_session *s)$/;"	f	file:
ovsdb_jsonrpc_trigger_complete_done	.\ovsdb\jsonrpc-server.c	/^ovsdb_jsonrpc_trigger_complete_done(struct ovsdb_jsonrpc_session *s)$/;"	f	file:
ovsdb_jsonrpc_trigger_create	.\ovsdb\jsonrpc-server.c	/^ovsdb_jsonrpc_trigger_create(struct ovsdb_jsonrpc_session *s, struct ovsdb *db,$/;"	f	file:
ovsdb_jsonrpc_trigger_find	.\ovsdb\jsonrpc-server.c	/^ovsdb_jsonrpc_trigger_find(struct ovsdb_jsonrpc_session *s,$/;"	f	file:
ovsdb_libovsdb_la_CFLAGS	.\ovsdb\automake.mk	/^ovsdb_libovsdb_la_CFLAGS = $(AM_CFLAGS)$/;"	m
ovsdb_libovsdb_la_CPPFLAGS	.\ovsdb\automake.mk	/^ovsdb_libovsdb_la_CPPFLAGS = $(AM_CPPFLAGS)$/;"	m
ovsdb_libovsdb_la_LDFLAGS	.\ovsdb\automake.mk	/^ovsdb_libovsdb_la_LDFLAGS = -release $(VERSION)$/;"	m
ovsdb_libovsdb_la_SOURCES	.\ovsdb\automake.mk	/^ovsdb_libovsdb_la_SOURCES = \\$/;"	m
ovsdb_lock	.\ovsdb\server.h	/^struct ovsdb_lock {$/;"	s
ovsdb_lock_get_owner	.\ovsdb\server.c	/^ovsdb_lock_get_owner(const struct ovsdb_lock *lock)$/;"	f
ovsdb_lock_mode	.\ovsdb\server.h	/^enum ovsdb_lock_mode {$/;"	g
ovsdb_lock_waiter	.\ovsdb\server.h	/^struct ovsdb_lock_waiter {$/;"	s
ovsdb_lock_waiter_destroy	.\ovsdb\server.c	/^ovsdb_lock_waiter_destroy(struct ovsdb_lock_waiter *waiter)$/;"	f
ovsdb_lock_waiter_is_owner	.\ovsdb\server.c	/^ovsdb_lock_waiter_is_owner(const struct ovsdb_lock_waiter *waiter)$/;"	f
ovsdb_lock_waiter_remove	.\ovsdb\server.c	/^ovsdb_lock_waiter_remove(struct ovsdb_lock_waiter *waiter)$/;"	f
ovsdb_log	.\ovsdb\log.c	/^struct ovsdb_log {$/;"	s	file:
ovsdb_log_close	.\ovsdb\log.c	/^ovsdb_log_close(struct ovsdb_log *file)$/;"	f
ovsdb_log_commit	.\ovsdb\log.c	/^ovsdb_log_commit(struct ovsdb_log *file)$/;"	f
ovsdb_log_get_offset	.\ovsdb\log.c	/^ovsdb_log_get_offset(const struct ovsdb_log *log)$/;"	f
ovsdb_log_mode	.\ovsdb\log.c	/^enum ovsdb_log_mode {$/;"	g	file:
ovsdb_log_open	.\ovsdb\log.c	/^ovsdb_log_open(const char *name, enum ovsdb_log_open_mode open_mode,$/;"	f
ovsdb_log_open_mode	.\ovsdb\log.h	/^enum ovsdb_log_open_mode {$/;"	g
ovsdb_log_read	.\ovsdb\log.c	/^ovsdb_log_read(struct ovsdb_log *file, struct json **jsonp)$/;"	f
ovsdb_log_read_cbdata	.\ovsdb\log.c	/^struct ovsdb_log_read_cbdata {$/;"	s	file:
ovsdb_log_unread	.\ovsdb\log.c	/^ovsdb_log_unread(struct ovsdb_log *file)$/;"	f
ovsdb_log_write	.\ovsdb\log.c	/^ovsdb_log_write(struct ovsdb_log *file, struct json *json)$/;"	f
ovsdb_mutation	.\ovsdb\mutation.h	/^struct ovsdb_mutation {$/;"	s
ovsdb_mutation_check_count	.\ovsdb\mutation.c	/^ovsdb_mutation_check_count(struct ovsdb_datum *dst,$/;"	f	file:
ovsdb_mutation_free	.\ovsdb\mutation.c	/^ovsdb_mutation_free(struct ovsdb_mutation *m)$/;"	f	file:
ovsdb_mutation_from_json	.\ovsdb\mutation.c	/^ovsdb_mutation_from_json(const struct ovsdb_table_schema *ts,$/;"	f	file:
ovsdb_mutation_scalar_error	.\ovsdb\mutation.c	/^enum ovsdb_mutation_scalar_error {$/;"	g	file:
ovsdb_mutation_scalar_error	.\ovsdb\mutation.c	/^ovsdb_mutation_scalar_error(enum ovsdb_mutation_scalar_error error,$/;"	f	file:
ovsdb_mutation_set	.\ovsdb\mutation.h	/^struct ovsdb_mutation_set {$/;"	s
ovsdb_mutation_set_destroy	.\ovsdb\mutation.c	/^ovsdb_mutation_set_destroy(struct ovsdb_mutation_set *set)$/;"	f
ovsdb_mutation_set_execute	.\ovsdb\mutation.c	/^ovsdb_mutation_set_execute(struct ovsdb_row *row,$/;"	f
ovsdb_mutation_set_from_json	.\ovsdb\mutation.c	/^ovsdb_mutation_set_from_json(const struct ovsdb_table_schema *ts,$/;"	f
ovsdb_mutation_set_to_json	.\ovsdb\mutation.c	/^ovsdb_mutation_set_to_json(const struct ovsdb_mutation_set *set)$/;"	f
ovsdb_mutation_to_json	.\ovsdb\mutation.c	/^ovsdb_mutation_to_json(const struct ovsdb_mutation *m)$/;"	f	file:
ovsdb_mutator	.\ovsdb\mutation.h	/^enum ovsdb_mutator {$/;"	g
ovsdb_mutator_from_string	.\ovsdb\mutation.c	/^ovsdb_mutator_from_string(const char *name, enum ovsdb_mutator *mutator)$/;"	f
ovsdb_mutator_to_string	.\ovsdb\mutation.c	/^ovsdb_mutator_to_string(enum ovsdb_mutator mutator)$/;"	f
ovsdb_operation_executor	.\ovsdb\execution.c	/^typedef struct ovsdb_error *ovsdb_operation_executor(struct ovsdb_execution *,$/;"	t	typeref:struct:ovsdb_operation_executor	file:
ovsdb_ovsdb_client_LDADD	.\ovsdb\automake.mk	/^ovsdb_ovsdb_client_LDADD = ovsdb\/libovsdb.la lib\/libopenvswitch.la$/;"	m
ovsdb_ovsdb_client_SOURCES	.\ovsdb\automake.mk	/^ovsdb_ovsdb_client_SOURCES = ovsdb\/ovsdb-client.c$/;"	m
ovsdb_ovsdb_server_LDADD	.\ovsdb\automake.mk	/^ovsdb_ovsdb_server_LDADD = ovsdb\/libovsdb.la lib\/libopenvswitch.la$/;"	m
ovsdb_ovsdb_server_SOURCES	.\ovsdb\automake.mk	/^ovsdb_ovsdb_server_SOURCES = ovsdb\/ovsdb-server.c$/;"	m
ovsdb_ovsdb_tool_LDADD	.\ovsdb\automake.mk	/^ovsdb_ovsdb_tool_LDADD = ovsdb\/libovsdb.la lib\/libopenvswitch.la$/;"	m
ovsdb_ovsdb_tool_SOURCES	.\ovsdb\automake.mk	/^ovsdb_ovsdb_tool_SOURCES = ovsdb\/ovsdb-tool.c$/;"	m
ovsdb_parser	.\lib\ovsdb-parser.h	/^struct ovsdb_parser {$/;"	s
ovsdb_parser_finish	.\lib\ovsdb-parser.c	/^ovsdb_parser_finish(struct ovsdb_parser *parser)$/;"	f
ovsdb_parser_get_error	.\lib\ovsdb-parser.c	/^ovsdb_parser_get_error(const struct ovsdb_parser *parser)$/;"	f
ovsdb_parser_has_error	.\lib\ovsdb-parser.c	/^ovsdb_parser_has_error(const struct ovsdb_parser *parser)$/;"	f
ovsdb_parser_init	.\lib\ovsdb-parser.c	/^ovsdb_parser_init(struct ovsdb_parser *parser, const struct json *json,$/;"	f
ovsdb_parser_is_id	.\lib\ovsdb-parser.c	/^ovsdb_parser_is_id(const char *string)$/;"	f
ovsdb_parser_member	.\lib\ovsdb-parser.c	/^ovsdb_parser_member(struct ovsdb_parser *parser, const char *name,$/;"	f
ovsdb_parser_raise_error	.\lib\ovsdb-parser.c	/^ovsdb_parser_raise_error(struct ovsdb_parser *parser, const char *format, ...)$/;"	f
ovsdb_parser_types	.\lib\ovsdb-parser.h	/^enum ovsdb_parser_types {$/;"	g
ovsdb_query	.\ovsdb\query.c	/^ovsdb_query(struct ovsdb_table *table, const struct ovsdb_condition *cnd,$/;"	f
ovsdb_query_distinct	.\ovsdb\query.c	/^ovsdb_query_distinct(struct ovsdb_table *table,$/;"	f
ovsdb_query_row_set	.\ovsdb\query.c	/^ovsdb_query_row_set(struct ovsdb_table *table,$/;"	f
ovsdb_real_constraints	.\lib\ovsdb-types.h	/^        struct ovsdb_real_constraints {$/;"	s	union:ovsdb_base_type::__anon86
ovsdb_ref_type	.\lib\ovsdb-types.h	/^enum ovsdb_ref_type {$/;"	g
ovsdb_remove_replica	.\ovsdb\ovsdb.c	/^ovsdb_remove_replica(struct ovsdb *db OVS_UNUSED, struct ovsdb_replica *r)$/;"	f
ovsdb_replica	.\ovsdb\ovsdb.h	/^struct ovsdb_replica {$/;"	s
ovsdb_replica_class	.\ovsdb\ovsdb.h	/^struct ovsdb_replica_class {$/;"	s
ovsdb_replica_init	.\ovsdb\ovsdb.c	/^ovsdb_replica_init(struct ovsdb_replica *r,$/;"	f
ovsdb_row	.\ovsdb\row.h	/^struct ovsdb_row {$/;"	s
ovsdb_row_clone	.\ovsdb\row.c	/^ovsdb_row_clone(const struct ovsdb_row *old)$/;"	f
ovsdb_row_columns_to_string	.\ovsdb\row.c	/^ovsdb_row_columns_to_string(const struct ovsdb_row *row,$/;"	f
ovsdb_row_compare_columns_3way	.\ovsdb\row.c	/^ovsdb_row_compare_columns_3way(const struct ovsdb_row *a,$/;"	f
ovsdb_row_create	.\ovsdb\row.c	/^ovsdb_row_create(const struct ovsdb_table *table)$/;"	f
ovsdb_row_destroy	.\ovsdb\row.c	/^ovsdb_row_destroy(struct ovsdb_row *row)$/;"	f
ovsdb_row_equal_columns	.\ovsdb\row.c	/^ovsdb_row_equal_columns(const struct ovsdb_row *a,$/;"	f
ovsdb_row_from_index_node	.\ovsdb\transaction.c	/^ovsdb_row_from_index_node(struct hmap_node *index_node,$/;"	f	file:
ovsdb_row_from_json	.\ovsdb\row.c	/^ovsdb_row_from_json(struct ovsdb_row *row, const struct json *json,$/;"	f
ovsdb_row_get_index_node	.\ovsdb\transaction.c	/^ovsdb_row_get_index_node(struct ovsdb_row *row, size_t i)$/;"	f	file:
ovsdb_row_get_uuid	.\ovsdb\row.h	/^ovsdb_row_get_uuid(const struct ovsdb_row *row)$/;"	f
ovsdb_row_get_uuid_rw	.\ovsdb\row.h	/^ovsdb_row_get_uuid_rw(struct ovsdb_row *row)$/;"	f
ovsdb_row_get_version	.\ovsdb\row.h	/^ovsdb_row_get_version(const struct ovsdb_row *row)$/;"	f
ovsdb_row_get_version_rw	.\ovsdb\row.h	/^ovsdb_row_get_version_rw(struct ovsdb_row *row)$/;"	f
ovsdb_row_hash	.\ovsdb\row.h	/^ovsdb_row_hash(const struct ovsdb_row *row)$/;"	f
ovsdb_row_hash	.\ovsdb\row.h	/^struct ovsdb_row_hash {$/;"	s
ovsdb_row_hash_columns	.\ovsdb\row.c	/^ovsdb_row_hash_columns(const struct ovsdb_row *row,$/;"	f
ovsdb_row_hash_contains	.\ovsdb\row.c	/^ovsdb_row_hash_contains(const struct ovsdb_row_hash *rh,$/;"	f
ovsdb_row_hash_contains__	.\ovsdb\row.c	/^ovsdb_row_hash_contains__(const struct ovsdb_row_hash *rh,$/;"	f
ovsdb_row_hash_contains_all	.\ovsdb\row.c	/^ovsdb_row_hash_contains_all(const struct ovsdb_row_hash *a,$/;"	f
ovsdb_row_hash_count	.\ovsdb\row.c	/^ovsdb_row_hash_count(const struct ovsdb_row_hash *rh)$/;"	f
ovsdb_row_hash_destroy	.\ovsdb\row.c	/^ovsdb_row_hash_destroy(struct ovsdb_row_hash *rh, bool destroy_rows)$/;"	f
ovsdb_row_hash_init	.\ovsdb\row.c	/^ovsdb_row_hash_init(struct ovsdb_row_hash *rh,$/;"	f
ovsdb_row_hash_insert	.\ovsdb\row.c	/^ovsdb_row_hash_insert(struct ovsdb_row_hash *rh, const struct ovsdb_row *row)$/;"	f
ovsdb_row_hash_insert__	.\ovsdb\row.c	/^ovsdb_row_hash_insert__(struct ovsdb_row_hash *rh, const struct ovsdb_row *row,$/;"	f
ovsdb_row_hash_node	.\ovsdb\row.h	/^struct ovsdb_row_hash_node {$/;"	s
ovsdb_row_index_offset__	.\ovsdb\transaction.c	/^ovsdb_row_index_offset__(const struct ovsdb_table *table, size_t i)$/;"	f	file:
ovsdb_row_set	.\ovsdb\row.h	/^struct ovsdb_row_set {$/;"	s
ovsdb_row_set_add_row	.\ovsdb\row.c	/^ovsdb_row_set_add_row(struct ovsdb_row_set *set, const struct ovsdb_row *row)$/;"	f
ovsdb_row_set_destroy	.\ovsdb\row.c	/^ovsdb_row_set_destroy(struct ovsdb_row_set *set)$/;"	f
ovsdb_row_set_init	.\ovsdb\row.c	/^ovsdb_row_set_init(struct ovsdb_row_set *set)$/;"	f
ovsdb_row_set_sort	.\ovsdb\row.c	/^ovsdb_row_set_sort(struct ovsdb_row_set *set,$/;"	f
ovsdb_row_set_sort_cbdata	.\ovsdb\row.c	/^struct ovsdb_row_set_sort_cbdata {$/;"	s	file:
ovsdb_row_set_sort_compare_cb	.\ovsdb\row.c	/^ovsdb_row_set_sort_compare_cb(size_t a, size_t b, void *cbdata_)$/;"	f	file:
ovsdb_row_set_sort_swap_cb	.\ovsdb\row.c	/^ovsdb_row_set_sort_swap_cb(size_t a, size_t b, void *cbdata_)$/;"	f	file:
ovsdb_row_set_to_json	.\ovsdb\row.c	/^ovsdb_row_set_to_json(const struct ovsdb_row_set *rows,$/;"	f
ovsdb_row_to_json	.\ovsdb\row.c	/^ovsdb_row_to_json(const struct ovsdb_row *row,$/;"	f
ovsdb_row_update_columns	.\ovsdb\row.c	/^ovsdb_row_update_columns(struct ovsdb_row *dst,$/;"	f
ovsdb_scalar_mutation	.\ovsdb\mutation.c	/^struct ovsdb_scalar_mutation {$/;"	s	file:
ovsdb_schema	.\ovsdb\ovsdb.h	/^struct ovsdb_schema {$/;"	s
ovsdb_schema_check_ref_table	.\ovsdb\ovsdb.c	/^ovsdb_schema_check_ref_table(struct ovsdb_column *column,$/;"	f	file:
ovsdb_schema_clone	.\ovsdb\ovsdb.c	/^ovsdb_schema_clone(const struct ovsdb_schema *old)$/;"	f
ovsdb_schema_create	.\ovsdb\ovsdb.c	/^ovsdb_schema_create(const char *name, const char *version, const char *cksum)$/;"	f
ovsdb_schema_destroy	.\ovsdb\ovsdb.c	/^ovsdb_schema_destroy(struct ovsdb_schema *schema)$/;"	f
ovsdb_schema_equal	.\ovsdb\ovsdb.c	/^ovsdb_schema_equal(const struct ovsdb_schema *a,$/;"	f
ovsdb_schema_from_file	.\ovsdb\ovsdb.c	/^ovsdb_schema_from_file(const char *file_name, struct ovsdb_schema **schemap)$/;"	f
ovsdb_schema_from_json	.\ovsdb\ovsdb.c	/^ovsdb_schema_from_json(struct json *json, struct ovsdb_schema **schemap)$/;"	f
ovsdb_schema_to_json	.\ovsdb\ovsdb.c	/^ovsdb_schema_to_json(const struct ovsdb_schema *schema)$/;"	f
ovsdb_server	.\ovsdb\ovsdb-server.c	/^VLOG_DEFINE_THIS_MODULE(ovsdb_server);$/;"	v
ovsdb_server	.\ovsdb\server.h	/^struct ovsdb_server {$/;"	s
ovsdb_server_add_database	.\ovsdb\ovsdb-server.c	/^ovsdb_server_add_database(struct unixctl_conn *conn, int argc OVS_UNUSED,$/;"	f	file:
ovsdb_server_add_database	.\ovsdb\ovsdb-server.c	/^static unixctl_cb_func ovsdb_server_add_database;$/;"	v	file:
ovsdb_server_add_db	.\ovsdb\server.c	/^ovsdb_server_add_db(struct ovsdb_server *server, struct ovsdb *db)$/;"	f
ovsdb_server_add_remote	.\ovsdb\ovsdb-server.c	/^ovsdb_server_add_remote(struct unixctl_conn *conn, int argc OVS_UNUSED,$/;"	f	file:
ovsdb_server_add_remote	.\ovsdb\ovsdb-server.c	/^static unixctl_cb_func ovsdb_server_add_remote;$/;"	v	file:
ovsdb_server_compact	.\ovsdb\ovsdb-server.c	/^ovsdb_server_compact(struct unixctl_conn *conn, int argc,$/;"	f	file:
ovsdb_server_compact	.\ovsdb\ovsdb-server.c	/^static unixctl_cb_func ovsdb_server_compact;$/;"	v	file:
ovsdb_server_create_lock__	.\ovsdb\server.c	/^ovsdb_server_create_lock__(struct ovsdb_server *server, const char *lock_name,$/;"	f	file:
ovsdb_server_destroy	.\ovsdb\server.c	/^ovsdb_server_destroy(struct ovsdb_server *server)$/;"	f
ovsdb_server_exit	.\ovsdb\ovsdb-server.c	/^ovsdb_server_exit(struct unixctl_conn *conn, int argc OVS_UNUSED,$/;"	f	file:
ovsdb_server_exit	.\ovsdb\ovsdb-server.c	/^static unixctl_cb_func ovsdb_server_exit;$/;"	v	file:
ovsdb_server_init	.\ovsdb\server.c	/^ovsdb_server_init(struct ovsdb_server *server)$/;"	f
ovsdb_server_list_databases	.\ovsdb\ovsdb-server.c	/^ovsdb_server_list_databases(struct unixctl_conn *conn, int argc OVS_UNUSED,$/;"	f	file:
ovsdb_server_list_databases	.\ovsdb\ovsdb-server.c	/^static unixctl_cb_func ovsdb_server_list_databases;$/;"	v	file:
ovsdb_server_list_remotes	.\ovsdb\ovsdb-server.c	/^ovsdb_server_list_remotes(struct unixctl_conn *conn, int argc OVS_UNUSED,$/;"	f	file:
ovsdb_server_list_remotes	.\ovsdb\ovsdb-server.c	/^static unixctl_cb_func ovsdb_server_list_remotes;$/;"	v	file:
ovsdb_server_lock	.\ovsdb\server.c	/^ovsdb_server_lock(struct ovsdb_server *server,$/;"	f
ovsdb_server_reconnect	.\ovsdb\ovsdb-server.c	/^ovsdb_server_reconnect(struct unixctl_conn *conn, int argc OVS_UNUSED,$/;"	f	file:
ovsdb_server_reconnect	.\ovsdb\ovsdb-server.c	/^static unixctl_cb_func ovsdb_server_reconnect;$/;"	v	file:
ovsdb_server_remove_database	.\ovsdb\ovsdb-server.c	/^ovsdb_server_remove_database(struct unixctl_conn *conn, int argc OVS_UNUSED,$/;"	f	file:
ovsdb_server_remove_database	.\ovsdb\ovsdb-server.c	/^static unixctl_cb_func ovsdb_server_remove_database;$/;"	v	file:
ovsdb_server_remove_db	.\ovsdb\server.c	/^ovsdb_server_remove_db(struct ovsdb_server *server, struct ovsdb *db)$/;"	f
ovsdb_server_remove_remote	.\ovsdb\ovsdb-server.c	/^ovsdb_server_remove_remote(struct unixctl_conn *conn, int argc OVS_UNUSED,$/;"	f	file:
ovsdb_server_remove_remote	.\ovsdb\ovsdb-server.c	/^static unixctl_cb_func ovsdb_server_remove_remote;$/;"	v	file:
ovsdb_session	.\ovsdb\server.h	/^struct ovsdb_session {$/;"	s
ovsdb_session_destroy	.\ovsdb\server.c	/^ovsdb_session_destroy(struct ovsdb_session *session)$/;"	f
ovsdb_session_get_lock_waiter	.\ovsdb\server.c	/^ovsdb_session_get_lock_waiter(const struct ovsdb_session *session,$/;"	f
ovsdb_session_init	.\ovsdb\server.c	/^ovsdb_session_init(struct ovsdb_session *session, struct ovsdb_server *server)$/;"	f
ovsdb_set_ref_table	.\ovsdb\ovsdb.c	/^ovsdb_set_ref_table(const struct shash *tables,$/;"	f	file:
ovsdb_string_constraints	.\lib\ovsdb-types.h	/^        struct ovsdb_string_constraints {$/;"	s	union:ovsdb_base_type::__anon86
ovsdb_symbol	.\lib\ovsdb-data.h	/^struct ovsdb_symbol {$/;"	s
ovsdb_symbol_referenced	.\lib\ovsdb-data.c	/^ovsdb_symbol_referenced(struct ovsdb_symbol *symbol,$/;"	f	file:
ovsdb_symbol_table	.\lib\ovsdb-data.h	/^struct ovsdb_symbol_table {$/;"	s
ovsdb_symbol_table_create	.\lib\ovsdb-data.c	/^ovsdb_symbol_table_create(void)$/;"	f
ovsdb_symbol_table_destroy	.\lib\ovsdb-data.c	/^ovsdb_symbol_table_destroy(struct ovsdb_symbol_table *symtab)$/;"	f
ovsdb_symbol_table_get	.\lib\ovsdb-data.c	/^ovsdb_symbol_table_get(const struct ovsdb_symbol_table *symtab,$/;"	f
ovsdb_symbol_table_insert	.\lib\ovsdb-data.c	/^ovsdb_symbol_table_insert(struct ovsdb_symbol_table *symtab,$/;"	f
ovsdb_symbol_table_put	.\lib\ovsdb-data.c	/^ovsdb_symbol_table_put(struct ovsdb_symbol_table *symtab, const char *name,$/;"	f
ovsdb_syntax_error	.\lib\ovsdb-error.c	/^ovsdb_syntax_error(const struct json *json, const char *tag,$/;"	f
ovsdb_table	.\ovsdb\table.h	/^struct ovsdb_table {$/;"	s
ovsdb_table_create	.\ovsdb\table.c	/^ovsdb_table_create(struct ovsdb_table_schema *ts)$/;"	f
ovsdb_table_destroy	.\ovsdb\table.c	/^ovsdb_table_destroy(struct ovsdb_table *table)$/;"	f
ovsdb_table_get_row	.\ovsdb\table.c	/^ovsdb_table_get_row(const struct ovsdb_table *table, const struct uuid *uuid)$/;"	f
ovsdb_table_schema	.\ovsdb\table.h	/^struct ovsdb_table_schema {$/;"	s
ovsdb_table_schema_clone	.\ovsdb\table.c	/^ovsdb_table_schema_clone(const struct ovsdb_table_schema *old)$/;"	f
ovsdb_table_schema_create	.\ovsdb\table.c	/^ovsdb_table_schema_create(const char *name, bool mutable,$/;"	f
ovsdb_table_schema_destroy	.\ovsdb\table.c	/^ovsdb_table_schema_destroy(struct ovsdb_table_schema *ts)$/;"	f
ovsdb_table_schema_from_json	.\ovsdb\table.c	/^ovsdb_table_schema_from_json(const struct json *json, const char *name,$/;"	f
ovsdb_table_schema_get_column	.\ovsdb\table.c	/^ovsdb_table_schema_get_column(const struct ovsdb_table_schema *ts,$/;"	f
ovsdb_table_schema_to_json	.\ovsdb\table.c	/^ovsdb_table_schema_to_json(const struct ovsdb_table_schema *ts,$/;"	f
ovsdb_token_is_delim	.\lib\ovsdb-data.c	/^ovsdb_token_is_delim(unsigned char c)$/;"	f
ovsdb_token_parse	.\lib\ovsdb-data.c	/^ovsdb_token_parse(const char **s, char **outp)$/;"	f
ovsdb_trigger	.\ovsdb\trigger.h	/^struct ovsdb_trigger {$/;"	s
ovsdb_trigger_complete	.\ovsdb\trigger.c	/^ovsdb_trigger_complete(struct ovsdb_trigger *t)$/;"	f	file:
ovsdb_trigger_destroy	.\ovsdb\trigger.c	/^ovsdb_trigger_destroy(struct ovsdb_trigger *trigger)$/;"	f
ovsdb_trigger_init	.\ovsdb\trigger.c	/^ovsdb_trigger_init(struct ovsdb_session *session, struct ovsdb *db,$/;"	f
ovsdb_trigger_is_complete	.\ovsdb\trigger.c	/^ovsdb_trigger_is_complete(const struct ovsdb_trigger *trigger)$/;"	f
ovsdb_trigger_run	.\ovsdb\trigger.c	/^ovsdb_trigger_run(struct ovsdb *db, long long int now)$/;"	f
ovsdb_trigger_steal_result	.\ovsdb\trigger.c	/^ovsdb_trigger_steal_result(struct ovsdb_trigger *trigger)$/;"	f
ovsdb_trigger_try	.\ovsdb\trigger.c	/^ovsdb_trigger_try(struct ovsdb_trigger *t, long long int now)$/;"	f	file:
ovsdb_trigger_wait	.\ovsdb\trigger.c	/^ovsdb_trigger_wait(struct ovsdb *db, long long int now)$/;"	f
ovsdb_txn	.\ovsdb\transaction.c	/^struct ovsdb_txn {$/;"	s	file:
ovsdb_txn_abort	.\ovsdb\transaction.c	/^ovsdb_txn_abort(struct ovsdb_txn *txn)$/;"	f
ovsdb_txn_add_comment	.\ovsdb\transaction.c	/^ovsdb_txn_add_comment(struct ovsdb_txn *txn, const char *s)$/;"	f
ovsdb_txn_adjust_atom_refs	.\ovsdb\transaction.c	/^ovsdb_txn_adjust_atom_refs(struct ovsdb_txn *txn, const struct ovsdb_row *r,$/;"	f	file:
ovsdb_txn_adjust_row_refs	.\ovsdb\transaction.c	/^ovsdb_txn_adjust_row_refs(struct ovsdb_txn *txn, const struct ovsdb_row *r,$/;"	f	file:
ovsdb_txn_commit	.\ovsdb\transaction.c	/^ovsdb_txn_commit(struct ovsdb_txn *txn, bool durable)$/;"	f
ovsdb_txn_create	.\ovsdb\transaction.c	/^ovsdb_txn_create(struct ovsdb *db)$/;"	f
ovsdb_txn_create_txn_table	.\ovsdb\transaction.c	/^ovsdb_txn_create_txn_table(struct ovsdb_txn *txn, struct ovsdb_table *table)$/;"	f	file:
ovsdb_txn_for_each_change	.\ovsdb\transaction.c	/^ovsdb_txn_for_each_change(const struct ovsdb_txn *txn,$/;"	f
ovsdb_txn_free	.\ovsdb\transaction.c	/^ovsdb_txn_free(struct ovsdb_txn *txn)$/;"	f	file:
ovsdb_txn_get_comment	.\ovsdb\transaction.c	/^ovsdb_txn_get_comment(const struct ovsdb_txn *txn)$/;"	f
ovsdb_txn_row	.\ovsdb\transaction.c	/^struct ovsdb_txn_row {$/;"	s	file:
ovsdb_txn_row_abort	.\ovsdb\transaction.c	/^ovsdb_txn_row_abort(struct ovsdb_txn *txn OVS_UNUSED,$/;"	f	file:
ovsdb_txn_row_cb_func	.\ovsdb\transaction.h	/^typedef bool ovsdb_txn_row_cb_func(const struct ovsdb_row *old,$/;"	t
ovsdb_txn_row_commit	.\ovsdb\transaction.c	/^ovsdb_txn_row_commit(struct ovsdb_txn *txn OVS_UNUSED,$/;"	f	file:
ovsdb_txn_row_create	.\ovsdb\transaction.c	/^ovsdb_txn_row_create(struct ovsdb_txn *txn, struct ovsdb_table *table,$/;"	f	file:
ovsdb_txn_row_delete	.\ovsdb\transaction.c	/^ovsdb_txn_row_delete(struct ovsdb_txn *txn, const struct ovsdb_row *row_)$/;"	f
ovsdb_txn_row_insert	.\ovsdb\transaction.c	/^ovsdb_txn_row_insert(struct ovsdb_txn *txn, struct ovsdb_row *row)$/;"	f
ovsdb_txn_row_modify	.\ovsdb\transaction.c	/^ovsdb_txn_row_modify(struct ovsdb_txn *txn, const struct ovsdb_row *ro_row_)$/;"	f
ovsdb_txn_row_prefree	.\ovsdb\transaction.c	/^ovsdb_txn_row_prefree(struct ovsdb_txn_row *txn_row)$/;"	f	file:
ovsdb_txn_table	.\ovsdb\transaction.c	/^struct ovsdb_txn_table {$/;"	s	file:
ovsdb_txn_table_destroy	.\ovsdb\transaction.c	/^ovsdb_txn_table_destroy(struct ovsdb_txn_table *txn_table)$/;"	f	file:
ovsdb_type	.\lib\ovsdb-types.h	/^struct ovsdb_type {$/;"	s
ovsdb_type_boolean	.\lib\ovsdb-types.c	/^const struct ovsdb_type ovsdb_type_boolean =$/;"	v	typeref:struct:ovsdb_type
ovsdb_type_clone	.\lib\ovsdb-types.c	/^ovsdb_type_clone(struct ovsdb_type *dst, const struct ovsdb_type *src)$/;"	f
ovsdb_type_destroy	.\lib\ovsdb-types.c	/^ovsdb_type_destroy(struct ovsdb_type *type)$/;"	f
ovsdb_type_from_json	.\lib\ovsdb-types.c	/^ovsdb_type_from_json(struct ovsdb_type *type, const struct json *json)$/;"	f
ovsdb_type_integer	.\lib\ovsdb-types.c	/^const struct ovsdb_type ovsdb_type_integer =$/;"	v	typeref:struct:ovsdb_type
ovsdb_type_is_composite	.\lib\ovsdb-types.h	/^static inline bool ovsdb_type_is_composite(const struct ovsdb_type *type)$/;"	f
ovsdb_type_is_map	.\lib\ovsdb-types.h	/^static inline bool ovsdb_type_is_map(const struct ovsdb_type *type)$/;"	f
ovsdb_type_is_optional	.\lib\ovsdb-types.h	/^static inline bool ovsdb_type_is_optional(const struct ovsdb_type *type)$/;"	f
ovsdb_type_is_scalar	.\lib\ovsdb-types.h	/^static inline bool ovsdb_type_is_scalar(const struct ovsdb_type *type)$/;"	f
ovsdb_type_is_set	.\lib\ovsdb-types.h	/^static inline bool ovsdb_type_is_set(const struct ovsdb_type *type)$/;"	f
ovsdb_type_is_valid	.\lib\ovsdb-types.c	/^ovsdb_type_is_valid(const struct ovsdb_type *type)$/;"	f
ovsdb_type_real	.\lib\ovsdb-types.c	/^const struct ovsdb_type ovsdb_type_real =$/;"	v	typeref:struct:ovsdb_type
ovsdb_type_string	.\lib\ovsdb-types.c	/^const struct ovsdb_type ovsdb_type_string =$/;"	v	typeref:struct:ovsdb_type
ovsdb_type_to_english	.\lib\ovsdb-types.c	/^ovsdb_type_to_english(const struct ovsdb_type *type)$/;"	f
ovsdb_type_to_json	.\lib\ovsdb-types.c	/^ovsdb_type_to_json(const struct ovsdb_type *type)$/;"	f
ovsdb_type_uuid	.\lib\ovsdb-types.c	/^const struct ovsdb_type ovsdb_type_uuid =$/;"	v	typeref:struct:ovsdb_type
ovsdb_uuid_constraints	.\lib\ovsdb-types.h	/^        struct ovsdb_uuid_constraints {$/;"	s	union:ovsdb_base_type::__anon86
ovsdb_weak_ref	.\ovsdb\row.h	/^struct ovsdb_weak_ref {$/;"	s
ovsdb_wrap_error	.\lib\ovsdb-error.c	/^ovsdb_wrap_error(struct ovsdb_error *error, const char *details, ...)$/;"	f
ovsl_dereference	.\datapath\datapath.h	153;"	d
ovsrcu_call_postponed	.\lib\ovs-rcu.c	/^ovsrcu_call_postponed(void)$/;"	f	file:
ovsrcu_cb	.\lib\ovs-rcu.c	/^struct ovsrcu_cb {$/;"	s	file:
ovsrcu_cbset	.\lib\ovs-rcu.c	/^struct ovsrcu_cbset {$/;"	s	file:
ovsrcu_flush_cbset	.\lib\ovs-rcu.c	/^ovsrcu_flush_cbset(struct ovsrcu_perthread *perthread)$/;"	f	file:
ovsrcu_get	.\lib\ovs-rcu.h	141;"	d
ovsrcu_get	.\lib\ovs-rcu.h	170;"	d
ovsrcu_get__	.\lib\ovs-rcu.h	/^ovsrcu_get__(const struct ovsrcu_pointer *pointer, memory_order order)$/;"	f
ovsrcu_get__	.\lib\ovs-rcu.h	132;"	d
ovsrcu_get_protected	.\lib\ovs-rcu.h	143;"	d
ovsrcu_get_protected	.\lib\ovs-rcu.h	172;"	d
ovsrcu_init	.\lib\ovs-rcu.c	/^ovsrcu_init(void)$/;"	f	file:
ovsrcu_is_quiescent	.\lib\ovs-rcu.c	/^ovsrcu_is_quiescent(void)$/;"	f
ovsrcu_perthread	.\lib\ovs-rcu.c	/^struct ovsrcu_perthread {$/;"	s	file:
ovsrcu_perthread_get	.\lib\ovs-rcu.c	/^ovsrcu_perthread_get(void)$/;"	f	file:
ovsrcu_pointer	.\lib\ovs-rcu.h	/^struct ovsrcu_pointer { ATOMIC(void *) p; };$/;"	s
ovsrcu_postpone	.\lib\ovs-rcu.h	193;"	d
ovsrcu_postpone__	.\lib\ovs-rcu.c	/^ovsrcu_postpone__(void (*function)(void *aux), void *aux)$/;"	f
ovsrcu_postpone_thread	.\lib\ovs-rcu.c	/^ovsrcu_postpone_thread(void *arg OVS_UNUSED)$/;"	f	file:
ovsrcu_quiesce	.\lib\ovs-rcu.c	/^ovsrcu_quiesce(void)$/;"	f
ovsrcu_quiesce_end	.\lib\ovs-rcu.c	/^ovsrcu_quiesce_end(void)$/;"	f
ovsrcu_quiesce_start	.\lib\ovs-rcu.c	/^ovsrcu_quiesce_start(void)$/;"	f
ovsrcu_quiesced	.\lib\ovs-rcu.c	/^ovsrcu_quiesced(void)$/;"	f	file:
ovsrcu_set	.\lib\ovs-rcu.h	187;"	d
ovsrcu_set__	.\lib\ovs-rcu.h	/^static inline void ovsrcu_set__(struct ovsrcu_pointer *pointer,$/;"	f
ovsrcu_set__	.\lib\ovs-rcu.h	150;"	d
ovsrcu_synchronize	.\lib\ovs-rcu.c	/^ovsrcu_synchronize(void)$/;"	f	file:
ovsrcu_thread_exit_cb	.\lib\ovs-rcu.c	/^ovsrcu_thread_exit_cb(void *perthread)$/;"	f	file:
ovsrcu_threads	.\lib\ovs-rcu.c	/^static struct list ovsrcu_threads;$/;"	v	typeref:struct:list	file:
ovsrcu_threads_mutex	.\lib\ovs-rcu.c	/^static struct ovs_mutex ovsrcu_threads_mutex;$/;"	v	typeref:struct:ovs_mutex	file:
ovsrcu_unregister__	.\lib\ovs-rcu.c	/^ovsrcu_unregister__(struct ovsrcu_perthread *perthread)$/;"	f	file:
ovsrec_bridge	.\lib\vswitch-idl.h	/^struct ovsrec_bridge {$/;"	s
ovsrec_bridge_cast	.\lib\vswitch-idl.c	/^ovsrec_bridge_cast(const struct ovsdb_idl_row *row)$/;"	f	file:
ovsrec_bridge_col_controller	.\lib\vswitch-idl.h	107;"	d
ovsrec_bridge_col_datapath_id	.\lib\vswitch-idl.h	100;"	d
ovsrec_bridge_col_datapath_type	.\lib\vswitch-idl.h	101;"	d
ovsrec_bridge_col_external_ids	.\lib\vswitch-idl.h	111;"	d
ovsrec_bridge_col_fail_mode	.\lib\vswitch-idl.h	99;"	d
ovsrec_bridge_col_flood_vlans	.\lib\vswitch-idl.h	106;"	d
ovsrec_bridge_col_flow_tables	.\lib\vswitch-idl.h	110;"	d
ovsrec_bridge_col_ipfix	.\lib\vswitch-idl.h	104;"	d
ovsrec_bridge_col_mirrors	.\lib\vswitch-idl.h	103;"	d
ovsrec_bridge_col_name	.\lib\vswitch-idl.h	114;"	d
ovsrec_bridge_col_netflow	.\lib\vswitch-idl.h	108;"	d
ovsrec_bridge_col_other_config	.\lib\vswitch-idl.h	105;"	d
ovsrec_bridge_col_ports	.\lib\vswitch-idl.h	112;"	d
ovsrec_bridge_col_protocols	.\lib\vswitch-idl.h	113;"	d
ovsrec_bridge_col_sflow	.\lib\vswitch-idl.h	102;"	d
ovsrec_bridge_col_status	.\lib\vswitch-idl.h	98;"	d
ovsrec_bridge_col_stp_enable	.\lib\vswitch-idl.h	109;"	d
ovsrec_bridge_columns	.\lib\vswitch-idl.c	/^struct ovsdb_idl_column ovsrec_bridge_columns[OVSREC_BRIDGE_N_COLUMNS];$/;"	v	typeref:struct:ovsdb_idl_column
ovsrec_bridge_columns_init	.\lib\vswitch-idl.c	/^ovsrec_bridge_columns_init(void)$/;"	f	file:
ovsrec_bridge_delete	.\lib\vswitch-idl.c	/^ovsrec_bridge_delete(const struct ovsrec_bridge *row)$/;"	f
ovsrec_bridge_first	.\lib\vswitch-idl.c	/^ovsrec_bridge_first(const struct ovsdb_idl *idl)$/;"	f
ovsrec_bridge_get_controller	.\lib\vswitch-idl.c	/^ovsrec_bridge_get_controller(const struct ovsrec_bridge *row,$/;"	f
ovsrec_bridge_get_datapath_id	.\lib\vswitch-idl.c	/^ovsrec_bridge_get_datapath_id(const struct ovsrec_bridge *row,$/;"	f
ovsrec_bridge_get_datapath_type	.\lib\vswitch-idl.c	/^ovsrec_bridge_get_datapath_type(const struct ovsrec_bridge *row,$/;"	f
ovsrec_bridge_get_external_ids	.\lib\vswitch-idl.c	/^ovsrec_bridge_get_external_ids(const struct ovsrec_bridge *row,$/;"	f
ovsrec_bridge_get_fail_mode	.\lib\vswitch-idl.c	/^ovsrec_bridge_get_fail_mode(const struct ovsrec_bridge *row,$/;"	f
ovsrec_bridge_get_flood_vlans	.\lib\vswitch-idl.c	/^ovsrec_bridge_get_flood_vlans(const struct ovsrec_bridge *row,$/;"	f
ovsrec_bridge_get_flow_tables	.\lib\vswitch-idl.c	/^ovsrec_bridge_get_flow_tables(const struct ovsrec_bridge *row,$/;"	f
ovsrec_bridge_get_for_uuid	.\lib\vswitch-idl.c	/^ovsrec_bridge_get_for_uuid(const struct ovsdb_idl *idl, const struct uuid *uuid)$/;"	f
ovsrec_bridge_get_ipfix	.\lib\vswitch-idl.c	/^ovsrec_bridge_get_ipfix(const struct ovsrec_bridge *row,$/;"	f
ovsrec_bridge_get_mirrors	.\lib\vswitch-idl.c	/^ovsrec_bridge_get_mirrors(const struct ovsrec_bridge *row,$/;"	f
ovsrec_bridge_get_name	.\lib\vswitch-idl.c	/^ovsrec_bridge_get_name(const struct ovsrec_bridge *row,$/;"	f
ovsrec_bridge_get_netflow	.\lib\vswitch-idl.c	/^ovsrec_bridge_get_netflow(const struct ovsrec_bridge *row,$/;"	f
ovsrec_bridge_get_other_config	.\lib\vswitch-idl.c	/^ovsrec_bridge_get_other_config(const struct ovsrec_bridge *row,$/;"	f
ovsrec_bridge_get_ports	.\lib\vswitch-idl.c	/^ovsrec_bridge_get_ports(const struct ovsrec_bridge *row,$/;"	f
ovsrec_bridge_get_protocols	.\lib\vswitch-idl.c	/^ovsrec_bridge_get_protocols(const struct ovsrec_bridge *row,$/;"	f
ovsrec_bridge_get_sflow	.\lib\vswitch-idl.c	/^ovsrec_bridge_get_sflow(const struct ovsrec_bridge *row,$/;"	f
ovsrec_bridge_get_status	.\lib\vswitch-idl.c	/^ovsrec_bridge_get_status(const struct ovsrec_bridge *row,$/;"	f
ovsrec_bridge_get_stp_enable	.\lib\vswitch-idl.c	/^ovsrec_bridge_get_stp_enable(const struct ovsrec_bridge *row,$/;"	f
ovsrec_bridge_init	.\lib\vswitch-idl.c	/^ovsrec_bridge_init(struct ovsrec_bridge *row)$/;"	f
ovsrec_bridge_init__	.\lib\vswitch-idl.c	/^ovsrec_bridge_init__(struct ovsdb_idl_row *row)$/;"	f	file:
ovsrec_bridge_insert	.\lib\vswitch-idl.c	/^ovsrec_bridge_insert(struct ovsdb_idl_txn *txn)$/;"	f
ovsrec_bridge_next	.\lib\vswitch-idl.c	/^ovsrec_bridge_next(const struct ovsrec_bridge *row)$/;"	f
ovsrec_bridge_parse_controller	.\lib\vswitch-idl.c	/^ovsrec_bridge_parse_controller(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
ovsrec_bridge_parse_datapath_id	.\lib\vswitch-idl.c	/^ovsrec_bridge_parse_datapath_id(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
ovsrec_bridge_parse_datapath_type	.\lib\vswitch-idl.c	/^ovsrec_bridge_parse_datapath_type(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
ovsrec_bridge_parse_external_ids	.\lib\vswitch-idl.c	/^ovsrec_bridge_parse_external_ids(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
ovsrec_bridge_parse_fail_mode	.\lib\vswitch-idl.c	/^ovsrec_bridge_parse_fail_mode(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
ovsrec_bridge_parse_flood_vlans	.\lib\vswitch-idl.c	/^ovsrec_bridge_parse_flood_vlans(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
ovsrec_bridge_parse_flow_tables	.\lib\vswitch-idl.c	/^ovsrec_bridge_parse_flow_tables(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
ovsrec_bridge_parse_ipfix	.\lib\vswitch-idl.c	/^ovsrec_bridge_parse_ipfix(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
ovsrec_bridge_parse_mirrors	.\lib\vswitch-idl.c	/^ovsrec_bridge_parse_mirrors(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
ovsrec_bridge_parse_name	.\lib\vswitch-idl.c	/^ovsrec_bridge_parse_name(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
ovsrec_bridge_parse_netflow	.\lib\vswitch-idl.c	/^ovsrec_bridge_parse_netflow(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
ovsrec_bridge_parse_other_config	.\lib\vswitch-idl.c	/^ovsrec_bridge_parse_other_config(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
ovsrec_bridge_parse_ports	.\lib\vswitch-idl.c	/^ovsrec_bridge_parse_ports(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
ovsrec_bridge_parse_protocols	.\lib\vswitch-idl.c	/^ovsrec_bridge_parse_protocols(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
ovsrec_bridge_parse_sflow	.\lib\vswitch-idl.c	/^ovsrec_bridge_parse_sflow(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
ovsrec_bridge_parse_status	.\lib\vswitch-idl.c	/^ovsrec_bridge_parse_status(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
ovsrec_bridge_parse_stp_enable	.\lib\vswitch-idl.c	/^ovsrec_bridge_parse_stp_enable(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
ovsrec_bridge_set_controller	.\lib\vswitch-idl.c	/^ovsrec_bridge_set_controller(const struct ovsrec_bridge *row, struct ovsrec_controller **controller, size_t n_controller)$/;"	f
ovsrec_bridge_set_datapath_id	.\lib\vswitch-idl.c	/^ovsrec_bridge_set_datapath_id(const struct ovsrec_bridge *row, const char *datapath_id)$/;"	f
ovsrec_bridge_set_datapath_type	.\lib\vswitch-idl.c	/^ovsrec_bridge_set_datapath_type(const struct ovsrec_bridge *row, const char *datapath_type)$/;"	f
ovsrec_bridge_set_external_ids	.\lib\vswitch-idl.c	/^ovsrec_bridge_set_external_ids(const struct ovsrec_bridge *row, const struct smap *smap)$/;"	f
ovsrec_bridge_set_fail_mode	.\lib\vswitch-idl.c	/^ovsrec_bridge_set_fail_mode(const struct ovsrec_bridge *row, const char *fail_mode)$/;"	f
ovsrec_bridge_set_flood_vlans	.\lib\vswitch-idl.c	/^ovsrec_bridge_set_flood_vlans(const struct ovsrec_bridge *row, const int64_t *flood_vlans, size_t n_flood_vlans)$/;"	f
ovsrec_bridge_set_flow_tables	.\lib\vswitch-idl.c	/^ovsrec_bridge_set_flow_tables(const struct ovsrec_bridge *row, const int64_t *key_flow_tables, struct ovsrec_flow_table **value_flow_tables, size_t n_flow_tables)$/;"	f
ovsrec_bridge_set_ipfix	.\lib\vswitch-idl.c	/^ovsrec_bridge_set_ipfix(const struct ovsrec_bridge *row, const struct ovsrec_ipfix *ipfix)$/;"	f
ovsrec_bridge_set_mirrors	.\lib\vswitch-idl.c	/^ovsrec_bridge_set_mirrors(const struct ovsrec_bridge *row, struct ovsrec_mirror **mirrors, size_t n_mirrors)$/;"	f
ovsrec_bridge_set_name	.\lib\vswitch-idl.c	/^ovsrec_bridge_set_name(const struct ovsrec_bridge *row, const char *name)$/;"	f
ovsrec_bridge_set_netflow	.\lib\vswitch-idl.c	/^ovsrec_bridge_set_netflow(const struct ovsrec_bridge *row, const struct ovsrec_netflow *netflow)$/;"	f
ovsrec_bridge_set_other_config	.\lib\vswitch-idl.c	/^ovsrec_bridge_set_other_config(const struct ovsrec_bridge *row, const struct smap *smap)$/;"	f
ovsrec_bridge_set_ports	.\lib\vswitch-idl.c	/^ovsrec_bridge_set_ports(const struct ovsrec_bridge *row, struct ovsrec_port **ports, size_t n_ports)$/;"	f
ovsrec_bridge_set_protocols	.\lib\vswitch-idl.c	/^ovsrec_bridge_set_protocols(const struct ovsrec_bridge *row, char **protocols, size_t n_protocols)$/;"	f
ovsrec_bridge_set_sflow	.\lib\vswitch-idl.c	/^ovsrec_bridge_set_sflow(const struct ovsrec_bridge *row, const struct ovsrec_sflow *sflow)$/;"	f
ovsrec_bridge_set_status	.\lib\vswitch-idl.c	/^ovsrec_bridge_set_status(const struct ovsrec_bridge *row, const struct smap *smap)$/;"	f
ovsrec_bridge_set_stp_enable	.\lib\vswitch-idl.c	/^ovsrec_bridge_set_stp_enable(const struct ovsrec_bridge *row, bool stp_enable)$/;"	f
ovsrec_bridge_unparse_controller	.\lib\vswitch-idl.c	/^ovsrec_bridge_unparse_controller(struct ovsdb_idl_row *row_)$/;"	f	file:
ovsrec_bridge_unparse_datapath_id	.\lib\vswitch-idl.c	/^ovsrec_bridge_unparse_datapath_id(struct ovsdb_idl_row *row OVS_UNUSED)$/;"	f	file:
ovsrec_bridge_unparse_datapath_type	.\lib\vswitch-idl.c	/^ovsrec_bridge_unparse_datapath_type(struct ovsdb_idl_row *row OVS_UNUSED)$/;"	f	file:
ovsrec_bridge_unparse_external_ids	.\lib\vswitch-idl.c	/^ovsrec_bridge_unparse_external_ids(struct ovsdb_idl_row *row_)$/;"	f	file:
ovsrec_bridge_unparse_fail_mode	.\lib\vswitch-idl.c	/^ovsrec_bridge_unparse_fail_mode(struct ovsdb_idl_row *row OVS_UNUSED)$/;"	f	file:
ovsrec_bridge_unparse_flood_vlans	.\lib\vswitch-idl.c	/^ovsrec_bridge_unparse_flood_vlans(struct ovsdb_idl_row *row_)$/;"	f	file:
ovsrec_bridge_unparse_flow_tables	.\lib\vswitch-idl.c	/^ovsrec_bridge_unparse_flow_tables(struct ovsdb_idl_row *row_)$/;"	f	file:
ovsrec_bridge_unparse_ipfix	.\lib\vswitch-idl.c	/^ovsrec_bridge_unparse_ipfix(struct ovsdb_idl_row *row OVS_UNUSED)$/;"	f	file:
ovsrec_bridge_unparse_mirrors	.\lib\vswitch-idl.c	/^ovsrec_bridge_unparse_mirrors(struct ovsdb_idl_row *row_)$/;"	f	file:
ovsrec_bridge_unparse_name	.\lib\vswitch-idl.c	/^ovsrec_bridge_unparse_name(struct ovsdb_idl_row *row OVS_UNUSED)$/;"	f	file:
ovsrec_bridge_unparse_netflow	.\lib\vswitch-idl.c	/^ovsrec_bridge_unparse_netflow(struct ovsdb_idl_row *row OVS_UNUSED)$/;"	f	file:
ovsrec_bridge_unparse_other_config	.\lib\vswitch-idl.c	/^ovsrec_bridge_unparse_other_config(struct ovsdb_idl_row *row_)$/;"	f	file:
ovsrec_bridge_unparse_ports	.\lib\vswitch-idl.c	/^ovsrec_bridge_unparse_ports(struct ovsdb_idl_row *row_)$/;"	f	file:
ovsrec_bridge_unparse_protocols	.\lib\vswitch-idl.c	/^ovsrec_bridge_unparse_protocols(struct ovsdb_idl_row *row_)$/;"	f	file:
ovsrec_bridge_unparse_sflow	.\lib\vswitch-idl.c	/^ovsrec_bridge_unparse_sflow(struct ovsdb_idl_row *row OVS_UNUSED)$/;"	f	file:
ovsrec_bridge_unparse_status	.\lib\vswitch-idl.c	/^ovsrec_bridge_unparse_status(struct ovsdb_idl_row *row_)$/;"	f	file:
ovsrec_bridge_unparse_stp_enable	.\lib\vswitch-idl.c	/^ovsrec_bridge_unparse_stp_enable(struct ovsdb_idl_row *row OVS_UNUSED)$/;"	f	file:
ovsrec_bridge_verify_controller	.\lib\vswitch-idl.c	/^ovsrec_bridge_verify_controller(const struct ovsrec_bridge *row)$/;"	f
ovsrec_bridge_verify_datapath_id	.\lib\vswitch-idl.c	/^ovsrec_bridge_verify_datapath_id(const struct ovsrec_bridge *row)$/;"	f
ovsrec_bridge_verify_datapath_type	.\lib\vswitch-idl.c	/^ovsrec_bridge_verify_datapath_type(const struct ovsrec_bridge *row)$/;"	f
ovsrec_bridge_verify_external_ids	.\lib\vswitch-idl.c	/^ovsrec_bridge_verify_external_ids(const struct ovsrec_bridge *row)$/;"	f
ovsrec_bridge_verify_fail_mode	.\lib\vswitch-idl.c	/^ovsrec_bridge_verify_fail_mode(const struct ovsrec_bridge *row)$/;"	f
ovsrec_bridge_verify_flood_vlans	.\lib\vswitch-idl.c	/^ovsrec_bridge_verify_flood_vlans(const struct ovsrec_bridge *row)$/;"	f
ovsrec_bridge_verify_flow_tables	.\lib\vswitch-idl.c	/^ovsrec_bridge_verify_flow_tables(const struct ovsrec_bridge *row)$/;"	f
ovsrec_bridge_verify_ipfix	.\lib\vswitch-idl.c	/^ovsrec_bridge_verify_ipfix(const struct ovsrec_bridge *row)$/;"	f
ovsrec_bridge_verify_mirrors	.\lib\vswitch-idl.c	/^ovsrec_bridge_verify_mirrors(const struct ovsrec_bridge *row)$/;"	f
ovsrec_bridge_verify_name	.\lib\vswitch-idl.c	/^ovsrec_bridge_verify_name(const struct ovsrec_bridge *row)$/;"	f
ovsrec_bridge_verify_netflow	.\lib\vswitch-idl.c	/^ovsrec_bridge_verify_netflow(const struct ovsrec_bridge *row)$/;"	f
ovsrec_bridge_verify_other_config	.\lib\vswitch-idl.c	/^ovsrec_bridge_verify_other_config(const struct ovsrec_bridge *row)$/;"	f
ovsrec_bridge_verify_ports	.\lib\vswitch-idl.c	/^ovsrec_bridge_verify_ports(const struct ovsrec_bridge *row)$/;"	f
ovsrec_bridge_verify_protocols	.\lib\vswitch-idl.c	/^ovsrec_bridge_verify_protocols(const struct ovsrec_bridge *row)$/;"	f
ovsrec_bridge_verify_sflow	.\lib\vswitch-idl.c	/^ovsrec_bridge_verify_sflow(const struct ovsrec_bridge *row)$/;"	f
ovsrec_bridge_verify_status	.\lib\vswitch-idl.c	/^ovsrec_bridge_verify_status(const struct ovsrec_bridge *row)$/;"	f
ovsrec_bridge_verify_stp_enable	.\lib\vswitch-idl.c	/^ovsrec_bridge_verify_stp_enable(const struct ovsrec_bridge *row)$/;"	f
ovsrec_controller	.\lib\vswitch-idl.h	/^struct ovsrec_controller {$/;"	s
ovsrec_controller_cast	.\lib\vswitch-idl.c	/^ovsrec_controller_cast(const struct ovsdb_idl_row *row)$/;"	f	file:
ovsrec_controller_col_connection_mode	.\lib\vswitch-idl.h	270;"	d
ovsrec_controller_col_controller_burst_limit	.\lib\vswitch-idl.h	276;"	d
ovsrec_controller_col_controller_rate_limit	.\lib\vswitch-idl.h	272;"	d
ovsrec_controller_col_enable_async_messages	.\lib\vswitch-idl.h	280;"	d
ovsrec_controller_col_external_ids	.\lib\vswitch-idl.h	277;"	d
ovsrec_controller_col_inactivity_probe	.\lib\vswitch-idl.h	273;"	d
ovsrec_controller_col_is_connected	.\lib\vswitch-idl.h	279;"	d
ovsrec_controller_col_local_gateway	.\lib\vswitch-idl.h	278;"	d
ovsrec_controller_col_local_ip	.\lib\vswitch-idl.h	269;"	d
ovsrec_controller_col_local_netmask	.\lib\vswitch-idl.h	274;"	d
ovsrec_controller_col_max_backoff	.\lib\vswitch-idl.h	266;"	d
ovsrec_controller_col_other_config	.\lib\vswitch-idl.h	271;"	d
ovsrec_controller_col_role	.\lib\vswitch-idl.h	275;"	d
ovsrec_controller_col_status	.\lib\vswitch-idl.h	267;"	d
ovsrec_controller_col_target	.\lib\vswitch-idl.h	268;"	d
ovsrec_controller_columns	.\lib\vswitch-idl.c	/^struct ovsdb_idl_column ovsrec_controller_columns[OVSREC_CONTROLLER_N_COLUMNS];$/;"	v	typeref:struct:ovsdb_idl_column
ovsrec_controller_columns_init	.\lib\vswitch-idl.c	/^ovsrec_controller_columns_init(void)$/;"	f	file:
ovsrec_controller_delete	.\lib\vswitch-idl.c	/^ovsrec_controller_delete(const struct ovsrec_controller *row)$/;"	f
ovsrec_controller_first	.\lib\vswitch-idl.c	/^ovsrec_controller_first(const struct ovsdb_idl *idl)$/;"	f
ovsrec_controller_get_connection_mode	.\lib\vswitch-idl.c	/^ovsrec_controller_get_connection_mode(const struct ovsrec_controller *row,$/;"	f
ovsrec_controller_get_controller_burst_limit	.\lib\vswitch-idl.c	/^ovsrec_controller_get_controller_burst_limit(const struct ovsrec_controller *row,$/;"	f
ovsrec_controller_get_controller_rate_limit	.\lib\vswitch-idl.c	/^ovsrec_controller_get_controller_rate_limit(const struct ovsrec_controller *row,$/;"	f
ovsrec_controller_get_enable_async_messages	.\lib\vswitch-idl.c	/^ovsrec_controller_get_enable_async_messages(const struct ovsrec_controller *row,$/;"	f
ovsrec_controller_get_external_ids	.\lib\vswitch-idl.c	/^ovsrec_controller_get_external_ids(const struct ovsrec_controller *row,$/;"	f
ovsrec_controller_get_for_uuid	.\lib\vswitch-idl.c	/^ovsrec_controller_get_for_uuid(const struct ovsdb_idl *idl, const struct uuid *uuid)$/;"	f
ovsrec_controller_get_inactivity_probe	.\lib\vswitch-idl.c	/^ovsrec_controller_get_inactivity_probe(const struct ovsrec_controller *row,$/;"	f
ovsrec_controller_get_is_connected	.\lib\vswitch-idl.c	/^ovsrec_controller_get_is_connected(const struct ovsrec_controller *row,$/;"	f
ovsrec_controller_get_local_gateway	.\lib\vswitch-idl.c	/^ovsrec_controller_get_local_gateway(const struct ovsrec_controller *row,$/;"	f
ovsrec_controller_get_local_ip	.\lib\vswitch-idl.c	/^ovsrec_controller_get_local_ip(const struct ovsrec_controller *row,$/;"	f
ovsrec_controller_get_local_netmask	.\lib\vswitch-idl.c	/^ovsrec_controller_get_local_netmask(const struct ovsrec_controller *row,$/;"	f
ovsrec_controller_get_max_backoff	.\lib\vswitch-idl.c	/^ovsrec_controller_get_max_backoff(const struct ovsrec_controller *row,$/;"	f
ovsrec_controller_get_other_config	.\lib\vswitch-idl.c	/^ovsrec_controller_get_other_config(const struct ovsrec_controller *row,$/;"	f
ovsrec_controller_get_role	.\lib\vswitch-idl.c	/^ovsrec_controller_get_role(const struct ovsrec_controller *row,$/;"	f
ovsrec_controller_get_status	.\lib\vswitch-idl.c	/^ovsrec_controller_get_status(const struct ovsrec_controller *row,$/;"	f
ovsrec_controller_get_target	.\lib\vswitch-idl.c	/^ovsrec_controller_get_target(const struct ovsrec_controller *row,$/;"	f
ovsrec_controller_init	.\lib\vswitch-idl.c	/^ovsrec_controller_init(struct ovsrec_controller *row)$/;"	f
ovsrec_controller_init__	.\lib\vswitch-idl.c	/^ovsrec_controller_init__(struct ovsdb_idl_row *row)$/;"	f	file:
ovsrec_controller_insert	.\lib\vswitch-idl.c	/^ovsrec_controller_insert(struct ovsdb_idl_txn *txn)$/;"	f
ovsrec_controller_next	.\lib\vswitch-idl.c	/^ovsrec_controller_next(const struct ovsrec_controller *row)$/;"	f
ovsrec_controller_parse_connection_mode	.\lib\vswitch-idl.c	/^ovsrec_controller_parse_connection_mode(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
ovsrec_controller_parse_controller_burst_limit	.\lib\vswitch-idl.c	/^ovsrec_controller_parse_controller_burst_limit(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
ovsrec_controller_parse_controller_rate_limit	.\lib\vswitch-idl.c	/^ovsrec_controller_parse_controller_rate_limit(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
ovsrec_controller_parse_enable_async_messages	.\lib\vswitch-idl.c	/^ovsrec_controller_parse_enable_async_messages(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
ovsrec_controller_parse_external_ids	.\lib\vswitch-idl.c	/^ovsrec_controller_parse_external_ids(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
ovsrec_controller_parse_inactivity_probe	.\lib\vswitch-idl.c	/^ovsrec_controller_parse_inactivity_probe(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
ovsrec_controller_parse_is_connected	.\lib\vswitch-idl.c	/^ovsrec_controller_parse_is_connected(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
ovsrec_controller_parse_local_gateway	.\lib\vswitch-idl.c	/^ovsrec_controller_parse_local_gateway(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
ovsrec_controller_parse_local_ip	.\lib\vswitch-idl.c	/^ovsrec_controller_parse_local_ip(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
ovsrec_controller_parse_local_netmask	.\lib\vswitch-idl.c	/^ovsrec_controller_parse_local_netmask(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
ovsrec_controller_parse_max_backoff	.\lib\vswitch-idl.c	/^ovsrec_controller_parse_max_backoff(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
ovsrec_controller_parse_other_config	.\lib\vswitch-idl.c	/^ovsrec_controller_parse_other_config(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
ovsrec_controller_parse_role	.\lib\vswitch-idl.c	/^ovsrec_controller_parse_role(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
ovsrec_controller_parse_status	.\lib\vswitch-idl.c	/^ovsrec_controller_parse_status(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
ovsrec_controller_parse_target	.\lib\vswitch-idl.c	/^ovsrec_controller_parse_target(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
ovsrec_controller_set_connection_mode	.\lib\vswitch-idl.c	/^ovsrec_controller_set_connection_mode(const struct ovsrec_controller *row, const char *connection_mode)$/;"	f
ovsrec_controller_set_controller_burst_limit	.\lib\vswitch-idl.c	/^ovsrec_controller_set_controller_burst_limit(const struct ovsrec_controller *row, const int64_t *controller_burst_limit, size_t n_controller_burst_limit)$/;"	f
ovsrec_controller_set_controller_rate_limit	.\lib\vswitch-idl.c	/^ovsrec_controller_set_controller_rate_limit(const struct ovsrec_controller *row, const int64_t *controller_rate_limit, size_t n_controller_rate_limit)$/;"	f
ovsrec_controller_set_enable_async_messages	.\lib\vswitch-idl.c	/^ovsrec_controller_set_enable_async_messages(const struct ovsrec_controller *row, const bool *enable_async_messages, size_t n_enable_async_messages)$/;"	f
ovsrec_controller_set_external_ids	.\lib\vswitch-idl.c	/^ovsrec_controller_set_external_ids(const struct ovsrec_controller *row, const struct smap *smap)$/;"	f
ovsrec_controller_set_inactivity_probe	.\lib\vswitch-idl.c	/^ovsrec_controller_set_inactivity_probe(const struct ovsrec_controller *row, const int64_t *inactivity_probe, size_t n_inactivity_probe)$/;"	f
ovsrec_controller_set_is_connected	.\lib\vswitch-idl.c	/^ovsrec_controller_set_is_connected(const struct ovsrec_controller *row, bool is_connected)$/;"	f
ovsrec_controller_set_local_gateway	.\lib\vswitch-idl.c	/^ovsrec_controller_set_local_gateway(const struct ovsrec_controller *row, const char *local_gateway)$/;"	f
ovsrec_controller_set_local_ip	.\lib\vswitch-idl.c	/^ovsrec_controller_set_local_ip(const struct ovsrec_controller *row, const char *local_ip)$/;"	f
ovsrec_controller_set_local_netmask	.\lib\vswitch-idl.c	/^ovsrec_controller_set_local_netmask(const struct ovsrec_controller *row, const char *local_netmask)$/;"	f
ovsrec_controller_set_max_backoff	.\lib\vswitch-idl.c	/^ovsrec_controller_set_max_backoff(const struct ovsrec_controller *row, const int64_t *max_backoff, size_t n_max_backoff)$/;"	f
ovsrec_controller_set_other_config	.\lib\vswitch-idl.c	/^ovsrec_controller_set_other_config(const struct ovsrec_controller *row, const struct smap *smap)$/;"	f
ovsrec_controller_set_role	.\lib\vswitch-idl.c	/^ovsrec_controller_set_role(const struct ovsrec_controller *row, const char *role)$/;"	f
ovsrec_controller_set_status	.\lib\vswitch-idl.c	/^ovsrec_controller_set_status(const struct ovsrec_controller *row, const struct smap *smap)$/;"	f
ovsrec_controller_set_target	.\lib\vswitch-idl.c	/^ovsrec_controller_set_target(const struct ovsrec_controller *row, const char *target)$/;"	f
ovsrec_controller_unparse_connection_mode	.\lib\vswitch-idl.c	/^ovsrec_controller_unparse_connection_mode(struct ovsdb_idl_row *row OVS_UNUSED)$/;"	f	file:
ovsrec_controller_unparse_controller_burst_limit	.\lib\vswitch-idl.c	/^ovsrec_controller_unparse_controller_burst_limit(struct ovsdb_idl_row *row_)$/;"	f	file:
ovsrec_controller_unparse_controller_rate_limit	.\lib\vswitch-idl.c	/^ovsrec_controller_unparse_controller_rate_limit(struct ovsdb_idl_row *row_)$/;"	f	file:
ovsrec_controller_unparse_enable_async_messages	.\lib\vswitch-idl.c	/^ovsrec_controller_unparse_enable_async_messages(struct ovsdb_idl_row *row_)$/;"	f	file:
ovsrec_controller_unparse_external_ids	.\lib\vswitch-idl.c	/^ovsrec_controller_unparse_external_ids(struct ovsdb_idl_row *row_)$/;"	f	file:
ovsrec_controller_unparse_inactivity_probe	.\lib\vswitch-idl.c	/^ovsrec_controller_unparse_inactivity_probe(struct ovsdb_idl_row *row_)$/;"	f	file:
ovsrec_controller_unparse_is_connected	.\lib\vswitch-idl.c	/^ovsrec_controller_unparse_is_connected(struct ovsdb_idl_row *row OVS_UNUSED)$/;"	f	file:
ovsrec_controller_unparse_local_gateway	.\lib\vswitch-idl.c	/^ovsrec_controller_unparse_local_gateway(struct ovsdb_idl_row *row OVS_UNUSED)$/;"	f	file:
ovsrec_controller_unparse_local_ip	.\lib\vswitch-idl.c	/^ovsrec_controller_unparse_local_ip(struct ovsdb_idl_row *row OVS_UNUSED)$/;"	f	file:
ovsrec_controller_unparse_local_netmask	.\lib\vswitch-idl.c	/^ovsrec_controller_unparse_local_netmask(struct ovsdb_idl_row *row OVS_UNUSED)$/;"	f	file:
ovsrec_controller_unparse_max_backoff	.\lib\vswitch-idl.c	/^ovsrec_controller_unparse_max_backoff(struct ovsdb_idl_row *row_)$/;"	f	file:
ovsrec_controller_unparse_other_config	.\lib\vswitch-idl.c	/^ovsrec_controller_unparse_other_config(struct ovsdb_idl_row *row_)$/;"	f	file:
ovsrec_controller_unparse_role	.\lib\vswitch-idl.c	/^ovsrec_controller_unparse_role(struct ovsdb_idl_row *row OVS_UNUSED)$/;"	f	file:
ovsrec_controller_unparse_status	.\lib\vswitch-idl.c	/^ovsrec_controller_unparse_status(struct ovsdb_idl_row *row_)$/;"	f	file:
ovsrec_controller_unparse_target	.\lib\vswitch-idl.c	/^ovsrec_controller_unparse_target(struct ovsdb_idl_row *row OVS_UNUSED)$/;"	f	file:
ovsrec_controller_verify_connection_mode	.\lib\vswitch-idl.c	/^ovsrec_controller_verify_connection_mode(const struct ovsrec_controller *row)$/;"	f
ovsrec_controller_verify_controller_burst_limit	.\lib\vswitch-idl.c	/^ovsrec_controller_verify_controller_burst_limit(const struct ovsrec_controller *row)$/;"	f
ovsrec_controller_verify_controller_rate_limit	.\lib\vswitch-idl.c	/^ovsrec_controller_verify_controller_rate_limit(const struct ovsrec_controller *row)$/;"	f
ovsrec_controller_verify_enable_async_messages	.\lib\vswitch-idl.c	/^ovsrec_controller_verify_enable_async_messages(const struct ovsrec_controller *row)$/;"	f
ovsrec_controller_verify_external_ids	.\lib\vswitch-idl.c	/^ovsrec_controller_verify_external_ids(const struct ovsrec_controller *row)$/;"	f
ovsrec_controller_verify_inactivity_probe	.\lib\vswitch-idl.c	/^ovsrec_controller_verify_inactivity_probe(const struct ovsrec_controller *row)$/;"	f
ovsrec_controller_verify_is_connected	.\lib\vswitch-idl.c	/^ovsrec_controller_verify_is_connected(const struct ovsrec_controller *row)$/;"	f
ovsrec_controller_verify_local_gateway	.\lib\vswitch-idl.c	/^ovsrec_controller_verify_local_gateway(const struct ovsrec_controller *row)$/;"	f
ovsrec_controller_verify_local_ip	.\lib\vswitch-idl.c	/^ovsrec_controller_verify_local_ip(const struct ovsrec_controller *row)$/;"	f
ovsrec_controller_verify_local_netmask	.\lib\vswitch-idl.c	/^ovsrec_controller_verify_local_netmask(const struct ovsrec_controller *row)$/;"	f
ovsrec_controller_verify_max_backoff	.\lib\vswitch-idl.c	/^ovsrec_controller_verify_max_backoff(const struct ovsrec_controller *row)$/;"	f
ovsrec_controller_verify_other_config	.\lib\vswitch-idl.c	/^ovsrec_controller_verify_other_config(const struct ovsrec_controller *row)$/;"	f
ovsrec_controller_verify_role	.\lib\vswitch-idl.c	/^ovsrec_controller_verify_role(const struct ovsrec_controller *row)$/;"	f
ovsrec_controller_verify_status	.\lib\vswitch-idl.c	/^ovsrec_controller_verify_status(const struct ovsrec_controller *row)$/;"	f
ovsrec_controller_verify_target	.\lib\vswitch-idl.c	/^ovsrec_controller_verify_target(const struct ovsrec_controller *row)$/;"	f
ovsrec_flow_sample_collector_set	.\lib\vswitch-idl.h	/^struct ovsrec_flow_sample_collector_set {$/;"	s
ovsrec_flow_sample_collector_set_cast	.\lib\vswitch-idl.c	/^ovsrec_flow_sample_collector_set_cast(const struct ovsdb_idl_row *row)$/;"	f	file:
ovsrec_flow_sample_collector_set_col_bridge	.\lib\vswitch-idl.h	377;"	d
ovsrec_flow_sample_collector_set_col_external_ids	.\lib\vswitch-idl.h	378;"	d
ovsrec_flow_sample_collector_set_col_id	.\lib\vswitch-idl.h	379;"	d
ovsrec_flow_sample_collector_set_col_ipfix	.\lib\vswitch-idl.h	380;"	d
ovsrec_flow_sample_collector_set_columns	.\lib\vswitch-idl.c	/^struct ovsdb_idl_column ovsrec_flow_sample_collector_set_columns[OVSREC_FLOW_SAMPLE_COLLECTOR_SET_N_COLUMNS];$/;"	v	typeref:struct:ovsdb_idl_column
ovsrec_flow_sample_collector_set_columns_init	.\lib\vswitch-idl.c	/^ovsrec_flow_sample_collector_set_columns_init(void)$/;"	f	file:
ovsrec_flow_sample_collector_set_delete	.\lib\vswitch-idl.c	/^ovsrec_flow_sample_collector_set_delete(const struct ovsrec_flow_sample_collector_set *row)$/;"	f
ovsrec_flow_sample_collector_set_first	.\lib\vswitch-idl.c	/^ovsrec_flow_sample_collector_set_first(const struct ovsdb_idl *idl)$/;"	f
ovsrec_flow_sample_collector_set_get_bridge	.\lib\vswitch-idl.c	/^ovsrec_flow_sample_collector_set_get_bridge(const struct ovsrec_flow_sample_collector_set *row,$/;"	f
ovsrec_flow_sample_collector_set_get_external_ids	.\lib\vswitch-idl.c	/^ovsrec_flow_sample_collector_set_get_external_ids(const struct ovsrec_flow_sample_collector_set *row,$/;"	f
ovsrec_flow_sample_collector_set_get_for_uuid	.\lib\vswitch-idl.c	/^ovsrec_flow_sample_collector_set_get_for_uuid(const struct ovsdb_idl *idl, const struct uuid *uuid)$/;"	f
ovsrec_flow_sample_collector_set_get_id	.\lib\vswitch-idl.c	/^ovsrec_flow_sample_collector_set_get_id(const struct ovsrec_flow_sample_collector_set *row,$/;"	f
ovsrec_flow_sample_collector_set_get_ipfix	.\lib\vswitch-idl.c	/^ovsrec_flow_sample_collector_set_get_ipfix(const struct ovsrec_flow_sample_collector_set *row,$/;"	f
ovsrec_flow_sample_collector_set_init	.\lib\vswitch-idl.c	/^ovsrec_flow_sample_collector_set_init(struct ovsrec_flow_sample_collector_set *row)$/;"	f
ovsrec_flow_sample_collector_set_init__	.\lib\vswitch-idl.c	/^ovsrec_flow_sample_collector_set_init__(struct ovsdb_idl_row *row)$/;"	f	file:
ovsrec_flow_sample_collector_set_insert	.\lib\vswitch-idl.c	/^ovsrec_flow_sample_collector_set_insert(struct ovsdb_idl_txn *txn)$/;"	f
ovsrec_flow_sample_collector_set_next	.\lib\vswitch-idl.c	/^ovsrec_flow_sample_collector_set_next(const struct ovsrec_flow_sample_collector_set *row)$/;"	f
ovsrec_flow_sample_collector_set_parse_bridge	.\lib\vswitch-idl.c	/^ovsrec_flow_sample_collector_set_parse_bridge(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
ovsrec_flow_sample_collector_set_parse_external_ids	.\lib\vswitch-idl.c	/^ovsrec_flow_sample_collector_set_parse_external_ids(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
ovsrec_flow_sample_collector_set_parse_id	.\lib\vswitch-idl.c	/^ovsrec_flow_sample_collector_set_parse_id(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
ovsrec_flow_sample_collector_set_parse_ipfix	.\lib\vswitch-idl.c	/^ovsrec_flow_sample_collector_set_parse_ipfix(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
ovsrec_flow_sample_collector_set_set_bridge	.\lib\vswitch-idl.c	/^ovsrec_flow_sample_collector_set_set_bridge(const struct ovsrec_flow_sample_collector_set *row, const struct ovsrec_bridge *bridge)$/;"	f
ovsrec_flow_sample_collector_set_set_external_ids	.\lib\vswitch-idl.c	/^ovsrec_flow_sample_collector_set_set_external_ids(const struct ovsrec_flow_sample_collector_set *row, const struct smap *smap)$/;"	f
ovsrec_flow_sample_collector_set_set_id	.\lib\vswitch-idl.c	/^ovsrec_flow_sample_collector_set_set_id(const struct ovsrec_flow_sample_collector_set *row, int64_t id)$/;"	f
ovsrec_flow_sample_collector_set_set_ipfix	.\lib\vswitch-idl.c	/^ovsrec_flow_sample_collector_set_set_ipfix(const struct ovsrec_flow_sample_collector_set *row, const struct ovsrec_ipfix *ipfix)$/;"	f
ovsrec_flow_sample_collector_set_unparse_bridge	.\lib\vswitch-idl.c	/^ovsrec_flow_sample_collector_set_unparse_bridge(struct ovsdb_idl_row *row OVS_UNUSED)$/;"	f	file:
ovsrec_flow_sample_collector_set_unparse_external_ids	.\lib\vswitch-idl.c	/^ovsrec_flow_sample_collector_set_unparse_external_ids(struct ovsdb_idl_row *row_)$/;"	f	file:
ovsrec_flow_sample_collector_set_unparse_id	.\lib\vswitch-idl.c	/^ovsrec_flow_sample_collector_set_unparse_id(struct ovsdb_idl_row *row OVS_UNUSED)$/;"	f	file:
ovsrec_flow_sample_collector_set_unparse_ipfix	.\lib\vswitch-idl.c	/^ovsrec_flow_sample_collector_set_unparse_ipfix(struct ovsdb_idl_row *row OVS_UNUSED)$/;"	f	file:
ovsrec_flow_sample_collector_set_verify_bridge	.\lib\vswitch-idl.c	/^ovsrec_flow_sample_collector_set_verify_bridge(const struct ovsrec_flow_sample_collector_set *row)$/;"	f
ovsrec_flow_sample_collector_set_verify_external_ids	.\lib\vswitch-idl.c	/^ovsrec_flow_sample_collector_set_verify_external_ids(const struct ovsrec_flow_sample_collector_set *row)$/;"	f
ovsrec_flow_sample_collector_set_verify_id	.\lib\vswitch-idl.c	/^ovsrec_flow_sample_collector_set_verify_id(const struct ovsrec_flow_sample_collector_set *row)$/;"	f
ovsrec_flow_sample_collector_set_verify_ipfix	.\lib\vswitch-idl.c	/^ovsrec_flow_sample_collector_set_verify_ipfix(const struct ovsrec_flow_sample_collector_set *row)$/;"	f
ovsrec_flow_table	.\lib\vswitch-idl.h	/^struct ovsrec_flow_table {$/;"	s
ovsrec_flow_table_cast	.\lib\vswitch-idl.c	/^ovsrec_flow_table_cast(const struct ovsdb_idl_row *row)$/;"	f	file:
ovsrec_flow_table_col_external_ids	.\lib\vswitch-idl.h	460;"	d
ovsrec_flow_table_col_flow_limit	.\lib\vswitch-idl.h	457;"	d
ovsrec_flow_table_col_groups	.\lib\vswitch-idl.h	459;"	d
ovsrec_flow_table_col_name	.\lib\vswitch-idl.h	456;"	d
ovsrec_flow_table_col_overflow_policy	.\lib\vswitch-idl.h	455;"	d
ovsrec_flow_table_col_prefixes	.\lib\vswitch-idl.h	458;"	d
ovsrec_flow_table_columns	.\lib\vswitch-idl.c	/^struct ovsdb_idl_column ovsrec_flow_table_columns[OVSREC_FLOW_TABLE_N_COLUMNS];$/;"	v	typeref:struct:ovsdb_idl_column
ovsrec_flow_table_columns_init	.\lib\vswitch-idl.c	/^ovsrec_flow_table_columns_init(void)$/;"	f	file:
ovsrec_flow_table_delete	.\lib\vswitch-idl.c	/^ovsrec_flow_table_delete(const struct ovsrec_flow_table *row)$/;"	f
ovsrec_flow_table_first	.\lib\vswitch-idl.c	/^ovsrec_flow_table_first(const struct ovsdb_idl *idl)$/;"	f
ovsrec_flow_table_get_external_ids	.\lib\vswitch-idl.c	/^ovsrec_flow_table_get_external_ids(const struct ovsrec_flow_table *row,$/;"	f
ovsrec_flow_table_get_flow_limit	.\lib\vswitch-idl.c	/^ovsrec_flow_table_get_flow_limit(const struct ovsrec_flow_table *row,$/;"	f
ovsrec_flow_table_get_for_uuid	.\lib\vswitch-idl.c	/^ovsrec_flow_table_get_for_uuid(const struct ovsdb_idl *idl, const struct uuid *uuid)$/;"	f
ovsrec_flow_table_get_groups	.\lib\vswitch-idl.c	/^ovsrec_flow_table_get_groups(const struct ovsrec_flow_table *row,$/;"	f
ovsrec_flow_table_get_name	.\lib\vswitch-idl.c	/^ovsrec_flow_table_get_name(const struct ovsrec_flow_table *row,$/;"	f
ovsrec_flow_table_get_overflow_policy	.\lib\vswitch-idl.c	/^ovsrec_flow_table_get_overflow_policy(const struct ovsrec_flow_table *row,$/;"	f
ovsrec_flow_table_get_prefixes	.\lib\vswitch-idl.c	/^ovsrec_flow_table_get_prefixes(const struct ovsrec_flow_table *row,$/;"	f
ovsrec_flow_table_init	.\lib\vswitch-idl.c	/^ovsrec_flow_table_init(struct ovsrec_flow_table *row)$/;"	f
ovsrec_flow_table_init__	.\lib\vswitch-idl.c	/^ovsrec_flow_table_init__(struct ovsdb_idl_row *row)$/;"	f	file:
ovsrec_flow_table_insert	.\lib\vswitch-idl.c	/^ovsrec_flow_table_insert(struct ovsdb_idl_txn *txn)$/;"	f
ovsrec_flow_table_next	.\lib\vswitch-idl.c	/^ovsrec_flow_table_next(const struct ovsrec_flow_table *row)$/;"	f
ovsrec_flow_table_parse_external_ids	.\lib\vswitch-idl.c	/^ovsrec_flow_table_parse_external_ids(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
ovsrec_flow_table_parse_flow_limit	.\lib\vswitch-idl.c	/^ovsrec_flow_table_parse_flow_limit(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
ovsrec_flow_table_parse_groups	.\lib\vswitch-idl.c	/^ovsrec_flow_table_parse_groups(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
ovsrec_flow_table_parse_name	.\lib\vswitch-idl.c	/^ovsrec_flow_table_parse_name(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
ovsrec_flow_table_parse_overflow_policy	.\lib\vswitch-idl.c	/^ovsrec_flow_table_parse_overflow_policy(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
ovsrec_flow_table_parse_prefixes	.\lib\vswitch-idl.c	/^ovsrec_flow_table_parse_prefixes(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
ovsrec_flow_table_set_external_ids	.\lib\vswitch-idl.c	/^ovsrec_flow_table_set_external_ids(const struct ovsrec_flow_table *row, const struct smap *smap)$/;"	f
ovsrec_flow_table_set_flow_limit	.\lib\vswitch-idl.c	/^ovsrec_flow_table_set_flow_limit(const struct ovsrec_flow_table *row, const int64_t *flow_limit, size_t n_flow_limit)$/;"	f
ovsrec_flow_table_set_groups	.\lib\vswitch-idl.c	/^ovsrec_flow_table_set_groups(const struct ovsrec_flow_table *row, char **groups, size_t n_groups)$/;"	f
ovsrec_flow_table_set_name	.\lib\vswitch-idl.c	/^ovsrec_flow_table_set_name(const struct ovsrec_flow_table *row, const char *name)$/;"	f
ovsrec_flow_table_set_overflow_policy	.\lib\vswitch-idl.c	/^ovsrec_flow_table_set_overflow_policy(const struct ovsrec_flow_table *row, const char *overflow_policy)$/;"	f
ovsrec_flow_table_set_prefixes	.\lib\vswitch-idl.c	/^ovsrec_flow_table_set_prefixes(const struct ovsrec_flow_table *row, char **prefixes, size_t n_prefixes)$/;"	f
ovsrec_flow_table_unparse_external_ids	.\lib\vswitch-idl.c	/^ovsrec_flow_table_unparse_external_ids(struct ovsdb_idl_row *row_)$/;"	f	file:
ovsrec_flow_table_unparse_flow_limit	.\lib\vswitch-idl.c	/^ovsrec_flow_table_unparse_flow_limit(struct ovsdb_idl_row *row_)$/;"	f	file:
ovsrec_flow_table_unparse_groups	.\lib\vswitch-idl.c	/^ovsrec_flow_table_unparse_groups(struct ovsdb_idl_row *row_)$/;"	f	file:
ovsrec_flow_table_unparse_name	.\lib\vswitch-idl.c	/^ovsrec_flow_table_unparse_name(struct ovsdb_idl_row *row OVS_UNUSED)$/;"	f	file:
ovsrec_flow_table_unparse_overflow_policy	.\lib\vswitch-idl.c	/^ovsrec_flow_table_unparse_overflow_policy(struct ovsdb_idl_row *row OVS_UNUSED)$/;"	f	file:
ovsrec_flow_table_unparse_prefixes	.\lib\vswitch-idl.c	/^ovsrec_flow_table_unparse_prefixes(struct ovsdb_idl_row *row_)$/;"	f	file:
ovsrec_flow_table_verify_external_ids	.\lib\vswitch-idl.c	/^ovsrec_flow_table_verify_external_ids(const struct ovsrec_flow_table *row)$/;"	f
ovsrec_flow_table_verify_flow_limit	.\lib\vswitch-idl.c	/^ovsrec_flow_table_verify_flow_limit(const struct ovsrec_flow_table *row)$/;"	f
ovsrec_flow_table_verify_groups	.\lib\vswitch-idl.c	/^ovsrec_flow_table_verify_groups(const struct ovsrec_flow_table *row)$/;"	f
ovsrec_flow_table_verify_name	.\lib\vswitch-idl.c	/^ovsrec_flow_table_verify_name(const struct ovsrec_flow_table *row)$/;"	f
ovsrec_flow_table_verify_overflow_policy	.\lib\vswitch-idl.c	/^ovsrec_flow_table_verify_overflow_policy(const struct ovsrec_flow_table *row)$/;"	f
ovsrec_flow_table_verify_prefixes	.\lib\vswitch-idl.c	/^ovsrec_flow_table_verify_prefixes(const struct ovsrec_flow_table *row)$/;"	f
ovsrec_fscs_is_valid	.\vswitchd\bridge.c	/^ovsrec_fscs_is_valid(const struct ovsrec_flow_sample_collector_set *fscs,$/;"	f	file:
ovsrec_get_db_version	.\lib\vswitch-idl.c	/^ovsrec_get_db_version(void)$/;"	f
ovsrec_idl_class	.\lib\vswitch-idl.c	/^struct ovsdb_idl_class ovsrec_idl_class = {$/;"	v	typeref:struct:ovsdb_idl_class
ovsrec_init	.\lib\vswitch-idl.c	/^ovsrec_init(void)$/;"	f
ovsrec_interface	.\lib\vswitch-idl.h	/^struct ovsrec_interface {$/;"	s
ovsrec_interface_cast	.\lib\vswitch-idl.c	/^ovsrec_interface_cast(const struct ovsdb_idl_row *row)$/;"	f	file:
ovsrec_interface_col_admin_state	.\lib\vswitch-idl.h	763;"	d
ovsrec_interface_col_bfd	.\lib\vswitch-idl.h	753;"	d
ovsrec_interface_col_bfd_status	.\lib\vswitch-idl.h	756;"	d
ovsrec_interface_col_cfm_fault	.\lib\vswitch-idl.h	748;"	d
ovsrec_interface_col_cfm_fault_status	.\lib\vswitch-idl.h	774;"	d
ovsrec_interface_col_cfm_flap_count	.\lib\vswitch-idl.h	770;"	d
ovsrec_interface_col_cfm_health	.\lib\vswitch-idl.h	755;"	d
ovsrec_interface_col_cfm_mpid	.\lib\vswitch-idl.h	771;"	d
ovsrec_interface_col_cfm_remote_mpids	.\lib\vswitch-idl.h	775;"	d
ovsrec_interface_col_cfm_remote_opstate	.\lib\vswitch-idl.h	746;"	d
ovsrec_interface_col_duplex	.\lib\vswitch-idl.h	754;"	d
ovsrec_interface_col_external_ids	.\lib\vswitch-idl.h	764;"	d
ovsrec_interface_col_ifindex	.\lib\vswitch-idl.h	772;"	d
ovsrec_interface_col_ingress_policing_burst	.\lib\vswitch-idl.h	760;"	d
ovsrec_interface_col_ingress_policing_rate	.\lib\vswitch-idl.h	750;"	d
ovsrec_interface_col_lacp_current	.\lib\vswitch-idl.h	758;"	d
ovsrec_interface_col_link_resets	.\lib\vswitch-idl.h	751;"	d
ovsrec_interface_col_link_speed	.\lib\vswitch-idl.h	768;"	d
ovsrec_interface_col_link_state	.\lib\vswitch-idl.h	747;"	d
ovsrec_interface_col_mac	.\lib\vswitch-idl.h	762;"	d
ovsrec_interface_col_mac_in_use	.\lib\vswitch-idl.h	761;"	d
ovsrec_interface_col_mtu	.\lib\vswitch-idl.h	769;"	d
ovsrec_interface_col_name	.\lib\vswitch-idl.h	766;"	d
ovsrec_interface_col_ofport	.\lib\vswitch-idl.h	765;"	d
ovsrec_interface_col_ofport_request	.\lib\vswitch-idl.h	749;"	d
ovsrec_interface_col_options	.\lib\vswitch-idl.h	773;"	d
ovsrec_interface_col_other_config	.\lib\vswitch-idl.h	767;"	d
ovsrec_interface_col_statistics	.\lib\vswitch-idl.h	752;"	d
ovsrec_interface_col_status	.\lib\vswitch-idl.h	759;"	d
ovsrec_interface_col_type	.\lib\vswitch-idl.h	757;"	d
ovsrec_interface_columns	.\lib\vswitch-idl.c	/^struct ovsdb_idl_column ovsrec_interface_columns[OVSREC_INTERFACE_N_COLUMNS];$/;"	v	typeref:struct:ovsdb_idl_column
ovsrec_interface_columns_init	.\lib\vswitch-idl.c	/^ovsrec_interface_columns_init(void)$/;"	f	file:
ovsrec_interface_delete	.\lib\vswitch-idl.c	/^ovsrec_interface_delete(const struct ovsrec_interface *row)$/;"	f
ovsrec_interface_first	.\lib\vswitch-idl.c	/^ovsrec_interface_first(const struct ovsdb_idl *idl)$/;"	f
ovsrec_interface_get_admin_state	.\lib\vswitch-idl.c	/^ovsrec_interface_get_admin_state(const struct ovsrec_interface *row,$/;"	f
ovsrec_interface_get_bfd	.\lib\vswitch-idl.c	/^ovsrec_interface_get_bfd(const struct ovsrec_interface *row,$/;"	f
ovsrec_interface_get_bfd_status	.\lib\vswitch-idl.c	/^ovsrec_interface_get_bfd_status(const struct ovsrec_interface *row,$/;"	f
ovsrec_interface_get_cfm_fault	.\lib\vswitch-idl.c	/^ovsrec_interface_get_cfm_fault(const struct ovsrec_interface *row,$/;"	f
ovsrec_interface_get_cfm_fault_status	.\lib\vswitch-idl.c	/^ovsrec_interface_get_cfm_fault_status(const struct ovsrec_interface *row,$/;"	f
ovsrec_interface_get_cfm_flap_count	.\lib\vswitch-idl.c	/^ovsrec_interface_get_cfm_flap_count(const struct ovsrec_interface *row,$/;"	f
ovsrec_interface_get_cfm_health	.\lib\vswitch-idl.c	/^ovsrec_interface_get_cfm_health(const struct ovsrec_interface *row,$/;"	f
ovsrec_interface_get_cfm_mpid	.\lib\vswitch-idl.c	/^ovsrec_interface_get_cfm_mpid(const struct ovsrec_interface *row,$/;"	f
ovsrec_interface_get_cfm_remote_mpids	.\lib\vswitch-idl.c	/^ovsrec_interface_get_cfm_remote_mpids(const struct ovsrec_interface *row,$/;"	f
ovsrec_interface_get_cfm_remote_opstate	.\lib\vswitch-idl.c	/^ovsrec_interface_get_cfm_remote_opstate(const struct ovsrec_interface *row,$/;"	f
ovsrec_interface_get_duplex	.\lib\vswitch-idl.c	/^ovsrec_interface_get_duplex(const struct ovsrec_interface *row,$/;"	f
ovsrec_interface_get_external_ids	.\lib\vswitch-idl.c	/^ovsrec_interface_get_external_ids(const struct ovsrec_interface *row,$/;"	f
ovsrec_interface_get_for_uuid	.\lib\vswitch-idl.c	/^ovsrec_interface_get_for_uuid(const struct ovsdb_idl *idl, const struct uuid *uuid)$/;"	f
ovsrec_interface_get_ifindex	.\lib\vswitch-idl.c	/^ovsrec_interface_get_ifindex(const struct ovsrec_interface *row,$/;"	f
ovsrec_interface_get_ingress_policing_burst	.\lib\vswitch-idl.c	/^ovsrec_interface_get_ingress_policing_burst(const struct ovsrec_interface *row,$/;"	f
ovsrec_interface_get_ingress_policing_rate	.\lib\vswitch-idl.c	/^ovsrec_interface_get_ingress_policing_rate(const struct ovsrec_interface *row,$/;"	f
ovsrec_interface_get_lacp_current	.\lib\vswitch-idl.c	/^ovsrec_interface_get_lacp_current(const struct ovsrec_interface *row,$/;"	f
ovsrec_interface_get_link_resets	.\lib\vswitch-idl.c	/^ovsrec_interface_get_link_resets(const struct ovsrec_interface *row,$/;"	f
ovsrec_interface_get_link_speed	.\lib\vswitch-idl.c	/^ovsrec_interface_get_link_speed(const struct ovsrec_interface *row,$/;"	f
ovsrec_interface_get_link_state	.\lib\vswitch-idl.c	/^ovsrec_interface_get_link_state(const struct ovsrec_interface *row,$/;"	f
ovsrec_interface_get_mac	.\lib\vswitch-idl.c	/^ovsrec_interface_get_mac(const struct ovsrec_interface *row,$/;"	f
ovsrec_interface_get_mac_in_use	.\lib\vswitch-idl.c	/^ovsrec_interface_get_mac_in_use(const struct ovsrec_interface *row,$/;"	f
ovsrec_interface_get_mtu	.\lib\vswitch-idl.c	/^ovsrec_interface_get_mtu(const struct ovsrec_interface *row,$/;"	f
ovsrec_interface_get_name	.\lib\vswitch-idl.c	/^ovsrec_interface_get_name(const struct ovsrec_interface *row,$/;"	f
ovsrec_interface_get_ofport	.\lib\vswitch-idl.c	/^ovsrec_interface_get_ofport(const struct ovsrec_interface *row,$/;"	f
ovsrec_interface_get_ofport_request	.\lib\vswitch-idl.c	/^ovsrec_interface_get_ofport_request(const struct ovsrec_interface *row,$/;"	f
ovsrec_interface_get_options	.\lib\vswitch-idl.c	/^ovsrec_interface_get_options(const struct ovsrec_interface *row,$/;"	f
ovsrec_interface_get_other_config	.\lib\vswitch-idl.c	/^ovsrec_interface_get_other_config(const struct ovsrec_interface *row,$/;"	f
ovsrec_interface_get_statistics	.\lib\vswitch-idl.c	/^ovsrec_interface_get_statistics(const struct ovsrec_interface *row,$/;"	f
ovsrec_interface_get_status	.\lib\vswitch-idl.c	/^ovsrec_interface_get_status(const struct ovsrec_interface *row,$/;"	f
ovsrec_interface_get_type	.\lib\vswitch-idl.c	/^ovsrec_interface_get_type(const struct ovsrec_interface *row,$/;"	f
ovsrec_interface_init	.\lib\vswitch-idl.c	/^ovsrec_interface_init(struct ovsrec_interface *row)$/;"	f
ovsrec_interface_init__	.\lib\vswitch-idl.c	/^ovsrec_interface_init__(struct ovsdb_idl_row *row)$/;"	f	file:
ovsrec_interface_insert	.\lib\vswitch-idl.c	/^ovsrec_interface_insert(struct ovsdb_idl_txn *txn)$/;"	f
ovsrec_interface_next	.\lib\vswitch-idl.c	/^ovsrec_interface_next(const struct ovsrec_interface *row)$/;"	f
ovsrec_interface_parse_admin_state	.\lib\vswitch-idl.c	/^ovsrec_interface_parse_admin_state(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
ovsrec_interface_parse_bfd	.\lib\vswitch-idl.c	/^ovsrec_interface_parse_bfd(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
ovsrec_interface_parse_bfd_status	.\lib\vswitch-idl.c	/^ovsrec_interface_parse_bfd_status(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
ovsrec_interface_parse_cfm_fault	.\lib\vswitch-idl.c	/^ovsrec_interface_parse_cfm_fault(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
ovsrec_interface_parse_cfm_fault_status	.\lib\vswitch-idl.c	/^ovsrec_interface_parse_cfm_fault_status(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
ovsrec_interface_parse_cfm_flap_count	.\lib\vswitch-idl.c	/^ovsrec_interface_parse_cfm_flap_count(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
ovsrec_interface_parse_cfm_health	.\lib\vswitch-idl.c	/^ovsrec_interface_parse_cfm_health(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
ovsrec_interface_parse_cfm_mpid	.\lib\vswitch-idl.c	/^ovsrec_interface_parse_cfm_mpid(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
ovsrec_interface_parse_cfm_remote_mpids	.\lib\vswitch-idl.c	/^ovsrec_interface_parse_cfm_remote_mpids(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
ovsrec_interface_parse_cfm_remote_opstate	.\lib\vswitch-idl.c	/^ovsrec_interface_parse_cfm_remote_opstate(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
ovsrec_interface_parse_duplex	.\lib\vswitch-idl.c	/^ovsrec_interface_parse_duplex(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
ovsrec_interface_parse_external_ids	.\lib\vswitch-idl.c	/^ovsrec_interface_parse_external_ids(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
ovsrec_interface_parse_ifindex	.\lib\vswitch-idl.c	/^ovsrec_interface_parse_ifindex(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
ovsrec_interface_parse_ingress_policing_burst	.\lib\vswitch-idl.c	/^ovsrec_interface_parse_ingress_policing_burst(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
ovsrec_interface_parse_ingress_policing_rate	.\lib\vswitch-idl.c	/^ovsrec_interface_parse_ingress_policing_rate(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
ovsrec_interface_parse_lacp_current	.\lib\vswitch-idl.c	/^ovsrec_interface_parse_lacp_current(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
ovsrec_interface_parse_link_resets	.\lib\vswitch-idl.c	/^ovsrec_interface_parse_link_resets(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
ovsrec_interface_parse_link_speed	.\lib\vswitch-idl.c	/^ovsrec_interface_parse_link_speed(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
ovsrec_interface_parse_link_state	.\lib\vswitch-idl.c	/^ovsrec_interface_parse_link_state(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
ovsrec_interface_parse_mac	.\lib\vswitch-idl.c	/^ovsrec_interface_parse_mac(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
ovsrec_interface_parse_mac_in_use	.\lib\vswitch-idl.c	/^ovsrec_interface_parse_mac_in_use(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
ovsrec_interface_parse_mtu	.\lib\vswitch-idl.c	/^ovsrec_interface_parse_mtu(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
ovsrec_interface_parse_name	.\lib\vswitch-idl.c	/^ovsrec_interface_parse_name(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
ovsrec_interface_parse_ofport	.\lib\vswitch-idl.c	/^ovsrec_interface_parse_ofport(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
ovsrec_interface_parse_ofport_request	.\lib\vswitch-idl.c	/^ovsrec_interface_parse_ofport_request(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
ovsrec_interface_parse_options	.\lib\vswitch-idl.c	/^ovsrec_interface_parse_options(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
ovsrec_interface_parse_other_config	.\lib\vswitch-idl.c	/^ovsrec_interface_parse_other_config(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
ovsrec_interface_parse_statistics	.\lib\vswitch-idl.c	/^ovsrec_interface_parse_statistics(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
ovsrec_interface_parse_status	.\lib\vswitch-idl.c	/^ovsrec_interface_parse_status(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
ovsrec_interface_parse_type	.\lib\vswitch-idl.c	/^ovsrec_interface_parse_type(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
ovsrec_interface_set_admin_state	.\lib\vswitch-idl.c	/^ovsrec_interface_set_admin_state(const struct ovsrec_interface *row, const char *admin_state)$/;"	f
ovsrec_interface_set_bfd	.\lib\vswitch-idl.c	/^ovsrec_interface_set_bfd(const struct ovsrec_interface *row, const struct smap *smap)$/;"	f
ovsrec_interface_set_bfd_status	.\lib\vswitch-idl.c	/^ovsrec_interface_set_bfd_status(const struct ovsrec_interface *row, const struct smap *smap)$/;"	f
ovsrec_interface_set_cfm_fault	.\lib\vswitch-idl.c	/^ovsrec_interface_set_cfm_fault(const struct ovsrec_interface *row, const bool *cfm_fault, size_t n_cfm_fault)$/;"	f
ovsrec_interface_set_cfm_fault_status	.\lib\vswitch-idl.c	/^ovsrec_interface_set_cfm_fault_status(const struct ovsrec_interface *row, char **cfm_fault_status, size_t n_cfm_fault_status)$/;"	f
ovsrec_interface_set_cfm_flap_count	.\lib\vswitch-idl.c	/^ovsrec_interface_set_cfm_flap_count(const struct ovsrec_interface *row, const int64_t *cfm_flap_count, size_t n_cfm_flap_count)$/;"	f
ovsrec_interface_set_cfm_health	.\lib\vswitch-idl.c	/^ovsrec_interface_set_cfm_health(const struct ovsrec_interface *row, const int64_t *cfm_health, size_t n_cfm_health)$/;"	f
ovsrec_interface_set_cfm_mpid	.\lib\vswitch-idl.c	/^ovsrec_interface_set_cfm_mpid(const struct ovsrec_interface *row, const int64_t *cfm_mpid, size_t n_cfm_mpid)$/;"	f
ovsrec_interface_set_cfm_remote_mpids	.\lib\vswitch-idl.c	/^ovsrec_interface_set_cfm_remote_mpids(const struct ovsrec_interface *row, const int64_t *cfm_remote_mpids, size_t n_cfm_remote_mpids)$/;"	f
ovsrec_interface_set_cfm_remote_opstate	.\lib\vswitch-idl.c	/^ovsrec_interface_set_cfm_remote_opstate(const struct ovsrec_interface *row, const char *cfm_remote_opstate)$/;"	f
ovsrec_interface_set_duplex	.\lib\vswitch-idl.c	/^ovsrec_interface_set_duplex(const struct ovsrec_interface *row, const char *duplex)$/;"	f
ovsrec_interface_set_external_ids	.\lib\vswitch-idl.c	/^ovsrec_interface_set_external_ids(const struct ovsrec_interface *row, const struct smap *smap)$/;"	f
ovsrec_interface_set_ifindex	.\lib\vswitch-idl.c	/^ovsrec_interface_set_ifindex(const struct ovsrec_interface *row, const int64_t *ifindex, size_t n_ifindex)$/;"	f
ovsrec_interface_set_ingress_policing_burst	.\lib\vswitch-idl.c	/^ovsrec_interface_set_ingress_policing_burst(const struct ovsrec_interface *row, int64_t ingress_policing_burst)$/;"	f
ovsrec_interface_set_ingress_policing_rate	.\lib\vswitch-idl.c	/^ovsrec_interface_set_ingress_policing_rate(const struct ovsrec_interface *row, int64_t ingress_policing_rate)$/;"	f
ovsrec_interface_set_lacp_current	.\lib\vswitch-idl.c	/^ovsrec_interface_set_lacp_current(const struct ovsrec_interface *row, const bool *lacp_current, size_t n_lacp_current)$/;"	f
ovsrec_interface_set_link_resets	.\lib\vswitch-idl.c	/^ovsrec_interface_set_link_resets(const struct ovsrec_interface *row, const int64_t *link_resets, size_t n_link_resets)$/;"	f
ovsrec_interface_set_link_speed	.\lib\vswitch-idl.c	/^ovsrec_interface_set_link_speed(const struct ovsrec_interface *row, const int64_t *link_speed, size_t n_link_speed)$/;"	f
ovsrec_interface_set_link_state	.\lib\vswitch-idl.c	/^ovsrec_interface_set_link_state(const struct ovsrec_interface *row, const char *link_state)$/;"	f
ovsrec_interface_set_mac	.\lib\vswitch-idl.c	/^ovsrec_interface_set_mac(const struct ovsrec_interface *row, const char *mac)$/;"	f
ovsrec_interface_set_mac_in_use	.\lib\vswitch-idl.c	/^ovsrec_interface_set_mac_in_use(const struct ovsrec_interface *row, const char *mac_in_use)$/;"	f
ovsrec_interface_set_mtu	.\lib\vswitch-idl.c	/^ovsrec_interface_set_mtu(const struct ovsrec_interface *row, const int64_t *mtu, size_t n_mtu)$/;"	f
ovsrec_interface_set_name	.\lib\vswitch-idl.c	/^ovsrec_interface_set_name(const struct ovsrec_interface *row, const char *name)$/;"	f
ovsrec_interface_set_ofport	.\lib\vswitch-idl.c	/^ovsrec_interface_set_ofport(const struct ovsrec_interface *row, const int64_t *ofport, size_t n_ofport)$/;"	f
ovsrec_interface_set_ofport_request	.\lib\vswitch-idl.c	/^ovsrec_interface_set_ofport_request(const struct ovsrec_interface *row, const int64_t *ofport_request, size_t n_ofport_request)$/;"	f
ovsrec_interface_set_options	.\lib\vswitch-idl.c	/^ovsrec_interface_set_options(const struct ovsrec_interface *row, const struct smap *smap)$/;"	f
ovsrec_interface_set_other_config	.\lib\vswitch-idl.c	/^ovsrec_interface_set_other_config(const struct ovsrec_interface *row, const struct smap *smap)$/;"	f
ovsrec_interface_set_statistics	.\lib\vswitch-idl.c	/^ovsrec_interface_set_statistics(const struct ovsrec_interface *row, char **key_statistics, const int64_t *value_statistics, size_t n_statistics)$/;"	f
ovsrec_interface_set_status	.\lib\vswitch-idl.c	/^ovsrec_interface_set_status(const struct ovsrec_interface *row, const struct smap *smap)$/;"	f
ovsrec_interface_set_type	.\lib\vswitch-idl.c	/^ovsrec_interface_set_type(const struct ovsrec_interface *row, const char *type)$/;"	f
ovsrec_interface_unparse_admin_state	.\lib\vswitch-idl.c	/^ovsrec_interface_unparse_admin_state(struct ovsdb_idl_row *row OVS_UNUSED)$/;"	f	file:
ovsrec_interface_unparse_bfd	.\lib\vswitch-idl.c	/^ovsrec_interface_unparse_bfd(struct ovsdb_idl_row *row_)$/;"	f	file:
ovsrec_interface_unparse_bfd_status	.\lib\vswitch-idl.c	/^ovsrec_interface_unparse_bfd_status(struct ovsdb_idl_row *row_)$/;"	f	file:
ovsrec_interface_unparse_cfm_fault	.\lib\vswitch-idl.c	/^ovsrec_interface_unparse_cfm_fault(struct ovsdb_idl_row *row_)$/;"	f	file:
ovsrec_interface_unparse_cfm_fault_status	.\lib\vswitch-idl.c	/^ovsrec_interface_unparse_cfm_fault_status(struct ovsdb_idl_row *row_)$/;"	f	file:
ovsrec_interface_unparse_cfm_flap_count	.\lib\vswitch-idl.c	/^ovsrec_interface_unparse_cfm_flap_count(struct ovsdb_idl_row *row_)$/;"	f	file:
ovsrec_interface_unparse_cfm_health	.\lib\vswitch-idl.c	/^ovsrec_interface_unparse_cfm_health(struct ovsdb_idl_row *row_)$/;"	f	file:
ovsrec_interface_unparse_cfm_mpid	.\lib\vswitch-idl.c	/^ovsrec_interface_unparse_cfm_mpid(struct ovsdb_idl_row *row_)$/;"	f	file:
ovsrec_interface_unparse_cfm_remote_mpids	.\lib\vswitch-idl.c	/^ovsrec_interface_unparse_cfm_remote_mpids(struct ovsdb_idl_row *row_)$/;"	f	file:
ovsrec_interface_unparse_cfm_remote_opstate	.\lib\vswitch-idl.c	/^ovsrec_interface_unparse_cfm_remote_opstate(struct ovsdb_idl_row *row OVS_UNUSED)$/;"	f	file:
ovsrec_interface_unparse_duplex	.\lib\vswitch-idl.c	/^ovsrec_interface_unparse_duplex(struct ovsdb_idl_row *row OVS_UNUSED)$/;"	f	file:
ovsrec_interface_unparse_external_ids	.\lib\vswitch-idl.c	/^ovsrec_interface_unparse_external_ids(struct ovsdb_idl_row *row_)$/;"	f	file:
ovsrec_interface_unparse_ifindex	.\lib\vswitch-idl.c	/^ovsrec_interface_unparse_ifindex(struct ovsdb_idl_row *row_)$/;"	f	file:
ovsrec_interface_unparse_ingress_policing_burst	.\lib\vswitch-idl.c	/^ovsrec_interface_unparse_ingress_policing_burst(struct ovsdb_idl_row *row OVS_UNUSED)$/;"	f	file:
ovsrec_interface_unparse_ingress_policing_rate	.\lib\vswitch-idl.c	/^ovsrec_interface_unparse_ingress_policing_rate(struct ovsdb_idl_row *row OVS_UNUSED)$/;"	f	file:
ovsrec_interface_unparse_lacp_current	.\lib\vswitch-idl.c	/^ovsrec_interface_unparse_lacp_current(struct ovsdb_idl_row *row_)$/;"	f	file:
ovsrec_interface_unparse_link_resets	.\lib\vswitch-idl.c	/^ovsrec_interface_unparse_link_resets(struct ovsdb_idl_row *row_)$/;"	f	file:
ovsrec_interface_unparse_link_speed	.\lib\vswitch-idl.c	/^ovsrec_interface_unparse_link_speed(struct ovsdb_idl_row *row_)$/;"	f	file:
ovsrec_interface_unparse_link_state	.\lib\vswitch-idl.c	/^ovsrec_interface_unparse_link_state(struct ovsdb_idl_row *row OVS_UNUSED)$/;"	f	file:
ovsrec_interface_unparse_mac	.\lib\vswitch-idl.c	/^ovsrec_interface_unparse_mac(struct ovsdb_idl_row *row OVS_UNUSED)$/;"	f	file:
ovsrec_interface_unparse_mac_in_use	.\lib\vswitch-idl.c	/^ovsrec_interface_unparse_mac_in_use(struct ovsdb_idl_row *row OVS_UNUSED)$/;"	f	file:
ovsrec_interface_unparse_mtu	.\lib\vswitch-idl.c	/^ovsrec_interface_unparse_mtu(struct ovsdb_idl_row *row_)$/;"	f	file:
ovsrec_interface_unparse_name	.\lib\vswitch-idl.c	/^ovsrec_interface_unparse_name(struct ovsdb_idl_row *row OVS_UNUSED)$/;"	f	file:
ovsrec_interface_unparse_ofport	.\lib\vswitch-idl.c	/^ovsrec_interface_unparse_ofport(struct ovsdb_idl_row *row_)$/;"	f	file:
ovsrec_interface_unparse_ofport_request	.\lib\vswitch-idl.c	/^ovsrec_interface_unparse_ofport_request(struct ovsdb_idl_row *row_)$/;"	f	file:
ovsrec_interface_unparse_options	.\lib\vswitch-idl.c	/^ovsrec_interface_unparse_options(struct ovsdb_idl_row *row_)$/;"	f	file:
ovsrec_interface_unparse_other_config	.\lib\vswitch-idl.c	/^ovsrec_interface_unparse_other_config(struct ovsdb_idl_row *row_)$/;"	f	file:
ovsrec_interface_unparse_statistics	.\lib\vswitch-idl.c	/^ovsrec_interface_unparse_statistics(struct ovsdb_idl_row *row_)$/;"	f	file:
ovsrec_interface_unparse_status	.\lib\vswitch-idl.c	/^ovsrec_interface_unparse_status(struct ovsdb_idl_row *row_)$/;"	f	file:
ovsrec_interface_unparse_type	.\lib\vswitch-idl.c	/^ovsrec_interface_unparse_type(struct ovsdb_idl_row *row OVS_UNUSED)$/;"	f	file:
ovsrec_interface_verify_admin_state	.\lib\vswitch-idl.c	/^ovsrec_interface_verify_admin_state(const struct ovsrec_interface *row)$/;"	f
ovsrec_interface_verify_bfd	.\lib\vswitch-idl.c	/^ovsrec_interface_verify_bfd(const struct ovsrec_interface *row)$/;"	f
ovsrec_interface_verify_bfd_status	.\lib\vswitch-idl.c	/^ovsrec_interface_verify_bfd_status(const struct ovsrec_interface *row)$/;"	f
ovsrec_interface_verify_cfm_fault	.\lib\vswitch-idl.c	/^ovsrec_interface_verify_cfm_fault(const struct ovsrec_interface *row)$/;"	f
ovsrec_interface_verify_cfm_fault_status	.\lib\vswitch-idl.c	/^ovsrec_interface_verify_cfm_fault_status(const struct ovsrec_interface *row)$/;"	f
ovsrec_interface_verify_cfm_flap_count	.\lib\vswitch-idl.c	/^ovsrec_interface_verify_cfm_flap_count(const struct ovsrec_interface *row)$/;"	f
ovsrec_interface_verify_cfm_health	.\lib\vswitch-idl.c	/^ovsrec_interface_verify_cfm_health(const struct ovsrec_interface *row)$/;"	f
ovsrec_interface_verify_cfm_mpid	.\lib\vswitch-idl.c	/^ovsrec_interface_verify_cfm_mpid(const struct ovsrec_interface *row)$/;"	f
ovsrec_interface_verify_cfm_remote_mpids	.\lib\vswitch-idl.c	/^ovsrec_interface_verify_cfm_remote_mpids(const struct ovsrec_interface *row)$/;"	f
ovsrec_interface_verify_cfm_remote_opstate	.\lib\vswitch-idl.c	/^ovsrec_interface_verify_cfm_remote_opstate(const struct ovsrec_interface *row)$/;"	f
ovsrec_interface_verify_duplex	.\lib\vswitch-idl.c	/^ovsrec_interface_verify_duplex(const struct ovsrec_interface *row)$/;"	f
ovsrec_interface_verify_external_ids	.\lib\vswitch-idl.c	/^ovsrec_interface_verify_external_ids(const struct ovsrec_interface *row)$/;"	f
ovsrec_interface_verify_ifindex	.\lib\vswitch-idl.c	/^ovsrec_interface_verify_ifindex(const struct ovsrec_interface *row)$/;"	f
ovsrec_interface_verify_ingress_policing_burst	.\lib\vswitch-idl.c	/^ovsrec_interface_verify_ingress_policing_burst(const struct ovsrec_interface *row)$/;"	f
ovsrec_interface_verify_ingress_policing_rate	.\lib\vswitch-idl.c	/^ovsrec_interface_verify_ingress_policing_rate(const struct ovsrec_interface *row)$/;"	f
ovsrec_interface_verify_lacp_current	.\lib\vswitch-idl.c	/^ovsrec_interface_verify_lacp_current(const struct ovsrec_interface *row)$/;"	f
ovsrec_interface_verify_link_resets	.\lib\vswitch-idl.c	/^ovsrec_interface_verify_link_resets(const struct ovsrec_interface *row)$/;"	f
ovsrec_interface_verify_link_speed	.\lib\vswitch-idl.c	/^ovsrec_interface_verify_link_speed(const struct ovsrec_interface *row)$/;"	f
ovsrec_interface_verify_link_state	.\lib\vswitch-idl.c	/^ovsrec_interface_verify_link_state(const struct ovsrec_interface *row)$/;"	f
ovsrec_interface_verify_mac	.\lib\vswitch-idl.c	/^ovsrec_interface_verify_mac(const struct ovsrec_interface *row)$/;"	f
ovsrec_interface_verify_mac_in_use	.\lib\vswitch-idl.c	/^ovsrec_interface_verify_mac_in_use(const struct ovsrec_interface *row)$/;"	f
ovsrec_interface_verify_mtu	.\lib\vswitch-idl.c	/^ovsrec_interface_verify_mtu(const struct ovsrec_interface *row)$/;"	f
ovsrec_interface_verify_name	.\lib\vswitch-idl.c	/^ovsrec_interface_verify_name(const struct ovsrec_interface *row)$/;"	f
ovsrec_interface_verify_ofport	.\lib\vswitch-idl.c	/^ovsrec_interface_verify_ofport(const struct ovsrec_interface *row)$/;"	f
ovsrec_interface_verify_ofport_request	.\lib\vswitch-idl.c	/^ovsrec_interface_verify_ofport_request(const struct ovsrec_interface *row)$/;"	f
ovsrec_interface_verify_options	.\lib\vswitch-idl.c	/^ovsrec_interface_verify_options(const struct ovsrec_interface *row)$/;"	f
ovsrec_interface_verify_other_config	.\lib\vswitch-idl.c	/^ovsrec_interface_verify_other_config(const struct ovsrec_interface *row)$/;"	f
ovsrec_interface_verify_statistics	.\lib\vswitch-idl.c	/^ovsrec_interface_verify_statistics(const struct ovsrec_interface *row)$/;"	f
ovsrec_interface_verify_status	.\lib\vswitch-idl.c	/^ovsrec_interface_verify_status(const struct ovsrec_interface *row)$/;"	f
ovsrec_interface_verify_type	.\lib\vswitch-idl.c	/^ovsrec_interface_verify_type(const struct ovsrec_interface *row)$/;"	f
ovsrec_ipfix	.\lib\vswitch-idl.h	/^struct ovsrec_ipfix {$/;"	s
ovsrec_ipfix_cast	.\lib\vswitch-idl.c	/^ovsrec_ipfix_cast(const struct ovsdb_idl_row *row)$/;"	f	file:
ovsrec_ipfix_col_cache_active_timeout	.\lib\vswitch-idl.h	549;"	d
ovsrec_ipfix_col_cache_max_flows	.\lib\vswitch-idl.h	550;"	d
ovsrec_ipfix_col_external_ids	.\lib\vswitch-idl.h	553;"	d
ovsrec_ipfix_col_obs_domain_id	.\lib\vswitch-idl.h	551;"	d
ovsrec_ipfix_col_obs_point_id	.\lib\vswitch-idl.h	548;"	d
ovsrec_ipfix_col_sampling	.\lib\vswitch-idl.h	552;"	d
ovsrec_ipfix_col_targets	.\lib\vswitch-idl.h	554;"	d
ovsrec_ipfix_columns	.\lib\vswitch-idl.c	/^struct ovsdb_idl_column ovsrec_ipfix_columns[OVSREC_IPFIX_N_COLUMNS];$/;"	v	typeref:struct:ovsdb_idl_column
ovsrec_ipfix_columns_init	.\lib\vswitch-idl.c	/^ovsrec_ipfix_columns_init(void)$/;"	f	file:
ovsrec_ipfix_delete	.\lib\vswitch-idl.c	/^ovsrec_ipfix_delete(const struct ovsrec_ipfix *row)$/;"	f
ovsrec_ipfix_first	.\lib\vswitch-idl.c	/^ovsrec_ipfix_first(const struct ovsdb_idl *idl)$/;"	f
ovsrec_ipfix_get_cache_active_timeout	.\lib\vswitch-idl.c	/^ovsrec_ipfix_get_cache_active_timeout(const struct ovsrec_ipfix *row,$/;"	f
ovsrec_ipfix_get_cache_max_flows	.\lib\vswitch-idl.c	/^ovsrec_ipfix_get_cache_max_flows(const struct ovsrec_ipfix *row,$/;"	f
ovsrec_ipfix_get_external_ids	.\lib\vswitch-idl.c	/^ovsrec_ipfix_get_external_ids(const struct ovsrec_ipfix *row,$/;"	f
ovsrec_ipfix_get_for_uuid	.\lib\vswitch-idl.c	/^ovsrec_ipfix_get_for_uuid(const struct ovsdb_idl *idl, const struct uuid *uuid)$/;"	f
ovsrec_ipfix_get_obs_domain_id	.\lib\vswitch-idl.c	/^ovsrec_ipfix_get_obs_domain_id(const struct ovsrec_ipfix *row,$/;"	f
ovsrec_ipfix_get_obs_point_id	.\lib\vswitch-idl.c	/^ovsrec_ipfix_get_obs_point_id(const struct ovsrec_ipfix *row,$/;"	f
ovsrec_ipfix_get_sampling	.\lib\vswitch-idl.c	/^ovsrec_ipfix_get_sampling(const struct ovsrec_ipfix *row,$/;"	f
ovsrec_ipfix_get_targets	.\lib\vswitch-idl.c	/^ovsrec_ipfix_get_targets(const struct ovsrec_ipfix *row,$/;"	f
ovsrec_ipfix_init	.\lib\vswitch-idl.c	/^ovsrec_ipfix_init(struct ovsrec_ipfix *row)$/;"	f
ovsrec_ipfix_init__	.\lib\vswitch-idl.c	/^ovsrec_ipfix_init__(struct ovsdb_idl_row *row)$/;"	f	file:
ovsrec_ipfix_insert	.\lib\vswitch-idl.c	/^ovsrec_ipfix_insert(struct ovsdb_idl_txn *txn)$/;"	f
ovsrec_ipfix_is_valid	.\vswitchd\bridge.c	/^ovsrec_ipfix_is_valid(const struct ovsrec_ipfix *ipfix)$/;"	f	file:
ovsrec_ipfix_next	.\lib\vswitch-idl.c	/^ovsrec_ipfix_next(const struct ovsrec_ipfix *row)$/;"	f
ovsrec_ipfix_parse_cache_active_timeout	.\lib\vswitch-idl.c	/^ovsrec_ipfix_parse_cache_active_timeout(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
ovsrec_ipfix_parse_cache_max_flows	.\lib\vswitch-idl.c	/^ovsrec_ipfix_parse_cache_max_flows(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
ovsrec_ipfix_parse_external_ids	.\lib\vswitch-idl.c	/^ovsrec_ipfix_parse_external_ids(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
ovsrec_ipfix_parse_obs_domain_id	.\lib\vswitch-idl.c	/^ovsrec_ipfix_parse_obs_domain_id(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
ovsrec_ipfix_parse_obs_point_id	.\lib\vswitch-idl.c	/^ovsrec_ipfix_parse_obs_point_id(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
ovsrec_ipfix_parse_sampling	.\lib\vswitch-idl.c	/^ovsrec_ipfix_parse_sampling(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
ovsrec_ipfix_parse_targets	.\lib\vswitch-idl.c	/^ovsrec_ipfix_parse_targets(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
ovsrec_ipfix_set_cache_active_timeout	.\lib\vswitch-idl.c	/^ovsrec_ipfix_set_cache_active_timeout(const struct ovsrec_ipfix *row, const int64_t *cache_active_timeout, size_t n_cache_active_timeout)$/;"	f
ovsrec_ipfix_set_cache_max_flows	.\lib\vswitch-idl.c	/^ovsrec_ipfix_set_cache_max_flows(const struct ovsrec_ipfix *row, const int64_t *cache_max_flows, size_t n_cache_max_flows)$/;"	f
ovsrec_ipfix_set_external_ids	.\lib\vswitch-idl.c	/^ovsrec_ipfix_set_external_ids(const struct ovsrec_ipfix *row, const struct smap *smap)$/;"	f
ovsrec_ipfix_set_obs_domain_id	.\lib\vswitch-idl.c	/^ovsrec_ipfix_set_obs_domain_id(const struct ovsrec_ipfix *row, const int64_t *obs_domain_id, size_t n_obs_domain_id)$/;"	f
ovsrec_ipfix_set_obs_point_id	.\lib\vswitch-idl.c	/^ovsrec_ipfix_set_obs_point_id(const struct ovsrec_ipfix *row, const int64_t *obs_point_id, size_t n_obs_point_id)$/;"	f
ovsrec_ipfix_set_sampling	.\lib\vswitch-idl.c	/^ovsrec_ipfix_set_sampling(const struct ovsrec_ipfix *row, const int64_t *sampling, size_t n_sampling)$/;"	f
ovsrec_ipfix_set_targets	.\lib\vswitch-idl.c	/^ovsrec_ipfix_set_targets(const struct ovsrec_ipfix *row, char **targets, size_t n_targets)$/;"	f
ovsrec_ipfix_unparse_cache_active_timeout	.\lib\vswitch-idl.c	/^ovsrec_ipfix_unparse_cache_active_timeout(struct ovsdb_idl_row *row_)$/;"	f	file:
ovsrec_ipfix_unparse_cache_max_flows	.\lib\vswitch-idl.c	/^ovsrec_ipfix_unparse_cache_max_flows(struct ovsdb_idl_row *row_)$/;"	f	file:
ovsrec_ipfix_unparse_external_ids	.\lib\vswitch-idl.c	/^ovsrec_ipfix_unparse_external_ids(struct ovsdb_idl_row *row_)$/;"	f	file:
ovsrec_ipfix_unparse_obs_domain_id	.\lib\vswitch-idl.c	/^ovsrec_ipfix_unparse_obs_domain_id(struct ovsdb_idl_row *row_)$/;"	f	file:
ovsrec_ipfix_unparse_obs_point_id	.\lib\vswitch-idl.c	/^ovsrec_ipfix_unparse_obs_point_id(struct ovsdb_idl_row *row_)$/;"	f	file:
ovsrec_ipfix_unparse_sampling	.\lib\vswitch-idl.c	/^ovsrec_ipfix_unparse_sampling(struct ovsdb_idl_row *row_)$/;"	f	file:
ovsrec_ipfix_unparse_targets	.\lib\vswitch-idl.c	/^ovsrec_ipfix_unparse_targets(struct ovsdb_idl_row *row_)$/;"	f	file:
ovsrec_ipfix_verify_cache_active_timeout	.\lib\vswitch-idl.c	/^ovsrec_ipfix_verify_cache_active_timeout(const struct ovsrec_ipfix *row)$/;"	f
ovsrec_ipfix_verify_cache_max_flows	.\lib\vswitch-idl.c	/^ovsrec_ipfix_verify_cache_max_flows(const struct ovsrec_ipfix *row)$/;"	f
ovsrec_ipfix_verify_external_ids	.\lib\vswitch-idl.c	/^ovsrec_ipfix_verify_external_ids(const struct ovsrec_ipfix *row)$/;"	f
ovsrec_ipfix_verify_obs_domain_id	.\lib\vswitch-idl.c	/^ovsrec_ipfix_verify_obs_domain_id(const struct ovsrec_ipfix *row)$/;"	f
ovsrec_ipfix_verify_obs_point_id	.\lib\vswitch-idl.c	/^ovsrec_ipfix_verify_obs_point_id(const struct ovsrec_ipfix *row)$/;"	f
ovsrec_ipfix_verify_sampling	.\lib\vswitch-idl.c	/^ovsrec_ipfix_verify_sampling(const struct ovsrec_ipfix *row)$/;"	f
ovsrec_ipfix_verify_targets	.\lib\vswitch-idl.c	/^ovsrec_ipfix_verify_targets(const struct ovsrec_ipfix *row)$/;"	f
ovsrec_manager	.\lib\vswitch-idl.h	/^struct ovsrec_manager {$/;"	s
ovsrec_manager_cast	.\lib\vswitch-idl.c	/^ovsrec_manager_cast(const struct ovsdb_idl_row *row)$/;"	f	file:
ovsrec_manager_col_connection_mode	.\lib\vswitch-idl.h	938;"	d
ovsrec_manager_col_external_ids	.\lib\vswitch-idl.h	941;"	d
ovsrec_manager_col_inactivity_probe	.\lib\vswitch-idl.h	940;"	d
ovsrec_manager_col_is_connected	.\lib\vswitch-idl.h	942;"	d
ovsrec_manager_col_max_backoff	.\lib\vswitch-idl.h	935;"	d
ovsrec_manager_col_other_config	.\lib\vswitch-idl.h	939;"	d
ovsrec_manager_col_status	.\lib\vswitch-idl.h	936;"	d
ovsrec_manager_col_target	.\lib\vswitch-idl.h	937;"	d
ovsrec_manager_columns	.\lib\vswitch-idl.c	/^struct ovsdb_idl_column ovsrec_manager_columns[OVSREC_MANAGER_N_COLUMNS];$/;"	v	typeref:struct:ovsdb_idl_column
ovsrec_manager_columns_init	.\lib\vswitch-idl.c	/^ovsrec_manager_columns_init(void)$/;"	f	file:
ovsrec_manager_delete	.\lib\vswitch-idl.c	/^ovsrec_manager_delete(const struct ovsrec_manager *row)$/;"	f
ovsrec_manager_first	.\lib\vswitch-idl.c	/^ovsrec_manager_first(const struct ovsdb_idl *idl)$/;"	f
ovsrec_manager_get_connection_mode	.\lib\vswitch-idl.c	/^ovsrec_manager_get_connection_mode(const struct ovsrec_manager *row,$/;"	f
ovsrec_manager_get_external_ids	.\lib\vswitch-idl.c	/^ovsrec_manager_get_external_ids(const struct ovsrec_manager *row,$/;"	f
ovsrec_manager_get_for_uuid	.\lib\vswitch-idl.c	/^ovsrec_manager_get_for_uuid(const struct ovsdb_idl *idl, const struct uuid *uuid)$/;"	f
ovsrec_manager_get_inactivity_probe	.\lib\vswitch-idl.c	/^ovsrec_manager_get_inactivity_probe(const struct ovsrec_manager *row,$/;"	f
ovsrec_manager_get_is_connected	.\lib\vswitch-idl.c	/^ovsrec_manager_get_is_connected(const struct ovsrec_manager *row,$/;"	f
ovsrec_manager_get_max_backoff	.\lib\vswitch-idl.c	/^ovsrec_manager_get_max_backoff(const struct ovsrec_manager *row,$/;"	f
ovsrec_manager_get_other_config	.\lib\vswitch-idl.c	/^ovsrec_manager_get_other_config(const struct ovsrec_manager *row,$/;"	f
ovsrec_manager_get_status	.\lib\vswitch-idl.c	/^ovsrec_manager_get_status(const struct ovsrec_manager *row,$/;"	f
ovsrec_manager_get_target	.\lib\vswitch-idl.c	/^ovsrec_manager_get_target(const struct ovsrec_manager *row,$/;"	f
ovsrec_manager_init	.\lib\vswitch-idl.c	/^ovsrec_manager_init(struct ovsrec_manager *row)$/;"	f
ovsrec_manager_init__	.\lib\vswitch-idl.c	/^ovsrec_manager_init__(struct ovsdb_idl_row *row)$/;"	f	file:
ovsrec_manager_insert	.\lib\vswitch-idl.c	/^ovsrec_manager_insert(struct ovsdb_idl_txn *txn)$/;"	f
ovsrec_manager_next	.\lib\vswitch-idl.c	/^ovsrec_manager_next(const struct ovsrec_manager *row)$/;"	f
ovsrec_manager_parse_connection_mode	.\lib\vswitch-idl.c	/^ovsrec_manager_parse_connection_mode(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
ovsrec_manager_parse_external_ids	.\lib\vswitch-idl.c	/^ovsrec_manager_parse_external_ids(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
ovsrec_manager_parse_inactivity_probe	.\lib\vswitch-idl.c	/^ovsrec_manager_parse_inactivity_probe(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
ovsrec_manager_parse_is_connected	.\lib\vswitch-idl.c	/^ovsrec_manager_parse_is_connected(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
ovsrec_manager_parse_max_backoff	.\lib\vswitch-idl.c	/^ovsrec_manager_parse_max_backoff(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
ovsrec_manager_parse_other_config	.\lib\vswitch-idl.c	/^ovsrec_manager_parse_other_config(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
ovsrec_manager_parse_status	.\lib\vswitch-idl.c	/^ovsrec_manager_parse_status(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
ovsrec_manager_parse_target	.\lib\vswitch-idl.c	/^ovsrec_manager_parse_target(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
ovsrec_manager_set_connection_mode	.\lib\vswitch-idl.c	/^ovsrec_manager_set_connection_mode(const struct ovsrec_manager *row, const char *connection_mode)$/;"	f
ovsrec_manager_set_external_ids	.\lib\vswitch-idl.c	/^ovsrec_manager_set_external_ids(const struct ovsrec_manager *row, const struct smap *smap)$/;"	f
ovsrec_manager_set_inactivity_probe	.\lib\vswitch-idl.c	/^ovsrec_manager_set_inactivity_probe(const struct ovsrec_manager *row, const int64_t *inactivity_probe, size_t n_inactivity_probe)$/;"	f
ovsrec_manager_set_is_connected	.\lib\vswitch-idl.c	/^ovsrec_manager_set_is_connected(const struct ovsrec_manager *row, bool is_connected)$/;"	f
ovsrec_manager_set_max_backoff	.\lib\vswitch-idl.c	/^ovsrec_manager_set_max_backoff(const struct ovsrec_manager *row, const int64_t *max_backoff, size_t n_max_backoff)$/;"	f
ovsrec_manager_set_other_config	.\lib\vswitch-idl.c	/^ovsrec_manager_set_other_config(const struct ovsrec_manager *row, const struct smap *smap)$/;"	f
ovsrec_manager_set_status	.\lib\vswitch-idl.c	/^ovsrec_manager_set_status(const struct ovsrec_manager *row, const struct smap *smap)$/;"	f
ovsrec_manager_set_target	.\lib\vswitch-idl.c	/^ovsrec_manager_set_target(const struct ovsrec_manager *row, const char *target)$/;"	f
ovsrec_manager_unparse_connection_mode	.\lib\vswitch-idl.c	/^ovsrec_manager_unparse_connection_mode(struct ovsdb_idl_row *row OVS_UNUSED)$/;"	f	file:
ovsrec_manager_unparse_external_ids	.\lib\vswitch-idl.c	/^ovsrec_manager_unparse_external_ids(struct ovsdb_idl_row *row_)$/;"	f	file:
ovsrec_manager_unparse_inactivity_probe	.\lib\vswitch-idl.c	/^ovsrec_manager_unparse_inactivity_probe(struct ovsdb_idl_row *row_)$/;"	f	file:
ovsrec_manager_unparse_is_connected	.\lib\vswitch-idl.c	/^ovsrec_manager_unparse_is_connected(struct ovsdb_idl_row *row OVS_UNUSED)$/;"	f	file:
ovsrec_manager_unparse_max_backoff	.\lib\vswitch-idl.c	/^ovsrec_manager_unparse_max_backoff(struct ovsdb_idl_row *row_)$/;"	f	file:
ovsrec_manager_unparse_other_config	.\lib\vswitch-idl.c	/^ovsrec_manager_unparse_other_config(struct ovsdb_idl_row *row_)$/;"	f	file:
ovsrec_manager_unparse_status	.\lib\vswitch-idl.c	/^ovsrec_manager_unparse_status(struct ovsdb_idl_row *row_)$/;"	f	file:
ovsrec_manager_unparse_target	.\lib\vswitch-idl.c	/^ovsrec_manager_unparse_target(struct ovsdb_idl_row *row OVS_UNUSED)$/;"	f	file:
ovsrec_manager_verify_connection_mode	.\lib\vswitch-idl.c	/^ovsrec_manager_verify_connection_mode(const struct ovsrec_manager *row)$/;"	f
ovsrec_manager_verify_external_ids	.\lib\vswitch-idl.c	/^ovsrec_manager_verify_external_ids(const struct ovsrec_manager *row)$/;"	f
ovsrec_manager_verify_inactivity_probe	.\lib\vswitch-idl.c	/^ovsrec_manager_verify_inactivity_probe(const struct ovsrec_manager *row)$/;"	f
ovsrec_manager_verify_is_connected	.\lib\vswitch-idl.c	/^ovsrec_manager_verify_is_connected(const struct ovsrec_manager *row)$/;"	f
ovsrec_manager_verify_max_backoff	.\lib\vswitch-idl.c	/^ovsrec_manager_verify_max_backoff(const struct ovsrec_manager *row)$/;"	f
ovsrec_manager_verify_other_config	.\lib\vswitch-idl.c	/^ovsrec_manager_verify_other_config(const struct ovsrec_manager *row)$/;"	f
ovsrec_manager_verify_status	.\lib\vswitch-idl.c	/^ovsrec_manager_verify_status(const struct ovsrec_manager *row)$/;"	f
ovsrec_manager_verify_target	.\lib\vswitch-idl.c	/^ovsrec_manager_verify_target(const struct ovsrec_manager *row)$/;"	f
ovsrec_mirror	.\lib\vswitch-idl.h	/^struct ovsrec_mirror {$/;"	s
ovsrec_mirror_cast	.\lib\vswitch-idl.c	/^ovsrec_mirror_cast(const struct ovsdb_idl_row *row)$/;"	f	file:
ovsrec_mirror_col_external_ids	.\lib\vswitch-idl.h	1050;"	d
ovsrec_mirror_col_name	.\lib\vswitch-idl.h	1047;"	d
ovsrec_mirror_col_output_port	.\lib\vswitch-idl.h	1044;"	d
ovsrec_mirror_col_output_vlan	.\lib\vswitch-idl.h	1051;"	d
ovsrec_mirror_col_select_all	.\lib\vswitch-idl.h	1048;"	d
ovsrec_mirror_col_select_dst_port	.\lib\vswitch-idl.h	1049;"	d
ovsrec_mirror_col_select_src_port	.\lib\vswitch-idl.h	1045;"	d
ovsrec_mirror_col_select_vlan	.\lib\vswitch-idl.h	1052;"	d
ovsrec_mirror_col_statistics	.\lib\vswitch-idl.h	1046;"	d
ovsrec_mirror_columns	.\lib\vswitch-idl.c	/^struct ovsdb_idl_column ovsrec_mirror_columns[OVSREC_MIRROR_N_COLUMNS];$/;"	v	typeref:struct:ovsdb_idl_column
ovsrec_mirror_columns_init	.\lib\vswitch-idl.c	/^ovsrec_mirror_columns_init(void)$/;"	f	file:
ovsrec_mirror_delete	.\lib\vswitch-idl.c	/^ovsrec_mirror_delete(const struct ovsrec_mirror *row)$/;"	f
ovsrec_mirror_first	.\lib\vswitch-idl.c	/^ovsrec_mirror_first(const struct ovsdb_idl *idl)$/;"	f
ovsrec_mirror_get_external_ids	.\lib\vswitch-idl.c	/^ovsrec_mirror_get_external_ids(const struct ovsrec_mirror *row,$/;"	f
ovsrec_mirror_get_for_uuid	.\lib\vswitch-idl.c	/^ovsrec_mirror_get_for_uuid(const struct ovsdb_idl *idl, const struct uuid *uuid)$/;"	f
ovsrec_mirror_get_name	.\lib\vswitch-idl.c	/^ovsrec_mirror_get_name(const struct ovsrec_mirror *row,$/;"	f
ovsrec_mirror_get_output_port	.\lib\vswitch-idl.c	/^ovsrec_mirror_get_output_port(const struct ovsrec_mirror *row,$/;"	f
ovsrec_mirror_get_output_vlan	.\lib\vswitch-idl.c	/^ovsrec_mirror_get_output_vlan(const struct ovsrec_mirror *row,$/;"	f
ovsrec_mirror_get_select_all	.\lib\vswitch-idl.c	/^ovsrec_mirror_get_select_all(const struct ovsrec_mirror *row,$/;"	f
ovsrec_mirror_get_select_dst_port	.\lib\vswitch-idl.c	/^ovsrec_mirror_get_select_dst_port(const struct ovsrec_mirror *row,$/;"	f
ovsrec_mirror_get_select_src_port	.\lib\vswitch-idl.c	/^ovsrec_mirror_get_select_src_port(const struct ovsrec_mirror *row,$/;"	f
ovsrec_mirror_get_select_vlan	.\lib\vswitch-idl.c	/^ovsrec_mirror_get_select_vlan(const struct ovsrec_mirror *row,$/;"	f
ovsrec_mirror_get_statistics	.\lib\vswitch-idl.c	/^ovsrec_mirror_get_statistics(const struct ovsrec_mirror *row,$/;"	f
ovsrec_mirror_init	.\lib\vswitch-idl.c	/^ovsrec_mirror_init(struct ovsrec_mirror *row)$/;"	f
ovsrec_mirror_init__	.\lib\vswitch-idl.c	/^ovsrec_mirror_init__(struct ovsdb_idl_row *row)$/;"	f	file:
ovsrec_mirror_insert	.\lib\vswitch-idl.c	/^ovsrec_mirror_insert(struct ovsdb_idl_txn *txn)$/;"	f
ovsrec_mirror_next	.\lib\vswitch-idl.c	/^ovsrec_mirror_next(const struct ovsrec_mirror *row)$/;"	f
ovsrec_mirror_parse_external_ids	.\lib\vswitch-idl.c	/^ovsrec_mirror_parse_external_ids(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
ovsrec_mirror_parse_name	.\lib\vswitch-idl.c	/^ovsrec_mirror_parse_name(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
ovsrec_mirror_parse_output_port	.\lib\vswitch-idl.c	/^ovsrec_mirror_parse_output_port(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
ovsrec_mirror_parse_output_vlan	.\lib\vswitch-idl.c	/^ovsrec_mirror_parse_output_vlan(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
ovsrec_mirror_parse_select_all	.\lib\vswitch-idl.c	/^ovsrec_mirror_parse_select_all(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
ovsrec_mirror_parse_select_dst_port	.\lib\vswitch-idl.c	/^ovsrec_mirror_parse_select_dst_port(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
ovsrec_mirror_parse_select_src_port	.\lib\vswitch-idl.c	/^ovsrec_mirror_parse_select_src_port(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
ovsrec_mirror_parse_select_vlan	.\lib\vswitch-idl.c	/^ovsrec_mirror_parse_select_vlan(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
ovsrec_mirror_parse_statistics	.\lib\vswitch-idl.c	/^ovsrec_mirror_parse_statistics(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
ovsrec_mirror_set_external_ids	.\lib\vswitch-idl.c	/^ovsrec_mirror_set_external_ids(const struct ovsrec_mirror *row, const struct smap *smap)$/;"	f
ovsrec_mirror_set_name	.\lib\vswitch-idl.c	/^ovsrec_mirror_set_name(const struct ovsrec_mirror *row, const char *name)$/;"	f
ovsrec_mirror_set_output_port	.\lib\vswitch-idl.c	/^ovsrec_mirror_set_output_port(const struct ovsrec_mirror *row, const struct ovsrec_port *output_port)$/;"	f
ovsrec_mirror_set_output_vlan	.\lib\vswitch-idl.c	/^ovsrec_mirror_set_output_vlan(const struct ovsrec_mirror *row, const int64_t *output_vlan, size_t n_output_vlan)$/;"	f
ovsrec_mirror_set_select_all	.\lib\vswitch-idl.c	/^ovsrec_mirror_set_select_all(const struct ovsrec_mirror *row, bool select_all)$/;"	f
ovsrec_mirror_set_select_dst_port	.\lib\vswitch-idl.c	/^ovsrec_mirror_set_select_dst_port(const struct ovsrec_mirror *row, struct ovsrec_port **select_dst_port, size_t n_select_dst_port)$/;"	f
ovsrec_mirror_set_select_src_port	.\lib\vswitch-idl.c	/^ovsrec_mirror_set_select_src_port(const struct ovsrec_mirror *row, struct ovsrec_port **select_src_port, size_t n_select_src_port)$/;"	f
ovsrec_mirror_set_select_vlan	.\lib\vswitch-idl.c	/^ovsrec_mirror_set_select_vlan(const struct ovsrec_mirror *row, const int64_t *select_vlan, size_t n_select_vlan)$/;"	f
ovsrec_mirror_set_statistics	.\lib\vswitch-idl.c	/^ovsrec_mirror_set_statistics(const struct ovsrec_mirror *row, char **key_statistics, const int64_t *value_statistics, size_t n_statistics)$/;"	f
ovsrec_mirror_unparse_external_ids	.\lib\vswitch-idl.c	/^ovsrec_mirror_unparse_external_ids(struct ovsdb_idl_row *row_)$/;"	f	file:
ovsrec_mirror_unparse_name	.\lib\vswitch-idl.c	/^ovsrec_mirror_unparse_name(struct ovsdb_idl_row *row OVS_UNUSED)$/;"	f	file:
ovsrec_mirror_unparse_output_port	.\lib\vswitch-idl.c	/^ovsrec_mirror_unparse_output_port(struct ovsdb_idl_row *row OVS_UNUSED)$/;"	f	file:
ovsrec_mirror_unparse_output_vlan	.\lib\vswitch-idl.c	/^ovsrec_mirror_unparse_output_vlan(struct ovsdb_idl_row *row_)$/;"	f	file:
ovsrec_mirror_unparse_select_all	.\lib\vswitch-idl.c	/^ovsrec_mirror_unparse_select_all(struct ovsdb_idl_row *row OVS_UNUSED)$/;"	f	file:
ovsrec_mirror_unparse_select_dst_port	.\lib\vswitch-idl.c	/^ovsrec_mirror_unparse_select_dst_port(struct ovsdb_idl_row *row_)$/;"	f	file:
ovsrec_mirror_unparse_select_src_port	.\lib\vswitch-idl.c	/^ovsrec_mirror_unparse_select_src_port(struct ovsdb_idl_row *row_)$/;"	f	file:
ovsrec_mirror_unparse_select_vlan	.\lib\vswitch-idl.c	/^ovsrec_mirror_unparse_select_vlan(struct ovsdb_idl_row *row_)$/;"	f	file:
ovsrec_mirror_unparse_statistics	.\lib\vswitch-idl.c	/^ovsrec_mirror_unparse_statistics(struct ovsdb_idl_row *row_)$/;"	f	file:
ovsrec_mirror_verify_external_ids	.\lib\vswitch-idl.c	/^ovsrec_mirror_verify_external_ids(const struct ovsrec_mirror *row)$/;"	f
ovsrec_mirror_verify_name	.\lib\vswitch-idl.c	/^ovsrec_mirror_verify_name(const struct ovsrec_mirror *row)$/;"	f
ovsrec_mirror_verify_output_port	.\lib\vswitch-idl.c	/^ovsrec_mirror_verify_output_port(const struct ovsrec_mirror *row)$/;"	f
ovsrec_mirror_verify_output_vlan	.\lib\vswitch-idl.c	/^ovsrec_mirror_verify_output_vlan(const struct ovsrec_mirror *row)$/;"	f
ovsrec_mirror_verify_select_all	.\lib\vswitch-idl.c	/^ovsrec_mirror_verify_select_all(const struct ovsrec_mirror *row)$/;"	f
ovsrec_mirror_verify_select_dst_port	.\lib\vswitch-idl.c	/^ovsrec_mirror_verify_select_dst_port(const struct ovsrec_mirror *row)$/;"	f
ovsrec_mirror_verify_select_src_port	.\lib\vswitch-idl.c	/^ovsrec_mirror_verify_select_src_port(const struct ovsrec_mirror *row)$/;"	f
ovsrec_mirror_verify_select_vlan	.\lib\vswitch-idl.c	/^ovsrec_mirror_verify_select_vlan(const struct ovsrec_mirror *row)$/;"	f
ovsrec_mirror_verify_statistics	.\lib\vswitch-idl.c	/^ovsrec_mirror_verify_statistics(const struct ovsrec_mirror *row)$/;"	f
ovsrec_netflow	.\lib\vswitch-idl.h	/^struct ovsrec_netflow {$/;"	s
ovsrec_netflow_cast	.\lib\vswitch-idl.c	/^ovsrec_netflow_cast(const struct ovsdb_idl_row *row)$/;"	f	file:
ovsrec_netflow_col_active_timeout	.\lib\vswitch-idl.h	1143;"	d
ovsrec_netflow_col_add_id_to_interface	.\lib\vswitch-idl.h	1144;"	d
ovsrec_netflow_col_engine_id	.\lib\vswitch-idl.h	1142;"	d
ovsrec_netflow_col_engine_type	.\lib\vswitch-idl.h	1147;"	d
ovsrec_netflow_col_external_ids	.\lib\vswitch-idl.h	1145;"	d
ovsrec_netflow_col_targets	.\lib\vswitch-idl.h	1146;"	d
ovsrec_netflow_columns	.\lib\vswitch-idl.c	/^struct ovsdb_idl_column ovsrec_netflow_columns[OVSREC_NETFLOW_N_COLUMNS];$/;"	v	typeref:struct:ovsdb_idl_column
ovsrec_netflow_columns_init	.\lib\vswitch-idl.c	/^ovsrec_netflow_columns_init(void)$/;"	f	file:
ovsrec_netflow_delete	.\lib\vswitch-idl.c	/^ovsrec_netflow_delete(const struct ovsrec_netflow *row)$/;"	f
ovsrec_netflow_first	.\lib\vswitch-idl.c	/^ovsrec_netflow_first(const struct ovsdb_idl *idl)$/;"	f
ovsrec_netflow_get_active_timeout	.\lib\vswitch-idl.c	/^ovsrec_netflow_get_active_timeout(const struct ovsrec_netflow *row,$/;"	f
ovsrec_netflow_get_add_id_to_interface	.\lib\vswitch-idl.c	/^ovsrec_netflow_get_add_id_to_interface(const struct ovsrec_netflow *row,$/;"	f
ovsrec_netflow_get_engine_id	.\lib\vswitch-idl.c	/^ovsrec_netflow_get_engine_id(const struct ovsrec_netflow *row,$/;"	f
ovsrec_netflow_get_engine_type	.\lib\vswitch-idl.c	/^ovsrec_netflow_get_engine_type(const struct ovsrec_netflow *row,$/;"	f
ovsrec_netflow_get_external_ids	.\lib\vswitch-idl.c	/^ovsrec_netflow_get_external_ids(const struct ovsrec_netflow *row,$/;"	f
ovsrec_netflow_get_for_uuid	.\lib\vswitch-idl.c	/^ovsrec_netflow_get_for_uuid(const struct ovsdb_idl *idl, const struct uuid *uuid)$/;"	f
ovsrec_netflow_get_targets	.\lib\vswitch-idl.c	/^ovsrec_netflow_get_targets(const struct ovsrec_netflow *row,$/;"	f
ovsrec_netflow_init	.\lib\vswitch-idl.c	/^ovsrec_netflow_init(struct ovsrec_netflow *row)$/;"	f
ovsrec_netflow_init__	.\lib\vswitch-idl.c	/^ovsrec_netflow_init__(struct ovsdb_idl_row *row)$/;"	f	file:
ovsrec_netflow_insert	.\lib\vswitch-idl.c	/^ovsrec_netflow_insert(struct ovsdb_idl_txn *txn)$/;"	f
ovsrec_netflow_next	.\lib\vswitch-idl.c	/^ovsrec_netflow_next(const struct ovsrec_netflow *row)$/;"	f
ovsrec_netflow_parse_active_timeout	.\lib\vswitch-idl.c	/^ovsrec_netflow_parse_active_timeout(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
ovsrec_netflow_parse_add_id_to_interface	.\lib\vswitch-idl.c	/^ovsrec_netflow_parse_add_id_to_interface(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
ovsrec_netflow_parse_engine_id	.\lib\vswitch-idl.c	/^ovsrec_netflow_parse_engine_id(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
ovsrec_netflow_parse_engine_type	.\lib\vswitch-idl.c	/^ovsrec_netflow_parse_engine_type(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
ovsrec_netflow_parse_external_ids	.\lib\vswitch-idl.c	/^ovsrec_netflow_parse_external_ids(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
ovsrec_netflow_parse_targets	.\lib\vswitch-idl.c	/^ovsrec_netflow_parse_targets(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
ovsrec_netflow_set_active_timeout	.\lib\vswitch-idl.c	/^ovsrec_netflow_set_active_timeout(const struct ovsrec_netflow *row, int64_t active_timeout)$/;"	f
ovsrec_netflow_set_add_id_to_interface	.\lib\vswitch-idl.c	/^ovsrec_netflow_set_add_id_to_interface(const struct ovsrec_netflow *row, bool add_id_to_interface)$/;"	f
ovsrec_netflow_set_engine_id	.\lib\vswitch-idl.c	/^ovsrec_netflow_set_engine_id(const struct ovsrec_netflow *row, const int64_t *engine_id, size_t n_engine_id)$/;"	f
ovsrec_netflow_set_engine_type	.\lib\vswitch-idl.c	/^ovsrec_netflow_set_engine_type(const struct ovsrec_netflow *row, const int64_t *engine_type, size_t n_engine_type)$/;"	f
ovsrec_netflow_set_external_ids	.\lib\vswitch-idl.c	/^ovsrec_netflow_set_external_ids(const struct ovsrec_netflow *row, const struct smap *smap)$/;"	f
ovsrec_netflow_set_targets	.\lib\vswitch-idl.c	/^ovsrec_netflow_set_targets(const struct ovsrec_netflow *row, char **targets, size_t n_targets)$/;"	f
ovsrec_netflow_unparse_active_timeout	.\lib\vswitch-idl.c	/^ovsrec_netflow_unparse_active_timeout(struct ovsdb_idl_row *row OVS_UNUSED)$/;"	f	file:
ovsrec_netflow_unparse_add_id_to_interface	.\lib\vswitch-idl.c	/^ovsrec_netflow_unparse_add_id_to_interface(struct ovsdb_idl_row *row OVS_UNUSED)$/;"	f	file:
ovsrec_netflow_unparse_engine_id	.\lib\vswitch-idl.c	/^ovsrec_netflow_unparse_engine_id(struct ovsdb_idl_row *row_)$/;"	f	file:
ovsrec_netflow_unparse_engine_type	.\lib\vswitch-idl.c	/^ovsrec_netflow_unparse_engine_type(struct ovsdb_idl_row *row_)$/;"	f	file:
ovsrec_netflow_unparse_external_ids	.\lib\vswitch-idl.c	/^ovsrec_netflow_unparse_external_ids(struct ovsdb_idl_row *row_)$/;"	f	file:
ovsrec_netflow_unparse_targets	.\lib\vswitch-idl.c	/^ovsrec_netflow_unparse_targets(struct ovsdb_idl_row *row_)$/;"	f	file:
ovsrec_netflow_verify_active_timeout	.\lib\vswitch-idl.c	/^ovsrec_netflow_verify_active_timeout(const struct ovsrec_netflow *row)$/;"	f
ovsrec_netflow_verify_add_id_to_interface	.\lib\vswitch-idl.c	/^ovsrec_netflow_verify_add_id_to_interface(const struct ovsrec_netflow *row)$/;"	f
ovsrec_netflow_verify_engine_id	.\lib\vswitch-idl.c	/^ovsrec_netflow_verify_engine_id(const struct ovsrec_netflow *row)$/;"	f
ovsrec_netflow_verify_engine_type	.\lib\vswitch-idl.c	/^ovsrec_netflow_verify_engine_type(const struct ovsrec_netflow *row)$/;"	f
ovsrec_netflow_verify_external_ids	.\lib\vswitch-idl.c	/^ovsrec_netflow_verify_external_ids(const struct ovsrec_netflow *row)$/;"	f
ovsrec_netflow_verify_targets	.\lib\vswitch-idl.c	/^ovsrec_netflow_verify_targets(const struct ovsrec_netflow *row)$/;"	f
ovsrec_open_vswitch	.\lib\vswitch-idl.h	/^struct ovsrec_open_vswitch {$/;"	s
ovsrec_open_vswitch_cast	.\lib\vswitch-idl.c	/^ovsrec_open_vswitch_cast(const struct ovsdb_idl_row *row)$/;"	f	file:
ovsrec_open_vswitch_col_bridges	.\lib\vswitch-idl.h	1251;"	d
ovsrec_open_vswitch_col_cur_cfg	.\lib\vswitch-idl.h	1261;"	d
ovsrec_open_vswitch_col_db_version	.\lib\vswitch-idl.h	1253;"	d
ovsrec_open_vswitch_col_external_ids	.\lib\vswitch-idl.h	1259;"	d
ovsrec_open_vswitch_col_manager_options	.\lib\vswitch-idl.h	1258;"	d
ovsrec_open_vswitch_col_next_cfg	.\lib\vswitch-idl.h	1254;"	d
ovsrec_open_vswitch_col_other_config	.\lib\vswitch-idl.h	1256;"	d
ovsrec_open_vswitch_col_ovs_version	.\lib\vswitch-idl.h	1255;"	d
ovsrec_open_vswitch_col_ssl	.\lib\vswitch-idl.h	1257;"	d
ovsrec_open_vswitch_col_statistics	.\lib\vswitch-idl.h	1252;"	d
ovsrec_open_vswitch_col_system_type	.\lib\vswitch-idl.h	1262;"	d
ovsrec_open_vswitch_col_system_version	.\lib\vswitch-idl.h	1260;"	d
ovsrec_open_vswitch_columns	.\lib\vswitch-idl.c	/^struct ovsdb_idl_column ovsrec_open_vswitch_columns[OVSREC_OPEN_VSWITCH_N_COLUMNS];$/;"	v	typeref:struct:ovsdb_idl_column
ovsrec_open_vswitch_columns_init	.\lib\vswitch-idl.c	/^ovsrec_open_vswitch_columns_init(void)$/;"	f	file:
ovsrec_open_vswitch_delete	.\lib\vswitch-idl.c	/^ovsrec_open_vswitch_delete(const struct ovsrec_open_vswitch *row)$/;"	f
ovsrec_open_vswitch_first	.\lib\vswitch-idl.c	/^ovsrec_open_vswitch_first(const struct ovsdb_idl *idl)$/;"	f
ovsrec_open_vswitch_get_bridges	.\lib\vswitch-idl.c	/^ovsrec_open_vswitch_get_bridges(const struct ovsrec_open_vswitch *row,$/;"	f
ovsrec_open_vswitch_get_cur_cfg	.\lib\vswitch-idl.c	/^ovsrec_open_vswitch_get_cur_cfg(const struct ovsrec_open_vswitch *row,$/;"	f
ovsrec_open_vswitch_get_db_version	.\lib\vswitch-idl.c	/^ovsrec_open_vswitch_get_db_version(const struct ovsrec_open_vswitch *row,$/;"	f
ovsrec_open_vswitch_get_external_ids	.\lib\vswitch-idl.c	/^ovsrec_open_vswitch_get_external_ids(const struct ovsrec_open_vswitch *row,$/;"	f
ovsrec_open_vswitch_get_for_uuid	.\lib\vswitch-idl.c	/^ovsrec_open_vswitch_get_for_uuid(const struct ovsdb_idl *idl, const struct uuid *uuid)$/;"	f
ovsrec_open_vswitch_get_manager_options	.\lib\vswitch-idl.c	/^ovsrec_open_vswitch_get_manager_options(const struct ovsrec_open_vswitch *row,$/;"	f
ovsrec_open_vswitch_get_next_cfg	.\lib\vswitch-idl.c	/^ovsrec_open_vswitch_get_next_cfg(const struct ovsrec_open_vswitch *row,$/;"	f
ovsrec_open_vswitch_get_other_config	.\lib\vswitch-idl.c	/^ovsrec_open_vswitch_get_other_config(const struct ovsrec_open_vswitch *row,$/;"	f
ovsrec_open_vswitch_get_ovs_version	.\lib\vswitch-idl.c	/^ovsrec_open_vswitch_get_ovs_version(const struct ovsrec_open_vswitch *row,$/;"	f
ovsrec_open_vswitch_get_ssl	.\lib\vswitch-idl.c	/^ovsrec_open_vswitch_get_ssl(const struct ovsrec_open_vswitch *row,$/;"	f
ovsrec_open_vswitch_get_statistics	.\lib\vswitch-idl.c	/^ovsrec_open_vswitch_get_statistics(const struct ovsrec_open_vswitch *row,$/;"	f
ovsrec_open_vswitch_get_system_type	.\lib\vswitch-idl.c	/^ovsrec_open_vswitch_get_system_type(const struct ovsrec_open_vswitch *row,$/;"	f
ovsrec_open_vswitch_get_system_version	.\lib\vswitch-idl.c	/^ovsrec_open_vswitch_get_system_version(const struct ovsrec_open_vswitch *row,$/;"	f
ovsrec_open_vswitch_init	.\lib\vswitch-idl.c	/^ovsrec_open_vswitch_init(struct ovsrec_open_vswitch *row)$/;"	f
ovsrec_open_vswitch_init__	.\lib\vswitch-idl.c	/^ovsrec_open_vswitch_init__(struct ovsdb_idl_row *row)$/;"	f	file:
ovsrec_open_vswitch_insert	.\lib\vswitch-idl.c	/^ovsrec_open_vswitch_insert(struct ovsdb_idl_txn *txn)$/;"	f
ovsrec_open_vswitch_next	.\lib\vswitch-idl.c	/^ovsrec_open_vswitch_next(const struct ovsrec_open_vswitch *row)$/;"	f
ovsrec_open_vswitch_parse_bridges	.\lib\vswitch-idl.c	/^ovsrec_open_vswitch_parse_bridges(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
ovsrec_open_vswitch_parse_cur_cfg	.\lib\vswitch-idl.c	/^ovsrec_open_vswitch_parse_cur_cfg(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
ovsrec_open_vswitch_parse_db_version	.\lib\vswitch-idl.c	/^ovsrec_open_vswitch_parse_db_version(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
ovsrec_open_vswitch_parse_external_ids	.\lib\vswitch-idl.c	/^ovsrec_open_vswitch_parse_external_ids(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
ovsrec_open_vswitch_parse_manager_options	.\lib\vswitch-idl.c	/^ovsrec_open_vswitch_parse_manager_options(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
ovsrec_open_vswitch_parse_next_cfg	.\lib\vswitch-idl.c	/^ovsrec_open_vswitch_parse_next_cfg(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
ovsrec_open_vswitch_parse_other_config	.\lib\vswitch-idl.c	/^ovsrec_open_vswitch_parse_other_config(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
ovsrec_open_vswitch_parse_ovs_version	.\lib\vswitch-idl.c	/^ovsrec_open_vswitch_parse_ovs_version(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
ovsrec_open_vswitch_parse_ssl	.\lib\vswitch-idl.c	/^ovsrec_open_vswitch_parse_ssl(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
ovsrec_open_vswitch_parse_statistics	.\lib\vswitch-idl.c	/^ovsrec_open_vswitch_parse_statistics(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
ovsrec_open_vswitch_parse_system_type	.\lib\vswitch-idl.c	/^ovsrec_open_vswitch_parse_system_type(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
ovsrec_open_vswitch_parse_system_version	.\lib\vswitch-idl.c	/^ovsrec_open_vswitch_parse_system_version(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
ovsrec_open_vswitch_set_bridges	.\lib\vswitch-idl.c	/^ovsrec_open_vswitch_set_bridges(const struct ovsrec_open_vswitch *row, struct ovsrec_bridge **bridges, size_t n_bridges)$/;"	f
ovsrec_open_vswitch_set_cur_cfg	.\lib\vswitch-idl.c	/^ovsrec_open_vswitch_set_cur_cfg(const struct ovsrec_open_vswitch *row, int64_t cur_cfg)$/;"	f
ovsrec_open_vswitch_set_db_version	.\lib\vswitch-idl.c	/^ovsrec_open_vswitch_set_db_version(const struct ovsrec_open_vswitch *row, const char *db_version)$/;"	f
ovsrec_open_vswitch_set_external_ids	.\lib\vswitch-idl.c	/^ovsrec_open_vswitch_set_external_ids(const struct ovsrec_open_vswitch *row, const struct smap *smap)$/;"	f
ovsrec_open_vswitch_set_manager_options	.\lib\vswitch-idl.c	/^ovsrec_open_vswitch_set_manager_options(const struct ovsrec_open_vswitch *row, struct ovsrec_manager **manager_options, size_t n_manager_options)$/;"	f
ovsrec_open_vswitch_set_next_cfg	.\lib\vswitch-idl.c	/^ovsrec_open_vswitch_set_next_cfg(const struct ovsrec_open_vswitch *row, int64_t next_cfg)$/;"	f
ovsrec_open_vswitch_set_other_config	.\lib\vswitch-idl.c	/^ovsrec_open_vswitch_set_other_config(const struct ovsrec_open_vswitch *row, const struct smap *smap)$/;"	f
ovsrec_open_vswitch_set_ovs_version	.\lib\vswitch-idl.c	/^ovsrec_open_vswitch_set_ovs_version(const struct ovsrec_open_vswitch *row, const char *ovs_version)$/;"	f
ovsrec_open_vswitch_set_ssl	.\lib\vswitch-idl.c	/^ovsrec_open_vswitch_set_ssl(const struct ovsrec_open_vswitch *row, const struct ovsrec_ssl *ssl)$/;"	f
ovsrec_open_vswitch_set_statistics	.\lib\vswitch-idl.c	/^ovsrec_open_vswitch_set_statistics(const struct ovsrec_open_vswitch *row, const struct smap *smap)$/;"	f
ovsrec_open_vswitch_set_system_type	.\lib\vswitch-idl.c	/^ovsrec_open_vswitch_set_system_type(const struct ovsrec_open_vswitch *row, const char *system_type)$/;"	f
ovsrec_open_vswitch_set_system_version	.\lib\vswitch-idl.c	/^ovsrec_open_vswitch_set_system_version(const struct ovsrec_open_vswitch *row, const char *system_version)$/;"	f
ovsrec_open_vswitch_unparse_bridges	.\lib\vswitch-idl.c	/^ovsrec_open_vswitch_unparse_bridges(struct ovsdb_idl_row *row_)$/;"	f	file:
ovsrec_open_vswitch_unparse_cur_cfg	.\lib\vswitch-idl.c	/^ovsrec_open_vswitch_unparse_cur_cfg(struct ovsdb_idl_row *row OVS_UNUSED)$/;"	f	file:
ovsrec_open_vswitch_unparse_db_version	.\lib\vswitch-idl.c	/^ovsrec_open_vswitch_unparse_db_version(struct ovsdb_idl_row *row OVS_UNUSED)$/;"	f	file:
ovsrec_open_vswitch_unparse_external_ids	.\lib\vswitch-idl.c	/^ovsrec_open_vswitch_unparse_external_ids(struct ovsdb_idl_row *row_)$/;"	f	file:
ovsrec_open_vswitch_unparse_manager_options	.\lib\vswitch-idl.c	/^ovsrec_open_vswitch_unparse_manager_options(struct ovsdb_idl_row *row_)$/;"	f	file:
ovsrec_open_vswitch_unparse_next_cfg	.\lib\vswitch-idl.c	/^ovsrec_open_vswitch_unparse_next_cfg(struct ovsdb_idl_row *row OVS_UNUSED)$/;"	f	file:
ovsrec_open_vswitch_unparse_other_config	.\lib\vswitch-idl.c	/^ovsrec_open_vswitch_unparse_other_config(struct ovsdb_idl_row *row_)$/;"	f	file:
ovsrec_open_vswitch_unparse_ovs_version	.\lib\vswitch-idl.c	/^ovsrec_open_vswitch_unparse_ovs_version(struct ovsdb_idl_row *row OVS_UNUSED)$/;"	f	file:
ovsrec_open_vswitch_unparse_ssl	.\lib\vswitch-idl.c	/^ovsrec_open_vswitch_unparse_ssl(struct ovsdb_idl_row *row OVS_UNUSED)$/;"	f	file:
ovsrec_open_vswitch_unparse_statistics	.\lib\vswitch-idl.c	/^ovsrec_open_vswitch_unparse_statistics(struct ovsdb_idl_row *row_)$/;"	f	file:
ovsrec_open_vswitch_unparse_system_type	.\lib\vswitch-idl.c	/^ovsrec_open_vswitch_unparse_system_type(struct ovsdb_idl_row *row OVS_UNUSED)$/;"	f	file:
ovsrec_open_vswitch_unparse_system_version	.\lib\vswitch-idl.c	/^ovsrec_open_vswitch_unparse_system_version(struct ovsdb_idl_row *row OVS_UNUSED)$/;"	f	file:
ovsrec_open_vswitch_verify_bridges	.\lib\vswitch-idl.c	/^ovsrec_open_vswitch_verify_bridges(const struct ovsrec_open_vswitch *row)$/;"	f
ovsrec_open_vswitch_verify_cur_cfg	.\lib\vswitch-idl.c	/^ovsrec_open_vswitch_verify_cur_cfg(const struct ovsrec_open_vswitch *row)$/;"	f
ovsrec_open_vswitch_verify_db_version	.\lib\vswitch-idl.c	/^ovsrec_open_vswitch_verify_db_version(const struct ovsrec_open_vswitch *row)$/;"	f
ovsrec_open_vswitch_verify_external_ids	.\lib\vswitch-idl.c	/^ovsrec_open_vswitch_verify_external_ids(const struct ovsrec_open_vswitch *row)$/;"	f
ovsrec_open_vswitch_verify_manager_options	.\lib\vswitch-idl.c	/^ovsrec_open_vswitch_verify_manager_options(const struct ovsrec_open_vswitch *row)$/;"	f
ovsrec_open_vswitch_verify_next_cfg	.\lib\vswitch-idl.c	/^ovsrec_open_vswitch_verify_next_cfg(const struct ovsrec_open_vswitch *row)$/;"	f
ovsrec_open_vswitch_verify_other_config	.\lib\vswitch-idl.c	/^ovsrec_open_vswitch_verify_other_config(const struct ovsrec_open_vswitch *row)$/;"	f
ovsrec_open_vswitch_verify_ovs_version	.\lib\vswitch-idl.c	/^ovsrec_open_vswitch_verify_ovs_version(const struct ovsrec_open_vswitch *row)$/;"	f
ovsrec_open_vswitch_verify_ssl	.\lib\vswitch-idl.c	/^ovsrec_open_vswitch_verify_ssl(const struct ovsrec_open_vswitch *row)$/;"	f
ovsrec_open_vswitch_verify_statistics	.\lib\vswitch-idl.c	/^ovsrec_open_vswitch_verify_statistics(const struct ovsrec_open_vswitch *row)$/;"	f
ovsrec_open_vswitch_verify_system_type	.\lib\vswitch-idl.c	/^ovsrec_open_vswitch_verify_system_type(const struct ovsrec_open_vswitch *row)$/;"	f
ovsrec_open_vswitch_verify_system_version	.\lib\vswitch-idl.c	/^ovsrec_open_vswitch_verify_system_version(const struct ovsrec_open_vswitch *row)$/;"	f
ovsrec_port	.\lib\vswitch-idl.h	/^struct ovsrec_port {$/;"	s
ovsrec_port_cast	.\lib\vswitch-idl.c	/^ovsrec_port_cast(const struct ovsdb_idl_row *row)$/;"	f	file:
ovsrec_port_col_bond_active_slave	.\lib\vswitch-idl.h	1418;"	d
ovsrec_port_col_bond_downdelay	.\lib\vswitch-idl.h	1415;"	d
ovsrec_port_col_bond_fake_iface	.\lib\vswitch-idl.h	1419;"	d
ovsrec_port_col_bond_mode	.\lib\vswitch-idl.h	1428;"	d
ovsrec_port_col_bond_updelay	.\lib\vswitch-idl.h	1427;"	d
ovsrec_port_col_external_ids	.\lib\vswitch-idl.h	1425;"	d
ovsrec_port_col_fake_bridge	.\lib\vswitch-idl.h	1426;"	d
ovsrec_port_col_interfaces	.\lib\vswitch-idl.h	1416;"	d
ovsrec_port_col_lacp	.\lib\vswitch-idl.h	1420;"	d
ovsrec_port_col_mac	.\lib\vswitch-idl.h	1421;"	d
ovsrec_port_col_name	.\lib\vswitch-idl.h	1414;"	d
ovsrec_port_col_other_config	.\lib\vswitch-idl.h	1417;"	d
ovsrec_port_col_qos	.\lib\vswitch-idl.h	1413;"	d
ovsrec_port_col_statistics	.\lib\vswitch-idl.h	1412;"	d
ovsrec_port_col_status	.\lib\vswitch-idl.h	1411;"	d
ovsrec_port_col_tag	.\lib\vswitch-idl.h	1422;"	d
ovsrec_port_col_trunks	.\lib\vswitch-idl.h	1423;"	d
ovsrec_port_col_vlan_mode	.\lib\vswitch-idl.h	1424;"	d
ovsrec_port_columns	.\lib\vswitch-idl.c	/^struct ovsdb_idl_column ovsrec_port_columns[OVSREC_PORT_N_COLUMNS];$/;"	v	typeref:struct:ovsdb_idl_column
ovsrec_port_columns_init	.\lib\vswitch-idl.c	/^ovsrec_port_columns_init(void)$/;"	f	file:
ovsrec_port_delete	.\lib\vswitch-idl.c	/^ovsrec_port_delete(const struct ovsrec_port *row)$/;"	f
ovsrec_port_first	.\lib\vswitch-idl.c	/^ovsrec_port_first(const struct ovsdb_idl *idl)$/;"	f
ovsrec_port_get_bond_active_slave	.\lib\vswitch-idl.c	/^ovsrec_port_get_bond_active_slave(const struct ovsrec_port *row,$/;"	f
ovsrec_port_get_bond_downdelay	.\lib\vswitch-idl.c	/^ovsrec_port_get_bond_downdelay(const struct ovsrec_port *row,$/;"	f
ovsrec_port_get_bond_fake_iface	.\lib\vswitch-idl.c	/^ovsrec_port_get_bond_fake_iface(const struct ovsrec_port *row,$/;"	f
ovsrec_port_get_bond_mode	.\lib\vswitch-idl.c	/^ovsrec_port_get_bond_mode(const struct ovsrec_port *row,$/;"	f
ovsrec_port_get_bond_updelay	.\lib\vswitch-idl.c	/^ovsrec_port_get_bond_updelay(const struct ovsrec_port *row,$/;"	f
ovsrec_port_get_external_ids	.\lib\vswitch-idl.c	/^ovsrec_port_get_external_ids(const struct ovsrec_port *row,$/;"	f
ovsrec_port_get_fake_bridge	.\lib\vswitch-idl.c	/^ovsrec_port_get_fake_bridge(const struct ovsrec_port *row,$/;"	f
ovsrec_port_get_for_uuid	.\lib\vswitch-idl.c	/^ovsrec_port_get_for_uuid(const struct ovsdb_idl *idl, const struct uuid *uuid)$/;"	f
ovsrec_port_get_interfaces	.\lib\vswitch-idl.c	/^ovsrec_port_get_interfaces(const struct ovsrec_port *row,$/;"	f
ovsrec_port_get_lacp	.\lib\vswitch-idl.c	/^ovsrec_port_get_lacp(const struct ovsrec_port *row,$/;"	f
ovsrec_port_get_mac	.\lib\vswitch-idl.c	/^ovsrec_port_get_mac(const struct ovsrec_port *row,$/;"	f
ovsrec_port_get_name	.\lib\vswitch-idl.c	/^ovsrec_port_get_name(const struct ovsrec_port *row,$/;"	f
ovsrec_port_get_other_config	.\lib\vswitch-idl.c	/^ovsrec_port_get_other_config(const struct ovsrec_port *row,$/;"	f
ovsrec_port_get_qos	.\lib\vswitch-idl.c	/^ovsrec_port_get_qos(const struct ovsrec_port *row,$/;"	f
ovsrec_port_get_statistics	.\lib\vswitch-idl.c	/^ovsrec_port_get_statistics(const struct ovsrec_port *row,$/;"	f
ovsrec_port_get_status	.\lib\vswitch-idl.c	/^ovsrec_port_get_status(const struct ovsrec_port *row,$/;"	f
ovsrec_port_get_tag	.\lib\vswitch-idl.c	/^ovsrec_port_get_tag(const struct ovsrec_port *row,$/;"	f
ovsrec_port_get_trunks	.\lib\vswitch-idl.c	/^ovsrec_port_get_trunks(const struct ovsrec_port *row,$/;"	f
ovsrec_port_get_vlan_mode	.\lib\vswitch-idl.c	/^ovsrec_port_get_vlan_mode(const struct ovsrec_port *row,$/;"	f
ovsrec_port_init	.\lib\vswitch-idl.c	/^ovsrec_port_init(struct ovsrec_port *row)$/;"	f
ovsrec_port_init__	.\lib\vswitch-idl.c	/^ovsrec_port_init__(struct ovsdb_idl_row *row)$/;"	f	file:
ovsrec_port_insert	.\lib\vswitch-idl.c	/^ovsrec_port_insert(struct ovsdb_idl_txn *txn)$/;"	f
ovsrec_port_next	.\lib\vswitch-idl.c	/^ovsrec_port_next(const struct ovsrec_port *row)$/;"	f
ovsrec_port_parse_bond_active_slave	.\lib\vswitch-idl.c	/^ovsrec_port_parse_bond_active_slave(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
ovsrec_port_parse_bond_downdelay	.\lib\vswitch-idl.c	/^ovsrec_port_parse_bond_downdelay(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
ovsrec_port_parse_bond_fake_iface	.\lib\vswitch-idl.c	/^ovsrec_port_parse_bond_fake_iface(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
ovsrec_port_parse_bond_mode	.\lib\vswitch-idl.c	/^ovsrec_port_parse_bond_mode(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
ovsrec_port_parse_bond_updelay	.\lib\vswitch-idl.c	/^ovsrec_port_parse_bond_updelay(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
ovsrec_port_parse_external_ids	.\lib\vswitch-idl.c	/^ovsrec_port_parse_external_ids(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
ovsrec_port_parse_fake_bridge	.\lib\vswitch-idl.c	/^ovsrec_port_parse_fake_bridge(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
ovsrec_port_parse_interfaces	.\lib\vswitch-idl.c	/^ovsrec_port_parse_interfaces(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
ovsrec_port_parse_lacp	.\lib\vswitch-idl.c	/^ovsrec_port_parse_lacp(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
ovsrec_port_parse_mac	.\lib\vswitch-idl.c	/^ovsrec_port_parse_mac(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
ovsrec_port_parse_name	.\lib\vswitch-idl.c	/^ovsrec_port_parse_name(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
ovsrec_port_parse_other_config	.\lib\vswitch-idl.c	/^ovsrec_port_parse_other_config(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
ovsrec_port_parse_qos	.\lib\vswitch-idl.c	/^ovsrec_port_parse_qos(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
ovsrec_port_parse_statistics	.\lib\vswitch-idl.c	/^ovsrec_port_parse_statistics(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
ovsrec_port_parse_status	.\lib\vswitch-idl.c	/^ovsrec_port_parse_status(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
ovsrec_port_parse_tag	.\lib\vswitch-idl.c	/^ovsrec_port_parse_tag(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
ovsrec_port_parse_trunks	.\lib\vswitch-idl.c	/^ovsrec_port_parse_trunks(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
ovsrec_port_parse_vlan_mode	.\lib\vswitch-idl.c	/^ovsrec_port_parse_vlan_mode(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
ovsrec_port_set_bond_active_slave	.\lib\vswitch-idl.c	/^ovsrec_port_set_bond_active_slave(const struct ovsrec_port *row, const char *bond_active_slave)$/;"	f
ovsrec_port_set_bond_downdelay	.\lib\vswitch-idl.c	/^ovsrec_port_set_bond_downdelay(const struct ovsrec_port *row, int64_t bond_downdelay)$/;"	f
ovsrec_port_set_bond_fake_iface	.\lib\vswitch-idl.c	/^ovsrec_port_set_bond_fake_iface(const struct ovsrec_port *row, bool bond_fake_iface)$/;"	f
ovsrec_port_set_bond_mode	.\lib\vswitch-idl.c	/^ovsrec_port_set_bond_mode(const struct ovsrec_port *row, const char *bond_mode)$/;"	f
ovsrec_port_set_bond_updelay	.\lib\vswitch-idl.c	/^ovsrec_port_set_bond_updelay(const struct ovsrec_port *row, int64_t bond_updelay)$/;"	f
ovsrec_port_set_external_ids	.\lib\vswitch-idl.c	/^ovsrec_port_set_external_ids(const struct ovsrec_port *row, const struct smap *smap)$/;"	f
ovsrec_port_set_fake_bridge	.\lib\vswitch-idl.c	/^ovsrec_port_set_fake_bridge(const struct ovsrec_port *row, bool fake_bridge)$/;"	f
ovsrec_port_set_interfaces	.\lib\vswitch-idl.c	/^ovsrec_port_set_interfaces(const struct ovsrec_port *row, struct ovsrec_interface **interfaces, size_t n_interfaces)$/;"	f
ovsrec_port_set_lacp	.\lib\vswitch-idl.c	/^ovsrec_port_set_lacp(const struct ovsrec_port *row, const char *lacp)$/;"	f
ovsrec_port_set_mac	.\lib\vswitch-idl.c	/^ovsrec_port_set_mac(const struct ovsrec_port *row, const char *mac)$/;"	f
ovsrec_port_set_name	.\lib\vswitch-idl.c	/^ovsrec_port_set_name(const struct ovsrec_port *row, const char *name)$/;"	f
ovsrec_port_set_other_config	.\lib\vswitch-idl.c	/^ovsrec_port_set_other_config(const struct ovsrec_port *row, const struct smap *smap)$/;"	f
ovsrec_port_set_qos	.\lib\vswitch-idl.c	/^ovsrec_port_set_qos(const struct ovsrec_port *row, const struct ovsrec_qos *qos)$/;"	f
ovsrec_port_set_statistics	.\lib\vswitch-idl.c	/^ovsrec_port_set_statistics(const struct ovsrec_port *row, char **key_statistics, const int64_t *value_statistics, size_t n_statistics)$/;"	f
ovsrec_port_set_status	.\lib\vswitch-idl.c	/^ovsrec_port_set_status(const struct ovsrec_port *row, const struct smap *smap)$/;"	f
ovsrec_port_set_tag	.\lib\vswitch-idl.c	/^ovsrec_port_set_tag(const struct ovsrec_port *row, const int64_t *tag, size_t n_tag)$/;"	f
ovsrec_port_set_trunks	.\lib\vswitch-idl.c	/^ovsrec_port_set_trunks(const struct ovsrec_port *row, const int64_t *trunks, size_t n_trunks)$/;"	f
ovsrec_port_set_vlan_mode	.\lib\vswitch-idl.c	/^ovsrec_port_set_vlan_mode(const struct ovsrec_port *row, const char *vlan_mode)$/;"	f
ovsrec_port_unparse_bond_active_slave	.\lib\vswitch-idl.c	/^ovsrec_port_unparse_bond_active_slave(struct ovsdb_idl_row *row OVS_UNUSED)$/;"	f	file:
ovsrec_port_unparse_bond_downdelay	.\lib\vswitch-idl.c	/^ovsrec_port_unparse_bond_downdelay(struct ovsdb_idl_row *row OVS_UNUSED)$/;"	f	file:
ovsrec_port_unparse_bond_fake_iface	.\lib\vswitch-idl.c	/^ovsrec_port_unparse_bond_fake_iface(struct ovsdb_idl_row *row OVS_UNUSED)$/;"	f	file:
ovsrec_port_unparse_bond_mode	.\lib\vswitch-idl.c	/^ovsrec_port_unparse_bond_mode(struct ovsdb_idl_row *row OVS_UNUSED)$/;"	f	file:
ovsrec_port_unparse_bond_updelay	.\lib\vswitch-idl.c	/^ovsrec_port_unparse_bond_updelay(struct ovsdb_idl_row *row OVS_UNUSED)$/;"	f	file:
ovsrec_port_unparse_external_ids	.\lib\vswitch-idl.c	/^ovsrec_port_unparse_external_ids(struct ovsdb_idl_row *row_)$/;"	f	file:
ovsrec_port_unparse_fake_bridge	.\lib\vswitch-idl.c	/^ovsrec_port_unparse_fake_bridge(struct ovsdb_idl_row *row OVS_UNUSED)$/;"	f	file:
ovsrec_port_unparse_interfaces	.\lib\vswitch-idl.c	/^ovsrec_port_unparse_interfaces(struct ovsdb_idl_row *row_)$/;"	f	file:
ovsrec_port_unparse_lacp	.\lib\vswitch-idl.c	/^ovsrec_port_unparse_lacp(struct ovsdb_idl_row *row OVS_UNUSED)$/;"	f	file:
ovsrec_port_unparse_mac	.\lib\vswitch-idl.c	/^ovsrec_port_unparse_mac(struct ovsdb_idl_row *row OVS_UNUSED)$/;"	f	file:
ovsrec_port_unparse_name	.\lib\vswitch-idl.c	/^ovsrec_port_unparse_name(struct ovsdb_idl_row *row OVS_UNUSED)$/;"	f	file:
ovsrec_port_unparse_other_config	.\lib\vswitch-idl.c	/^ovsrec_port_unparse_other_config(struct ovsdb_idl_row *row_)$/;"	f	file:
ovsrec_port_unparse_qos	.\lib\vswitch-idl.c	/^ovsrec_port_unparse_qos(struct ovsdb_idl_row *row OVS_UNUSED)$/;"	f	file:
ovsrec_port_unparse_statistics	.\lib\vswitch-idl.c	/^ovsrec_port_unparse_statistics(struct ovsdb_idl_row *row_)$/;"	f	file:
ovsrec_port_unparse_status	.\lib\vswitch-idl.c	/^ovsrec_port_unparse_status(struct ovsdb_idl_row *row_)$/;"	f	file:
ovsrec_port_unparse_tag	.\lib\vswitch-idl.c	/^ovsrec_port_unparse_tag(struct ovsdb_idl_row *row_)$/;"	f	file:
ovsrec_port_unparse_trunks	.\lib\vswitch-idl.c	/^ovsrec_port_unparse_trunks(struct ovsdb_idl_row *row_)$/;"	f	file:
ovsrec_port_unparse_vlan_mode	.\lib\vswitch-idl.c	/^ovsrec_port_unparse_vlan_mode(struct ovsdb_idl_row *row OVS_UNUSED)$/;"	f	file:
ovsrec_port_verify_bond_active_slave	.\lib\vswitch-idl.c	/^ovsrec_port_verify_bond_active_slave(const struct ovsrec_port *row)$/;"	f
ovsrec_port_verify_bond_downdelay	.\lib\vswitch-idl.c	/^ovsrec_port_verify_bond_downdelay(const struct ovsrec_port *row)$/;"	f
ovsrec_port_verify_bond_fake_iface	.\lib\vswitch-idl.c	/^ovsrec_port_verify_bond_fake_iface(const struct ovsrec_port *row)$/;"	f
ovsrec_port_verify_bond_mode	.\lib\vswitch-idl.c	/^ovsrec_port_verify_bond_mode(const struct ovsrec_port *row)$/;"	f
ovsrec_port_verify_bond_updelay	.\lib\vswitch-idl.c	/^ovsrec_port_verify_bond_updelay(const struct ovsrec_port *row)$/;"	f
ovsrec_port_verify_external_ids	.\lib\vswitch-idl.c	/^ovsrec_port_verify_external_ids(const struct ovsrec_port *row)$/;"	f
ovsrec_port_verify_fake_bridge	.\lib\vswitch-idl.c	/^ovsrec_port_verify_fake_bridge(const struct ovsrec_port *row)$/;"	f
ovsrec_port_verify_interfaces	.\lib\vswitch-idl.c	/^ovsrec_port_verify_interfaces(const struct ovsrec_port *row)$/;"	f
ovsrec_port_verify_lacp	.\lib\vswitch-idl.c	/^ovsrec_port_verify_lacp(const struct ovsrec_port *row)$/;"	f
ovsrec_port_verify_mac	.\lib\vswitch-idl.c	/^ovsrec_port_verify_mac(const struct ovsrec_port *row)$/;"	f
ovsrec_port_verify_name	.\lib\vswitch-idl.c	/^ovsrec_port_verify_name(const struct ovsrec_port *row)$/;"	f
ovsrec_port_verify_other_config	.\lib\vswitch-idl.c	/^ovsrec_port_verify_other_config(const struct ovsrec_port *row)$/;"	f
ovsrec_port_verify_qos	.\lib\vswitch-idl.c	/^ovsrec_port_verify_qos(const struct ovsrec_port *row)$/;"	f
ovsrec_port_verify_statistics	.\lib\vswitch-idl.c	/^ovsrec_port_verify_statistics(const struct ovsrec_port *row)$/;"	f
ovsrec_port_verify_status	.\lib\vswitch-idl.c	/^ovsrec_port_verify_status(const struct ovsrec_port *row)$/;"	f
ovsrec_port_verify_tag	.\lib\vswitch-idl.c	/^ovsrec_port_verify_tag(const struct ovsrec_port *row)$/;"	f
ovsrec_port_verify_trunks	.\lib\vswitch-idl.c	/^ovsrec_port_verify_trunks(const struct ovsrec_port *row)$/;"	f
ovsrec_port_verify_vlan_mode	.\lib\vswitch-idl.c	/^ovsrec_port_verify_vlan_mode(const struct ovsrec_port *row)$/;"	f
ovsrec_qos	.\lib\vswitch-idl.h	/^struct ovsrec_qos {$/;"	s
ovsrec_qos_cast	.\lib\vswitch-idl.c	/^ovsrec_qos_cast(const struct ovsdb_idl_row *row)$/;"	f	file:
ovsrec_qos_col_external_ids	.\lib\vswitch-idl.h	1536;"	d
ovsrec_qos_col_other_config	.\lib\vswitch-idl.h	1537;"	d
ovsrec_qos_col_queues	.\lib\vswitch-idl.h	1539;"	d
ovsrec_qos_col_type	.\lib\vswitch-idl.h	1538;"	d
ovsrec_qos_columns	.\lib\vswitch-idl.c	/^struct ovsdb_idl_column ovsrec_qos_columns[OVSREC_QOS_N_COLUMNS];$/;"	v	typeref:struct:ovsdb_idl_column
ovsrec_qos_columns_init	.\lib\vswitch-idl.c	/^ovsrec_qos_columns_init(void)$/;"	f	file:
ovsrec_qos_delete	.\lib\vswitch-idl.c	/^ovsrec_qos_delete(const struct ovsrec_qos *row)$/;"	f
ovsrec_qos_first	.\lib\vswitch-idl.c	/^ovsrec_qos_first(const struct ovsdb_idl *idl)$/;"	f
ovsrec_qos_get_external_ids	.\lib\vswitch-idl.c	/^ovsrec_qos_get_external_ids(const struct ovsrec_qos *row,$/;"	f
ovsrec_qos_get_for_uuid	.\lib\vswitch-idl.c	/^ovsrec_qos_get_for_uuid(const struct ovsdb_idl *idl, const struct uuid *uuid)$/;"	f
ovsrec_qos_get_other_config	.\lib\vswitch-idl.c	/^ovsrec_qos_get_other_config(const struct ovsrec_qos *row,$/;"	f
ovsrec_qos_get_queues	.\lib\vswitch-idl.c	/^ovsrec_qos_get_queues(const struct ovsrec_qos *row,$/;"	f
ovsrec_qos_get_type	.\lib\vswitch-idl.c	/^ovsrec_qos_get_type(const struct ovsrec_qos *row,$/;"	f
ovsrec_qos_init	.\lib\vswitch-idl.c	/^ovsrec_qos_init(struct ovsrec_qos *row)$/;"	f
ovsrec_qos_init__	.\lib\vswitch-idl.c	/^ovsrec_qos_init__(struct ovsdb_idl_row *row)$/;"	f	file:
ovsrec_qos_insert	.\lib\vswitch-idl.c	/^ovsrec_qos_insert(struct ovsdb_idl_txn *txn)$/;"	f
ovsrec_qos_next	.\lib\vswitch-idl.c	/^ovsrec_qos_next(const struct ovsrec_qos *row)$/;"	f
ovsrec_qos_parse_external_ids	.\lib\vswitch-idl.c	/^ovsrec_qos_parse_external_ids(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
ovsrec_qos_parse_other_config	.\lib\vswitch-idl.c	/^ovsrec_qos_parse_other_config(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
ovsrec_qos_parse_queues	.\lib\vswitch-idl.c	/^ovsrec_qos_parse_queues(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
ovsrec_qos_parse_type	.\lib\vswitch-idl.c	/^ovsrec_qos_parse_type(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
ovsrec_qos_set_external_ids	.\lib\vswitch-idl.c	/^ovsrec_qos_set_external_ids(const struct ovsrec_qos *row, const struct smap *smap)$/;"	f
ovsrec_qos_set_other_config	.\lib\vswitch-idl.c	/^ovsrec_qos_set_other_config(const struct ovsrec_qos *row, const struct smap *smap)$/;"	f
ovsrec_qos_set_queues	.\lib\vswitch-idl.c	/^ovsrec_qos_set_queues(const struct ovsrec_qos *row, const int64_t *key_queues, struct ovsrec_queue **value_queues, size_t n_queues)$/;"	f
ovsrec_qos_set_type	.\lib\vswitch-idl.c	/^ovsrec_qos_set_type(const struct ovsrec_qos *row, const char *type)$/;"	f
ovsrec_qos_unparse_external_ids	.\lib\vswitch-idl.c	/^ovsrec_qos_unparse_external_ids(struct ovsdb_idl_row *row_)$/;"	f	file:
ovsrec_qos_unparse_other_config	.\lib\vswitch-idl.c	/^ovsrec_qos_unparse_other_config(struct ovsdb_idl_row *row_)$/;"	f	file:
ovsrec_qos_unparse_queues	.\lib\vswitch-idl.c	/^ovsrec_qos_unparse_queues(struct ovsdb_idl_row *row_)$/;"	f	file:
ovsrec_qos_unparse_type	.\lib\vswitch-idl.c	/^ovsrec_qos_unparse_type(struct ovsdb_idl_row *row OVS_UNUSED)$/;"	f	file:
ovsrec_qos_verify_external_ids	.\lib\vswitch-idl.c	/^ovsrec_qos_verify_external_ids(const struct ovsrec_qos *row)$/;"	f
ovsrec_qos_verify_other_config	.\lib\vswitch-idl.c	/^ovsrec_qos_verify_other_config(const struct ovsrec_qos *row)$/;"	f
ovsrec_qos_verify_queues	.\lib\vswitch-idl.c	/^ovsrec_qos_verify_queues(const struct ovsrec_qos *row)$/;"	f
ovsrec_qos_verify_type	.\lib\vswitch-idl.c	/^ovsrec_qos_verify_type(const struct ovsrec_qos *row)$/;"	f
ovsrec_queue	.\lib\vswitch-idl.h	/^struct ovsrec_queue {$/;"	s
ovsrec_queue_cast	.\lib\vswitch-idl.c	/^ovsrec_queue_cast(const struct ovsdb_idl_row *row)$/;"	f	file:
ovsrec_queue_col_dscp	.\lib\vswitch-idl.h	1602;"	d
ovsrec_queue_col_external_ids	.\lib\vswitch-idl.h	1600;"	d
ovsrec_queue_col_other_config	.\lib\vswitch-idl.h	1601;"	d
ovsrec_queue_columns	.\lib\vswitch-idl.c	/^struct ovsdb_idl_column ovsrec_queue_columns[OVSREC_QUEUE_N_COLUMNS];$/;"	v	typeref:struct:ovsdb_idl_column
ovsrec_queue_columns_init	.\lib\vswitch-idl.c	/^ovsrec_queue_columns_init(void)$/;"	f	file:
ovsrec_queue_delete	.\lib\vswitch-idl.c	/^ovsrec_queue_delete(const struct ovsrec_queue *row)$/;"	f
ovsrec_queue_first	.\lib\vswitch-idl.c	/^ovsrec_queue_first(const struct ovsdb_idl *idl)$/;"	f
ovsrec_queue_get_dscp	.\lib\vswitch-idl.c	/^ovsrec_queue_get_dscp(const struct ovsrec_queue *row,$/;"	f
ovsrec_queue_get_external_ids	.\lib\vswitch-idl.c	/^ovsrec_queue_get_external_ids(const struct ovsrec_queue *row,$/;"	f
ovsrec_queue_get_for_uuid	.\lib\vswitch-idl.c	/^ovsrec_queue_get_for_uuid(const struct ovsdb_idl *idl, const struct uuid *uuid)$/;"	f
ovsrec_queue_get_other_config	.\lib\vswitch-idl.c	/^ovsrec_queue_get_other_config(const struct ovsrec_queue *row,$/;"	f
ovsrec_queue_init	.\lib\vswitch-idl.c	/^ovsrec_queue_init(struct ovsrec_queue *row)$/;"	f
ovsrec_queue_init__	.\lib\vswitch-idl.c	/^ovsrec_queue_init__(struct ovsdb_idl_row *row)$/;"	f	file:
ovsrec_queue_insert	.\lib\vswitch-idl.c	/^ovsrec_queue_insert(struct ovsdb_idl_txn *txn)$/;"	f
ovsrec_queue_next	.\lib\vswitch-idl.c	/^ovsrec_queue_next(const struct ovsrec_queue *row)$/;"	f
ovsrec_queue_parse_dscp	.\lib\vswitch-idl.c	/^ovsrec_queue_parse_dscp(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
ovsrec_queue_parse_external_ids	.\lib\vswitch-idl.c	/^ovsrec_queue_parse_external_ids(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
ovsrec_queue_parse_other_config	.\lib\vswitch-idl.c	/^ovsrec_queue_parse_other_config(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
ovsrec_queue_set_dscp	.\lib\vswitch-idl.c	/^ovsrec_queue_set_dscp(const struct ovsrec_queue *row, const int64_t *dscp, size_t n_dscp)$/;"	f
ovsrec_queue_set_external_ids	.\lib\vswitch-idl.c	/^ovsrec_queue_set_external_ids(const struct ovsrec_queue *row, const struct smap *smap)$/;"	f
ovsrec_queue_set_other_config	.\lib\vswitch-idl.c	/^ovsrec_queue_set_other_config(const struct ovsrec_queue *row, const struct smap *smap)$/;"	f
ovsrec_queue_unparse_dscp	.\lib\vswitch-idl.c	/^ovsrec_queue_unparse_dscp(struct ovsdb_idl_row *row_)$/;"	f	file:
ovsrec_queue_unparse_external_ids	.\lib\vswitch-idl.c	/^ovsrec_queue_unparse_external_ids(struct ovsdb_idl_row *row_)$/;"	f	file:
ovsrec_queue_unparse_other_config	.\lib\vswitch-idl.c	/^ovsrec_queue_unparse_other_config(struct ovsdb_idl_row *row_)$/;"	f	file:
ovsrec_queue_verify_dscp	.\lib\vswitch-idl.c	/^ovsrec_queue_verify_dscp(const struct ovsrec_queue *row)$/;"	f
ovsrec_queue_verify_external_ids	.\lib\vswitch-idl.c	/^ovsrec_queue_verify_external_ids(const struct ovsrec_queue *row)$/;"	f
ovsrec_queue_verify_other_config	.\lib\vswitch-idl.c	/^ovsrec_queue_verify_other_config(const struct ovsrec_queue *row)$/;"	f
ovsrec_sflow	.\lib\vswitch-idl.h	/^struct ovsrec_sflow {$/;"	s
ovsrec_sflow_cast	.\lib\vswitch-idl.c	/^ovsrec_sflow_cast(const struct ovsdb_idl_row *row)$/;"	f	file:
ovsrec_sflow_col_agent	.\lib\vswitch-idl.h	1750;"	d
ovsrec_sflow_col_external_ids	.\lib\vswitch-idl.h	1754;"	d
ovsrec_sflow_col_header	.\lib\vswitch-idl.h	1752;"	d
ovsrec_sflow_col_polling	.\lib\vswitch-idl.h	1753;"	d
ovsrec_sflow_col_sampling	.\lib\vswitch-idl.h	1751;"	d
ovsrec_sflow_col_targets	.\lib\vswitch-idl.h	1755;"	d
ovsrec_sflow_columns	.\lib\vswitch-idl.c	/^struct ovsdb_idl_column ovsrec_sflow_columns[OVSREC_SFLOW_N_COLUMNS];$/;"	v	typeref:struct:ovsdb_idl_column
ovsrec_sflow_columns_init	.\lib\vswitch-idl.c	/^ovsrec_sflow_columns_init(void)$/;"	f	file:
ovsrec_sflow_delete	.\lib\vswitch-idl.c	/^ovsrec_sflow_delete(const struct ovsrec_sflow *row)$/;"	f
ovsrec_sflow_first	.\lib\vswitch-idl.c	/^ovsrec_sflow_first(const struct ovsdb_idl *idl)$/;"	f
ovsrec_sflow_get_agent	.\lib\vswitch-idl.c	/^ovsrec_sflow_get_agent(const struct ovsrec_sflow *row,$/;"	f
ovsrec_sflow_get_external_ids	.\lib\vswitch-idl.c	/^ovsrec_sflow_get_external_ids(const struct ovsrec_sflow *row,$/;"	f
ovsrec_sflow_get_for_uuid	.\lib\vswitch-idl.c	/^ovsrec_sflow_get_for_uuid(const struct ovsdb_idl *idl, const struct uuid *uuid)$/;"	f
ovsrec_sflow_get_header	.\lib\vswitch-idl.c	/^ovsrec_sflow_get_header(const struct ovsrec_sflow *row,$/;"	f
ovsrec_sflow_get_polling	.\lib\vswitch-idl.c	/^ovsrec_sflow_get_polling(const struct ovsrec_sflow *row,$/;"	f
ovsrec_sflow_get_sampling	.\lib\vswitch-idl.c	/^ovsrec_sflow_get_sampling(const struct ovsrec_sflow *row,$/;"	f
ovsrec_sflow_get_targets	.\lib\vswitch-idl.c	/^ovsrec_sflow_get_targets(const struct ovsrec_sflow *row,$/;"	f
ovsrec_sflow_init	.\lib\vswitch-idl.c	/^ovsrec_sflow_init(struct ovsrec_sflow *row)$/;"	f
ovsrec_sflow_init__	.\lib\vswitch-idl.c	/^ovsrec_sflow_init__(struct ovsdb_idl_row *row)$/;"	f	file:
ovsrec_sflow_insert	.\lib\vswitch-idl.c	/^ovsrec_sflow_insert(struct ovsdb_idl_txn *txn)$/;"	f
ovsrec_sflow_next	.\lib\vswitch-idl.c	/^ovsrec_sflow_next(const struct ovsrec_sflow *row)$/;"	f
ovsrec_sflow_parse_agent	.\lib\vswitch-idl.c	/^ovsrec_sflow_parse_agent(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
ovsrec_sflow_parse_external_ids	.\lib\vswitch-idl.c	/^ovsrec_sflow_parse_external_ids(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
ovsrec_sflow_parse_header	.\lib\vswitch-idl.c	/^ovsrec_sflow_parse_header(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
ovsrec_sflow_parse_polling	.\lib\vswitch-idl.c	/^ovsrec_sflow_parse_polling(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
ovsrec_sflow_parse_sampling	.\lib\vswitch-idl.c	/^ovsrec_sflow_parse_sampling(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
ovsrec_sflow_parse_targets	.\lib\vswitch-idl.c	/^ovsrec_sflow_parse_targets(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
ovsrec_sflow_set_agent	.\lib\vswitch-idl.c	/^ovsrec_sflow_set_agent(const struct ovsrec_sflow *row, const char *agent)$/;"	f
ovsrec_sflow_set_external_ids	.\lib\vswitch-idl.c	/^ovsrec_sflow_set_external_ids(const struct ovsrec_sflow *row, const struct smap *smap)$/;"	f
ovsrec_sflow_set_header	.\lib\vswitch-idl.c	/^ovsrec_sflow_set_header(const struct ovsrec_sflow *row, const int64_t *header, size_t n_header)$/;"	f
ovsrec_sflow_set_polling	.\lib\vswitch-idl.c	/^ovsrec_sflow_set_polling(const struct ovsrec_sflow *row, const int64_t *polling, size_t n_polling)$/;"	f
ovsrec_sflow_set_sampling	.\lib\vswitch-idl.c	/^ovsrec_sflow_set_sampling(const struct ovsrec_sflow *row, const int64_t *sampling, size_t n_sampling)$/;"	f
ovsrec_sflow_set_targets	.\lib\vswitch-idl.c	/^ovsrec_sflow_set_targets(const struct ovsrec_sflow *row, char **targets, size_t n_targets)$/;"	f
ovsrec_sflow_unparse_agent	.\lib\vswitch-idl.c	/^ovsrec_sflow_unparse_agent(struct ovsdb_idl_row *row OVS_UNUSED)$/;"	f	file:
ovsrec_sflow_unparse_external_ids	.\lib\vswitch-idl.c	/^ovsrec_sflow_unparse_external_ids(struct ovsdb_idl_row *row_)$/;"	f	file:
ovsrec_sflow_unparse_header	.\lib\vswitch-idl.c	/^ovsrec_sflow_unparse_header(struct ovsdb_idl_row *row_)$/;"	f	file:
ovsrec_sflow_unparse_polling	.\lib\vswitch-idl.c	/^ovsrec_sflow_unparse_polling(struct ovsdb_idl_row *row_)$/;"	f	file:
ovsrec_sflow_unparse_sampling	.\lib\vswitch-idl.c	/^ovsrec_sflow_unparse_sampling(struct ovsdb_idl_row *row_)$/;"	f	file:
ovsrec_sflow_unparse_targets	.\lib\vswitch-idl.c	/^ovsrec_sflow_unparse_targets(struct ovsdb_idl_row *row_)$/;"	f	file:
ovsrec_sflow_verify_agent	.\lib\vswitch-idl.c	/^ovsrec_sflow_verify_agent(const struct ovsrec_sflow *row)$/;"	f
ovsrec_sflow_verify_external_ids	.\lib\vswitch-idl.c	/^ovsrec_sflow_verify_external_ids(const struct ovsrec_sflow *row)$/;"	f
ovsrec_sflow_verify_header	.\lib\vswitch-idl.c	/^ovsrec_sflow_verify_header(const struct ovsrec_sflow *row)$/;"	f
ovsrec_sflow_verify_polling	.\lib\vswitch-idl.c	/^ovsrec_sflow_verify_polling(const struct ovsrec_sflow *row)$/;"	f
ovsrec_sflow_verify_sampling	.\lib\vswitch-idl.c	/^ovsrec_sflow_verify_sampling(const struct ovsrec_sflow *row)$/;"	f
ovsrec_sflow_verify_targets	.\lib\vswitch-idl.c	/^ovsrec_sflow_verify_targets(const struct ovsrec_sflow *row)$/;"	f
ovsrec_ssl	.\lib\vswitch-idl.h	/^struct ovsrec_ssl {$/;"	s
ovsrec_ssl_cast	.\lib\vswitch-idl.c	/^ovsrec_ssl_cast(const struct ovsdb_idl_row *row)$/;"	f	file:
ovsrec_ssl_col_bootstrap_ca_cert	.\lib\vswitch-idl.h	1669;"	d
ovsrec_ssl_col_ca_cert	.\lib\vswitch-idl.h	1667;"	d
ovsrec_ssl_col_certificate	.\lib\vswitch-idl.h	1671;"	d
ovsrec_ssl_col_external_ids	.\lib\vswitch-idl.h	1670;"	d
ovsrec_ssl_col_private_key	.\lib\vswitch-idl.h	1668;"	d
ovsrec_ssl_columns	.\lib\vswitch-idl.c	/^struct ovsdb_idl_column ovsrec_ssl_columns[OVSREC_SSL_N_COLUMNS];$/;"	v	typeref:struct:ovsdb_idl_column
ovsrec_ssl_columns_init	.\lib\vswitch-idl.c	/^ovsrec_ssl_columns_init(void)$/;"	f	file:
ovsrec_ssl_delete	.\lib\vswitch-idl.c	/^ovsrec_ssl_delete(const struct ovsrec_ssl *row)$/;"	f
ovsrec_ssl_first	.\lib\vswitch-idl.c	/^ovsrec_ssl_first(const struct ovsdb_idl *idl)$/;"	f
ovsrec_ssl_get_bootstrap_ca_cert	.\lib\vswitch-idl.c	/^ovsrec_ssl_get_bootstrap_ca_cert(const struct ovsrec_ssl *row,$/;"	f
ovsrec_ssl_get_ca_cert	.\lib\vswitch-idl.c	/^ovsrec_ssl_get_ca_cert(const struct ovsrec_ssl *row,$/;"	f
ovsrec_ssl_get_certificate	.\lib\vswitch-idl.c	/^ovsrec_ssl_get_certificate(const struct ovsrec_ssl *row,$/;"	f
ovsrec_ssl_get_external_ids	.\lib\vswitch-idl.c	/^ovsrec_ssl_get_external_ids(const struct ovsrec_ssl *row,$/;"	f
ovsrec_ssl_get_for_uuid	.\lib\vswitch-idl.c	/^ovsrec_ssl_get_for_uuid(const struct ovsdb_idl *idl, const struct uuid *uuid)$/;"	f
ovsrec_ssl_get_private_key	.\lib\vswitch-idl.c	/^ovsrec_ssl_get_private_key(const struct ovsrec_ssl *row,$/;"	f
ovsrec_ssl_init	.\lib\vswitch-idl.c	/^ovsrec_ssl_init(struct ovsrec_ssl *row)$/;"	f
ovsrec_ssl_init__	.\lib\vswitch-idl.c	/^ovsrec_ssl_init__(struct ovsdb_idl_row *row)$/;"	f	file:
ovsrec_ssl_insert	.\lib\vswitch-idl.c	/^ovsrec_ssl_insert(struct ovsdb_idl_txn *txn)$/;"	f
ovsrec_ssl_next	.\lib\vswitch-idl.c	/^ovsrec_ssl_next(const struct ovsrec_ssl *row)$/;"	f
ovsrec_ssl_parse_bootstrap_ca_cert	.\lib\vswitch-idl.c	/^ovsrec_ssl_parse_bootstrap_ca_cert(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
ovsrec_ssl_parse_ca_cert	.\lib\vswitch-idl.c	/^ovsrec_ssl_parse_ca_cert(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
ovsrec_ssl_parse_certificate	.\lib\vswitch-idl.c	/^ovsrec_ssl_parse_certificate(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
ovsrec_ssl_parse_external_ids	.\lib\vswitch-idl.c	/^ovsrec_ssl_parse_external_ids(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
ovsrec_ssl_parse_private_key	.\lib\vswitch-idl.c	/^ovsrec_ssl_parse_private_key(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
ovsrec_ssl_set_bootstrap_ca_cert	.\lib\vswitch-idl.c	/^ovsrec_ssl_set_bootstrap_ca_cert(const struct ovsrec_ssl *row, bool bootstrap_ca_cert)$/;"	f
ovsrec_ssl_set_ca_cert	.\lib\vswitch-idl.c	/^ovsrec_ssl_set_ca_cert(const struct ovsrec_ssl *row, const char *ca_cert)$/;"	f
ovsrec_ssl_set_certificate	.\lib\vswitch-idl.c	/^ovsrec_ssl_set_certificate(const struct ovsrec_ssl *row, const char *certificate)$/;"	f
ovsrec_ssl_set_external_ids	.\lib\vswitch-idl.c	/^ovsrec_ssl_set_external_ids(const struct ovsrec_ssl *row, const struct smap *smap)$/;"	f
ovsrec_ssl_set_private_key	.\lib\vswitch-idl.c	/^ovsrec_ssl_set_private_key(const struct ovsrec_ssl *row, const char *private_key)$/;"	f
ovsrec_ssl_unparse_bootstrap_ca_cert	.\lib\vswitch-idl.c	/^ovsrec_ssl_unparse_bootstrap_ca_cert(struct ovsdb_idl_row *row OVS_UNUSED)$/;"	f	file:
ovsrec_ssl_unparse_ca_cert	.\lib\vswitch-idl.c	/^ovsrec_ssl_unparse_ca_cert(struct ovsdb_idl_row *row OVS_UNUSED)$/;"	f	file:
ovsrec_ssl_unparse_certificate	.\lib\vswitch-idl.c	/^ovsrec_ssl_unparse_certificate(struct ovsdb_idl_row *row OVS_UNUSED)$/;"	f	file:
ovsrec_ssl_unparse_external_ids	.\lib\vswitch-idl.c	/^ovsrec_ssl_unparse_external_ids(struct ovsdb_idl_row *row_)$/;"	f	file:
ovsrec_ssl_unparse_private_key	.\lib\vswitch-idl.c	/^ovsrec_ssl_unparse_private_key(struct ovsdb_idl_row *row OVS_UNUSED)$/;"	f	file:
ovsrec_ssl_verify_bootstrap_ca_cert	.\lib\vswitch-idl.c	/^ovsrec_ssl_verify_bootstrap_ca_cert(const struct ovsrec_ssl *row)$/;"	f
ovsrec_ssl_verify_ca_cert	.\lib\vswitch-idl.c	/^ovsrec_ssl_verify_ca_cert(const struct ovsrec_ssl *row)$/;"	f
ovsrec_ssl_verify_certificate	.\lib\vswitch-idl.c	/^ovsrec_ssl_verify_certificate(const struct ovsrec_ssl *row)$/;"	f
ovsrec_ssl_verify_external_ids	.\lib\vswitch-idl.c	/^ovsrec_ssl_verify_external_ids(const struct ovsrec_ssl *row)$/;"	f
ovsrec_ssl_verify_private_key	.\lib\vswitch-idl.c	/^ovsrec_ssl_verify_private_key(const struct ovsrec_ssl *row)$/;"	f
ovsrec_table_bridge	.\lib\vswitch-idl.h	1819;"	d
ovsrec_table_classes	.\lib\vswitch-idl.c	/^struct ovsdb_idl_table_class ovsrec_table_classes[OVSREC_N_TABLES] = {$/;"	v	typeref:struct:ovsdb_idl_table_class
ovsrec_table_controller	.\lib\vswitch-idl.h	1825;"	d
ovsrec_table_flow_sample_collector_set	.\lib\vswitch-idl.h	1822;"	d
ovsrec_table_flow_table	.\lib\vswitch-idl.h	1826;"	d
ovsrec_table_interface	.\lib\vswitch-idl.h	1831;"	d
ovsrec_table_ipfix	.\lib\vswitch-idl.h	1823;"	d
ovsrec_table_manager	.\lib\vswitch-idl.h	1829;"	d
ovsrec_table_mirror	.\lib\vswitch-idl.h	1830;"	d
ovsrec_table_netflow	.\lib\vswitch-idl.h	1832;"	d
ovsrec_table_open_vswitch	.\lib\vswitch-idl.h	1824;"	d
ovsrec_table_port	.\lib\vswitch-idl.h	1833;"	d
ovsrec_table_qos	.\lib\vswitch-idl.h	1820;"	d
ovsrec_table_queue	.\lib\vswitch-idl.h	1827;"	d
ovsrec_table_sflow	.\lib\vswitch-idl.h	1821;"	d
ovsrec_table_ssl	.\lib\vswitch-idl.h	1828;"	d
ovstest	.\python\ovstest\tests.py	/^import ovstest.util as util$/;"	i
ovstest_func	.\tests\ovstest.h	/^typedef void (*ovstest_func)(int argc, char *argv[]);$/;"	t
ovstest_pyfiles	.\python\automake.mk	/^ovstest_pyfiles = \\$/;"	m
ovstest_register	.\tests\ovstest.c	/^ovstest_register(const char *test_name, ovstest_func f)$/;"	f
ovsthread_aux	.\lib\ovs-thread.c	/^struct ovsthread_aux {$/;"	s	file:
ovsthread_getspecific	.\lib\ovs-thread.c	/^ovsthread_getspecific(ovsthread_key_t key)$/;"	f
ovsthread_id_self	.\lib\ovs-thread.h	/^ovsthread_id_self(void)$/;"	f
ovsthread_key	.\lib\ovs-thread.c	/^struct ovsthread_key {$/;"	s	file:
ovsthread_key_create	.\lib\ovs-thread.c	/^ovsthread_key_create(ovsthread_key_t *keyp, void (*destructor)(void *))$/;"	f
ovsthread_key_delete	.\lib\ovs-thread.c	/^ovsthread_key_delete(ovsthread_key_t key)$/;"	f
ovsthread_key_destruct__	.\lib\ovs-thread.c	/^ovsthread_key_destruct__(void *slots_)$/;"	f	file:
ovsthread_key_lookup__	.\lib\ovs-thread.c	/^ovsthread_key_lookup__(const struct ovsthread_key *key)$/;"	f	file:
ovsthread_key_slots	.\lib\ovs-thread.c	/^struct ovsthread_key_slots {$/;"	s	file:
ovsthread_key_t	.\lib\ovs-thread.h	/^typedef struct ovsthread_key *ovsthread_key_t;$/;"	t	typeref:struct:ovsthread_key
ovsthread_once	.\lib\ovs-thread.h	/^struct ovsthread_once {$/;"	s
ovsthread_once_done	.\lib\ovs-thread.c	/^ovsthread_once_done(struct ovsthread_once *once)$/;"	f
ovsthread_once_is_done__	.\lib\ovs-thread.h	/^ovsthread_once_is_done__(struct ovsthread_once *once)$/;"	f
ovsthread_once_start	.\lib\ovs-thread.h	/^ovsthread_once_start(struct ovsthread_once *once)$/;"	f
ovsthread_once_start__	.\lib\ovs-thread.c	/^ovsthread_once_start__(struct ovsthread_once *once)$/;"	f
ovsthread_setspecific	.\lib\ovs-thread.c	/^ovsthread_setspecific(ovsthread_key_t key, const void *value)$/;"	f
ovsthread_stats	.\lib\ovs-thread.h	/^struct ovsthread_stats {$/;"	s
ovsthread_stats_bucket_get	.\lib\ovs-thread.c	/^ovsthread_stats_bucket_get(struct ovsthread_stats *stats,$/;"	f
ovsthread_stats_destroy	.\lib\ovs-thread.c	/^ovsthread_stats_destroy(struct ovsthread_stats *stats)$/;"	f
ovsthread_stats_init	.\lib\ovs-thread.c	/^ovsthread_stats_init(struct ovsthread_stats *stats)$/;"	f
ovsthread_wrapper	.\lib\ovs-thread.c	/^ovsthread_wrapper(void *aux_)$/;"	f	file:
ovsuuid	.\python\ovs\db\data.py	/^import ovs.ovsuuid$/;"	i
ovsuuid	.\python\ovs\db\idl.py	/^import ovs.ovsuuid$/;"	i
ovsuuid	.\python\ovs\db\types.py	/^import ovs.ovsuuid$/;"	i
ovsuuid	.\tests\test-ovsdb.py	/^import ovs.ovsuuid$/;"	i
oxm12_ofb_match_fields	.\include\openflow\openflow-1.2.h	/^enum oxm12_ofb_match_fields {$/;"	g
oxm12_to_ofp11_flow_match_fields	.\lib\ofp-util.c	/^oxm12_to_ofp11_flow_match_fields(ovs_be64 oxm12)$/;"	f	file:
oxm_header	.\include\openflow\openflow-1.2.h	/^    ovs_be32 oxm_header;   \/* oxm_class = OFPXMC_EXPERIMENTER *\/$/;"	m	struct:ofp12_oxm_experimenter_header
oxm_header	.\lib\meta-flow.h	/^    uint32_t oxm_header;        \/* An OXM_* (or NXM_*) constant. *\/$/;"	m	struct:mf_field
oxm_match_from_string	.\lib\nx-match.c	/^oxm_match_from_string(const char *s, struct ofpbuf *b)$/;"	f
oxm_match_to_string	.\lib\nx-match.c	/^oxm_match_to_string(const struct ofpbuf *p, unsigned int match_len)$/;"	f
oxm_name	.\lib\meta-flow.h	/^    const char *oxm_name;       \/* The oxm_header constant's name *\/$/;"	m	struct:mf_field
oxm_pull_match	.\lib\nx-match.c	/^oxm_pull_match(struct ofpbuf *b, struct match *match)$/;"	f
oxm_pull_match__	.\lib\nx-match.c	/^oxm_pull_match__(struct ofpbuf *b, bool strict, struct match *match)$/;"	f	file:
oxm_pull_match_loose	.\lib\nx-match.c	/^oxm_pull_match_loose(struct ofpbuf *b, struct match *match)$/;"	f
oxm_put_match	.\lib\nx-match.c	/^oxm_put_match(struct ofpbuf *b, const struct match *match,$/;"	f
oxm_version	.\lib\meta-flow.h	/^    enum ofp_version oxm_version; \/* OpenFlow version that added oxm_header. *\/$/;"	m	struct:mf_field	typeref:enum:mf_field::ofp_version
p	.\lib\mac-learning.h	/^        void *p;$/;"	m	union:mac_entry::__anon52
p	.\lib\ovs-rcu.h	/^struct ovsrcu_pointer { ATOMIC(void *) p; };$/;"	m	struct:ovsrcu_pointer
p1	.\lib\ovs-thread.c	/^    void **p1[L1_SIZE];$/;"	m	struct:ovsthread_key_slots	file:
pack_ethaddr	.\tests\flowgen.pl	/^sub pack_ethaddr {$/;"	s
packet	.\lib\dpif.h	/^    struct ofpbuf *packet;          \/* Packet to execute. *\/$/;"	m	struct:dpif_execute	typeref:struct:dpif_execute::ofpbuf
packet	.\lib\dpif.h	/^    struct ofpbuf packet;       \/* Packet data. *\/$/;"	m	struct:dpif_upcall	typeref:struct:dpif_upcall::ofpbuf
packet	.\lib\ofp-util.h	/^    const void *packet;         \/* Packet data, if buffer_id == UINT32_MAX. *\/$/;"	m	struct:ofputil_packet_out
packet	.\lib\ofp-util.h	/^    const void *packet;$/;"	m	struct:ofputil_packet_in
packet	.\ofproto\netflow.c	/^    struct ofpbuf packet;         \/* NetFlow packet being accumulated. *\/$/;"	m	struct:netflow	typeref:struct:netflow::ofpbuf	file:
packet	.\ofproto\ofproto-dpif-xlate.h	/^    const struct ofpbuf *packet;$/;"	m	struct:xlate_in	typeref:struct:xlate_in::ofpbuf
packet	.\ofproto\ofproto.c	/^    struct ofpbuf *packet;      \/* Owns the packet. *\/$/;"	m	struct:rule_execute	typeref:struct:rule_execute::ofpbuf	file:
packet	.\ofproto\pktbuf.c	/^struct packet {$/;"	s	file:
packetSeqNo	.\lib\sflow_api.h	/^    u_int32_t packetSeqNo;$/;"	m	struct:_SFLSampleCollector
packet_band_count	.\include\openflow\openflow-1.3.h	/^    ovs_be64    packet_band_count;      \/* Number of packets in band. *\/$/;"	m	struct:ofp13_action_self_learning::ofp13_meter_band_stats
packet_count	.\datapath\flow.h	/^	u64 packet_count;		\/* Number of packets matched. *\/$/;"	m	struct:flow_stats
packet_count	.\include\openflow\nicira-ext.h	/^    ovs_be64 packet_count;    \/* Number of packets, UINT64_MAX if unknown. *\/$/;"	m	struct:nx_flow_stats
packet_count	.\include\openflow\nicira-ext.h	/^    ovs_be64 packet_count;$/;"	m	struct:nx_flow_removed
packet_count	.\include\openflow\openflow-1.0.h	/^    ovs_32aligned_be64 packet_count; \/* Number of packets in flow. *\/$/;"	m	struct:ofp10_flow_stats
packet_count	.\include\openflow\openflow-1.0.h	/^    ovs_be64 packet_count;$/;"	m	struct:ofp10_flow_removed
packet_count	.\include\openflow\openflow-1.1.h	/^    ovs_be64 packet_count;     \/* Number of packets in flow. *\/$/;"	m	struct:ofp11_flow_stats
packet_count	.\include\openflow\openflow-1.1.h	/^    ovs_be64 packet_count;     \/* Number of packets processed by group. *\/$/;"	m	struct:ofp11_group_stats
packet_count	.\include\openflow\openflow-1.1.h	/^    ovs_be64 packet_count;   \/* Number of packets processed by bucket. *\/$/;"	m	struct:ofp11_bucket_counter
packet_count	.\include\openflow\openflow-1.1.h	/^    ovs_be64 packet_count;$/;"	m	struct:ofp11_flow_removed
packet_count	.\include\openflow\openflow-1.2.h	/^    ovs_be64 packet_count;$/;"	m	struct:ofp12_flow_removed
packet_count	.\include\openflow\openflow-common.h	/^    ovs_32aligned_be64 packet_count; \/* Number of packets in flows. *\/$/;"	m	struct:ofp_aggregate_stats_reply
packet_count	.\lib\netflow.h	/^    ovs_be32 packet_count;         \/* Number of packets. *\/$/;"	m	struct:netflow_v5_record
packet_count	.\lib\ofp-util.h	/^    uint64_t packet_count;      \/* Packet count, UINT64_MAX if unknown. *\/$/;"	m	struct:ofputil_aggregate_stats
packet_count	.\lib\ofp-util.h	/^    uint64_t packet_count;      \/* Packet count, UINT64_MAX if unknown. *\/$/;"	m	struct:ofputil_flow_removed
packet_count	.\lib\ofp-util.h	/^    uint64_t packet_count;      \/* Packet count, UINT64_MAX if unknown. *\/$/;"	m	struct:ofputil_flow_stats
packet_count	.\lib\ofp-util.h	/^    uint64_t packet_count;      \/* Packet count, UINT64_MAX if unknown. *\/$/;"	m	struct:ofputil_group_stats
packet_count	.\lib\ofp-util.h	/^    uint64_t packet_count;   \/* Number of packets processed by bucket. *\/$/;"	m	struct:bucket_counter
packet_count	.\lib\ofp-util.h	/^    uint64_t packet_count;$/;"	m	struct:ofputil_meter_band_stats
packet_count	.\ofproto\netflow.c	/^    uint64_t packet_count;        \/* Packets from subrules. *\/$/;"	m	struct:netflow_flow	file:
packet_count	.\ofproto\ofproto-dpif-mirror.c	/^    int64_t packet_count;       \/* Number of packets sent. *\/$/;"	m	struct:mirror	file:
packet_delta_count	.\ofproto\ofproto-dpif-ipfix.c	/^    uint64_t packet_delta_count;$/;"	m	struct:ipfix_flow_cache_entry	file:
packet_format_tcp_flags	.\lib\packets.c	/^packet_format_tcp_flags(struct ds *s, uint16_t tcp_flags)$/;"	f
packet_in_count	.\include\openflow\openflow-1.3.h	/^    ovs_be64  packet_in_count;   \/* Number of packets in input. *\/$/;"	m	struct:ofp13_action_self_learning::ofp13_meter_stats
packet_in_count	.\lib\ofp-util.h	/^    uint64_t packet_in_count;$/;"	m	struct:ofputil_meter_stats
packet_in_counter	.\ofproto\connmgr.c	/^    struct rconn_packet_counter *packet_in_counter; \/* # queued on 'rconn'. *\/$/;"	m	struct:ofconn	typeref:struct:ofconn::rconn_packet_counter	file:
packet_in_format	.\ofproto\connmgr.c	/^    enum nx_packet_in_format packet_in_format; \/* OFPT_PACKET_IN format. *\/$/;"	m	struct:ofconn	typeref:enum:ofconn::nx_packet_in_format	file:
packet_in_mask	.\include\openflow\nicira-ext.h	/^    ovs_be32 packet_in_mask[2];    \/* Bitmasks of OFPR_* values. *\/$/;"	m	struct:nx_async_config
packet_in_mask	.\include\openflow\openflow-1.3.h	/^    ovs_be32 packet_in_mask[2];   \/* Bitmasks of OFPR_* values. *\/$/;"	m	struct:ofp13_action_self_learning::ofp13_async_config
packet_in_overflow	.\ofproto\ofproto-dpif.c	/^COVERAGE_DEFINE(packet_in_overflow);$/;"	v
packet_len	.\lib\ofp-util.h	/^    size_t packet_len;          \/* Length of packet data in bytes. *\/$/;"	m	struct:ofputil_packet_out
packet_len	.\lib\ofp-util.h	/^    size_t packet_len;          \/* Number of bytes in 'packet'. *\/$/;"	m	struct:ofputil_packet_in
packet_length	.\datapath\vport-netdev.c	/^static unsigned int packet_length(const struct sk_buff *skb)$/;"	f	file:
packet_out	.\ofproto\ofproto-dpif.c	/^packet_out(struct ofproto *ofproto_, struct ofpbuf *packet,$/;"	f	file:
packet_out	.\ofproto\ofproto-provider.h	/^    enum ofperr (*packet_out)(struct ofproto *ofproto, struct ofpbuf *packet,$/;"	m	struct:ofproto_class	typeref:enum:ofproto_class::packet_out
packet_policy	.\datapath\datapath.c	/^static const struct nla_policy packet_policy[OVS_PACKET_ATTR_MAX + 1] = {$/;"	v	typeref:struct:nla_policy	file:
packet_rh_present	.\lib\packets.c	/^packet_rh_present(struct ofpbuf *packet)$/;"	f	file:
packet_set_ipv4	.\lib\packets.c	/^packet_set_ipv4(struct ofpbuf *packet, ovs_be32 src, ovs_be32 dst,$/;"	f
packet_set_ipv4_addr	.\lib\packets.c	/^packet_set_ipv4_addr(struct ofpbuf *packet,$/;"	f	file:
packet_set_ipv6	.\lib\packets.c	/^packet_set_ipv6(struct ofpbuf *packet, uint8_t proto, const ovs_be32 src[4],$/;"	f
packet_set_ipv6_addr	.\lib\packets.c	/^packet_set_ipv6_addr(struct ofpbuf *packet, uint8_t proto,$/;"	f	file:
packet_set_ipv6_flow_label	.\lib\packets.c	/^packet_set_ipv6_flow_label(ovs_16aligned_be32 *flow_label, ovs_be32 flow_key)$/;"	f	file:
packet_set_ipv6_tc	.\lib\packets.c	/^packet_set_ipv6_tc(ovs_16aligned_be32 *flow_label, uint8_t tc)$/;"	f	file:
packet_set_port	.\lib\packets.c	/^packet_set_port(ovs_be16 *port, ovs_be16 new_port, ovs_be16 *csum)$/;"	f	file:
packet_set_sctp_port	.\lib\packets.c	/^packet_set_sctp_port(struct ofpbuf *packet, ovs_be16 src, ovs_be16 dst)$/;"	f
packet_set_tcp_port	.\lib\packets.c	/^packet_set_tcp_port(struct ofpbuf *packet, ovs_be16 src, ovs_be16 dst)$/;"	f
packet_set_udp_port	.\lib\packets.c	/^packet_set_udp_port(struct ofpbuf *packet, ovs_be16 src, ovs_be16 dst)$/;"	f
packet_tcp_flag_to_string	.\lib\packets.c	/^packet_tcp_flag_to_string(uint32_t flag)$/;"	f
packet_update_csum128	.\lib\packets.c	/^packet_update_csum128(struct ofpbuf *packet, uint8_t proto,$/;"	f	file:
packets	.\ofproto\pinsched.c	/^    struct list packets;        \/* Contains "struct ofpbuf"s. *\/$/;"	m	struct:pinqueue	typeref:struct:pinqueue::list	file:
packets	.\ofproto\pktbuf.c	/^    struct packet packets[PKTBUF_CNT];$/;"	m	struct:pktbuf	typeref:struct:pktbuf::packet	file:
packets_from_local	.\lib\vtep-idl.h	/^	int64_t packets_from_local;$/;"	m	struct:vteprec_logical_binding_stats
packets_received	.\lib\rconn.c	/^    unsigned int packets_received;$/;"	m	struct:rconn	file:
packets_sent	.\lib\rconn.c	/^    unsigned int packets_sent;$/;"	m	struct:rconn	file:
packets_to_local	.\lib\vtep-idl.h	/^	int64_t packets_to_local;$/;"	m	struct:vteprec_logical_binding_stats
pad	.\include\openflow\nicira-ext.h	/^    ovs_be16 pad;               \/* Must be zero. *\/$/;"	m	struct:nx_action_fin_timeout
pad	.\include\openflow\nicira-ext.h	/^    uint8_t  pad[4];$/;"	m	struct:nx_action_pop_mpls
pad	.\include\openflow\nicira-ext.h	/^    uint8_t  pad[4];$/;"	m	struct:nx_action_push_mpls
pad	.\include\openflow\nicira-ext.h	/^    uint8_t  pad[5];$/;"	m	struct:nx_action_mpls_tc
pad	.\include\openflow\nicira-ext.h	/^    uint8_t  pad[5];$/;"	m	struct:nx_action_mpls_ttl
pad	.\include\openflow\nicira-ext.h	/^    uint8_t pad;                \/* Must be zero. *\/$/;"	m	struct:nx_action_learn
pad	.\include\openflow\nicira-ext.h	/^    uint8_t pad;                \/* Reserved, currently zeroed. *\/$/;"	m	struct:nx_flow_update_full
pad	.\include\openflow\nicira-ext.h	/^    uint8_t pad;$/;"	m	struct:nx_flow_stats
pad	.\include\openflow\nicira-ext.h	/^    uint8_t pad[2];$/;"	m	struct:nx_action_set_queue
pad	.\include\openflow\nicira-ext.h	/^    uint8_t pad[2];$/;"	m	struct:nx_action_set_tunnel
pad	.\include\openflow\nicira-ext.h	/^    uint8_t pad[3];           \/* Align to 64 bits. *\/$/;"	m	struct:nx_aggregate_stats_request
pad	.\include\openflow\nicira-ext.h	/^    uint8_t pad[3];           \/* Align to 64 bits. *\/$/;"	m	struct:nx_flow_stats_request
pad	.\include\openflow\nicira-ext.h	/^    uint8_t pad[3];$/;"	m	struct:nx_action_resubmit
pad	.\include\openflow\nicira-ext.h	/^    uint8_t pad[4];             \/* Align to 64-bits. *\/$/;"	m	struct:nicira10_stats_msg
pad	.\include\openflow\nicira-ext.h	/^    uint8_t pad[6];               \/* Align to 64-bits. *\/$/;"	m	struct:nx_flow_mod
pad	.\include\openflow\nicira-ext.h	/^    uint8_t pad[6];           \/* Align to 64-bits. *\/$/;"	m	struct:nx_packet_in
pad	.\include\openflow\nicira-ext.h	/^    uint8_t pad[6];$/;"	m	struct:nx_action_header
pad	.\include\openflow\nicira-ext.h	/^    uint8_t pad[6];$/;"	m	struct:nx_action_pop_queue
pad	.\include\openflow\nicira-ext.h	/^    uint8_t pad[6];$/;"	m	struct:nx_action_set_tunnel64
pad	.\include\openflow\nicira-ext.h	/^    uint8_t pad[7];$/;"	m	struct:nx_flow_mod_table_id
pad	.\include\openflow\openflow-1.0.h	/^    uint8_t pad;              \/* Align to 32 bits. *\/$/;"	m	struct:ofp10_flow_stats_request
pad	.\include\openflow\openflow-1.0.h	/^    uint8_t pad;$/;"	m	struct:ofp10_flow_stats
pad	.\include\openflow\openflow-1.0.h	/^    uint8_t pad;$/;"	m	struct:ofp10_packet_in
pad	.\include\openflow\openflow-1.0.h	/^    uint8_t pad[1];           \/* Align to 32-bits. *\/$/;"	m	struct:ofp10_flow_removed
pad	.\include\openflow\openflow-1.0.h	/^    uint8_t pad[2];             \/* 64-bit alignment. *\/$/;"	m	struct:ofp10_packet_queue
pad	.\include\openflow\openflow-1.0.h	/^    uint8_t pad[2];          \/* Align to 32-bits. *\/$/;"	m	struct:ofp10_queue_stats
pad	.\include\openflow\openflow-1.0.h	/^    uint8_t pad[2];          \/* Align to 32-bits. *\/$/;"	m	struct:ofp10_queue_stats_request
pad	.\include\openflow\openflow-1.0.h	/^    uint8_t pad[2];$/;"	m	struct:ofp10_queue_get_config_request
pad	.\include\openflow\openflow-1.0.h	/^    uint8_t pad[3];          \/* Align to 32-bits. *\/$/;"	m	struct:ofp10_table_stats
pad	.\include\openflow\openflow-1.0.h	/^    uint8_t pad[4];         \/* Pad to 64-bits. *\/$/;"	m	struct:ofp10_port_mod
pad	.\include\openflow\openflow-1.0.h	/^    uint8_t pad[6];           \/* Pad for 64-bit alignment. *\/$/;"	m	struct:ofp10_action_enqueue
pad	.\include\openflow\openflow-1.0.h	/^    uint8_t pad[6];          \/* Align to 64-bits. *\/$/;"	m	struct:ofp10_port_stats
pad	.\include\openflow\openflow-1.0.h	/^    uint8_t pad[6];$/;"	m	struct:ofp10_port_stats_request
pad	.\include\openflow\openflow-1.0.h	/^    uint8_t pad[6];$/;"	m	struct:ofp10_queue_get_config_reply
pad	.\include\openflow\openflow-1.1.h	/^    uint8_t pad;                  \/* Pad to 64 bits. *\/$/;"	m	struct:ofp11_group_mod
pad	.\include\openflow\openflow-1.1.h	/^    uint8_t pad;                \/* Pad to 64 bits. *\/$/;"	m	struct:ofp11_group_desc_stats
pad	.\include\openflow\openflow-1.1.h	/^    uint8_t pad;$/;"	m	struct:ofp11_flow_stats
pad	.\include\openflow\openflow-1.1.h	/^    uint8_t pad[2];            \/* Align to 64 bits. *\/$/;"	m	struct:ofp11_group_stats
pad	.\include\openflow\openflow-1.1.h	/^    uint8_t pad[2];$/;"	m	struct:ofp11_action_pop_mpls
pad	.\include\openflow\openflow-1.1.h	/^    uint8_t pad[2];$/;"	m	struct:ofp11_action_push
pad	.\include\openflow\openflow-1.1.h	/^    uint8_t pad[2];$/;"	m	struct:ofp11_flow_mod
pad	.\include\openflow\openflow-1.1.h	/^    uint8_t pad[3];                \/* Pad to 64 bits. *\/$/;"	m	struct:ofp11_instruction_goto_table
pad	.\include\openflow\openflow-1.1.h	/^    uint8_t pad[3];           \/* Align to 64 bits. *\/$/;"	m	struct:ofp11_flow_stats_request
pad	.\include\openflow\openflow-1.1.h	/^    uint8_t pad[3];         \/* Pad to 32 bits *\/$/;"	m	struct:ofp11_table_mod
pad	.\include\openflow\openflow-1.1.h	/^    uint8_t pad[3];$/;"	m	struct:ofp11_action_mpls_tc
pad	.\include\openflow\openflow-1.1.h	/^    uint8_t pad[3];$/;"	m	struct:ofp11_action_mpls_ttl
pad	.\include\openflow\openflow-1.1.h	/^    uint8_t pad[3];$/;"	m	struct:ofp11_action_nw_ecn
pad	.\include\openflow\openflow-1.1.h	/^    uint8_t pad[3];$/;"	m	struct:ofp11_action_nw_ttl
pad	.\include\openflow\openflow-1.1.h	/^    uint8_t pad[4];             \/* Align to 64-bits *\/$/;"	m	struct:ofp11_instruction
pad	.\include\openflow\openflow-1.1.h	/^    uint8_t pad[4];             \/* Align to 64-bits *\/$/;"	m	struct:ofp11_instruction_actions
pad	.\include\openflow\openflow-1.1.h	/^    uint8_t pad[4];             \/* Align to 64-bits *\/$/;"	m	struct:ofp11_instruction_write_metadata
pad	.\include\openflow\openflow-1.1.h	/^    uint8_t pad[4];            \/* Align to 64 bits. *\/$/;"	m	struct:ofp11_group_stats_request
pad	.\include\openflow\openflow-1.1.h	/^    uint8_t pad[4];           \/* Align to 64-bits. *\/$/;"	m	struct:ofp11_port_stats
pad	.\include\openflow\openflow-1.1.h	/^    uint8_t pad[4];$/;"	m	struct:ofp11_bucket
pad	.\include\openflow\openflow-1.1.h	/^    uint8_t pad[4];$/;"	m	struct:ofp11_port
pad	.\include\openflow\openflow-1.1.h	/^    uint8_t pad[4];$/;"	m	struct:ofp11_port_mod
pad	.\include\openflow\openflow-1.1.h	/^    uint8_t pad[4];$/;"	m	struct:ofp11_port_stats_request
pad	.\include\openflow\openflow-1.1.h	/^    uint8_t pad[4];$/;"	m	struct:ofp11_queue_get_config_reply
pad	.\include\openflow\openflow-1.1.h	/^    uint8_t pad[4];$/;"	m	struct:ofp11_queue_get_config_request
pad	.\include\openflow\openflow-1.1.h	/^    uint8_t pad[4];$/;"	m	struct:ofp11_stats_msg
pad	.\include\openflow\openflow-1.1.h	/^    uint8_t pad[6];                   \/* Pad to 64 bits. *\/$/;"	m	struct:ofp11_action_output
pad	.\include\openflow\openflow-1.1.h	/^    uint8_t pad[6];$/;"	m	struct:ofp11_packet_out
pad	.\include\openflow\openflow-1.1.h	/^    uint8_t pad[7];          \/* Align to 64-bits. *\/$/;"	m	struct:ofp11_table_stats
pad	.\include\openflow\openflow-1.2.h	/^    uint8_t pad[4];           \/* Align to 64 bits. *\/$/;"	m	struct:ofp12_role_request
pad	.\include\openflow\openflow-1.2.h	/^    uint8_t pad[6];        \/* 64-bit alignment. *\/$/;"	m	struct:ofp12_packet_queue
pad	.\include\openflow\openflow-1.2.h	/^    uint8_t pad[7];          \/* Align to 64-bits. *\/$/;"	m	struct:ofp12_table_stats
pad	.\include\openflow\openflow-1.3.h	/^    uint8_t     pad[3];$/;"	m	struct:ofp13_action_self_learning::ofp13_meter_band_dscp_remark
pad	.\include\openflow\openflow-1.3.h	/^    uint8_t     pad[4];$/;"	m	struct:ofp13_action_self_learning::ofp13_meter_band_drop
pad	.\include\openflow\openflow-1.3.h	/^    uint8_t    pad[2];$/;"	m	struct:ofp13_action_self_learning::ofp13_meter_features
pad	.\include\openflow\openflow-1.3.h	/^    uint8_t   pad[6];$/;"	m	struct:ofp13_action_self_learning::ofp13_meter_stats
pad	.\include\openflow\openflow-1.3.h	/^    uint8_t  pad[3];        \/* Align to 32-bits. *\/$/;"	m	struct:ofp13_action_self_learning::ofp13_table_stats
pad	.\include\openflow\openflow-1.3.h	/^    uint8_t pad[4];     \/* Align to 64 bits. *\/$/;"	m	struct:ofp13_action_self_learning::ofp13_meter_multipart_request
pad	.\include\openflow\openflow-1.3.h	/^    uint8_t pad[4];$/;"	m	struct:ofp13_action_self_learning
pad	.\include\openflow\openflow-1.3.h	/^    uint8_t pad[5];           \/* Align to 64-bits. *\/$/;"	m	struct:ofp13_action_self_learning::ofp13_table_features
pad	.\include\openflow\openflow-1.4.h	/^    uint8_t          pad[4];  \/* Align to 64 bits. *\/$/;"	m	struct:ofp14_port_desc_prop_ethernet
pad	.\include\openflow\openflow-1.4.h	/^    uint8_t          pad[4];  \/* Align to 64 bits. *\/$/;"	m	struct:ofp14_port_stats_prop_ethernet
pad	.\include\openflow\openflow-1.4.h	/^    uint8_t  pad[3];            \/* Align to 64 bits. *\/$/;"	m	struct:ofp14_role_status
pad	.\include\openflow\openflow-1.4.h	/^    uint8_t pad[1];          \/* Align to 64 bits. *\/$/;"	m	struct:ofp14_table_mod_prop_vacancy
pad	.\include\openflow\openflow-1.4.h	/^    uint8_t pad[2];          \/* Align to 64 bits. *\/$/;"	m	struct:ofp14_port_stats
pad	.\include\openflow\openflow-1.4.h	/^    uint8_t pad[2];$/;"	m	struct:ofp14_port
pad	.\include\openflow\openflow-1.4.h	/^    uint8_t pad[3];         \/* Pad to 32 bits *\/$/;"	m	struct:ofp14_table_mod
pad	.\include\openflow\openflow-1.4.h	/^    uint8_t pad[4];$/;"	m	struct:ofp14_port_mod
pad	.\include\openflow\openflow-1.4.h	/^    uint8_t pad[6];          \/* Align to 64 bits. *\/$/;"	m	struct:ofp14_queue_stats
pad	.\include\openflow\openflow-common.h	/^    uint8_t pad[2];         \/* Align to 64-bits. *\/$/;"	m	struct:ofp_switch_features
pad	.\include\openflow\openflow-common.h	/^    uint8_t pad[2];$/;"	m	struct:ofp_action_tp_port
pad	.\include\openflow\openflow-common.h	/^    uint8_t pad[2];$/;"	m	struct:ofp_action_vlan_vid
pad	.\include\openflow\openflow-common.h	/^    uint8_t pad[3];$/;"	m	struct:ofp_action_nw_tos
pad	.\include\openflow\openflow-common.h	/^    uint8_t pad[3];$/;"	m	struct:ofp_action_vlan_pcp
pad	.\include\openflow\openflow-common.h	/^    uint8_t pad[4];           \/* Align to 64 bits. *\/$/;"	m	struct:ofp_aggregate_stats_reply
pad	.\include\openflow\openflow-common.h	/^    uint8_t pad[4];    \/* 64-bit alignemnt. *\/$/;"	m	struct:ofp_queue_prop_header
pad	.\include\openflow\openflow-common.h	/^    uint8_t pad[4];$/;"	m	struct:ofp_action_header
pad	.\include\openflow\openflow-common.h	/^    uint8_t pad[6];       \/* 64-bit alignment *\/$/;"	m	struct:ofp_queue_prop_rate
pad	.\include\openflow\openflow-common.h	/^    uint8_t pad[6];$/;"	m	struct:ofp_action_dl_addr
pad	.\include\openflow\openflow-common.h	/^    uint8_t pad[7];          \/* Align to 64-bits. *\/$/;"	m	struct:ofp_port_status
pad	.\lib\flow.h	/^    ovs_be16 pad;               \/* Padding. *\/$/;"	m	struct:flow
pad	.\lib\netflow.h	/^    uint8_t  pad[2];$/;"	m	struct:netflow_v5_record
pad	.\lib\ofp-actions.h	/^    uint8_t pad[PAD_SIZE(sizeof(struct ofpact), OFPACT_ALIGNTO)];$/;"	m	struct:ofpact_nest
pad0	.\include\linux\openvswitch.h	/^	__u32 pad0;		 \/* Pad for future expension. *\/$/;"	m	struct:ovs_dp_megaflow_stats
pad0	.\include\openflow\nicira-ext.h	/^    ovs_be16 pad0;$/;"	m	struct:nx_action_multipath
pad1	.\include\linux\openvswitch.h	/^	__u64 pad1;		 \/* Pad for future expension. *\/$/;"	m	struct:ovs_dp_megaflow_stats
pad1	.\include\openflow\nicira-ext.h	/^    ovs_be16 pad1;$/;"	m	struct:nx_action_multipath
pad1	.\include\openflow\openflow-1.0.h	/^    uint8_t pad1[1];           \/* Align to 64-bits. *\/$/;"	m	struct:ofp10_match
pad1	.\include\openflow\openflow-1.1.h	/^    uint8_t pad1[1];           \/* Align to 32-bits *\/$/;"	m	struct:ofp11_match
pad1	.\lib\netflow.h	/^    uint8_t  pad1;$/;"	m	struct:netflow_v5_record
pad2	.\include\linux\openvswitch.h	/^	__u64 pad2;		 \/* Pad for future expension. *\/$/;"	m	struct:ovs_dp_megaflow_stats
pad2	.\include\openflow\openflow-1.0.h	/^    uint8_t pad2[2];           \/* Align to 64-bits. *\/$/;"	m	struct:ofp10_match
pad2	.\include\openflow\openflow-1.0.h	/^    uint8_t pad2[2];          \/* Align to 64-bits. *\/$/;"	m	struct:ofp10_flow_removed
pad2	.\include\openflow\openflow-1.0.h	/^    uint8_t pad2[6];          \/* Align to 64 bits. *\/$/;"	m	struct:ofp10_flow_stats
pad2	.\include\openflow\openflow-1.1.h	/^    uint8_t  pad2[4];          \/* Align to 64-bits. *\/$/;"	m	struct:ofp11_flow_stats
pad2	.\include\openflow\openflow-1.1.h	/^    uint8_t pad2[2];                  \/* Align to 64 bits. *\/$/;"	m	struct:ofp11_port
pad2	.\include\openflow\openflow-1.1.h	/^    uint8_t pad2[2];          \/* Align to 64-bits. *\/$/;"	m	struct:ofp11_flow_removed
pad2	.\include\openflow\openflow-1.1.h	/^    uint8_t pad2[2];        \/* Pad to 64 bits. *\/$/;"	m	struct:ofp11_port_mod
pad2	.\include\openflow\openflow-1.1.h	/^    uint8_t pad2[3];           \/* Align to 64-bits *\/$/;"	m	struct:ofp11_match
pad2	.\include\openflow\openflow-1.1.h	/^    uint8_t pad2[4];           \/* Align to 64 bits. *\/$/;"	m	struct:ofp11_group_stats
pad2	.\include\openflow\openflow-1.1.h	/^    uint8_t pad2[4];          \/* Align to 64 bits. *\/$/;"	m	struct:ofp11_flow_stats_request
pad2	.\include\openflow\openflow-1.4.h	/^    uint8_t pad2[2];                  \/* Align to 64 bits. *\/$/;"	m	struct:ofp14_port
pad2	.\include\openflow\openflow-1.4.h	/^    uint8_t pad2[2];$/;"	m	struct:ofp14_port_mod
pad3	.\include\openflow\openflow-1.1.h	/^    uint8_t pad3[4];        \/* Pad to 64 bits. *\/$/;"	m	struct:ofp11_port_mod
padding	.\datapath\linux\compat\include\linux\flex_array.h	/^		char padding[FLEX_ARRAY_BASE_SIZE];$/;"	m	union:flex_array::__anon12
pairs	.\ofproto\ofproto.h	/^    } pairs;$/;"	m	struct:ofproto_controller_info	typeref:struct:ofproto_controller_info::__anon148
parallel_ops	.\datapath\linux\compat\include\net\genetlink.h	/^	bool                    parallel_ops;$/;"	m	struct:rpl_genl_family
params	.\lib\jsonrpc.h	/^    struct json *params;        \/* Request or notification only. *\/$/;"	m	struct:jsonrpc_msg	typeref:struct:jsonrpc_msg::json
parent	.\utilities\ovs-vsctl.c	/^    struct vsctl_bridge *parent; \/* Real bridge, or NULL. *\/$/;"	m	struct:vsctl_bridge	typeref:struct:vsctl_bridge::vsctl_bridge	file:
parse	.\lib\netlink-notifier.c	/^    nln_parse_func *parse;       \/* Message parsing function. *\/$/;"	m	struct:nln	file:
parse	.\lib\ovsdb-idl-provider.h	/^    void (*parse)(struct ovsdb_idl_row *, const struct ovsdb_datum *);$/;"	m	struct:ovsdb_idl_column
parseXML	.\xenserver\opt_xensource_libexec_InterfaceReconfigure.py	/^from xml.dom.minidom import parse as parseXML$/;"	i
parse_8021q_onward	.\lib\odp-util.c	/^parse_8021q_onward(const struct nlattr *attrs[OVS_KEY_ATTR_MAX + 1],$/;"	f	file:
parse_actions	.\tests\test-odp.c	/^parse_actions(void)$/;"	f	file:
parse_args	.\python\compat\argparse.py	/^    def parse_args(self, args=None, namespace=None):$/;"	m	class:ArgumentParser
parse_atom_token	.\lib\ovsdb-data.c	/^parse_atom_token(const char **s, const struct ovsdb_base_type *base,$/;"	f	file:
parse_body	.\ovsdb\log.c	/^parse_body(struct ovsdb_log *file, off_t offset, unsigned long int length,$/;"	f	file:
parse_bool	.\ovsdb\jsonrpc-server.c	/^parse_bool(struct ovsdb_parser *parser, const char *name, bool default_value)$/;"	f	file:
parse_bracketed_token	.\lib\socket-util.c	/^parse_bracketed_token(char **pp)$/;"	f	file:
parse_bucket_str	.\lib\ofp-parse.c	/^parse_bucket_str(struct ofputil_bucket *bucket, char *str_,$/;"	f	file:
parse_bundle_actions	.\tests\test-bundle.c	/^parse_bundle_actions(char *actions)$/;"	f	file:
parse_column_key_value	.\utilities\ovs-vsctl.c	/^parse_column_key_value(const char *arg,$/;"	f	file:
parse_column_key_value	.\vtep\vtep-ctl.c	/^parse_column_key_value(const char *arg,$/;"	f	file:
parse_column_names	.\utilities\ovs-vsctl.c	/^parse_column_names(const char *column_names,$/;"	f	file:
parse_column_names	.\vtep\vtep-ctl.c	/^parse_column_names(const char *column_names,$/;"	f	file:
parse_command	.\utilities\ovs-vsctl.c	/^parse_command(int argc, char *argv[], struct shash *local_options,$/;"	f	file:
parse_command	.\vtep\vtep-ctl.c	/^parse_command(int argc, char *argv[], struct shash *local_options,$/;"	f	file:
parse_command_line	.\utilities\ovs-appctl.c	/^parse_command_line(int argc, char *argv[])$/;"	f	file:
parse_commands	.\utilities\ovs-vsctl.c	/^parse_commands(int argc, char *argv[], struct shash *local_options,$/;"	f	file:
parse_commands	.\vtep\vtep-ctl.c	/^parse_commands(int argc, char *argv[], struct shash *local_options,$/;"	f	file:
parse_controller	.\lib\ofp-parse.c	/^parse_controller(struct ofpbuf *b, char *arg)$/;"	f	file:
parse_cpuinfo	.\lib\ovs-thread.c	/^parse_cpuinfo(long int *n_cores)$/;"	f	file:
parse_db_column	.\ovsdb\ovsdb-server.c	/^parse_db_column(const struct shash *all_dbs,$/;"	f	file:
parse_db_column__	.\ovsdb\ovsdb-server.c	/^parse_db_column__(const struct shash *all_dbs,$/;"	f	file:
parse_db_string_column	.\ovsdb\ovsdb-server.c	/^parse_db_string_column(const struct shash *all_dbs,$/;"	f	file:
parse_dec_ttl	.\lib\ofp-parse.c	/^parse_dec_ttl(struct ofpbuf *b, char *arg)$/;"	f	file:
parse_enqueue	.\lib\ofp-parse.c	/^parse_enqueue(char *arg, struct ofpbuf *ofpacts)$/;"	f	file:
parse_ethertype	.\datapath\flow.c	/^static __be16 parse_ethertype(struct sk_buff *skb)$/;"	f	file:
parse_ethertype	.\lib\flow.c	/^parse_ethertype(void **datap, size_t *sizep)$/;"	f	file:
parse_ethertype	.\lib\odp-util.c	/^parse_ethertype(const struct nlattr *attrs[OVS_KEY_ATTR_MAX + 1],$/;"	f	file:
parse_field	.\lib\ofp-parse.c	/^parse_field(const struct mf_field *mf, const char *s, struct match *match,$/;"	f	file:
parse_filter	.\tests\test-odp.c	/^parse_filter(char *filter_parse)$/;"	f	file:
parse_fin_timeout	.\lib\ofp-parse.c	/^parse_fin_timeout(struct ofpbuf *b, char *arg)$/;"	f	file:
parse_flags	.\lib\odp-util.c	/^parse_flags(const char *s, const char *(*bit_to_string)(uint32_t),$/;"	f	file:
parse_flow_and_packet	.\ofproto\ofproto-dpif.c	/^parse_flow_and_packet(int argc, const char *argv[],$/;"	f	file:
parse_flow_mask_nlattrs	.\datapath\flow_netlink.c	/^static int parse_flow_mask_nlattrs(const struct nlattr *attr,$/;"	f	file:
parse_flow_monitor_request	.\lib\ofp-parse.c	/^parse_flow_monitor_request(struct ofputil_flow_monitor_request *fmr,$/;"	f
parse_flow_monitor_request__	.\lib\ofp-parse.c	/^parse_flow_monitor_request__(struct ofputil_flow_monitor_request *fmr,$/;"	f	file:
parse_flow_nlattrs	.\datapath\flow_netlink.c	/^static int parse_flow_nlattrs(const struct nlattr *attr,$/;"	f	file:
parse_flow_nlattrs	.\lib\odp-util.c	/^parse_flow_nlattrs(const struct nlattr *key, size_t key_len,$/;"	f	file:
parse_flow_tun_flags	.\lib\meta-flow.c	/^parse_flow_tun_flags(const char *s_, const char *(*bit_to_string)(uint32_t),$/;"	f	file:
parse_gre_header	.\datapath\linux\compat\gre.c	/^static int parse_gre_header(struct sk_buff *skb, struct tnl_ptk_info *tpi,$/;"	f	file:
parse_header	.\ovsdb\log.c	/^parse_header(char *header, unsigned long int *length,$/;"	f	file:
parse_icmpv6	.\datapath\flow.c	/^static int parse_icmpv6(struct sk_buff *skb, struct sw_flow_key *key,$/;"	f	file:
parse_icmpv6	.\lib\flow.c	/^parse_icmpv6(void **datap, size_t *sizep, const struct icmp6_hdr *icmp,$/;"	f	file:
parse_if_inet6_line	.\lib\netdev-linux.c	/^parse_if_inet6_line(const char *line,$/;"	f	file:
parse_instruction_ids	.\lib\ofp-util.c	/^parse_instruction_ids(struct ofpbuf *payload, bool loose, uint32_t *insts)$/;"	f	file:
parse_ipv6hdr	.\datapath\flow.c	/^static int parse_ipv6hdr(struct sk_buff *skb, struct sw_flow_key *key)$/;"	f	file:
parse_json	.\ovsdb\ovsdb-client.c	/^parse_json(const char *s)$/;"	f	file:
parse_json	.\ovsdb\ovsdb-tool.c	/^parse_json(const char *s)$/;"	f	file:
parse_json	.\tests\test-jsonrpc.c	/^parse_json(const char *s)$/;"	f	file:
parse_json	.\tests\test-ovsdb.c	/^parse_json(const char *s)$/;"	f	file:
parse_json_pair	.\lib\ovsdb-data.c	/^parse_json_pair(const struct json *json,$/;"	f	file:
parse_json_pair	.\python\ovs\db\parser.py	/^def parse_json_pair(json):$/;"	f
parse_key	.\lib\netdev-vport.c	/^parse_key(const struct smap *args, const char *name,$/;"	f	file:
parse_key_value	.\lib\ovsdb-data.c	/^parse_key_value(const char **s, const struct ovsdb_type *type,$/;"	f	file:
parse_keys	.\tests\test-odp.c	/^parse_keys(bool wc_keys)$/;"	f	file:
parse_known_args	.\python\compat\argparse.py	/^    def parse_known_args(self, args=None, namespace=None):$/;"	m	class:ArgumentParser
parse_l2_5_onward	.\lib\odp-util.c	/^parse_l2_5_onward(const struct nlattr *attrs[OVS_KEY_ATTR_MAX + 1],$/;"	f	file:
parse_lacp_packet	.\lib\lacp.c	/^parse_lacp_packet(const struct ofpbuf *b)$/;"	f	file:
parse_metadata	.\lib\ofp-parse.c	/^parse_metadata(struct ofpbuf *b, char *arg)$/;"	f	file:
parse_monitor_columns	.\ovsdb\ovsdb-client.c	/^parse_monitor_columns(char *arg, const char *server, const char *database,$/;"	f	file:
parse_mpls	.\lib\flow.c	/^parse_mpls(void **datap, size_t *sizep)$/;"	f	file:
parse_multiple	.\tests\test-json.c	/^parse_multiple(FILE *stream)$/;"	f	file:
parse_multiple	.\tests\test-json.py	/^def parse_multiple(stream):$/;"	f
parse_named_action	.\lib\ofp-parse.c	/^parse_named_action(enum ofputil_action_code code,$/;"	f	file:
parse_named_instruction	.\lib\ofp-parse.c	/^parse_named_instruction(enum ovs_instruction_type type,$/;"	f	file:
parse_noargs_dec_ttl	.\lib\ofp-parse.c	/^parse_noargs_dec_ttl(struct ofpbuf *b)$/;"	f	file:
parse_note	.\lib\ofp-parse.c	/^parse_note(const char *arg, struct ofpbuf *ofpacts)$/;"	f	file:
parse_nxm_field_name	.\lib\nx-match.c	/^parse_nxm_field_name(const char *name, int name_len)$/;"	f	file:
parse_odp_action	.\lib\odp-util.c	/^parse_odp_action(const char *s, const struct simap *port_names,$/;"	f	file:
parse_odp_key_mask_attr	.\lib\odp-util.c	/^parse_odp_key_mask_attr(const char *s, const struct simap *port_names,$/;"	f	file:
parse_odp_packet	.\lib\dpif-linux.c	/^parse_odp_packet(struct ofpbuf *buf, struct dpif_upcall *upcall,$/;"	f	file:
parse_ofp14_port_ethernet_property	.\lib\ofp-util.c	/^parse_ofp14_port_ethernet_property(const struct ofpbuf *payload,$/;"	f	file:
parse_ofp14_port_stats_ethernet_property	.\lib\ofp-util.c	/^parse_ofp14_port_stats_ethernet_property(const struct ofpbuf *payload,$/;"	f	file:
parse_ofp_exact_flow	.\lib\ofp-parse.c	/^parse_ofp_exact_flow(struct flow *flow, struct flow *mask, const char *s,$/;"	f
parse_ofp_flow_mod_file	.\lib\ofp-parse.c	/^parse_ofp_flow_mod_file(const char *file_name, uint16_t command,$/;"	f
parse_ofp_flow_mod_str	.\lib\ofp-parse.c	/^parse_ofp_flow_mod_str(struct ofputil_flow_mod *fm, const char *string,$/;"	f
parse_ofp_flow_stats_request_str	.\lib\ofp-parse.c	/^parse_ofp_flow_stats_request_str(struct ofputil_flow_stats_request *fsr,$/;"	f
parse_ofp_group_mod_file	.\lib\ofp-parse.c	/^parse_ofp_group_mod_file(const char *file_name, uint16_t command,$/;"	f
parse_ofp_group_mod_str	.\lib\ofp-parse.c	/^parse_ofp_group_mod_str(struct ofputil_group_mod *gm, uint16_t command,$/;"	f
parse_ofp_group_mod_str__	.\lib\ofp-parse.c	/^parse_ofp_group_mod_str__(struct ofputil_group_mod *gm, uint16_t command,$/;"	f	file:
parse_ofp_meter_mod_str	.\lib\ofp-parse.c	/^parse_ofp_meter_mod_str(struct ofputil_meter_mod *mm, const char *str_,$/;"	f
parse_ofp_meter_mod_str__	.\lib\ofp-parse.c	/^parse_ofp_meter_mod_str__(struct ofputil_meter_mod *mm, char *string,$/;"	f	file:
parse_ofp_str	.\lib\ofp-parse.c	/^parse_ofp_str(struct ofputil_flow_mod *fm, int command, const char *str_,$/;"	f
parse_ofp_str__	.\lib\ofp-parse.c	/^parse_ofp_str__(struct ofputil_flow_mod *fm, int command, char *string,$/;"	f	file:
parse_ofp_table_mod	.\lib\ofp-parse.c	/^parse_ofp_table_mod(struct ofputil_table_mod *tm, const char *table_id,$/;"	f
parse_ofpacts	.\lib\ofp-parse.c	/^parse_ofpacts(const char *s_, struct ofpbuf *ofpacts,$/;"	f
parse_optional_uint	.\lib\ovsdb-types.c	/^parse_optional_uint(struct ovsdb_parser *parser, const char *member,$/;"	f	file:
parse_options	.\ovsdb\ovsdb-client.c	/^parse_options(int argc, char *argv[])$/;"	f	file:
parse_options	.\ovsdb\ovsdb-server.c	/^parse_options(int *argcp, char **argvp[],$/;"	f	file:
parse_options	.\ovsdb\ovsdb-tool.c	/^parse_options(int argc, char *argv[])$/;"	f	file:
parse_options	.\tests\test-controller.c	/^parse_options(int argc, char *argv[])$/;"	f	file:
parse_options	.\tests\test-jsonrpc.c	/^parse_options(int argc, char *argv[])$/;"	f	file:
parse_options	.\tests\test-netflow.c	/^parse_options(int argc, char *argv[])$/;"	f	file:
parse_options	.\tests\test-ovsdb.c	/^parse_options(int argc, char *argv[])$/;"	f	file:
parse_options	.\tests\test-sflow.c	/^parse_options(int argc, char *argv[])$/;"	f	file:
parse_options	.\tests\test-util.c	/^parse_options(int argc, char *argv[])$/;"	f	file:
parse_options	.\utilities\ovs-benchmark.c	/^parse_options(int argc, char *argv[])$/;"	f	file:
parse_options	.\utilities\ovs-dpctl.c	/^parse_options(int argc, char *argv[])$/;"	f	file:
parse_options	.\utilities\ovs-ofctl.c	/^parse_options(int argc, char *argv[])$/;"	f	file:
parse_options	.\utilities\ovs-vlan-bug-workaround.c	/^parse_options(int argc, char *argv[])$/;"	f	file:
parse_options	.\utilities\ovs-vsctl.c	/^parse_options(int argc, char *argv[], struct shash *local_options)$/;"	f	file:
parse_options	.\vswitchd\ovs-vswitchd.c	/^parse_options(int argc, char *argv[], char **unixctl_pathp)$/;"	f	file:
parse_options	.\vtep\vtep-ctl.c	/^parse_options(int argc, char *argv[], struct shash *local_options)$/;"	f	file:
parse_output	.\lib\ofp-parse.c	/^parse_output(const char *arg, struct ofpbuf *ofpacts)$/;"	f	file:
parse_oxm	.\lib\ofp-util.c	/^parse_oxm(struct ofpbuf *b, bool loose,$/;"	f	file:
parse_oxms	.\lib\ofp-util.c	/^parse_oxms(struct ofpbuf *payload, bool loose,$/;"	f	file:
parse_port_mod_ethernet_property	.\lib\ofp-util.c	/^parse_port_mod_ethernet_property(struct ofpbuf *property,$/;"	f	file:
parse_protocol	.\lib\ofp-parse.c	/^parse_protocol(const char *name, const struct protocol **p_out)$/;"	f	file:
parse_queue_rate	.\lib\ofp-util.c	/^parse_queue_rate(const struct ofp_queue_prop_header *hdr, uint16_t *rate)$/;"	f	file:
parse_resubmit	.\lib\ofp-parse.c	/^parse_resubmit(char *arg, struct ofpbuf *ofpacts)$/;"	f	file:
parse_row	.\ovsdb\execution.c	/^parse_row(const struct json *json, const struct ovsdb_table *table,$/;"	f	file:
parse_sample	.\lib\ofp-parse.c	/^parse_sample(struct ofpbuf *b, char *arg)$/;"	f	file:
parse_scanset	.\lib\util.c	/^parse_scanset(const char *p_, unsigned long *set, bool *complemented)$/;"	f	file:
parse_set_mpls_label	.\lib\ofp-parse.c	/^parse_set_mpls_label(struct ofpbuf *b, const char *arg)$/;"	f	file:
parse_set_mpls_tc	.\lib\ofp-parse.c	/^parse_set_mpls_tc(struct ofpbuf *b, const char *arg)$/;"	f	file:
parse_set_mpls_ttl	.\lib\ofp-parse.c	/^parse_set_mpls_ttl(struct ofpbuf *b, const char *arg)$/;"	f	file:
parse_sockaddr_components	.\lib\socket-util.c	/^parse_sockaddr_components(struct sockaddr_storage *ss,$/;"	f	file:
parse_state	.\lib\json.c	/^    enum json_parse_state parse_state;$/;"	m	struct:json_parser	typeref:enum:json_parser::json_parse_state	file:
parse_table	.\ovsdb\execution.c	/^parse_table(struct ovsdb_execution *x,$/;"	f	file:
parse_table_features_next_table	.\lib\ofp-util.c	/^parse_table_features_next_table(struct ofpbuf *payload,$/;"	f	file:
parse_table_ids	.\lib\ofp-util.c	/^parse_table_ids(struct ofpbuf *payload, uint32_t *ids)$/;"	f	file:
parse_target	.\utilities\ovs-benchmark.c	/^parse_target(const char *s_, struct in_addr *addr,$/;"	f	file:
parse_uuids	.\tests\test-ovsdb.c	/^parse_uuids(const struct json *json, struct ovsdb_symbol_table *symtab,$/;"	f	file:
parse_uuids	.\tests\test-ovsdb.py	/^def parse_uuids(json, symtab):$/;"	f
parse_vlan	.\datapath\flow.c	/^static int parse_vlan(struct sk_buff *skb, struct sw_flow_key *key)$/;"	f	file:
parse_vlan	.\lib\flow.c	/^parse_vlan(void **datap, size_t *sizep)$/;"	f	file:
parsed_dpif_open	.\utilities\ovs-dpctl.c	/^parsed_dpif_open(const char *arg_, bool create, struct dpif **dpifp)$/;"	f	file:
parser	.\lib\jsonrpc.c	/^    struct json_parser *parser;$/;"	m	struct:jsonrpc	typeref:struct:jsonrpc::json_parser	file:
parser	.\python\ovs\db\data.py	/^import ovs.db.parser$/;"	i
parser	.\python\ovs\db\idl.py	/^import ovs.db.parser$/;"	i
parser	.\python\ovs\db\schema.py	/^import ovs.db.parser$/;"	i
parser	.\python\ovs\db\types.py	/^import ovs.db.parser$/;"	i
parser	.\python\ovs\ovsuuid.py	/^import ovs.db.parser$/;"	i
parser	.\utilities\ovs-dev.py	/^parser = None$/;"	v
part_is_free	.\datapath\linux\compat\flex_array.c	/^static int part_is_free(struct flex_array_part *part)$/;"	f	file:
partition	.\lib\classifier.c	/^    struct cls_partition *partition;$/;"	m	struct:cls_match	typeref:struct:cls_match::cls_partition	file:
partition	.\lib\sort.c	/^partition(size_t p, size_t r,$/;"	f	file:
partitions	.\lib\classifier.c	/^    struct hmap partitions;     \/* Contains "struct cls_partition"s. *\/$/;"	m	struct:cls_classifier	typeref:struct:cls_classifier::hmap	file:
partner	.\lib\lacp.c	/^    struct lacp_info partner;     \/* Partner information. *\/$/;"	m	struct:slave	typeref:struct:slave::lacp_info	file:
parts	.\datapath\linux\compat\include\linux\flex_array.h	/^			struct flex_array_part *parts[];$/;"	m	struct:flex_array::__anon12::__anon13	typeref:struct:flex_array::__anon12::__anon13::flex_array_part
parts	.\lib\uuid.h	/^    uint32_t parts[4];$/;"	m	struct:uuid
passive	.\lib\reconnect.c	/^    bool passive;$/;"	m	struct:reconnect	file:
patcher	.\python\ovs\poller.py	/^    import eventlet.patcher$/;"	i
path	.\python\ovs\socket_util.py	/^import os.path$/;"	i
path	.\python\ovs\util.py	/^import os.path$/;"	i
path	.\xenserver\opt_xensource_libexec_InterfaceReconfigure.py	/^    def path(self):$/;"	m	class:ConfigurationFile
path_cost	.\lib\stp.c	/^    int path_cost;                  \/* 8.5.5.3: Cost of tx\/rx on this port. *\/$/;"	m	struct:stp_port	file:
path_cost	.\ofproto\ofproto.h	/^    uint16_t path_cost;$/;"	m	struct:ofproto_port_stp_settings
pattern_rwlock	.\lib\vlog.c	/^static int syslog_fd OVS_GUARDED_BY(pattern_rwlock) = -1;$/;"	v	file:
pattern_rwlock	.\lib\vlog.c	/^static struct ovs_rwlock pattern_rwlock = OVS_RWLOCK_INITIALIZER;$/;"	v	typeref:struct:ovs_rwlock	file:
pauseProducing	.\python\ovstest\tcp.py	/^    def pauseProducing(self):$/;"	m	class:Producer
payload	.\lib\pcap-file.c	/^    struct ofpbuf payload;$/;"	m	struct:tcp_stream	typeref:struct:tcp_stream::ofpbuf	file:
pcap	.\lib\netdev-bsd.c	/^    pcap_t *pcap;$/;"	m	struct:netdev_bsd	file:
pcap	.\lib\pcap-file.c	/^VLOG_DEFINE_THIS_MODULE(pcap);$/;"	v
pcap_arg	.\lib\netdev-bsd.c	/^struct pcap_arg {$/;"	s	file:
pcap_handle	.\lib\netdev-bsd.c	/^    pcap_t *pcap_handle;$/;"	m	struct:netdev_rxq_bsd	file:
pcap_hdr	.\lib\pcap-file.c	/^struct pcap_hdr {$/;"	s	file:
pcaprec_hdr	.\lib\pcap-file.c	/^struct pcaprec_hdr {$/;"	s	file:
pconn	.\lib\netdev-dummy.c	/^        struct dummy_packet_pconn pconn;$/;"	m	union:dummy_packet_conn::__anon57	typeref:struct:dummy_packet_conn::__anon57::dummy_packet_pconn	file:
pcpu_sw_netstats	.\datapath\linux\compat\include\linux\netdevice.h	/^struct pcpu_sw_netstats {$/;"	s
peer	.\include\openflow\openflow-1.0.h	/^    ovs_be32 peer;          \/* Features advertised by peer. *\/$/;"	m	struct:ofp10_phy_port
peer	.\include\openflow\openflow-1.1.h	/^    ovs_be32 peer;          \/* Features advertised by peer. *\/$/;"	m	struct:ofp11_port
peer	.\include\openflow\openflow-1.4.h	/^    ovs_be32 peer;          \/* Features advertised by peer. *\/$/;"	m	struct:ofp14_port_desc_prop_ethernet
peer	.\lib\netdev-vport.c	/^    char *peer;$/;"	m	struct:netdev_vport	file:
peer	.\lib\ofp-util.h	/^    enum netdev_features peer;       \/* Features advertised by peer. *\/$/;"	m	struct:ofputil_phy_port	typeref:enum:ofputil_phy_port::netdev_features
peer	.\ofproto\ofproto-dpif-xlate.c	/^    struct xport *peer;              \/* Patch port peer or null. *\/$/;"	m	struct:xport	typeref:struct:xport::xport	file:
peer	.\ofproto\ofproto-dpif.c	/^    struct ofport_dpif *peer;   \/* Peer if patch port. *\/$/;"	m	struct:ofport_dpif	typeref:struct:ofport_dpif::ofport_dpif	file:
peer_versions	.\lib\vconn-provider.h	/^    uint32_t peer_versions;     \/* Peer's bitmap of versions it will accept. *\/$/;"	m	struct:vconn
percpu_stats	.\datapath\vport.h	/^	struct pcpu_sw_netstats __percpu *percpu_stats;$/;"	m	struct:vport	typeref:struct:vport::__percpu
permute_args	.\lib\getopt_long.c	/^permute_args(int panonopt_start, int panonopt_end, int opt_end, char **nargv)$/;"	f	file:
pernet_operations	.\datapath\linux\compat\include\net\net_namespace.h	15;"	d
persistent	.\ovsdb\column.h	/^    bool persistent;$/;"	m	struct:ovsdb_column
perthread_key	.\lib\ovs-rcu.c	/^static pthread_key_t perthread_key;$/;"	v	file:
pfd_accept	.\lib\stream-fd-unix.c	/^pfd_accept(struct pstream *pstream, struct stream **new_streamp)$/;"	f	file:
pfd_accept	.\lib\stream-fd-windows.c	/^pfd_accept(struct pstream *pstream, struct stream **new_streamp)$/;"	f	file:
pfd_close	.\lib\stream-fd-unix.c	/^pfd_close(struct pstream *pstream)$/;"	f	file:
pfd_close	.\lib\stream-fd-windows.c	/^pfd_close(struct pstream *pstream)$/;"	f	file:
pfd_set_dscp	.\lib\stream-fd-unix.c	/^pfd_set_dscp(struct pstream *pstream, uint8_t dscp)$/;"	f	file:
pfd_set_dscp	.\lib\stream-fd-windows.c	/^pfd_set_dscp(struct pstream *pstream, uint8_t dscp)$/;"	f	file:
pfd_wait	.\lib\stream-fd-unix.c	/^pfd_wait(struct pstream *pstream)$/;"	f	file:
pfd_wait	.\lib\stream-fd-windows.c	/^pfd_wait(struct pstream *pstream)$/;"	f	file:
phy	.\datapath\flow.h	/^	} __packed phy; \/* Safe when right after 'tun_key'. *\/$/;"	m	struct:sw_flow_key	typeref:struct:sw_flow_key::__anon1
pi	.\include\openflow\openflow-1.3.h	/^    struct ofp12_packet_in pi;$/;"	m	struct:ofp13_action_self_learning::ofp13_packet_in	typeref:struct:ofp13_action_self_learning::ofp13_packet_in::ofp12_packet_in
pick_datapath_id	.\ofproto\ofproto.c	/^pick_datapath_id(const struct ofproto *ofproto)$/;"	f	file:
pick_fallback_dpid	.\ofproto\ofproto.c	/^pick_fallback_dpid(void)$/;"	f	file:
pid	.\lib\netlink-socket.c	/^    uint32_t pid;$/;"	m	struct:nl_sock	file:
pid	.\lib\process.c	/^    pid_t pid;$/;"	m	struct:process	file:
pid	.\lib\route-table-bsd.c	/^static int pid;$/;"	v	file:
pid_t	.\include\windows\windefs.h	/^typedef int pid_t;$/;"	t
pidfile	.\lib\daemon-unix.c	/^char *pidfile;$/;"	v
pidfile	.\lib\daemon-windows.c	/^char *pidfile;                 \/* --pidfile: Name of pidfile (null if none). *\/$/;"	v
pidfile_dev	.\lib\daemon-unix.c	/^static dev_t pidfile_dev;$/;"	v	file:
pidfile_ino	.\lib\daemon-unix.c	/^static ino_t pidfile_ino;$/;"	v	file:
pif_bridge_name	.\xenserver\opt_xensource_libexec_InterfaceReconfigure.py	/^def pif_bridge_name(pif):$/;"	f
pif_currently_in_use	.\xenserver\opt_xensource_libexec_InterfaceReconfigureVswitch.py	/^def pif_currently_in_use(pif):$/;"	f
pif_datapath	.\xenserver\opt_xensource_libexec_InterfaceReconfigureVswitch.py	/^def pif_datapath(pif):$/;"	f
pif_exists	.\xenserver\opt_xensource_libexec_InterfaceReconfigure.py	/^    def pif_exists(self, pif):$/;"	m	class:DatabaseCache
pif_get_bond_masters	.\xenserver\opt_xensource_libexec_InterfaceReconfigure.py	/^def pif_get_bond_masters(pif):$/;"	f
pif_get_bond_slaves	.\xenserver\opt_xensource_libexec_InterfaceReconfigure.py	/^def pif_get_bond_slaves(pif):$/;"	f
pif_get_bond_slaves_sorted	.\xenserver\opt_xensource_libexec_InterfaceReconfigureBridge.py	/^def pif_get_bond_slaves_sorted(pif):$/;"	f
pif_get_vlan_masters	.\xenserver\opt_xensource_libexec_InterfaceReconfigure.py	/^def pif_get_vlan_masters(pif):$/;"	f
pif_get_vlan_slave	.\xenserver\opt_xensource_libexec_InterfaceReconfigure.py	/^def pif_get_vlan_slave(pif):$/;"	f
pif_ipdev_name	.\xenserver\opt_xensource_libexec_InterfaceReconfigure.py	/^def pif_ipdev_name(pif):$/;"	f
pif_is_bond	.\xenserver\opt_xensource_libexec_InterfaceReconfigure.py	/^def pif_is_bond(pif):$/;"	f
pif_is_bridged	.\xenserver\opt_xensource_libexec_InterfaceReconfigure.py	/^def pif_is_bridged(pif):$/;"	f
pif_is_tunnel	.\xenserver\opt_xensource_libexec_InterfaceReconfigure.py	/^def pif_is_tunnel(pif):$/;"	f
pif_is_vlan	.\xenserver\opt_xensource_libexec_InterfaceReconfigure.py	/^def pif_is_vlan(pif):$/;"	f
pif_netdev_name	.\xenserver\opt_xensource_libexec_InterfaceReconfigure.py	/^def pif_netdev_name(pif):$/;"	f
pinqueue	.\ofproto\pinsched.c	/^struct pinqueue {$/;"	s	file:
pinqueue_destroy	.\ofproto\pinsched.c	/^pinqueue_destroy(struct pinsched *ps, struct pinqueue *q)$/;"	f	file:
pinqueue_get	.\ofproto\pinsched.c	/^pinqueue_get(struct pinsched *ps, ofp_port_t port_no)$/;"	f	file:
pins	.\ofproto\ofproto-dpif.c	/^    struct guarded_list pins;      \/* Contains "struct ofputil_packet_in"s. *\/$/;"	m	struct:ofproto_dpif	typeref:struct:ofproto_dpif::guarded_list	file:
pins_seq	.\ofproto\ofproto-dpif.c	/^    struct seq *pins_seq;          \/* For notifying 'pins' reception. *\/$/;"	m	struct:ofproto_dpif	typeref:struct:ofproto_dpif::seq	file:
pins_seqno	.\ofproto\ofproto-dpif.c	/^    uint64_t pins_seqno;$/;"	m	struct:ofproto_dpif	file:
pinsched	.\ofproto\pinsched.c	/^struct pinsched {$/;"	s	file:
pinsched_count_txqlen	.\ofproto\pinsched.c	/^pinsched_count_txqlen(const struct pinsched *ps)$/;"	f
pinsched_create	.\ofproto\pinsched.c	/^pinsched_create(int rate_limit, int burst_limit)$/;"	f
pinsched_destroy	.\ofproto\pinsched.c	/^pinsched_destroy(struct pinsched *ps)$/;"	f
pinsched_get_limits	.\ofproto\pinsched.c	/^pinsched_get_limits(const struct pinsched *ps,$/;"	f
pinsched_run	.\ofproto\pinsched.c	/^pinsched_run(struct pinsched *ps, struct list *txq)$/;"	f
pinsched_send	.\ofproto\pinsched.c	/^pinsched_send(struct pinsched *ps, ofp_port_t port_no,$/;"	f
pinsched_set_limits	.\ofproto\pinsched.c	/^pinsched_set_limits(struct pinsched *ps, int rate_limit, int burst_limit)$/;"	f
pinsched_wait	.\ofproto\pinsched.c	/^pinsched_wait(struct pinsched *ps)$/;"	f
pkt_key	.\datapath\datapath.h	/^	struct sw_flow_key	*pkt_key;$/;"	m	struct:ovs_skb_cb	typeref:struct:ovs_skb_cb::sw_flow_key
pkt_mark	.\lib\flow.h	/^    uint32_t pkt_mark;          \/* Packet mark. *\/$/;"	m	struct:flow
pkt_mark	.\lib\packets.h	/^    uint32_t pkt_mark;          \/* Packet mark. *\/$/;"	m	struct:pkt_metadata
pkt_mark	.\ofproto\tunnel.c	/^    uint32_t pkt_mark;$/;"	m	struct:tnl_match	file:
pkt_metadata	.\lib\packets.h	/^struct pkt_metadata {$/;"	s
pktbuf	.\ofproto\connmgr.c	/^    struct pktbuf *pktbuf;         \/* OpenFlow packet buffers. *\/$/;"	m	struct:ofconn	typeref:struct:ofconn::pktbuf	file:
pktbuf	.\ofproto\pktbuf.c	/^VLOG_DEFINE_THIS_MODULE(pktbuf);$/;"	v
pktbuf	.\ofproto\pktbuf.c	/^struct pktbuf {$/;"	s	file:
pktbuf_buffer_unknown	.\ofproto\pktbuf.c	/^COVERAGE_DEFINE(pktbuf_buffer_unknown);$/;"	v
pktbuf_capacity	.\ofproto\pktbuf.c	/^pktbuf_capacity(void)$/;"	f
pktbuf_count_packets	.\ofproto\pktbuf.c	/^pktbuf_count_packets(const struct pktbuf *pb)$/;"	f
pktbuf_create	.\ofproto\pktbuf.c	/^pktbuf_create(void)$/;"	f
pktbuf_destroy	.\ofproto\pktbuf.c	/^pktbuf_destroy(struct pktbuf *pb)$/;"	f
pktbuf_discard	.\ofproto\pktbuf.c	/^pktbuf_discard(struct pktbuf *pb, uint32_t id)$/;"	f
pktbuf_get_null	.\ofproto\pktbuf.c	/^pktbuf_get_null(void)$/;"	f
pktbuf_null_cookie	.\ofproto\pktbuf.c	/^COVERAGE_DEFINE(pktbuf_null_cookie);$/;"	v
pktbuf_retrieve	.\ofproto\pktbuf.c	/^pktbuf_retrieve(struct pktbuf *pb, uint32_t id, struct ofpbuf **bufferp,$/;"	f
pktbuf_retrieved	.\ofproto\pktbuf.c	/^COVERAGE_DEFINE(pktbuf_retrieved);$/;"	v
pktbuf_reuse_error	.\ofproto\pktbuf.c	/^COVERAGE_DEFINE(pktbuf_reuse_error);$/;"	v
pktbuf_save	.\ofproto\pktbuf.c	/^pktbuf_save(struct pktbuf *pb, const void *buffer, size_t buffer_size,$/;"	f
pktlen	.\lib\sflow_api.h	/^    u_int32_t pktlen; \/* accumulated size *\/$/;"	m	struct:_SFLSampleCollector
place	.\lib\getopt_long.c	/^static const char *place = EMSG; \/* option letter processing *\/$/;"	v	file:
ploc_cfg	.\vtep\vtep-ctl.c	/^    const struct vteprec_physical_locator *ploc_cfg;$/;"	m	struct:vtep_ctl_ploc	typeref:struct:vtep_ctl_ploc::vteprec_physical_locator	file:
ploc_set_cfg	.\vtep\vtep-ctl.c	/^    const struct vteprec_physical_locator_set *ploc_set_cfg;$/;"	m	struct:vtep_ctl_mcast_mac	typeref:struct:vtep_ctl_mcast_mac::vteprec_physical_locator_set	file:
plocs	.\vtep\vtep-ctl.c	/^    struct shash plocs;     \/* Maps from "<encap>+<dst_ip>" to$/;"	m	struct:vtep_ctl_context	typeref:struct:vtep_ctl_context::shash	file:
pmd_count	.\lib\dpif-netdev.c	/^    int pmd_count;$/;"	m	struct:dp_netdev	file:
pmd_load_queues	.\lib\dpif-netdev.c	/^pmd_load_queues(struct pmd_thread *f,$/;"	f	file:
pmd_thread	.\lib\dpif-netdev.c	/^struct pmd_thread {$/;"	s	file:
pmd_thread_main	.\lib\dpif-netdev.c	/^pmd_thread_main(void *f_)$/;"	f	file:
pmd_thread_setaffinity_cpu	.\lib\netdev-dpdk.c	/^pmd_thread_setaffinity_cpu(int cpu)$/;"	f
pmd_thread_setaffinity_cpu	.\lib\netdev-dpdk.h	/^pmd_thread_setaffinity_cpu(int cpu OVS_UNUSED)$/;"	f
pmd_threads	.\lib\dpif-netdev.c	/^    struct pmd_thread *pmd_threads;$/;"	m	struct:dp_netdev	typeref:struct:dp_netdev::pmd_thread	file:
poll	.\python\ovs\poller.py	/^    def poll(self, timeout):$/;"	m	class:_SelectSelect
poll_block	.\lib\poll-loop.c	/^poll_block(void)$/;"	f
poll_fd_wait	.\lib\poll-loop.c	/^COVERAGE_DEFINE(poll_fd_wait);$/;"	v
poll_fd_wait	.\lib\poll-loop.h	55;"	d
poll_fd_wait_at	.\lib\poll-loop.c	/^poll_fd_wait_at(int fd, HANDLE wevent, short int events, const char *where)$/;"	f
poll_fd_wait_event	.\lib\poll-loop.h	57;"	d
poll_immediate_wake	.\lib\poll-loop.h	68;"	d
poll_immediate_wake_at	.\lib\poll-loop.c	/^poll_immediate_wake_at(const char *where)$/;"	f
poll_loop	.\lib\poll-loop.c	/^VLOG_DEFINE_THIS_MODULE(poll_loop);$/;"	v
poll_loop	.\lib\poll-loop.c	/^poll_loop(void)$/;"	f	file:
poll_loop	.\lib\poll-loop.c	/^struct poll_loop {$/;"	s	file:
poll_min_rx	.\lib\bfd.c	/^    long long int poll_min_rx;    \/* Min RX negotating in a poll sequence. *\/$/;"	m	struct:bfd	file:
poll_min_tx	.\lib\bfd.c	/^    long long int poll_min_tx;    \/* Min TX negotating in a poll sequence. *\/$/;"	m	struct:bfd	file:
poll_node	.\lib\poll-loop.c	/^struct poll_node {$/;"	s	file:
poll_nodes	.\lib\poll-loop.c	/^    struct hmap poll_nodes;$/;"	m	struct:poll_loop	typeref:struct:poll_loop::hmap	file:
poll_timer_wait	.\lib\poll-loop.h	61;"	d
poll_timer_wait_at	.\lib\poll-loop.c	/^poll_timer_wait_at(long long int msec, const char *where)$/;"	f
poll_timer_wait_until	.\lib\poll-loop.h	64;"	d
poll_timer_wait_until_at	.\lib\poll-loop.c	/^poll_timer_wait_until_at(long long int when, const char *where)$/;"	f
poll_zero_timeout	.\lib\poll-loop.c	/^COVERAGE_DEFINE(poll_zero_timeout);$/;"	v
poller	.\python\ovs\db\data.py	/^import ovs.poller$/;"	i
poller	.\python\ovs\db\idl.py	/^import ovs.poller$/;"	i
poller	.\python\ovs\jsonrpc.py	/^import ovs.poller$/;"	i
poller	.\python\ovs\socket_util.py	/^import ovs.poller$/;"	i
poller	.\python\ovs\stream.py	/^import ovs.poller$/;"	i
poller	.\tests\test-jsonrpc.py	/^import ovs.poller$/;"	i
poller	.\tests\test-ovsdb.py	/^import ovs.poller$/;"	i
pollers	.\lib\sflow_api.h	/^    SFLPoller  *pollers;    \/* the list of samplers *\/$/;"	m	struct:_SFLAgent
pollfd	.\lib\poll-loop.c	/^    struct pollfd pollfd;       \/* Events to pass to time_poll(). *\/$/;"	m	struct:poll_node	typeref:struct:poll_node::pollfd	file:
polling	.\lib\vswitch-idl.h	/^	int64_t *polling;$/;"	m	struct:ovsrec_sflow
polling_interval	.\ofproto\ofproto.h	/^    uint32_t polling_interval;$/;"	m	struct:ofproto_sflow_options
pool_mutex	.\lib\netlink-socket.c	/^static struct ovs_mutex pool_mutex = OVS_MUTEX_INITIALIZER;$/;"	v	typeref:struct:ovs_mutex	file:
pop_mpls	.\lib\ofp-actions.c	/^    struct nx_action_pop_mpls pop_mpls;$/;"	m	union:ofp_action	typeref:struct:ofp_action::nx_action_pop_mpls	file:
pop_mpls	.\lib\packets.c	/^pop_mpls(struct ofpbuf *packet, ovs_be16 ethtype)$/;"	f
pop_vlan	.\datapath\actions.c	/^static int pop_vlan(struct sk_buff *skb)$/;"	f	file:
pop_vlan	.\lib\odp-util.c	/^pop_vlan(struct flow *base,$/;"	f	file:
port	.\include\openflow\openflow-1.0.h	/^    ovs_be16 port;                  \/* Output port. *\/$/;"	m	struct:ofp10_action_output
port	.\include\openflow\openflow-1.0.h	/^    ovs_be16 port;            \/* Port that queue belongs. Should$/;"	m	struct:ofp10_action_enqueue
port	.\include\openflow\openflow-1.0.h	/^    ovs_be16 port;          \/* Port to be queried. Should refer$/;"	m	struct:ofp10_queue_get_config_request
port	.\include\openflow\openflow-1.0.h	/^    ovs_be16 port;$/;"	m	struct:ofp10_queue_get_config_reply
port	.\include\openflow\openflow-1.1.h	/^    ovs_be32 port;                    \/* Output port. *\/$/;"	m	struct:ofp11_action_output
port	.\include\openflow\openflow-1.1.h	/^    ovs_be32 port;$/;"	m	struct:ofp11_queue_get_config_reply
port	.\include\openflow\openflow-1.1.h	/^    ovs_be32 port;$/;"	m	struct:ofp11_queue_get_config_request
port	.\include\openflow\openflow-1.2.h	/^    ovs_be32 port;         \/* Port this queue is attached to. *\/$/;"	m	struct:ofp12_packet_queue
port	.\lib\dpif-netdev.c	/^    struct dp_netdev_port *port;$/;"	m	struct:rxq_poll	typeref:struct:rxq_poll::dp_netdev_port	file:
port	.\lib\ofp-actions.h	/^    ofp_port_t port;            \/* Output port. *\/$/;"	m	struct:ofpact_output
port	.\lib\ofp-actions.h	/^    ofp_port_t port;$/;"	m	struct:ofpact_enqueue
port	.\lib\ofp-actions.h	/^    uint16_t port;              \/* TCP, UDP or SCTP port number. *\/$/;"	m	struct:ofpact_l4_port
port	.\ofproto\ofproto-dpif.c	/^    struct ofproto_port port;$/;"	m	struct:port_dump_state	typeref:struct:port_dump_state::ofproto_port	file:
port	.\python\ovstest\args.py	/^def port(string):$/;"	f
port	.\utilities\ovs-vsctl.c	/^    struct vsctl_port *port;$/;"	m	struct:vsctl_iface	typeref:struct:vsctl_iface::vsctl_port	file:
port	.\vswitchd\bridge.c	/^    struct port *port;          \/* Containing port. *\/$/;"	m	struct:iface	typeref:struct:iface::port	file:
port	.\vswitchd\bridge.c	/^struct port {$/;"	s	file:
port16	.\datapath\linux\compat\include\net\flow_keys.h	/^		__be16 port16[2];$/;"	m	union:flow_keys::__anon15
port_add	.\lib\dpif-provider.h	/^    int (*port_add)(struct dpif *dpif, struct netdev *netdev,$/;"	m	struct:dpif_class
port_add	.\ofproto\ofproto-dpif.c	/^port_add(struct ofproto *ofproto_, struct netdev *netdev)$/;"	f	file:
port_add	.\ofproto\ofproto-provider.h	/^    int (*port_add)(struct ofproto *ofproto, struct netdev *netdev);$/;"	m	struct:ofproto_class
port_alloc	.\ofproto\ofproto-dpif.c	/^port_alloc(void)$/;"	f	file:
port_alloc	.\ofproto\ofproto-provider.h	/^    struct ofport *(*port_alloc)(void);$/;"	m	struct:ofproto_class	typeref:struct:ofproto_class::port_alloc
port_by_name	.\ofproto\ofproto-provider.h	/^    struct shash port_by_name;$/;"	m	struct:ofproto	typeref:struct:ofproto::shash
port_cfg	.\utilities\ovs-vsctl.c	/^    struct ovsrec_port *port_cfg;$/;"	m	struct:vsctl_port	typeref:struct:vsctl_port::ovsrec_port	file:
port_cfg	.\vtep\vtep-ctl.c	/^    const struct vteprec_physical_port *port_cfg;$/;"	m	struct:vtep_ctl_port	typeref:struct:vtep_ctl_port::vteprec_physical_port	file:
port_conf	.\lib\netdev-dpdk.c	/^static const struct rte_eth_conf port_conf = {$/;"	v	typeref:struct:rte_eth_conf	file:
port_configure	.\vswitchd\bridge.c	/^port_configure(struct port *port)$/;"	f	file:
port_configure_bond	.\vswitchd\bridge.c	/^port_configure_bond(struct port *port, struct bond_settings *s)$/;"	f	file:
port_configure_lacp	.\vswitchd\bridge.c	/^port_configure_lacp(struct port *port, struct lacp_settings *s)$/;"	f	file:
port_configure_stp	.\vswitchd\bridge.c	/^port_configure_stp(const struct ofproto *ofproto, struct port *port,$/;"	f	file:
port_construct	.\ofproto\ofproto-dpif.c	/^port_construct(struct ofport *port_)$/;"	f	file:
port_construct	.\ofproto\ofproto-provider.h	/^    int (*port_construct)(struct ofport *ofport);$/;"	m	struct:ofproto_class
port_create	.\vswitchd\bridge.c	/^port_create(struct bridge *br, const struct ovsrec_port *cfg)$/;"	f	file:
port_dealloc	.\ofproto\ofproto-dpif.c	/^port_dealloc(struct ofport *port_)$/;"	f	file:
port_dealloc	.\ofproto\ofproto-provider.h	/^    void (*port_dealloc)(struct ofport *ofport);$/;"	m	struct:ofproto_class
port_del	.\lib\dpif-provider.h	/^    int (*port_del)(struct dpif *dpif, odp_port_t port_no);$/;"	m	struct:dpif_class
port_del	.\ofproto\ofproto-dpif.c	/^port_del(struct ofproto *ofproto_, ofp_port_t ofp_port)$/;"	f	file:
port_del	.\ofproto\ofproto-provider.h	/^    int (*port_del)(struct ofproto *ofproto, ofp_port_t ofp_port);$/;"	m	struct:ofproto_class
port_del_ifaces	.\vswitchd\bridge.c	/^port_del_ifaces(struct port *port)$/;"	f	file:
port_destroy	.\vswitchd\bridge.c	/^port_destroy(struct port *port)$/;"	f	file:
port_destruct	.\ofproto\ofproto-dpif.c	/^port_destruct(struct ofport *port_)$/;"	f	file:
port_destruct	.\ofproto\ofproto-provider.h	/^    void (*port_destruct)(struct ofport *ofport);$/;"	m	struct:ofproto_class
port_dump_done	.\lib\dpif-provider.h	/^    int (*port_dump_done)(const struct dpif *dpif, void *state);$/;"	m	struct:dpif_class
port_dump_done	.\ofproto\ofproto-dpif.c	/^port_dump_done(const struct ofproto *ofproto_ OVS_UNUSED, void *state_)$/;"	f	file:
port_dump_done	.\ofproto\ofproto-provider.h	/^    int (*port_dump_done)(const struct ofproto *ofproto, void *state);$/;"	m	struct:ofproto_class
port_dump_next	.\lib\dpif-provider.h	/^    int (*port_dump_next)(const struct dpif *dpif, void *state,$/;"	m	struct:dpif_class
port_dump_next	.\ofproto\ofproto-dpif.c	/^port_dump_next(const struct ofproto *ofproto_, void *state_,$/;"	f	file:
port_dump_next	.\ofproto\ofproto-provider.h	/^    int (*port_dump_next)(const struct ofproto *ofproto, void *state,$/;"	m	struct:ofproto_class
port_dump_start	.\lib\dpif-provider.h	/^    int (*port_dump_start)(const struct dpif *dpif, void **statep);$/;"	m	struct:dpif_class
port_dump_start	.\ofproto\ofproto-dpif.c	/^port_dump_start(const struct ofproto *ofproto_ OVS_UNUSED, void **statep)$/;"	f	file:
port_dump_start	.\ofproto\ofproto-provider.h	/^    int (*port_dump_start)(const struct ofproto *ofproto, void **statep);$/;"	m	struct:ofproto_class
port_dump_state	.\ofproto\ofproto-dpif.c	/^struct port_dump_state {$/;"	s	file:
port_elem	.\vswitchd\bridge.c	/^    struct list port_elem;      \/* Element in struct port's "ifaces" list. *\/$/;"	m	struct:iface	typeref:struct:iface::list	file:
port_fault_status	.\lib\vtep-idl.h	/^	char **port_fault_status;$/;"	m	struct:vteprec_physical_port
port_get_pid	.\lib\dpif-provider.h	/^    uint32_t (*port_get_pid)(const struct dpif *dpif, odp_port_t port_no,$/;"	m	struct:dpif_class
port_get_stats	.\ofproto\ofproto-dpif.c	/^port_get_stats(const struct ofport *ofport_, struct netdev_stats *stats)$/;"	f	file:
port_get_stats	.\ofproto\ofproto-provider.h	/^    int (*port_get_stats)(const struct ofport *port,$/;"	m	struct:ofproto_class
port_id	.\lib\lacp.c	/^    uint16_t port_id;             \/* Port ID. *\/$/;"	m	struct:slave	file:
port_id	.\lib\netdev-dpdk.c	/^    int port_id;$/;"	m	struct:netdev_dpdk	file:
port_id	.\lib\netdev-dpdk.c	/^    int port_id;$/;"	m	struct:netdev_rxq_dpdk	file:
port_id	.\lib\stp.c	/^    int port_id;                    \/* 8.5.5.1: Unique port identifier. *\/$/;"	m	struct:stp_port	file:
port_id	.\ofproto\ofproto.h	/^    int port_id;$/;"	m	struct:ofproto_port_stp_status
port_is_bond_fake_iface	.\vswitchd\bridge.c	/^port_is_bond_fake_iface(const struct port *port)$/;"	f	file:
port_is_fake_bridge	.\utilities\ovs-vsctl.c	/^port_is_fake_bridge(const struct ovsrec_port *port_cfg)$/;"	f	file:
port_is_lacp_current	.\ofproto\ofproto-dpif.c	/^port_is_lacp_current(const struct ofport *ofport_)$/;"	f	file:
port_is_lacp_current	.\ofproto\ofproto-provider.h	/^    int (*port_is_lacp_current)(const struct ofport *port);$/;"	m	struct:ofproto_class
port_is_synthetic	.\vswitchd\bridge.c	/^port_is_synthetic(const struct port *port)$/;"	f	file:
port_lookup	.\vswitchd\bridge.c	/^port_lookup(const struct bridge *br, const char *name)$/;"	f	file:
port_modified	.\ofproto\ofproto-dpif.c	/^port_modified(struct ofport *port_)$/;"	f	file:
port_modified	.\ofproto\ofproto-provider.h	/^    void (*port_modified)(struct ofport *ofport);$/;"	m	struct:ofproto_class
port_no	.\datapath\vport.h	/^	u16 port_no;$/;"	m	struct:vport
port_no	.\datapath\vport.h	/^	u16 port_no;$/;"	m	struct:vport_parms
port_no	.\include\openflow\openflow-1.0.h	/^    ovs_be16 port_no;        \/* All ports if OFPP_ALL. *\/$/;"	m	struct:ofp10_queue_stats_request
port_no	.\include\openflow\openflow-1.0.h	/^    ovs_be16 port_no;        \/* OFPST_PORT message may request statistics$/;"	m	struct:ofp10_port_stats_request
port_no	.\include\openflow\openflow-1.0.h	/^    ovs_be16 port_no;$/;"	m	struct:ofp10_phy_port
port_no	.\include\openflow\openflow-1.0.h	/^    ovs_be16 port_no;$/;"	m	struct:ofp10_port_mod
port_no	.\include\openflow\openflow-1.0.h	/^    ovs_be16 port_no;$/;"	m	struct:ofp10_port_stats
port_no	.\include\openflow\openflow-1.0.h	/^    ovs_be16 port_no;$/;"	m	struct:ofp10_queue_stats
port_no	.\include\openflow\openflow-1.1.h	/^    ovs_be32 port_no;         \/* All ports if OFPP_ANY. *\/$/;"	m	struct:ofp11_queue_stats_request
port_no	.\include\openflow\openflow-1.1.h	/^    ovs_be32 port_no;        \/* OFPST_PORT message must request statistics$/;"	m	struct:ofp11_port_stats_request
port_no	.\include\openflow\openflow-1.1.h	/^    ovs_be32 port_no;$/;"	m	struct:ofp11_port
port_no	.\include\openflow\openflow-1.1.h	/^    ovs_be32 port_no;$/;"	m	struct:ofp11_port_mod
port_no	.\include\openflow\openflow-1.1.h	/^    ovs_be32 port_no;$/;"	m	struct:ofp11_port_stats
port_no	.\include\openflow\openflow-1.1.h	/^    ovs_be32 port_no;$/;"	m	struct:ofp11_queue_stats
port_no	.\include\openflow\openflow-1.4.h	/^    ovs_be32 port_no;$/;"	m	struct:ofp14_port
port_no	.\include\openflow\openflow-1.4.h	/^    ovs_be32 port_no;$/;"	m	struct:ofp14_port_mod
port_no	.\include\openflow\openflow-1.4.h	/^    ovs_be32 port_no;$/;"	m	struct:ofp14_port_stats
port_no	.\lib\dpif-linux.h	/^    odp_port_t port_no;                    \/* ODPP_NONE if unknown. *\/$/;"	m	struct:dpif_linux_vport
port_no	.\lib\dpif-netdev.c	/^    odp_port_t port_no;$/;"	m	struct:dp_netdev_port	file:
port_no	.\lib\dpif.h	/^    odp_port_t port_no;         \/* Port number within datapath. *\/$/;"	m	struct:dpif_port
port_no	.\lib\learning-switch.c	/^    ofp_port_t port_no;         \/* OpenFlow port number. *\/$/;"	m	struct:lswitch_port	file:
port_no	.\lib\odp-util.h	/^    odp_port_t port_no;         \/* Port number in the datapath. *\/$/;"	m	struct:odp_portno_names
port_no	.\lib\ofp-util.h	/^    ofp_port_t port_no;           \/* OFPP_ANY means "all ports". *\/$/;"	m	struct:ofputil_queue_stats_request
port_no	.\lib\ofp-util.h	/^    ofp_port_t port_no;$/;"	m	struct:ofputil_phy_port
port_no	.\lib\ofp-util.h	/^    ofp_port_t port_no;$/;"	m	struct:ofputil_port_mod
port_no	.\lib\ofp-util.h	/^    ofp_port_t port_no;$/;"	m	struct:ofputil_port_stats
port_no	.\lib\ofp-util.h	/^    ofp_port_t port_no;$/;"	m	struct:ofputil_queue_stats
port_no	.\ofproto\pinsched.c	/^    ofp_port_t port_no;           \/* Port number. *\/$/;"	m	struct:pinqueue	file:
port_no	.\tests\test-stp.c	/^    int port_no;$/;"	m	struct:bpdu	file:
port_no	.\tests\test-stp.c	/^    int port_no;$/;"	m	struct:lan_conn	file:
port_notifier	.\lib\dpif-linux.c	/^    struct nl_sock *port_notifier; \/* vport multicast group subscriber. *\/$/;"	m	struct:dpif_linux	typeref:struct:dpif_linux::nl_sock	file:
port_num	.\ofproto\ofproto.h	/^    uint8_t port_num;           \/* In the range 1-255, inclusive. *\/$/;"	m	struct:ofproto_port_stp_settings
port_open_type	.\lib\dpif-provider.h	/^    const char *(*port_open_type)(const struct dpif_class *dpif_class,$/;"	m	struct:dpif_class
port_open_type	.\ofproto\ofproto-dpif.c	/^port_open_type(const char *datapath_type, const char *port_type)$/;"	f	file:
port_open_type	.\ofproto\ofproto-provider.h	/^    const char *(*port_open_type)(const char *datapath_type,$/;"	m	struct:ofproto_class
port_poll	.\lib\dpif-provider.h	/^    int (*port_poll)(const struct dpif *dpif, char **devnamep);$/;"	m	struct:dpif_class
port_poll	.\ofproto\ofproto-dpif.c	/^port_poll(const struct ofproto *ofproto_, char **devnamep)$/;"	f	file:
port_poll	.\ofproto\ofproto-provider.h	/^    int (*port_poll)(const struct ofproto *ofproto, char **devnamep);$/;"	m	struct:ofproto_class
port_poll_errno	.\ofproto\ofproto-dpif.c	/^    int port_poll_errno;           \/* Last errno for port_poll() reply. *\/$/;"	m	struct:ofproto_dpif	file:
port_poll_set	.\ofproto\ofproto-dpif.c	/^    struct sset port_poll_set;     \/* Queued names for port_poll() reply. *\/$/;"	m	struct:ofproto_dpif	typeref:struct:ofproto_dpif::sset	file:
port_poll_wait	.\lib\dpif-provider.h	/^    void (*port_poll_wait)(const struct dpif *dpif);$/;"	m	struct:dpif_class
port_poll_wait	.\ofproto\ofproto-dpif.c	/^port_poll_wait(const struct ofproto *ofproto_)$/;"	f	file:
port_poll_wait	.\ofproto\ofproto-provider.h	/^    void (*port_poll_wait)(const struct ofproto *ofproto);$/;"	m	struct:ofproto_class
port_priority	.\lib\lacp.c	/^    uint16_t port_priority;       \/* Port Priority. *\/$/;"	m	struct:slave	file:
port_query_by_name	.\lib\dpif-provider.h	/^    int (*port_query_by_name)(const struct dpif *dpif, const char *devname,$/;"	m	struct:dpif_class
port_query_by_name	.\ofproto\ofproto-dpif.c	/^port_query_by_name(const struct ofproto *ofproto_, const char *devname,$/;"	f	file:
port_query_by_name	.\ofproto\ofproto-provider.h	/^    int (*port_query_by_name)(const struct ofproto *ofproto,$/;"	m	struct:ofproto_class
port_query_by_number	.\lib\dpif-provider.h	/^    int (*port_query_by_number)(const struct dpif *dpif, odp_port_t port_no,$/;"	m	struct:dpif_class
port_queues	.\lib\learning-switch.h	/^    const struct simap *port_queues;$/;"	m	struct:lswitch_config	typeref:struct:lswitch_config::simap
port_queues	.\tests\test-controller.c	/^static struct simap port_queues = SIMAP_INITIALIZER(&port_queues);$/;"	v	typeref:struct:simap	file:
port_reconfigured	.\ofproto\ofproto-dpif.c	/^port_reconfigured(struct ofport *port_, enum ofputil_port_config old_config)$/;"	f	file:
port_reconfigured	.\ofproto\ofproto-provider.h	/^    void (*port_reconfigured)(struct ofport *ofport,$/;"	m	struct:ofproto_class
port_ref	.\lib\dpif-netdev.c	/^port_ref(struct dp_netdev_port *port)$/;"	f	file:
port_refresh_bond_status	.\vswitchd\bridge.c	/^port_refresh_bond_status(struct port *port, bool force_update)$/;"	f	file:
port_refresh_stp_stats	.\vswitchd\bridge.c	/^port_refresh_stp_stats(struct port *port)$/;"	f	file:
port_refresh_stp_status	.\vswitchd\bridge.c	/^port_refresh_stp_status(struct port *port)$/;"	f	file:
port_run	.\ofproto\ofproto-dpif.c	/^port_run(struct ofport_dpif *ofport)$/;"	f	file:
port_rwlock	.\lib\dpif-netdev.c	/^    struct ovs_rwlock port_rwlock;$/;"	m	struct:dp_netdev	typeref:struct:dp_netdev::ovs_rwlock	file:
port_seq	.\lib\dpif-netdev.c	/^    struct seq *port_seq;       \/* Incremented whenever a port changes. *\/$/;"	m	struct:dp_netdev	typeref:struct:dp_netdev::seq	file:
port_status_mask	.\include\openflow\nicira-ext.h	/^    ovs_be32 port_status_mask[2];  \/* Bitmasks of OFPRR_* values. *\/$/;"	m	struct:nx_async_config
port_status_mask	.\include\openflow\openflow-1.3.h	/^    ovs_be32 port_status_mask[2]; \/* Bitmasks of OFPPR_* values. *\/$/;"	m	struct:ofp13_action_self_learning::ofp13_async_config
port_unref	.\lib\dpif-netdev.c	/^port_unref(struct dp_netdev_port *port)$/;"	f	file:
port_vlan_mode	.\ofproto\ofproto.h	/^enum port_vlan_mode {$/;"	g
portid	.\datapath\datapath.h	/^	u32 portid;$/;"	m	struct:dp_upcall_info
portid	.\datapath\linux\compat\include\net\genetlink.h	17;"	d
ports	.\datapath\datapath.h	/^	struct hlist_head *ports;$/;"	m	struct:datapath	typeref:struct:datapath::hlist_head
ports	.\datapath\linux\compat\include\net\flow_keys.h	/^		__be32 ports;$/;"	m	union:flow_keys::__anon15
ports	.\lib\stp.c	/^    struct stp_port ports[STP_MAX_PORTS];$/;"	m	struct:stp	typeref:struct:stp::stp_port	file:
ports	.\lib\vswitch-idl.h	/^	struct ovsrec_port **ports;$/;"	m	struct:ovsrec_bridge	typeref:struct:ovsrec_bridge::ovsrec_port
ports	.\lib\vtep-idl.h	/^	struct vteprec_physical_port **ports;$/;"	m	struct:vteprec_physical_switch	typeref:struct:vteprec_physical_switch::vteprec_physical_port
ports	.\ofproto\ofproto-dpif-sflow.c	/^    struct hmap ports;          \/* Contains "struct dpif_sflow_port"s. *\/$/;"	m	struct:dpif_sflow	typeref:struct:dpif_sflow::hmap	file:
ports	.\ofproto\ofproto-dpif.c	/^    struct list ports;          \/* Contains "struct ofport"s. *\/$/;"	m	struct:ofbundle	typeref:struct:ofbundle::list	file:
ports	.\ofproto\ofproto-dpif.c	/^    struct sset ports;             \/* Set of standard port names. *\/$/;"	m	struct:ofproto_dpif	typeref:struct:ofproto_dpif::sset	file:
ports	.\ofproto\ofproto-provider.h	/^    struct hmap ports;          \/* Contains "struct ofport"s. *\/$/;"	m	struct:ofproto	typeref:struct:ofproto::hmap
ports	.\tests\test-stp.c	/^    struct lan *ports[STP_MAX_PORTS];$/;"	m	struct:bridge	typeref:struct:bridge::lan	file:
ports	.\utilities\ovs-vsctl.c	/^    struct list ports;          \/* Contains "struct vsctl_port"s. *\/$/;"	m	struct:vsctl_bridge	typeref:struct:vsctl_bridge::list	file:
ports	.\utilities\ovs-vsctl.c	/^    struct shash ports;     \/* Maps from port name to struct vsctl_port. *\/$/;"	m	struct:vsctl_context	typeref:struct:vsctl_context::shash	file:
ports	.\vswitchd\bridge.c	/^    struct hmap ports;          \/* "struct port"s indexed by name. *\/$/;"	m	struct:bridge	typeref:struct:bridge::hmap	file:
ports	.\vtep\vtep-ctl.c	/^    struct list ports;          \/* Contains "struct vteprec_physical_port"s. *\/$/;"	m	struct:vtep_ctl_pswitch	typeref:struct:vtep_ctl_pswitch::list	file:
ports	.\vtep\vtep-ctl.c	/^    struct shash ports;     \/* Maps from port name to struct vtep_ctl_port. *\/$/;"	m	struct:vtep_ctl_context	typeref:struct:vtep_ctl_context::shash	file:
ports_mask_len	.\lib\classifier.c	/^    int ports_mask_len;$/;"	m	struct:cls_subtable	file:
ports_node	.\utilities\ovs-vsctl.c	/^    struct list ports_node;     \/* In struct vsctl_bridge's 'ports' list. *\/$/;"	m	struct:vsctl_port	typeref:struct:vsctl_port::list	file:
ports_node	.\vtep\vtep-ctl.c	/^    struct list ports_node;     \/* In struct vtep_ctl_pswitch's 'ports' list. *\/$/;"	m	struct:vtep_ctl_port	typeref:struct:vtep_ctl_port::list	file:
ports_trie	.\lib\classifier.c	/^    struct trie_node *ports_trie; \/* NULL if none. *\/$/;"	m	struct:cls_subtable	typeref:struct:cls_subtable::trie_node	file:
pos	.\tests\test-stp.c	/^static char *pos, *token;$/;"	v	file:
post	.\xenserver\opt_xensource_libexec_InterfaceReconfigure.py	/^    def post(self):$/;"	m	class:Datapath
post	.\xenserver\opt_xensource_libexec_InterfaceReconfigureBridge.py	/^    def post(self):$/;"	m	class:DatapathBridge
post	.\xenserver\opt_xensource_libexec_InterfaceReconfigureVswitch.py	/^    def post(self):$/;"	m	class:DatapathVswitch
post_create	.\utilities\ovs-vsctl.c	/^post_create(struct vsctl_context *ctx)$/;"	f	file:
post_create	.\vtep\vtep-ctl.c	/^post_create(struct vtep_ctl_context *ctx)$/;"	f	file:
post_db_reload_check_init	.\utilities\ovs-vsctl.c	/^post_db_reload_check_init(void)$/;"	f	file:
post_db_reload_do_checks	.\utilities\ovs-vsctl.c	/^post_db_reload_do_checks(const struct vsctl_context *ctx)$/;"	f	file:
post_db_reload_expect_iface	.\utilities\ovs-vsctl.c	/^post_db_reload_expect_iface(const struct ovsrec_interface *iface)$/;"	f	file:
post_doit	.\datapath\linux\compat\include\net\genetlink.h	/^	void                    (*post_doit)(const struct genl_ops *ops,$/;"	m	struct:rpl_genl_family
postfork	.\python\ovs\timeval.py	/^def postfork():$/;"	f
postprocess	.\utilities\ovs-vsctl.c	/^    void (*postprocess)(struct vsctl_context *ctx);$/;"	m	struct:vsctl_command_syntax	file:
postprocess	.\vtep\vtep-ctl.c	/^    void (*postprocess)(struct vtep_ctl_context *ctx);$/;"	m	struct:vtep_ctl_command_syntax	file:
pp	.\ofproto\ofproto-provider.h	/^    struct ofputil_phy_port pp;$/;"	m	struct:ofport	typeref:struct:ofport::ofputil_phy_port
ppid	.\vswitchd\system-stats.c	/^    pid_t ppid;                 \/* Parent. *\/$/;"	m	struct:raw_process_info	file:
pr_alert_once	.\datapath\linux\compat\include\linux\kernel.h	32;"	d
pr_cont_once	.\datapath\linux\compat\include\linux\kernel.h	44;"	d
pr_crit_once	.\datapath\linux\compat\include\linux\kernel.h	34;"	d
pr_emerg_once	.\datapath\linux\compat\include\linux\kernel.h	30;"	d
pr_err_once	.\datapath\linux\compat\include\linux\kernel.h	36;"	d
pr_fmt	.\datapath\actions.c	19;"	d	file:
pr_fmt	.\datapath\datapath.c	19;"	d	file:
pr_fmt	.\datapath\flow_netlink.c	19;"	d	file:
pr_fmt	.\datapath\linux\compat\ip_tunnels_core.c	20;"	d	file:
pr_fmt	.\datapath\linux\compat\skbuff-openvswitch.c	7;"	d	file:
pr_fmt	.\datapath\linux\compat\vxlan.c	23;"	d	file:
pr_fmt	.\datapath\vport-gre.c	21;"	d	file:
pr_fmt	.\datapath\vport-lisp.c	20;"	d	file:
pr_fmt	.\datapath\vport-netdev.c	19;"	d	file:
pr_fmt	.\datapath\vport-vxlan.c	20;"	d	file:
pr_info_once	.\datapath\linux\compat\include\linux\kernel.h	42;"	d
pr_notice_once	.\datapath\linux\compat\include\linux\kernel.h	40;"	d
pr_rule	.\ofproto\bond.c	/^    struct rule **pr_rule;$/;"	m	struct:bond_pr_rule_op	typeref:struct:bond_pr_rule_op::rule	file:
pr_rule	.\ofproto\bond.c	/^    struct rule *pr_rule;$/;"	m	struct:bond_entry	typeref:struct:bond_entry::rule	file:
pr_rule_ops	.\ofproto\bond.c	/^    struct hmap pr_rule_ops;     \/* Helps to maintain post recirculation rules.*\/$/;"	m	struct:bond	typeref:struct:bond::hmap	file:
pr_warn	.\datapath\linux\compat\include\linux\kernel.h	12;"	d
pr_warn_once	.\datapath\linux\compat\include\linux\kernel.h	38;"	d
prandom_u32	.\datapath\linux\compat\include\linux\random.h	7;"	d
pre_cmd_add	.\utilities\ovs-vsctl.c	/^pre_cmd_add(struct vsctl_context *ctx)$/;"	f	file:
pre_cmd_add	.\vtep\vtep-ctl.c	/^pre_cmd_add(struct vtep_ctl_context *ctx)$/;"	f	file:
pre_cmd_br_get_external_id	.\utilities\ovs-vsctl.c	/^pre_cmd_br_get_external_id(struct vsctl_context *ctx)$/;"	f	file:
pre_cmd_br_set_external_id	.\utilities\ovs-vsctl.c	/^pre_cmd_br_set_external_id(struct vsctl_context *ctx)$/;"	f	file:
pre_cmd_clear	.\utilities\ovs-vsctl.c	/^pre_cmd_clear(struct vsctl_context *ctx)$/;"	f	file:
pre_cmd_clear	.\vtep\vtep-ctl.c	/^pre_cmd_clear(struct vtep_ctl_context *ctx)$/;"	f	file:
pre_cmd_del_ssl	.\utilities\ovs-vsctl.c	/^pre_cmd_del_ssl(struct vsctl_context *ctx)$/;"	f	file:
pre_cmd_destroy	.\utilities\ovs-vsctl.c	/^pre_cmd_destroy(struct vsctl_context *ctx)$/;"	f	file:
pre_cmd_destroy	.\vtep\vtep-ctl.c	/^pre_cmd_destroy(struct vtep_ctl_context *ctx)$/;"	f	file:
pre_cmd_emer_reset	.\utilities\ovs-vsctl.c	/^pre_cmd_emer_reset(struct vsctl_context *ctx)$/;"	f	file:
pre_cmd_find	.\utilities\ovs-vsctl.c	/^pre_cmd_find(struct vsctl_context *ctx)$/;"	f	file:
pre_cmd_find	.\vtep\vtep-ctl.c	/^pre_cmd_find(struct vtep_ctl_context *ctx)$/;"	f	file:
pre_cmd_get	.\utilities\ovs-vsctl.c	/^pre_cmd_get(struct vsctl_context *ctx)$/;"	f	file:
pre_cmd_get	.\vtep\vtep-ctl.c	/^pre_cmd_get(struct vtep_ctl_context *ctx)$/;"	f	file:
pre_cmd_get_ssl	.\utilities\ovs-vsctl.c	/^pre_cmd_get_ssl(struct vsctl_context *ctx)$/;"	f	file:
pre_cmd_list	.\utilities\ovs-vsctl.c	/^pre_cmd_list(struct vsctl_context *ctx)$/;"	f	file:
pre_cmd_list	.\vtep\vtep-ctl.c	/^pre_cmd_list(struct vtep_ctl_context *ctx)$/;"	f	file:
pre_cmd_remove	.\utilities\ovs-vsctl.c	/^pre_cmd_remove(struct vsctl_context *ctx)$/;"	f	file:
pre_cmd_remove	.\vtep\vtep-ctl.c	/^pre_cmd_remove(struct vtep_ctl_context *ctx)$/;"	f	file:
pre_cmd_set	.\utilities\ovs-vsctl.c	/^pre_cmd_set(struct vsctl_context *ctx)$/;"	f	file:
pre_cmd_set	.\vtep\vtep-ctl.c	/^pre_cmd_set(struct vtep_ctl_context *ctx)$/;"	f	file:
pre_cmd_set_ssl	.\utilities\ovs-vsctl.c	/^pre_cmd_set_ssl(struct vsctl_context *ctx)$/;"	f	file:
pre_cmd_show	.\utilities\ovs-vsctl.c	/^pre_cmd_show(struct vsctl_context *ctx)$/;"	f	file:
pre_cmd_wait_until	.\utilities\ovs-vsctl.c	/^pre_cmd_wait_until(struct vsctl_context *ctx)$/;"	f	file:
pre_cmd_wait_until	.\vtep\vtep-ctl.c	/^pre_cmd_wait_until(struct vtep_ctl_context *ctx)$/;"	f	file:
pre_controller	.\utilities\ovs-vsctl.c	/^pre_controller(struct vsctl_context *ctx)$/;"	f	file:
pre_create	.\utilities\ovs-vsctl.c	/^pre_create(struct vsctl_context *ctx)$/;"	f	file:
pre_create	.\vtep\vtep-ctl.c	/^pre_create(struct vtep_ctl_context *ctx)$/;"	f	file:
pre_doit	.\datapath\linux\compat\include\net\genetlink.h	/^	int                     (*pre_doit)(const struct genl_ops *ops,$/;"	m	struct:rpl_genl_family
pre_get_column	.\utilities\ovs-vsctl.c	/^pre_get_column(struct vsctl_context *ctx,$/;"	f	file:
pre_get_column	.\vtep\vtep-ctl.c	/^pre_get_column(struct vtep_ctl_context *ctx,$/;"	f	file:
pre_get_info	.\utilities\ovs-vsctl.c	/^pre_get_info(struct vsctl_context *ctx)$/;"	f	file:
pre_get_info	.\vtep\vtep-ctl.c	/^pre_get_info(struct vtep_ctl_context *ctx)$/;"	f	file:
pre_get_table	.\utilities\ovs-vsctl.c	/^pre_get_table(struct vsctl_context *ctx, const char *table_name)$/;"	f	file:
pre_get_table	.\vtep\vtep-ctl.c	/^pre_get_table(struct vtep_ctl_context *ctx, const char *table_name)$/;"	f	file:
pre_list_columns	.\utilities\ovs-vsctl.c	/^pre_list_columns(struct vsctl_context *ctx,$/;"	f	file:
pre_list_columns	.\vtep\vtep-ctl.c	/^pre_list_columns(struct vtep_ctl_context *ctx,$/;"	f	file:
pre_manager	.\utilities\ovs-vsctl.c	/^pre_manager(struct vsctl_context *ctx)$/;"	f	file:
pre_manager	.\vtep\vtep-ctl.c	/^pre_manager(struct vtep_ctl_context *ctx)$/;"	f	file:
pre_parse_column_key_value	.\utilities\ovs-vsctl.c	/^pre_parse_column_key_value(struct vsctl_context *ctx,$/;"	f	file:
pre_parse_column_key_value	.\vtep\vtep-ctl.c	/^pre_parse_column_key_value(struct vtep_ctl_context *ctx,$/;"	f	file:
prec_level	.\include\openflow\openflow-1.3.h	/^    uint8_t     prec_level;  \/* Number of drop precedence level to add. *\/$/;"	m	struct:ofp13_action_self_learning::ofp13_meter_band_dscp_remark
prec_level	.\lib\ofp-util.h	/^    uint8_t prec_level;         \/* Non-zero if type == OFPMBT_DSCP_REMARK. *\/$/;"	m	struct:ofputil_meter_band
preconfigure	.\xenserver\opt_xensource_libexec_InterfaceReconfigure.py	/^    def preconfigure(self, parent):$/;"	m	class:Datapath
preconfigure	.\xenserver\opt_xensource_libexec_InterfaceReconfigureBridge.py	/^    def preconfigure(self, parent):$/;"	m	class:DatapathBridge
preconfigure	.\xenserver\opt_xensource_libexec_InterfaceReconfigureVswitch.py	/^    def preconfigure(self, parent):$/;"	m	class:DatapathVswitch
preferred_packet_in_format	.\utilities\ovs-ofctl.c	/^static int preferred_packet_in_format = -1;$/;"	v	file:
prefix	.\lib\classifier.c	/^    uint32_t prefix;           \/* Prefix bits for this node, MSB first. *\/$/;"	m	struct:trie_node	file:
prefix_equal_bits	.\lib\classifier.c	/^prefix_equal_bits(uint32_t prefix, unsigned int nbits, const ovs_be32 value[],$/;"	f	file:
prefix_fields	.\ofproto\ofproto.h	/^    enum mf_field_id prefix_fields[CLS_MAX_TRIES];$/;"	m	struct:ofproto_table_settings	typeref:enum:ofproto_table_settings::mf_field_id
prefixes	.\lib\vswitch-idl.h	/^	char **prefixes;$/;"	m	struct:ovsrec_flow_table
prepare_dump_flows	.\utilities\ovs-ofctl.c	/^prepare_dump_flows(int argc, char *argv[], bool aggregate,$/;"	f	file:
prereqs	.\lib\meta-flow.h	/^    enum mf_prereqs prereqs;$/;"	m	struct:mf_field	typeref:enum:mf_field::mf_prereqs
prereqs	.\lib\ovsdb-idl-provider.h	/^    unsigned long int *prereqs; \/* Bitmap of columns to verify in "old". *\/$/;"	m	struct:ovsdb_idl_row
prerequisites	.\utilities\ovs-vsctl.c	/^    void (*prerequisites)(struct vsctl_context *ctx);$/;"	m	struct:vsctl_command_syntax	file:
prerequisites	.\vtep\vtep-ctl.c	/^    void (*prerequisites)(struct vtep_ctl_context *ctx);$/;"	m	struct:vtep_ctl_command_syntax	file:
pretty	.\tests\test-json.c	/^static int pretty = 0;$/;"	v	file:
prev	.\lib\list.h	/^    struct list *prev;     \/* Previous list element. *\/$/;"	m	struct:list	typeref:struct:list::list
prev_offset	.\ovsdb\log.c	/^    off_t prev_offset;$/;"	m	struct:ovsdb_log	file:
print_and_free	.\lib\ofp-print.c	/^print_and_free(FILE *stream, char *string)$/;"	f	file:
print_and_free_json	.\ovsdb\ovsdb-client.c	/^print_and_free_json(struct json *json)$/;"	f	file:
print_and_free_json	.\ovsdb\ovsdb-tool.c	/^print_and_free_json(struct json *json)$/;"	f	file:
print_and_free_json	.\tests\test-json.c	/^print_and_free_json(struct json *json)$/;"	f	file:
print_and_free_json	.\tests\test-jsonrpc.c	/^print_and_free_json(struct json *json)$/;"	f	file:
print_and_free_json	.\tests\test-ovsdb.c	/^print_and_free_json(struct json *json)$/;"	f	file:
print_and_free_ovsdb_error	.\tests\test-ovsdb.c	/^print_and_free_ovsdb_error(struct ovsdb_error *error)$/;"	f	file:
print_db_changes	.\ovsdb\ovsdb-tool.c	/^print_db_changes(struct shash *tables, struct shash *names,$/;"	f	file:
print_dec_ttl	.\lib\ofp-actions.c	/^print_dec_ttl(const struct ofpact_cnt_ids *ids,$/;"	f	file:
print_differences	.\utilities\ovs-ofctl.c	/^print_differences(const char *prefix,$/;"	f	file:
print_fin_timeout	.\lib\ofp-actions.c	/^print_fin_timeout(const struct ofpact_fin_timeout *fin_timeout,$/;"	f	file:
print_heap	.\tests\test-heap.c	/^print_heap(const char *name, struct heap *heap)$/;"	f	file:
print_help	.\python\compat\argparse.py	/^    def print_help(self, file=None):$/;"	m	class:ArgumentParser
print_hex	.\tests\test-sflow.c	/^print_hex(const char *a, int len, char *buf, int bufLen)$/;"	f	file:
print_hindex	.\tests\test-hindex.c	/^print_hindex(const char *name, struct hindex *hindex)$/;"	f	file:
print_human_size	.\utilities\ovs-dpctl.c	/^print_human_size(uint64_t value)$/;"	f	file:
print_idl	.\tests\test-ovsdb.c	/^print_idl(struct ovsdb_idl *idl, int step)$/;"	f	file:
print_idl	.\tests\test-ovsdb.py	/^def print_idl(idl, step):$/;"	f
print_ints	.\tests\test-hindex.c	/^print_ints(const char *name, const int *values, size_t n)$/;"	f	file:
print_ip_netmask	.\lib\ofp-print.c	/^print_ip_netmask(struct ds *string, const char *leader, ovs_be32 ip,$/;"	f	file:
print_ipv6_addr	.\lib\packets.c	/^print_ipv6_addr(struct ds *string, const struct in6_addr *addr)$/;"	f
print_ipv6_masked	.\lib\packets.c	/^print_ipv6_masked(struct ds *s, const struct in6_addr *addr,$/;"	f
print_json	.\ovsdb\ovsdb-client.c	/^print_json(struct json *json)$/;"	f	file:
print_json	.\tests\test-json.py	/^def print_json(json):$/;"	f
print_netflow	.\tests\test-netflow.c	/^print_netflow(struct ofpbuf *buf)$/;"	f	file:
print_note	.\lib\ofp-actions.c	/^print_note(const struct ofpact_note *note, struct ds *string)$/;"	f	file:
print_port_stat	.\lib\ofp-print.c	/^print_port_stat(struct ds *string, const char *leader, uint64_t stat, int more)$/;"	f	file:
print_queue_rate	.\lib\ofp-print.c	/^print_queue_rate(struct ds *string, const char *name, unsigned int rate)$/;"	f	file:
print_sflow	.\tests\test-sflow.c	/^print_sflow(struct ofpbuf *buf)$/;"	f	file:
print_stat	.\utilities\ovs-dpctl.c	/^print_stat(const char *leader, uint64_t value)$/;"	f	file:
print_statistics	.\utilities\ovs-dpctl.c	/^static bool print_statistics;$/;"	v	file:
print_table_action_features	.\lib\ofp-print.c	/^print_table_action_features(struct ds *s,$/;"	f	file:
print_table_instruction_features	.\lib\ofp-print.c	/^print_table_instruction_features($/;"	f	file:
print_usage	.\python\compat\argparse.py	/^    def print_usage(self, file=None):$/;"	m	class:ArgumentParser
print_version	.\python\compat\argparse.py	/^    def print_version(self, file=None):$/;"	m	class:ArgumentParser
print_wild	.\lib\ofp-print.c	/^static void print_wild(struct ds *string, const char *leader, int is_wild,$/;"	f	file:
print_wild_port	.\lib\ofp-print.c	/^print_wild_port(struct ds *string, const char *leader, int is_wild,$/;"	f	file:
printk_once	.\datapath\linux\compat\include\linux\kernel.h	19;"	d
printk_once	.\datapath\linux\compat\include\linux\kernel.h	20;"	d
priority	.\datapath\flow.h	/^		u32	priority;	\/* Packet QoS priority. *\/$/;"	m	struct:sw_flow_key::__anon1
priority	.\datapath\linux\compat\include\net\gre.h	/^	u8 priority;$/;"	m	struct:gre_cisco_protocol
priority	.\include\openflow\nicira-ext.h	/^    ovs_be16 priority;            \/* Priority level of flow entry. *\/$/;"	m	struct:nx_flow_mod
priority	.\include\openflow\nicira-ext.h	/^    ovs_be16 priority;          \/* Priority level of flow entry. *\/$/;"	m	struct:nx_action_learn
priority	.\include\openflow\nicira-ext.h	/^    ovs_be16 priority;          \/* Priority of the entry. *\/$/;"	m	struct:nx_flow_update_full
priority	.\include\openflow\nicira-ext.h	/^    ovs_be16 priority;        \/* Priority level of flow entry. *\/$/;"	m	struct:nx_flow_removed
priority	.\include\openflow\nicira-ext.h	/^    ovs_be16 priority;        \/* Priority of the entry. *\/$/;"	m	struct:nx_flow_stats
priority	.\include\openflow\openflow-1.0.h	/^    ovs_be16 priority;            \/* Priority level of flow entry. *\/$/;"	m	struct:ofp10_flow_mod
priority	.\include\openflow\openflow-1.0.h	/^    ovs_be16 priority;        \/* Priority level of flow entry. *\/$/;"	m	struct:ofp10_flow_removed
priority	.\include\openflow\openflow-1.0.h	/^    ovs_be16 priority;        \/* Priority of the entry. Only meaningful$/;"	m	struct:ofp10_flow_stats
priority	.\include\openflow\openflow-1.1.h	/^    ovs_be16 priority;           \/* Priority level of flow entry. *\/$/;"	m	struct:ofp11_flow_mod
priority	.\include\openflow\openflow-1.1.h	/^    ovs_be16 priority;         \/* Priority of the entry. Only meaningful$/;"	m	struct:ofp11_flow_stats
priority	.\include\openflow\openflow-1.1.h	/^    ovs_be16 priority;        \/* Priority level of flow entry. *\/$/;"	m	struct:ofp11_flow_removed
priority	.\include\openflow\openflow-1.2.h	/^    ovs_be16 priority;        \/* Priority level of flow entry. *\/$/;"	m	struct:ofp12_flow_removed
priority	.\lib\classifier.c	/^    unsigned int priority;      \/* Larger numbers are higher priorities. *\/$/;"	m	struct:cls_match	file:
priority	.\lib\classifier.h	/^    unsigned int priority;       \/* Larger numbers are higher priorities. *\/$/;"	m	struct:cls_rule
priority	.\lib\heap.h	/^    uint64_t priority;$/;"	m	struct:heap_node
priority	.\lib\lacp.h	/^    uint16_t priority;                \/* Port priority. *\/$/;"	m	struct:lacp_slave_settings
priority	.\lib\lacp.h	/^    uint16_t priority;                \/* System priority. *\/$/;"	m	struct:lacp_settings
priority	.\lib\netdev-linux.c	/^    unsigned int priority;      \/* Lower values are higher priorities. *\/$/;"	m	struct:htb_class	file:
priority	.\lib\ofp-actions.h	/^    uint16_t priority;          \/* Priority level of flow entry. *\/$/;"	m	struct:ofpact_learn
priority	.\lib\ofp-util.h	/^    uint16_t priority;$/;"	m	struct:ofputil_flow_removed
priority	.\lib\ofp-util.h	/^    uint16_t priority;$/;"	m	struct:ofputil_flow_stats
priority	.\lib\ofp-util.h	/^    uint16_t priority;$/;"	m	struct:ofputil_flow_update
priority	.\lib\ofp-util.h	/^    unsigned int priority;$/;"	m	struct:ofputil_flow_mod
priority	.\lib\sflow.h	/^    u_int32_t priority;     \/* IP priority *\/$/;"	m	struct:_SFLSampled_ipv6
priority	.\ofproto\in-band.c	/^    unsigned int priority;$/;"	m	struct:in_band_rule	file:
priority	.\ofproto\ofproto.h	/^    uint16_t priority;$/;"	m	struct:ofproto_stp_settings
priority	.\ofproto\ofproto.h	/^    uint8_t priority;$/;"	m	struct:ofproto_port_stp_settings
private_key	.\lib\stream-ssl.c	/^static struct ssl_config_file private_key;$/;"	v	typeref:struct:ssl_config_file	file:
private_key	.\lib\vswitch-idl.h	/^	char *private_key;	\/* Always nonnull. *\/$/;"	m	struct:ovsrec_ssl
private_key_file	.\ovsdb\ovsdb-server.c	/^static char *private_key_file;$/;"	v	file:
probability	.\include\openflow\nicira-ext.h	/^    ovs_be16 probability;           \/* Fraction of packets to sample. *\/$/;"	m	struct:nx_action_sample
probability	.\lib\odp-util.h	/^        uint16_t probability;   \/* Sampling probability. *\/$/;"	m	struct:user_action_cookie::__anon71
probability	.\lib\ofp-actions.h	/^    uint16_t probability;  \/\/ Always >0.$/;"	m	struct:ofpact_sample
probability	.\ofproto\ofproto-dpif-ipfix.c	/^    uint32_t probability;$/;"	m	struct:dpif_ipfix_bridge_exporter	file:
probability	.\ofproto\ofproto-dpif-sflow.c	/^    uint32_t probability;$/;"	m	struct:dpif_sflow	file:
probably_admitted	.\lib\rconn.c	/^    bool probably_admitted;$/;"	m	struct:rconn	file:
probe_interval	.\lib\rconn.c	/^    int probe_interval;         \/* Secs of inactivity before sending probe. *\/$/;"	m	struct:rconn	file:
probe_interval	.\lib\reconnect.c	/^    int probe_interval;$/;"	m	struct:reconnect	file:
probe_interval	.\ofproto\connmgr.c	/^    int probe_interval;         \/* Max idle time before probing, in seconds. *\/$/;"	m	struct:ofservice	file:
probe_interval	.\ofproto\ofproto.h	/^    int probe_interval;         \/* Max idle time before probing, in seconds. *\/$/;"	m	struct:ofproto_controller
probe_interval	.\ovsdb\jsonrpc-server.h	/^    int probe_interval;         \/* Max idle time before probing, in msec. *\/$/;"	m	struct:ovsdb_jsonrpc_options
proc_pkt	.\lib\netdev-bsd.c	/^proc_pkt(u_char *args_, const struct pcap_pkthdr *hdr, const u_char *packet)$/;"	f	file:
process	.\lib\process.c	/^VLOG_DEFINE_THIS_MODULE(process);$/;"	v
process	.\lib\process.c	/^struct process {$/;"	s	file:
process	.\python\ovs\daemon.py	/^import ovs.process$/;"	i
process_command	.\lib\unixctl.c	/^process_command(struct unixctl_conn *conn, struct jsonrpc_msg *request)$/;"	f	file:
process_counter_sample	.\tests\test-sflow.c	/^process_counter_sample(struct sflow_xdr *x)$/;"	f	file:
process_datagram	.\tests\test-sflow.c	/^process_datagram(struct sflow_xdr *x)$/;"	f	file:
process_destroy	.\lib\process.c	/^process_destroy(struct process *p)$/;"	f
process_dpif_all_ports_changed	.\ofproto\ofproto-dpif.c	/^process_dpif_all_ports_changed(struct dpif_backer *backer)$/;"	f	file:
process_dpif_port_change	.\ofproto\ofproto-dpif.c	/^process_dpif_port_change(struct dpif_backer *backer, const char *devname)$/;"	f	file:
process_dpif_port_changes	.\ofproto\ofproto-dpif.c	/^process_dpif_port_changes(struct dpif_backer *backer)$/;"	f	file:
process_dpif_port_error	.\ofproto\ofproto-dpif.c	/^process_dpif_port_error(struct dpif_backer *backer, int error)$/;"	f	file:
process_echo_request	.\lib\learning-switch.c	/^process_echo_request(struct lswitch *sw, const struct ofp_header *rq)$/;"	f	file:
process_escape_args	.\lib\process.c	/^process_escape_args(char **argv)$/;"	f
process_exited	.\lib\process.c	/^process_exited(struct process *p)$/;"	f
process_flow_sample	.\tests\test-sflow.c	/^process_flow_sample(struct sflow_xdr *x)$/;"	f	file:
process_info	.\vswitchd\system-stats.c	/^struct process_info {$/;"	s	file:
process_init	.\lib\process.c	/^process_init(void)$/;"	f
process_kill	.\lib\process.c	/^process_kill(const struct process *p, int signr)$/;"	f
process_name	.\lib\process.c	/^process_name(const struct process *p)$/;"	f
process_packet_in	.\lib\learning-switch.c	/^process_packet_in(struct lswitch *sw, const struct ofp_header *oh)$/;"	f	file:
process_pid	.\lib\process.c	/^process_pid(const struct process *p)$/;"	f
process_port_change	.\ofproto\ofproto.c	/^process_port_change(struct ofproto *ofproto, int error, char *devname)$/;"	f	file:
process_prestart	.\lib\process.c	/^process_prestart(char **argv)$/;"	f	file:
process_register	.\lib\process.c	/^process_register(const char *name, pid_t pid)$/;"	f	file:
process_run	.\lib\process.c	/^process_run(void)$/;"	f
process_search_path	.\lib\process.c	/^process_search_path(const char *name)$/;"	f
process_special	.\ofproto\ofproto-dpif-xlate.c	/^process_special(struct xlate_ctx *ctx, const struct flow *flow,$/;"	f	file:
process_start	.\lib\process.c	/^COVERAGE_DEFINE(process_start);$/;"	v
process_start	.\lib\process.c	/^process_start(char **argv, struct process **pp)$/;"	f
process_status	.\lib\process.c	/^process_status(const struct process *p)$/;"	f
process_status_msg	.\lib\process.c	/^process_status_msg(int status)$/;"	f
process_switch_features	.\lib\learning-switch.c	/^process_switch_features(struct lswitch *sw, struct ofp_header *oh)$/;"	f	file:
process_wait	.\lib\process.c	/^process_wait(struct process *p)$/;"	f
proctitle_init	.\lib\command-line.c	/^proctitle_init(int argc OVS_UNUSED, char **argv OVS_UNUSED)$/;"	f
proctitle_init	.\lib\command-line.c	/^proctitle_init(int argc, char **argv)$/;"	f
proctitle_mutex	.\lib\command-line.c	/^static struct ovs_mutex proctitle_mutex = OVS_MUTEX_INITIALIZER;$/;"	v	typeref:struct:ovs_mutex	file:
proctitle_restore	.\lib\command-line.c	/^proctitle_restore(void)$/;"	f
proctitle_set	.\lib\command-line.c	/^proctitle_set(const char *format OVS_UNUSED, ...)$/;"	f
proctitle_set	.\lib\command-line.c	/^proctitle_set(const char *format, ...)$/;"	f
proctitle_set	.\lib\command-line.h	38;"	d
program_name	.\lib\util.c	/^char *program_name;$/;"	v
program_version	.\lib\util.c	/^static char *program_version;$/;"	v	file:
prop_header	.\include\openflow\openflow-common.h	/^    struct ofp_queue_prop_header prop_header;$/;"	m	struct:ofp_queue_prop_rate	typeref:struct:ofp_queue_prop_rate::ofp_queue_prop_header
properties	.\include\openflow\openflow-1.4.h	/^    struct ofp14_async_config_prop_header properties[0];$/;"	m	struct:ofp14_async_config	typeref:struct:ofp14_async_config::ofp14_async_config_prop_header
property	.\include\openflow\openflow-common.h	/^    ovs_be16 property; \/* One of OFPQT_. *\/$/;"	m	struct:ofp_queue_prop_header
proto	.\datapath\flow.h	/^		u8     proto;		\/* IP protocol or lower 8 bits of ARP opcode. *\/$/;"	m	struct:sw_flow_key::__anon3
proto	.\datapath\linux\compat\include\net\ip_tunnels.h	/^	__be16 proto;$/;"	m	struct:tnl_ptk_info
proto_abbrev	.\lib\ofp-util.c	/^struct proto_abbrev {$/;"	s	file:
proto_abbrevs	.\lib\ofp-util.c	/^static const struct proto_abbrev proto_abbrevs[] = {$/;"	v	typeref:struct:proto_abbrev	file:
proto_ports_offset	.\datapath\linux\compat\include\linux\in.h	/^static inline int proto_ports_offset(int proto)$/;"	f
protocol	.\datapath\linux\compat\include\net\gre.h	/^	__be16 protocol;$/;"	m	struct:gre_base_hdr
protocol	.\lib\learning-switch.c	/^    enum ofputil_protocol protocol;$/;"	m	struct:lswitch	typeref:enum:lswitch::ofputil_protocol	file:
protocol	.\lib\netlink-notifier.c	/^    int protocol;                \/* Protocol passed to nl_sock_create(). *\/$/;"	m	struct:nln	file:
protocol	.\lib\netlink-socket.c	/^    int protocol;$/;"	m	struct:nl_sock	file:
protocol	.\lib\ofp-parse.c	/^struct protocol {$/;"	s	file:
protocol	.\lib\ofp-util.c	/^    enum ofputil_protocol protocol;$/;"	m	struct:proto_abbrev	typeref:enum:proto_abbrev::ofputil_protocol	file:
protocol	.\lib\sflow.h	/^    u_int32_t protocol;     \/* IP Protocol type (for example, TCP = 6, UDP = 17) *\/$/;"	m	struct:_SFLSampled_ipv6
protocol	.\lib\sflow.h	/^    u_int32_t protocol;    \/* IP Protocol type (for example, TCP = 6, UDP = 17) *\/$/;"	m	struct:_SFLSampled_ipv4
protocol	.\ofproto\connmgr.c	/^    enum ofputil_protocol protocol; \/* Current protocol variant. *\/$/;"	m	struct:ofconn	typeref:enum:ofconn::ofputil_protocol	file:
protocol	.\python\ovstest\tcp.py	/^    protocol = TcpListenerConnection$/;"	v	class:TcpListenerFactory
protocol	.\python\ovstest\tcp.py	/^    protocol = TcpSenderConnection$/;"	v	class:TcpSenderFactory
protocols	.\lib\vswitch-idl.h	/^	char **protocols;$/;"	m	struct:ovsrec_bridge
provider_meter_id	.\ofproto\ofproto-provider.h	/^    uint32_t provider_meter_id;   \/* Datapath meter_id, or UINT32_MAX. *\/$/;"	m	struct:rule_actions
provider_meter_id	.\ofproto\ofproto.c	/^    ofproto_meter_id provider_meter_id;$/;"	m	struct:meter	file:
ps	.\include\openflow\openflow-1.3.h	/^    struct ofp11_port_stats ps;$/;"	m	struct:ofp13_action_self_learning::ofp13_port_stats	typeref:struct:ofp13_action_self_learning::ofp13_port_stats::ofp11_port_stats
ps	.\vtep\vtep-ctl.c	/^    struct vtep_ctl_pswitch *ps;$/;"	m	struct:vtep_ctl_port	typeref:struct:vtep_ctl_port::vtep_ctl_pswitch	file:
ps_cfg	.\vtep\vtep-ctl.c	/^    const struct vteprec_physical_switch *ps_cfg;$/;"	m	struct:vtep_ctl_pswitch	typeref:struct:vtep_ctl_pswitch::vteprec_physical_switch	file:
pssl_accept	.\lib\stream-ssl.c	/^pssl_accept(struct pstream *pstream, struct stream **new_streamp)$/;"	f	file:
pssl_close	.\lib\stream-ssl.c	/^pssl_close(struct pstream *pstream)$/;"	f	file:
pssl_open	.\lib\stream-ssl.c	/^pssl_open(const char *name OVS_UNUSED, char *suffix, struct pstream **pstreamp,$/;"	f	file:
pssl_pstream	.\lib\stream-ssl.c	/^struct pssl_pstream$/;"	s	file:
pssl_pstream_cast	.\lib\stream-ssl.c	/^pssl_pstream_cast(struct pstream *pstream)$/;"	f	file:
pssl_pstream_class	.\lib\stream-ssl.c	/^const struct pstream_class pssl_pstream_class = {$/;"	v	typeref:struct:pstream_class
pssl_pstream_class	.\lib\stream-ssl.c	/^const struct pstream_class pssl_pstream_class;$/;"	v	typeref:struct:pstream_class
pssl_pvconn_class	.\lib\vconn-stream.c	/^const struct pvconn_class pssl_pvconn_class = PSTREAM_INIT("pssl");$/;"	v	typeref:struct:pvconn_class
pssl_set_dscp	.\lib\stream-ssl.c	/^pssl_set_dscp(struct pstream *pstream, uint8_t dscp)$/;"	f	file:
pssl_wait	.\lib\stream-ssl.c	/^pssl_wait(struct pstream *pstream)$/;"	f	file:
pstream	.\lib\jsonrpc.c	/^    struct pstream *pstream;$/;"	m	struct:jsonrpc_session	typeref:struct:jsonrpc_session::pstream	file:
pstream	.\lib\netdev-dummy.c	/^    struct pstream *pstream;$/;"	m	struct:dummy_packet_pconn	typeref:struct:dummy_packet_pconn::pstream	file:
pstream	.\lib\stream-fd-unix.c	/^    struct pstream pstream;$/;"	m	struct:fd_pstream	typeref:struct:fd_pstream::pstream	file:
pstream	.\lib\stream-fd-windows.c	/^    struct pstream pstream;$/;"	m	struct:fd_pstream	typeref:struct:fd_pstream::pstream	file:
pstream	.\lib\stream-provider.h	/^struct pstream {$/;"	s
pstream	.\lib\stream-ssl.c	/^    struct pstream pstream;$/;"	m	struct:pssl_pstream	typeref:struct:pssl_pstream::pstream	file:
pstream	.\lib\vconn-stream.c	/^    struct pstream *pstream;$/;"	m	struct:pvconn_pstream	typeref:struct:pvconn_pstream::pstream	file:
pstream	.\tests\test-vconn.c	/^    struct pstream *pstream;$/;"	m	struct:fake_pvconn	typeref:struct:fake_pvconn::pstream	file:
pstream_accept	.\lib\stream.c	/^pstream_accept(struct pstream *pstream, struct stream **new_stream)$/;"	f
pstream_accept_block	.\lib\stream.c	/^pstream_accept_block(struct pstream *pstream, struct stream **new_stream)$/;"	f
pstream_assert_class	.\lib\stream-provider.h	/^static inline void pstream_assert_class(const struct pstream *pstream,$/;"	f
pstream_class	.\lib\stream-provider.h	/^struct pstream_class {$/;"	s
pstream_classes	.\lib\stream.c	/^static const struct pstream_class *pstream_classes[] = {$/;"	v	typeref:struct:pstream_class	file:
pstream_close	.\lib\stream.c	/^pstream_close(struct pstream *pstream)$/;"	f
pstream_get_bound_port	.\lib\stream.c	/^pstream_get_bound_port(const struct pstream *pstream)$/;"	f
pstream_get_name	.\lib\stream.c	/^pstream_get_name(const struct pstream *pstream)$/;"	f
pstream_init	.\lib\stream.c	/^pstream_init(struct pstream *pstream, const struct pstream_class *class,$/;"	f
pstream_lookup_class	.\lib\stream.c	/^pstream_lookup_class(const char *name, const struct pstream_class **classp)$/;"	f	file:
pstream_open	.\lib\stream.c	/^COVERAGE_DEFINE(pstream_open);$/;"	v
pstream_open	.\lib\stream.c	/^pstream_open(const char *name, struct pstream **pstreamp, uint8_t dscp)$/;"	f
pstream_open_with_default_port	.\lib\stream.c	/^pstream_open_with_default_port(const char *name_,$/;"	f
pstream_pvconn_class	.\lib\vconn-stream.c	/^static const struct pvconn_class pstream_pvconn_class = PSTREAM_INIT("pstream");$/;"	v	typeref:struct:pvconn_class	file:
pstream_pvconn_class	.\lib\vconn-stream.c	/^static const struct pvconn_class pstream_pvconn_class;$/;"	v	typeref:struct:pvconn_class	file:
pstream_set_bound_port	.\lib\stream.c	/^pstream_set_bound_port(struct pstream *pstream, ovs_be16 port)$/;"	f
pstream_set_dscp	.\lib\stream.c	/^pstream_set_dscp(struct pstream *pstream, uint8_t dscp)$/;"	f
pstream_verify_name	.\lib\stream.c	/^pstream_verify_name(const char *name)$/;"	f
pstream_wait	.\lib\stream.c	/^pstream_wait(struct pstream *pstream)$/;"	f
pswitch_delete_port	.\vtep\vtep-ctl.c	/^pswitch_delete_port(const struct vteprec_physical_switch *ps,$/;"	f	file:
pswitch_insert_port	.\vtep\vtep-ctl.c	/^pswitch_insert_port(const struct vteprec_physical_switch *ps,$/;"	f	file:
pswitches	.\vtep\vtep-ctl.c	/^    struct shash pswitches; \/* Maps from physical switch name to$/;"	m	struct:vtep_ctl_context	typeref:struct:vtep_ctl_context::shash	file:
ptcp_accept	.\lib\stream-tcp.c	/^ptcp_accept(int fd, const struct sockaddr_storage *ss,$/;"	f	file:
ptcp_open	.\lib\stream-tcp.c	/^ptcp_open(const char *name OVS_UNUSED, char *suffix, struct pstream **pstreamp,$/;"	f	file:
ptcp_pstream_class	.\lib\stream-tcp.c	/^const struct pstream_class ptcp_pstream_class = {$/;"	v	typeref:struct:pstream_class
ptcp_pvconn_class	.\lib\vconn-stream.c	/^const struct pvconn_class ptcp_pvconn_class = PSTREAM_INIT("ptcp");$/;"	v	typeref:struct:pvconn_class
pull_table_feature_property	.\lib\ofp-util.c	/^pull_table_feature_property(struct ofpbuf *msg, struct ofpbuf *payload,$/;"	f	file:
punix_accept	.\lib\stream-unix.c	/^punix_accept(int fd, const struct sockaddr_storage *ss, size_t ss_len,$/;"	f	file:
punix_open	.\lib\stream-unix.c	/^punix_open(const char *name OVS_UNUSED, char *suffix,$/;"	f	file:
punix_pstream_class	.\lib\stream-unix.c	/^const struct pstream_class punix_pstream_class = {$/;"	v	typeref:struct:pstream_class
punix_pvconn_class	.\lib\vconn-stream.c	/^const struct pvconn_class punix_pvconn_class = PSTREAM_INIT("punix");$/;"	v	typeref:struct:pvconn_class
push	.\lib\ofp-actions.c	/^    struct ofp11_action_push push;$/;"	m	union:ofp_action	typeref:struct:ofp_action::ofp11_action_push	file:
push_dump_ops	.\ofproto\ofproto-dpif-upcall.c	/^push_dump_ops(struct revalidator *revalidator,$/;"	f	file:
push_dump_ops__	.\ofproto\ofproto-dpif-upcall.c	/^push_dump_ops__(struct udpif *udpif, struct dump_op *ops, size_t n_ops)$/;"	f	file:
push_mpls	.\lib\ofp-actions.c	/^    struct nx_action_push_mpls push_mpls;$/;"	m	union:ofp_action	typeref:struct:ofp_action::nx_action_push_mpls	file:
push_mpls	.\lib\packets.c	/^push_mpls(struct ofpbuf *packet, ovs_be16 ethtype, ovs_be32 lse)$/;"	f
push_mpls_from_openflow	.\lib\ofp-actions.c	/^push_mpls_from_openflow(ovs_be16 ethertype, struct ofpbuf *out)$/;"	f	file:
push_vlan	.\datapath\actions.c	/^static int push_vlan(struct sk_buff *skb, const struct ovs_action_push_vlan *vlan)$/;"	f	file:
push_vlan_if_needed	.\lib\ofp-actions.h	/^    bool push_vlan_if_needed;   \/* OF 1.0 semantics if true. *\/$/;"	m	struct:ofpact_vlan_pcp
push_vlan_if_needed	.\lib\ofp-actions.h	/^    bool push_vlan_if_needed;   \/* OF 1.0 semantics if true. *\/$/;"	m	struct:ofpact_vlan_vid
put	.\ofproto\ofproto-dpif-upcall.c	/^    bool put;$/;"	m	struct:flow_miss	file:
put128	.\lib\sflow_receiver.c	/^inline static void put128(SFLReceiver *receiver, u_char *val)$/;"	f	file:
put32	.\lib\sflow_receiver.c	/^inline static void put32(SFLReceiver *receiver, u_int32_t val)$/;"	f	file:
putAddress	.\lib\sflow_receiver.c	/^inline static void putAddress(SFLReceiver *receiver, SFLAddress *addr)$/;"	f	file:
putGateway	.\lib\sflow_receiver.c	/^inline static void putGateway(SFLReceiver *receiver, SFLExtended_gateway *gw)$/;"	f	file:
putGenericCounters	.\lib\sflow_receiver.c	/^inline static void putGenericCounters(SFLReceiver *receiver, SFLIf_counters *counters)$/;"	f	file:
putLabelStack	.\lib\sflow_receiver.c	/^inline static void putLabelStack(SFLReceiver *receiver, SFLLabelStack *labelStack)$/;"	f	file:
putMACAddress	.\lib\sflow_receiver.c	/^inline static void putMACAddress(SFLReceiver *receiver, u_int8_t *mac)$/;"	f	file:
putMpls	.\lib\sflow_receiver.c	/^inline static void putMpls(SFLReceiver *receiver, SFLExtended_mpls *mpls)$/;"	f	file:
putMplsFtn	.\lib\sflow_receiver.c	/^inline static void putMplsFtn(SFLReceiver *receiver, SFLExtended_mpls_FTN *ftn)$/;"	f	file:
putMplsLdpFec	.\lib\sflow_receiver.c	/^inline static void putMplsLdpFec(SFLReceiver *receiver, SFLExtended_mpls_LDP_FEC *ldpfec)$/;"	f	file:
putMplsTunnel	.\lib\sflow_receiver.c	/^inline static void putMplsTunnel(SFLReceiver *receiver, SFLExtended_mpls_tunnel *tunnel)$/;"	f	file:
putMplsVc	.\lib\sflow_receiver.c	/^inline static void putMplsVc(SFLReceiver *receiver, SFLExtended_mpls_vc *vc)$/;"	f	file:
putNat	.\lib\sflow_receiver.c	/^inline static void putNat(SFLReceiver *receiver, SFLExtended_nat *nat)$/;"	f	file:
putNet32	.\lib\sflow_receiver.c	/^inline static void putNet32(SFLReceiver *receiver, u_int32_t val)$/;"	f	file:
putNet32_run	.\lib\sflow_receiver.c	/^inline static void putNet32_run(SFLReceiver *receiver, void *obj, size_t quads)$/;"	f	file:
putNet64	.\lib\sflow_receiver.c	/^inline static void putNet64(SFLReceiver *receiver, u_int64_t val64)$/;"	f	file:
putRouter	.\lib\sflow_receiver.c	/^inline static void putRouter(SFLReceiver *receiver, SFLExtended_router *router)$/;"	f	file:
putString	.\lib\sflow_receiver.c	/^inline static void putString(SFLReceiver *receiver, SFLString *s)$/;"	f	file:
putSwitch	.\lib\sflow_receiver.c	/^inline static void putSwitch(SFLReceiver *receiver, SFLExtended_switch *sw)$/;"	f	file:
putUrl	.\lib\sflow_receiver.c	/^inline static void putUrl(SFLReceiver *receiver, SFLExtended_url *url)$/;"	f	file:
putUser	.\lib\sflow_receiver.c	/^inline static void putUser(SFLReceiver *receiver, SFLExtended_user *user)$/;"	f	file:
putVlanTunnel	.\lib\sflow_receiver.c	/^inline static void putVlanTunnel(SFLReceiver *receiver, SFLExtended_vlan_tunnel *vlanTunnel)$/;"	f	file:
put_16aligned_be32	.\lib\unaligned.h	/^put_16aligned_be32(ovs_16aligned_be32 *x, ovs_be32 value)$/;"	f
put_16aligned_u32	.\lib\unaligned.h	/^put_16aligned_u32(ovs_16aligned_u32 *x, uint32_t value)$/;"	f
put_32aligned_be64	.\lib\unaligned.h	/^put_32aligned_be64(ovs_32aligned_be64 *x, ovs_be64 value)$/;"	f
put_32aligned_u64	.\lib\unaligned.h	/^put_32aligned_u64(ovs_32aligned_u64 *x, uint64_t value)$/;"	f
put_be16	.\lib\learn.c	/^put_be16(struct ofpbuf *b, ovs_be16 x)$/;"	f	file:
put_be32	.\lib\learn.c	/^put_be32(struct ofpbuf *b, ovs_be32 x)$/;"	f	file:
put_fd_filename	.\lib\socket-util.c	/^put_fd_filename(struct ds *string, int fd)$/;"	f	file:
put_json_column	.\ovsdb\row.c	/^put_json_column(struct json *object, const struct ovsdb_row *row,$/;"	f	file:
put_nd	.\lib\odp-util.c	/^put_nd(struct ovs_key_nd* nd_key, const uint8_t *nd_sll,$/;"	f	file:
put_nd_key	.\lib\odp-util.c	/^put_nd_key(int n, const char *nd_target_s, const uint8_t *nd_sll,$/;"	f	file:
put_nd_mask	.\lib\odp-util.c	/^put_nd_mask(int n, const char *nd_target_s,$/;"	f	file:
put_node	.\lib\heap.c	/^put_node(struct heap *heap, struct heap_node *node, size_t i)$/;"	f	file:
put_queue_rate	.\lib\ofp-util.c	/^put_queue_rate(struct ofpbuf *reply, enum ofp_queue_properties property,$/;"	f	file:
put_queue_stats	.\ofproto\ofproto.c	/^put_queue_stats(struct queue_stats_cbdata *cbdata, uint32_t queue_id,$/;"	f	file:
put_row	.\tests\test-ovsdb.c	/^put_row(struct ovsdb_table *table, struct ovsdb_row *row)$/;"	f	file:
put_u16	.\lib\learn.c	/^put_u16(struct ofpbuf *b, uint16_t x)$/;"	f	file:
put_u32	.\lib\aes128.c	/^put_u32(uint8_t *p, uint32_t x)$/;"	f	file:
put_u32	.\lib\learn.c	/^put_u32(struct ofpbuf *b, uint32_t x)$/;"	f	file:
put_unaligned_be16	.\lib\unaligned.h	140;"	d
put_unaligned_be32	.\lib\unaligned.h	141;"	d
put_unaligned_be64	.\lib\unaligned.h	142;"	d
put_unaligned_u16	.\lib\unaligned.h	/^static inline void put_unaligned_u16(uint16_t *p_, uint16_t x_)$/;"	f
put_unaligned_u32	.\lib\unaligned.h	/^static inline void put_unaligned_u32(uint32_t *p_, uint32_t x_)$/;"	f
put_unaligned_u64	.\lib\unaligned.h	/^put_unaligned_u64(uint64_t *p, uint64_t x)$/;"	f
put_unaligned_u64__	.\lib\unaligned.h	/^static inline void put_unaligned_u64__(uint64_t *p_, uint64_t x_)$/;"	f
pvconn	.\lib\vconn-provider.h	/^struct pvconn {$/;"	s
pvconn	.\lib\vconn-stream.c	/^    struct pvconn pvconn;$/;"	m	struct:pvconn_pstream	typeref:struct:pvconn_pstream::pvconn	file:
pvconn	.\ofproto\connmgr.c	/^    struct pvconn *pvconn;      \/* OpenFlow connection listener. *\/$/;"	m	struct:ofservice	typeref:struct:ofservice::pvconn	file:
pvconn_accept	.\lib\vconn.c	/^pvconn_accept(struct pvconn *pvconn, struct vconn **new_vconn)$/;"	f
pvconn_assert_class	.\lib\vconn-provider.h	/^static inline void pvconn_assert_class(const struct pvconn *pvconn,$/;"	f
pvconn_class	.\lib\vconn-provider.h	/^struct pvconn_class {$/;"	s
pvconn_classes	.\lib\vconn.c	/^static const struct pvconn_class *pvconn_classes[] = {$/;"	v	typeref:struct:pvconn_class	file:
pvconn_close	.\lib\vconn.c	/^pvconn_close(struct pvconn *pvconn)$/;"	f
pvconn_get_name	.\lib\vconn.c	/^pvconn_get_name(const struct pvconn *pvconn)$/;"	f
pvconn_init	.\lib\vconn.c	/^pvconn_init(struct pvconn *pvconn, const struct pvconn_class *class,$/;"	f
pvconn_lookup_class	.\lib\vconn.c	/^pvconn_lookup_class(const char *name, const struct pvconn_class **classp)$/;"	f	file:
pvconn_name	.\tests\test-vconn.c	/^    char *pvconn_name;$/;"	m	struct:fake_pvconn	file:
pvconn_open	.\lib\vconn.c	/^pvconn_open(const char *name, uint32_t allowed_versions, uint8_t dscp,$/;"	f
pvconn_pstream	.\lib\vconn-stream.c	/^struct pvconn_pstream$/;"	s	file:
pvconn_pstream_accept	.\lib\vconn-stream.c	/^pvconn_pstream_accept(struct pvconn *pvconn, struct vconn **new_vconnp)$/;"	f	file:
pvconn_pstream_cast	.\lib\vconn-stream.c	/^pvconn_pstream_cast(struct pvconn *pvconn)$/;"	f	file:
pvconn_pstream_close	.\lib\vconn-stream.c	/^pvconn_pstream_close(struct pvconn *pvconn)$/;"	f	file:
pvconn_pstream_listen	.\lib\vconn-stream.c	/^pvconn_pstream_listen(const char *name, uint32_t allowed_versions,$/;"	f	file:
pvconn_pstream_wait	.\lib\vconn-stream.c	/^pvconn_pstream_wait(struct pvconn *pvconn)$/;"	f	file:
pvconn_verify_name	.\lib\vconn.c	/^pvconn_verify_name(const char *name)$/;"	f
pvconn_wait	.\lib\vconn.c	/^pvconn_wait(struct pvconn *pvconn)$/;"	f
pwindows_open	.\lib\stream-tcp.c	/^pwindows_open(const char *name OVS_UNUSED, char *suffix,$/;"	f	file:
pwindows_pstream_class	.\lib\stream-tcp.c	/^const struct pstream_class pwindows_pstream_class = {$/;"	v	typeref:struct:pstream_class
qdisc_get	.\lib\netdev-linux.c	/^    int (*qdisc_get)(const struct netdev *netdev, struct smap *details);$/;"	m	struct:tc_ops	file:
qdisc_set	.\lib\netdev-linux.c	/^    int (*qdisc_set)(struct netdev *, const struct smap *details);$/;"	m	struct:tc_ops	file:
qdscp	.\ofproto\ofproto-dpif.c	/^    struct ofproto_port_queue *qdscp;$/;"	m	struct:ofport_dpif	typeref:struct:ofport_dpif::ofproto_port_queue	file:
qos	.\lib\vswitch-idl.h	/^	struct ovsrec_qos *qos;$/;"	m	struct:ovsrec_port	typeref:struct:ovsrec_port::ovsrec_qos
qos_unixctl_show	.\vswitchd\bridge.c	/^qos_unixctl_show(struct unixctl_conn *conn, int argc OVS_UNUSED,$/;"	f	file:
qos_unixctl_show	.\vswitchd\bridge.c	/^static unixctl_cb_func qos_unixctl_show;$/;"	v	file:
qos_unixctl_show_cbdata	.\vswitchd\bridge.c	/^struct qos_unixctl_show_cbdata {$/;"	s	file:
qos_unixctl_show_queue	.\vswitchd\bridge.c	/^qos_unixctl_show_queue(unsigned int queue_id,$/;"	f	file:
qs	.\include\openflow\openflow-1.3.h	/^    struct ofp11_queue_stats qs;$/;"	m	struct:ofp13_action_self_learning::ofp13_queue_stats	typeref:struct:ofp13_action_self_learning::ofp13_queue_stats::ofp11_queue_stats
qs	.\include\openflow\openflow-1.4.h	/^    struct ofp13_queue_stats qs;$/;"	m	struct:ofp14_queue_stats	typeref:struct:ofp14_queue_stats::ofp13_queue_stats
quads	.\tests\test-sflow.c	/^    uint32_t quads;$/;"	m	struct:sflow_xdr	file:
query_db_remotes	.\ovsdb\ovsdb-server.c	/^query_db_remotes(const char *name, const struct shash *all_dbs,$/;"	f	file:
query_db_string	.\ovsdb\ovsdb-server.c	/^query_db_string(const struct shash *all_dbs, const char *name,$/;"	f	file:
query_distinct_cb	.\ovsdb\query.c	/^query_distinct_cb(const struct ovsdb_row *row, void *hash_)$/;"	f	file:
query_row_set_cb	.\ovsdb\query.c	/^query_row_set_cb(const struct ovsdb_row *row, void *results_)$/;"	f	file:
queue	.\lib\ofp-actions.h	/^    uint32_t queue;$/;"	m	struct:ofpact_enqueue
queue	.\ofproto\ofproto.h	/^    uint32_t queue;             \/* Queue ID. *\/$/;"	m	struct:ofproto_port_queue
queue_dump_done	.\lib\netdev-provider.h	/^    int (*queue_dump_done)(const struct netdev *netdev, void *state);$/;"	m	struct:netdev_class
queue_dump_next	.\lib\netdev-provider.h	/^    int (*queue_dump_next)(const struct netdev *netdev, void *state,$/;"	m	struct:netdev_class
queue_dump_start	.\lib\netdev-provider.h	/^    int (*queue_dump_start)(const struct netdev *netdev, void **statep);$/;"	m	struct:netdev_class
queue_dump_state	.\lib\netdev-linux.c	/^struct queue_dump_state {$/;"	s	file:
queue_gso_packets	.\datapath\datapath.c	/^static int queue_gso_packets(struct datapath *dp, struct sk_buff *skb,$/;"	f	file:
queue_id	.\include\openflow\nicira-ext.h	/^    ovs_be32 queue_id;              \/* Where to enqueue packets. *\/$/;"	m	struct:nx_action_set_queue
queue_id	.\include\openflow\openflow-1.0.h	/^    ovs_be32 queue_id;          \/* id for the specific queue. *\/$/;"	m	struct:ofp10_packet_queue
queue_id	.\include\openflow\openflow-1.0.h	/^    ovs_be32 queue_id;        \/* Where to enqueue the packets. *\/$/;"	m	struct:ofp10_action_enqueue
queue_id	.\include\openflow\openflow-1.0.h	/^    ovs_be32 queue_id;       \/* All queues if OFPQ_ALL. *\/$/;"	m	struct:ofp10_queue_stats_request
queue_id	.\include\openflow\openflow-1.0.h	/^    ovs_be32 queue_id;       \/* Queue id. *\/$/;"	m	struct:ofp10_queue_stats
queue_id	.\include\openflow\openflow-1.1.h	/^    ovs_be32 queue_id;                \/* Queue id for the packets. *\/$/;"	m	struct:ofp11_action_set_queue
queue_id	.\include\openflow\openflow-1.1.h	/^    ovs_be32 queue_id;         \/* Queue id. *\/$/;"	m	struct:ofp11_queue_stats
queue_id	.\include\openflow\openflow-1.1.h	/^    ovs_be32 queue_id;        \/* All queues if OFPQ_ALL. *\/$/;"	m	struct:ofp11_queue_stats_request
queue_id	.\include\openflow\openflow-1.2.h	/^    ovs_be32 queue_id;     \/* id for the specific queue. *\/$/;"	m	struct:ofp12_packet_queue
queue_id	.\lib\learning-switch.c	/^    uint32_t queue_id;          \/* OpenFlow queue number. *\/$/;"	m	struct:lswitch_port	file:
queue_id	.\lib\netdev-linux.c	/^    unsigned int queue_id;      \/* OpenFlow queue ID. *\/$/;"	m	struct:tc_queue	file:
queue_id	.\lib\netdev-provider.h	/^    int queue_id;$/;"	m	struct:netdev_rxq
queue_id	.\lib\ofp-actions.h	/^    uint32_t queue_id;$/;"	m	struct:ofpact_queue
queue_id	.\lib\ofp-util.h	/^    uint32_t queue_id;$/;"	m	struct:ofputil_queue_config
queue_id	.\lib\ofp-util.h	/^    uint32_t queue_id;$/;"	m	struct:ofputil_queue_stats
queue_id	.\lib\ofp-util.h	/^    uint32_t queue_id;$/;"	m	struct:ofputil_queue_stats_request
queue_id	.\ofproto\in-band.c	/^    int queue_id;$/;"	m	struct:in_band	file:
queue_ids_include	.\vswitchd\bridge.c	/^queue_ids_include(const struct ovsdb_datum *queues, int64_t target)$/;"	f	file:
queue_names	.\lib\learning-switch.c	/^    struct shash queue_names;   \/* Map from port name to lswitch_port. *\/$/;"	m	struct:lswitch	typeref:struct:lswitch::shash	file:
queue_numbers	.\lib\learning-switch.c	/^    struct hmap queue_numbers;  \/* Map from port number to lswitch_port. *\/$/;"	m	struct:lswitch	typeref:struct:lswitch::hmap	file:
queue_rwlock	.\lib\dpif-netdev.c	/^    struct fat_rwlock queue_rwlock;$/;"	m	struct:dp_netdev	typeref:struct:dp_netdev::fat_rwlock	file:
queue_stats_cbdata	.\ofproto\ofproto.c	/^struct queue_stats_cbdata {$/;"	s	file:
queue_to_priority	.\lib\dpif-provider.h	/^    int (*queue_to_priority)(const struct dpif *dpif, uint32_t queue_id,$/;"	m	struct:dpif_class
queue_tx	.\lib\learning-switch.c	/^queue_tx(struct lswitch *sw, struct ofpbuf *b)$/;"	f	file:
queue_userspace_packet	.\datapath\datapath.c	/^static int queue_userspace_packet(struct datapath *dp, struct sk_buff *skb,$/;"	f	file:
queue_work	.\datapath\linux\compat\include\linux\workqueue.h	7;"	d
queued	.\lib\learning-switch.c	/^    struct rconn_packet_counter *queued;$/;"	m	struct:lswitch	typeref:struct:lswitch::rconn_packet_counter	file:
queues	.\lib\netdev-linux.c	/^    struct hmap queues;         \/* Contains "struct tc_queue"s.$/;"	m	struct:tc	typeref:struct:tc::hmap	file:
queues	.\lib\netdev-linux.c	/^    unsigned int *queues;$/;"	m	struct:netdev_linux_queue_state	file:
queues	.\ofproto\pinsched.c	/^    struct hmap queues;         \/* Contains "struct pinqueue"s. *\/$/;"	m	struct:pinsched	typeref:struct:pinsched::hmap	file:
quicksort	.\lib\sort.c	/^quicksort(size_t p, size_t r,$/;"	f	file:
r	.\tests\idltest.h	/^	double r;$/;"	m	struct:idltest_simple
r	.\tests\test-reconnect.py	/^r = None$/;"	v
ra	.\tests\idltest.h	/^	double *ra;$/;"	m	struct:idltest_simple
random	.\include\windows\windefs.h	43;"	d
random	.\python\compat\uuid.py	/^        import random$/;"	i
random	.\python\compat\uuid.py	/^    import random$/;"	i
random	.\python\ovs\socket_util.py	/^import random$/;"	i
random_bytes	.\lib\random.c	/^random_bytes(void *p_, size_t n)$/;"	f
random_in_range	.\tests\test-util.c	/^random_in_range(uint32_t min, uint32_t max)$/;"	f	file:
random_init	.\lib\random.c	/^random_init(void)$/;"	f
random_next	.\lib\random.c	/^random_next(void)$/;"	f	file:
random_range	.\lib\random.h	/^random_range(int max)$/;"	f
random_set_seed	.\lib\random.c	/^random_set_seed(uint32_t seed_)$/;"	f
random_uint16	.\lib\random.h	/^random_uint16(void)$/;"	f
random_uint32	.\lib\random.c	/^random_uint32(void)$/;"	f
random_uint64	.\lib\random.c	/^random_uint64(void)$/;"	f
random_uint8	.\lib\random.h	/^random_uint8(void)$/;"	f
random_value	.\tests\test-classifier.c	/^random_value(void)$/;"	f	file:
range	.\datapath\flow.h	/^	struct sw_flow_key_range range;$/;"	m	struct:sw_flow_mask	typeref:struct:sw_flow_mask::sw_flow_key_range
range	.\datapath\flow.h	/^	struct sw_flow_key_range range;$/;"	m	struct:sw_flow_match	typeref:struct:sw_flow_match::sw_flow_key_range
range	.\lib\classifier.c	/^struct range {$/;"	s	file:
range_n_bytes	.\datapath\flow_netlink.c	/^static u16 range_n_bytes(const struct sw_flow_key_range *range)$/;"	f	file:
range_n_bytes	.\datapath\flow_table.c	/^static u16 range_n_bytes(const struct sw_flow_key_range *range)$/;"	f	file:
rate	.\include\openflow\openflow-1.3.h	/^    ovs_be32    rate;        \/* Rate for dropping packets. *\/$/;"	m	struct:ofp13_action_self_learning::ofp13_meter_band_drop
rate	.\include\openflow\openflow-1.3.h	/^    ovs_be32    rate;        \/* Rate for dropping packets. *\/$/;"	m	struct:ofp13_action_self_learning::ofp13_meter_band_experimenter
rate	.\include\openflow\openflow-1.3.h	/^    ovs_be32    rate;        \/* Rate for remarking packets. *\/$/;"	m	struct:ofp13_action_self_learning::ofp13_meter_band_dscp_remark
rate	.\include\openflow\openflow-1.3.h	/^    ovs_be32 rate;       \/* Rate for this band. *\/$/;"	m	struct:ofp13_action_self_learning::ofp13_meter_band_header
rate	.\include\openflow\openflow-common.h	/^    ovs_be16 rate;        \/* In 1\/10 of a percent; >1000 -> disabled. *\/$/;"	m	struct:ofp_queue_prop_rate
rate	.\lib\ofp-util.h	/^    uint32_t rate;$/;"	m	struct:ofputil_meter_band
rate	.\lib\token-bucket.h	/^    unsigned int rate;          \/* Tokens added per millisecond. *\/$/;"	m	struct:token_bucket
rate_limit	.\ofproto\connmgr.c	/^    int rate_limit;             \/* Max packet-in rate in packets per second. *\/$/;"	m	struct:ofservice	file:
rate_limit	.\ofproto\ofproto.h	/^    int rate_limit;             \/* Max packet-in rate in packets per second. *\/$/;"	m	struct:ofproto_controller
raw	.\lib\ofp-msgs.c	/^    enum ofpraw raw;            \/* Value. *\/$/;"	m	struct:raw_instance	typeref:enum:raw_instance::ofpraw	file:
raw_clz64	.\lib\util.c	/^raw_clz64(uint64_t n)$/;"	f
raw_clz64	.\lib\util.h	/^raw_clz64(uint64_t n)$/;"	f
raw_ctz	.\lib\util.c	/^raw_ctz(uint64_t n)$/;"	f
raw_ctz	.\lib\util.h	/^raw_ctz(uint64_t n)$/;"	f
raw_flag	.\lib\ofp-util.c	/^    uint16_t raw_flag;$/;"	m	struct:ofputil_flow_mod_flag	file:
raw_get_prefix	.\lib\classifier.c	/^raw_get_prefix(const ovs_be32 pr[], unsigned int ofs, unsigned int plen)$/;"	f	file:
raw_info	.\lib\ofp-msgs.c	/^struct raw_info {$/;"	s	file:
raw_info_get	.\lib\ofp-msgs.c	/^raw_info_get(enum ofpraw raw)$/;"	f	file:
raw_instance	.\lib\ofp-msgs.c	/^struct raw_instance {$/;"	s	file:
raw_instance_get	.\lib\ofp-msgs.c	/^raw_instance_get(const struct raw_info *info, uint8_t version)$/;"	f	file:
raw_instance_map	.\lib\ofp-msgs.c	/^static struct hmap raw_instance_map;$/;"	v	typeref:struct:hmap	file:
raw_process_info	.\vswitchd\system-stats.c	/^struct raw_process_info {$/;"	s	file:
rcon	.\lib\aes128.c	/^static const uint32_t rcon[] = {$/;"	v	file:
rconn	.\lib\learning-switch.c	/^    struct rconn *rconn;$/;"	m	struct:lswitch	typeref:struct:lswitch::rconn	file:
rconn	.\lib\netdev-dummy.c	/^        struct dummy_packet_rconn rconn;$/;"	m	union:dummy_packet_conn::__anon57	typeref:struct:dummy_packet_conn::__anon57::dummy_packet_rconn	file:
rconn	.\lib\rconn.c	/^VLOG_DEFINE_THIS_MODULE(rconn);$/;"	v
rconn	.\lib\rconn.c	/^struct rconn {$/;"	s	file:
rconn	.\ofproto\connmgr.c	/^    struct rconn *rconn;        \/* OpenFlow connection. *\/$/;"	m	struct:ofconn	typeref:struct:ofconn::rconn	file:
rconn_create	.\lib\rconn.c	/^rconn_create(int probe_interval, int max_backoff, uint8_t dscp,$/;"	f
rconn_destroy	.\lib\rconn.c	/^rconn_destroy(struct rconn *rc)$/;"	f
rconn_discarded	.\lib\rconn.c	/^COVERAGE_DEFINE(rconn_discarded);$/;"	v
rconn_get_allowed_versions	.\lib\rconn.c	/^uint32_t rconn_get_allowed_versions(const struct rconn *rconn)$/;"	f
rconn_get_connection_seqno	.\lib\rconn.c	/^rconn_get_connection_seqno(const struct rconn *rc)$/;"	f
rconn_get_dscp	.\lib\rconn.c	/^rconn_get_dscp(const struct rconn *rc)$/;"	f
rconn_get_last_connection	.\lib\rconn.c	/^rconn_get_last_connection(const struct rconn *rc)$/;"	f
rconn_get_last_disconnect	.\lib\rconn.c	/^rconn_get_last_disconnect(const struct rconn *rc)$/;"	f
rconn_get_last_error	.\lib\rconn.c	/^rconn_get_last_error(const struct rconn *rc)$/;"	f
rconn_get_max_backoff	.\lib\rconn.c	/^rconn_get_max_backoff(const struct rconn *rc)$/;"	f
rconn_get_name	.\lib\rconn.c	/^rconn_get_name(const struct rconn *rc)$/;"	f
rconn_get_probe_interval	.\lib\rconn.c	/^rconn_get_probe_interval(const struct rconn *rc)$/;"	f
rconn_get_state	.\lib\rconn.c	/^rconn_get_state(const struct rconn *rc)$/;"	f
rconn_get_target	.\lib\rconn.c	/^rconn_get_target(const struct rconn *rc)$/;"	f
rconn_is_alive	.\lib\rconn.c	/^rconn_is_alive(const struct rconn *rconn)$/;"	f
rconn_is_connected	.\lib\rconn.c	/^rconn_is_connected(const struct rconn *rconn)$/;"	f
rconn_overflow	.\lib\rconn.c	/^COVERAGE_DEFINE(rconn_overflow);$/;"	v
rconn_packet_counter	.\lib\rconn.h	/^struct rconn_packet_counter {$/;"	s
rconn_packet_counter_create	.\lib\rconn.c	/^rconn_packet_counter_create(void)$/;"	f
rconn_packet_counter_dec	.\lib\rconn.c	/^rconn_packet_counter_dec(struct rconn_packet_counter *c, unsigned int n_bytes)$/;"	f
rconn_packet_counter_destroy	.\lib\rconn.c	/^rconn_packet_counter_destroy(struct rconn_packet_counter *c)$/;"	f
rconn_packet_counter_inc	.\lib\rconn.c	/^rconn_packet_counter_inc(struct rconn_packet_counter *c, unsigned int n_bytes)$/;"	f
rconn_packet_counter_n_bytes	.\lib\rconn.c	/^rconn_packet_counter_n_bytes(const struct rconn_packet_counter *c)$/;"	f
rconn_packet_counter_n_packets	.\lib\rconn.c	/^rconn_packet_counter_n_packets(const struct rconn_packet_counter *c)$/;"	f
rconn_packets_received	.\lib\rconn.c	/^rconn_packets_received(const struct rconn *rc)$/;"	f
rconn_packets_sent	.\lib\rconn.c	/^rconn_packets_sent(const struct rconn *rc)$/;"	f
rconn_queued	.\lib\rconn.c	/^COVERAGE_DEFINE(rconn_queued);$/;"	v
rconn_sent	.\lib\rconn.c	/^COVERAGE_DEFINE(rconn_sent);$/;"	v
rconn_set_dscp	.\lib\rconn.c	/^rconn_set_dscp(struct rconn *rc, uint8_t dscp)$/;"	f
rconn_set_probe_interval	.\lib\rconn.c	/^rconn_set_probe_interval(struct rconn *rc, int probe_interval)$/;"	f
rcu	.\datapath\datapath.h	/^	struct rcu_head rcu;$/;"	m	struct:datapath	typeref:struct:datapath::rcu_head
rcu	.\datapath\flow.h	/^	struct rcu_head rcu;$/;"	m	struct:sw_flow	typeref:struct:sw_flow::rcu_head
rcu	.\datapath\flow.h	/^	struct rcu_head rcu;$/;"	m	struct:sw_flow_actions	typeref:struct:sw_flow_actions::rcu_head
rcu	.\datapath\flow.h	/^	struct rcu_head rcu;$/;"	m	struct:sw_flow_mask	typeref:struct:sw_flow_mask::rcu_head
rcu	.\datapath\flow_table.h	/^	struct rcu_head rcu;$/;"	m	struct:mask_array	typeref:struct:mask_array::rcu_head
rcu	.\datapath\flow_table.h	/^	struct rcu_head rcu;$/;"	m	struct:table_instance	typeref:struct:table_instance::rcu_head
rcu	.\datapath\linux\compat\include\net\vxlan.h	/^	struct rcu_head	  rcu;$/;"	m	struct:vxlan_sock	typeref:struct:vxlan_sock::rcu_head
rcu	.\datapath\vport-netdev.h	/^	struct rcu_head rcu;$/;"	m	struct:netdev_vport	typeref:struct:netdev_vport::rcu_head
rcu	.\datapath\vport.h	/^	struct rcu_head rcu;$/;"	m	struct:vport	typeref:struct:vport::rcu_head
rcu	.\datapath\vport.h	/^	struct rcu_head rcu;$/;"	m	struct:vport_portids	typeref:struct:vport_portids::rcu_head
rcu_assign_sk_user_data	.\datapath\linux\compat\include\net\sock.h	10;"	d
rcu_dereference_check	.\datapath\linux\compat\include\linux\rcupdate.h	7;"	d
rcu_dereference_ovsl	.\datapath\datapath.h	155;"	d
rcu_dereference_protected	.\datapath\linux\compat\include\linux\rcupdate.h	11;"	d
rcu_dereference_raw	.\datapath\linux\compat\include\linux\rcupdate.h	15;"	d
rcu_dereference_rtnl	.\datapath\linux\compat\include\linux\rtnetlink.h	23;"	d
rcu_dereference_sk_user_data	.\datapath\linux\compat\include\net\sock.h	9;"	d
rcu_free_acts_callback	.\datapath\flow_netlink.c	/^static void rcu_free_acts_callback(struct rcu_head *rcu)$/;"	f	file:
rcu_free_flow_callback	.\datapath\flow_table.c	/^static void rcu_free_flow_callback(struct rcu_head *rcu)$/;"	f	file:
rcu_free_sw_flow_mask_cb	.\datapath\flow_table.c	/^static void rcu_free_sw_flow_mask_cb(struct rcu_head *rcu)$/;"	f	file:
rcu_free_vs	.\datapath\linux\compat\vxlan.c	/^static void rcu_free_vs(struct rcu_head *rcu)$/;"	f	file:
rcu_read_lock_held	.\datapath\linux\compat\include\linux\rcupdate.h	/^static inline int rcu_read_lock_held(void)$/;"	f
rcv	.\datapath\linux\compat\include\net\vxlan.h	/^	vxlan_rcv_t	 *rcv;$/;"	m	struct:vxlan_sock
rcvbuf	.\lib\netlink-socket.c	/^    unsigned int rcvbuf;        \/* Receive buffer size (SO_RCVBUF). *\/$/;"	m	struct:nl_sock	file:
rd	.\lib\route-table.c	/^    struct route_data rd;  \/* Data associated with this node. *\/$/;"	m	struct:route_node	typeref:struct:route_node::route_data	file:
rd	.\lib\route-table.c	/^    struct route_data rd; \/* Data parsed from this message. *\/$/;"	m	struct:route_table_msg	typeref:struct:route_table_msg::route_data	file:
re	.\python\compat\uuid.py	/^    import os, re$/;"	i
re	.\python\ovs\db\data.py	/^import re$/;"	i
re	.\python\ovs\db\parser.py	/^import re$/;"	i
re	.\python\ovs\db\schema.py	/^import re$/;"	i
re	.\python\ovs\json.py	/^import re$/;"	i
re	.\python\ovs\ovsuuid.py	/^import re$/;"	i
re	.\python\ovs\vlog.py	/^import re$/;"	i
re	.\python\ovstest\args.py	/^import re$/;"	i
re	.\python\ovstest\util.py	/^import re$/;"	i
re	.\tests\MockXenAPI.py	/^import re$/;"	i
re	.\tests\test-ovsdb.py	/^import re$/;"	i
re	.\xenserver\opt_xensource_libexec_InterfaceReconfigureVswitch.py	/^import re$/;"	i
reached	.\tests\test-stp.c	/^    bool reached;$/;"	m	struct:bridge	file:
reached	.\tests\test-stp.c	/^    bool reached;$/;"	m	struct:lan	file:
reactor	.\python\ovstest\rpcserver.py	/^from twisted.internet import reactor$/;"	i
read	.\lib\stream-ssl.c	/^    bool read;                  \/* Whether the file was successfully read. *\/$/;"	m	struct:ssl_config_file	file:
read_cert_file	.\lib\stream-ssl.c	/^read_cert_file(const char *file_name, X509 ***certs, size_t *n_certs)$/;"	f	file:
read_column	.\ovsdb\ovsdb-server.c	/^read_column(const struct ovsdb_row *row, const char *column_name,$/;"	f	file:
read_error	.\ovsdb\log.c	/^    struct ovsdb_error *read_error;$/;"	m	struct:ovsdb_log	typeref:struct:ovsdb_log::ovsdb_error	file:
read_flows_from_file	.\utilities\ovs-ofctl.c	/^read_flows_from_file(const char *filename, struct classifier *cls, int index)$/;"	f	file:
read_flows_from_source	.\utilities\ovs-ofctl.c	/^read_flows_from_source(const char *source, struct classifier *cls, int index)$/;"	f	file:
read_flows_from_switch	.\utilities\ovs-ofctl.c	/^read_flows_from_switch(struct vconn *vconn,$/;"	f	file:
read_fully	.\lib\socket-util.c	/^read_fully(int fd, void *p_, size_t size, size_t *bytes_read)$/;"	f
read_host_uuid	.\vswitchd\xenserver.c	/^read_host_uuid(void)$/;"	f	file:
read_integer_column	.\ovsdb\ovsdb-server.c	/^read_integer_column(const struct ovsdb_row *row, const char *column_name,$/;"	f	file:
read_map_string_column	.\ovsdb\ovsdb-server.c	/^read_map_string_column(const struct ovsdb_row *row, const char *column_name,$/;"	f	file:
read_pidfile	.\lib\daemon-unix.c	/^read_pidfile(const char *pidfile)$/;"	f
read_pidfile	.\python\ovs\daemon.py	/^def read_pidfile(pidfile):$/;"	f
read_pidfile__	.\lib\daemon-unix.c	/^read_pidfile__(const char *pidfile, bool delete_if_stale)$/;"	f	file:
read_psched	.\lib\netdev-linux.c	/^read_psched(void)$/;"	f	file:
read_string_column	.\ovsdb\ovsdb-server.c	/^read_string_column(const struct ovsdb_row *row, const char *column_name,$/;"	f	file:
read_upcalls	.\ofproto\ofproto-dpif-upcall.c	/^read_upcalls(struct handler *handler,$/;"	f	file:
readd	.\utilities\ovs-ofctl.c	/^static bool readd;$/;"	v	file:
readlines	.\xenserver\opt_xensource_libexec_InterfaceReconfigure.py	/^    def readlines(self):$/;"	m	class:ConfigurationFile
real	.\lib\json.c	/^        double real;$/;"	m	union:json_token::__anon48	file:
real	.\lib\json.h	/^        double real;$/;"	m	union:json::__anon49
real	.\lib\ovsdb-data.h	/^    double real;$/;"	m	union:ovsdb_atom
real	.\lib\ovsdb-idl.c	/^    struct uuid real;           \/* Real UUID used by database server. *\/$/;"	m	struct:ovsdb_idl_txn_insert	typeref:struct:ovsdb_idl_txn_insert::uuid	file:
real	.\lib\ovsdb-types.h	/^        } real;$/;"	m	union:ovsdb_base_type::__anon86	typeref:struct:ovsdb_base_type::__anon86::ovsdb_real_constraints
real_dev	.\lib\vlandev.h	/^    struct vlan_real_dev *real_dev; \/* Parent, e.g. "eth0". *\/$/;"	m	struct:vlan_dev	typeref:struct:vlan_dev::vlan_real_dev
realdev_ofp_port	.\ofproto\ofproto-dpif.c	/^    ofp_port_t realdev_ofp_port;$/;"	m	struct:ofport_dpif	file:
realdev_ofp_port	.\ofproto\ofproto-dpif.c	/^    ofp_port_t realdev_ofp_port;$/;"	m	struct:vlan_splinter	file:
realdev_ofp_port	.\ofproto\ofproto.h	/^    ofp_port_t realdev_ofp_port;\/* OpenFlow port number of real device. *\/$/;"	m	struct:ofproto_bundle_settings
realdev_vid_node	.\ofproto\ofproto-dpif.c	/^    struct hmap_node realdev_vid_node;$/;"	m	struct:vlan_splinter	typeref:struct:vlan_splinter::hmap_node	file:
reason	.\include\openflow\nicira-ext.h	/^    ovs_be16 reason;            \/* OFPRR_* for NXFME_DELETED, else zero. *\/$/;"	m	struct:nx_flow_update_full
reason	.\include\openflow\nicira-ext.h	/^    uint8_t reason;                 \/* enum ofp_packet_in_reason (OFPR_*). *\/$/;"	m	struct:nx_action_controller
reason	.\include\openflow\nicira-ext.h	/^    uint8_t reason;           \/* One of OFPRR_*. *\/$/;"	m	struct:nx_flow_removed
reason	.\include\openflow\nicira-ext.h	/^    uint8_t reason;           \/* Reason packet is sent (one of OFPR_*). *\/$/;"	m	struct:nx_packet_in
reason	.\include\openflow\openflow-1.0.h	/^    uint8_t reason;           \/* One of OFPRR_*. *\/$/;"	m	struct:ofp10_flow_removed
reason	.\include\openflow\openflow-1.0.h	/^    uint8_t reason;         \/* Reason packet is being sent (one of OFPR_*) *\/$/;"	m	struct:ofp10_packet_in
reason	.\include\openflow\openflow-1.1.h	/^    uint8_t reason;           \/* One of OFPRR_*. *\/$/;"	m	struct:ofp11_flow_removed
reason	.\include\openflow\openflow-1.1.h	/^    uint8_t reason;         \/* Reason packet is being sent (one of OFPR_*) *\/$/;"	m	struct:ofp11_packet_in
reason	.\include\openflow\openflow-1.2.h	/^    uint8_t reason;           \/* One of OFPRR_*. *\/$/;"	m	struct:ofp12_flow_removed
reason	.\include\openflow\openflow-1.2.h	/^    uint8_t reason;         \/* Reason packet is being sent (one of OFPR_*) *\/$/;"	m	struct:ofp12_packet_in
reason	.\include\openflow\openflow-1.4.h	/^    uint8_t  reason;            \/* One of OFPCRR_*. *\/$/;"	m	struct:ofp14_role_status
reason	.\include\openflow\openflow-common.h	/^    uint8_t reason;          \/* One of OFPPR_*. *\/$/;"	m	struct:ofp_port_status
reason	.\lib\odp-util.h	/^        uint32_t reason;        \/* enum slow_path_reason. *\/$/;"	m	struct:user_action_cookie::__anon70
reason	.\lib\ofp-actions.h	/^    enum ofp_packet_in_reason reason; \/* Reason to put in packet-in. *\/$/;"	m	struct:ofpact_controller	typeref:enum:ofpact_controller::ofp_packet_in_reason
reason	.\lib\ofp-util.h	/^    enum ofp14_controller_role_reason reason;$/;"	m	struct:ofputil_role_status	typeref:enum:ofputil_role_status::ofp14_controller_role_reason
reason	.\lib\ofp-util.h	/^    enum ofp_flow_removed_reason reason;$/;"	m	struct:ofputil_flow_update	typeref:enum:ofputil_flow_update::ofp_flow_removed_reason
reason	.\lib\ofp-util.h	/^    enum ofp_packet_in_reason reason;    \/* One of OFPR_*. *\/$/;"	m	struct:ofputil_packet_in	typeref:enum:ofputil_packet_in::ofp_packet_in_reason
reason	.\lib\ofp-util.h	/^    enum ofp_port_reason reason;$/;"	m	struct:ofputil_port_status	typeref:enum:ofputil_port_status::ofp_port_reason
reason	.\lib\ofp-util.h	/^    uint8_t reason;             \/* One of OFPRR_*. *\/$/;"	m	struct:ofputil_flow_removed
reason	.\ofproto\ofproto.c	/^    enum ofp_flow_removed_reason reason; \/* Reason flow was removed. *\/$/;"	m	struct:ofoperation	typeref:enum:ofoperation::ofp_flow_removed_reason	file:
rebalance_interval	.\ofproto\bond.c	/^    int rebalance_interval;      \/* Interval between rebalances, in ms. *\/$/;"	m	struct:bond	file:
rebalance_interval	.\ofproto\bond.h	/^    int rebalance_interval;     \/* Milliseconds between rebalances.$/;"	m	struct:bond_settings
recalc_csum128	.\lib\csum.c	/^recalc_csum128(ovs_be16 old_csum, ovs_16aligned_be32 old_u32[4],$/;"	f
recalc_csum16	.\lib\csum.c	/^recalc_csum16(ovs_be16 old_csum, ovs_be16 old_u16, ovs_be16 new_u16)$/;"	f
recalc_csum32	.\lib\csum.c	/^recalc_csum32(ovs_be16 old_csum, ovs_be32 old_u32, ovs_be32 new_u32)$/;"	f
recargchar	.\lib\getopt_long.c	/^static const char recargchar[] = "option requires an argument -- %c";$/;"	v	file:
recargstring	.\lib\getopt_long.c	/^static const char recargstring[] = "option requires an argument -- %s";$/;"	v	file:
receiver4	.\lib\sflow_api.h	/^    struct sockaddr_in receiver4;$/;"	m	struct:_SFLReceiver	typeref:struct:_SFLReceiver::sockaddr_in
receiver6	.\lib\sflow_api.h	/^    struct sockaddr_in6 receiver6;$/;"	m	struct:_SFLReceiver	typeref:struct:_SFLReceiver::sockaddr_in6
receiverSocket4	.\lib\sflow_api.h	/^    int receiverSocket4;$/;"	m	struct:_SFLAgent
receiverSocket6	.\lib\sflow_api.h	/^    int receiverSocket6;$/;"	m	struct:_SFLAgent
receivers	.\lib\sflow_api.h	/^    SFLReceiver *receivers; \/* the array of receivers *\/$/;"	m	struct:_SFLAgent
recent_rusage	.\lib\timeval.c	/^    struct rusage recent_rusage;$/;"	m	struct:cpu_tracker	typeref:struct:cpu_tracker::rusage	file:
reciprocal_divide	.\datapath\linux\compat\include\linux\reciprocal_div.h	/^static inline u32 reciprocal_divide(u32 a, struct reciprocal_value R)$/;"	f
reciprocal_divide	.\datapath\linux\compat\include\linux\reciprocal_div.h	30;"	d
reciprocal_elems	.\datapath\linux\compat\include\linux\flex_array.h	/^			struct reciprocal_value reciprocal_elems;$/;"	m	struct:flex_array::__anon12::__anon13	typeref:struct:flex_array::__anon12::__anon13::reciprocal_value
reciprocal_value	.\datapath\linux\compat\include\linux\reciprocal_div.h	/^struct reciprocal_value {$/;"	s
reciprocal_value	.\datapath\linux\compat\include\linux\reciprocal_div.h	22;"	d
reciprocal_value	.\datapath\linux\compat\reciprocal_div.c	/^struct reciprocal_value reciprocal_value(u32 d)$/;"	f
recirc	.\ofproto\ofproto-dpif-xlate.c	/^    struct xlate_recirc recirc; \/* Information used for generating$/;"	m	struct:xlate_ctx	typeref:struct:xlate_ctx::xlate_recirc	file:
recirc_id	.\datapath\flow.h	/^	u32 recirc_id;			\/* Recirculation ID.  *\/$/;"	m	struct:sw_flow_key
recirc_id	.\lib\flow.h	/^    uint32_t recirc_id;         \/* Must be exact match. *\/$/;"	m	struct:flow
recirc_id	.\lib\packets.h	/^    uint32_t recirc_id;         \/* Recirculation id carried with the$/;"	m	struct:pkt_metadata
recirc_id	.\ofproto\bond.c	/^    uint32_t recirc_id;          \/* Non zero if recirculation can be used.*\/$/;"	m	struct:bond	file:
recirc_id	.\ofproto\ofproto-dpif-rid.c	/^    uint32_t recirc_id;$/;"	m	struct:rid_node	file:
recirc_id	.\ofproto\ofproto-dpif-xlate.h	/^    uint32_t recirc_id;  \/* !0 Use recirculation instead of output. *\/$/;"	m	struct:xlate_recirc
recirc_id_alloc	.\ofproto\ofproto-dpif-rid.c	/^recirc_id_alloc(struct recirc_id_pool *pool)$/;"	f
recirc_id_free	.\ofproto\ofproto-dpif-rid.c	/^recirc_id_free(struct recirc_id_pool *pool, uint32_t id)$/;"	f
recirc_id_pool	.\ofproto\ofproto-dpif-rid.c	/^struct recirc_id_pool {$/;"	s	file:
recirc_id_pool_create	.\ofproto\ofproto-dpif-rid.c	/^recirc_id_pool_create(void)$/;"	f
recirc_id_pool_destroy	.\ofproto\ofproto-dpif-rid.c	/^recirc_id_pool_destroy(struct recirc_id_pool *pool)$/;"	f
reconfig_time	.\ofproto\netflow.c	/^    long long int reconfig_time;  \/* When we reconfigured the timeouts. *\/$/;"	m	struct:netflow	file:
reconfigure_remotes	.\ovsdb\ovsdb-server.c	/^reconfigure_remotes(struct ovsdb_jsonrpc_server *jsonrpc,$/;"	f	file:
reconfigure_ssl	.\ovsdb\ovsdb-server.c	/^reconfigure_ssl(const struct shash *all_dbs)$/;"	f	file:
reconfigure_system_stats	.\vswitchd\bridge.c	/^reconfigure_system_stats(const struct ovsrec_open_vswitch *cfg)$/;"	f	file:
reconnect	.\lib\jsonrpc.c	/^    struct reconnect *reconnect;$/;"	m	struct:jsonrpc_session	typeref:struct:jsonrpc_session::reconnect	file:
reconnect	.\lib\netdev-dummy.c	/^    struct reconnect *reconnect;$/;"	m	struct:dummy_packet_rconn	typeref:struct:dummy_packet_rconn::reconnect	file:
reconnect	.\lib\reconnect.c	/^VLOG_DEFINE_THIS_MODULE(reconnect);$/;"	v
reconnect	.\lib\reconnect.c	/^struct reconnect {$/;"	s	file:
reconnect	.\python\ovs\jsonrpc.py	/^import ovs.reconnect$/;"	i
reconnect	.\tests\test-reconnect.c	/^static struct reconnect *reconnect;$/;"	v	typeref:struct:reconnect	file:
reconnect	.\tests\test-reconnect.py	/^import ovs.reconnect$/;"	i
reconnect_action	.\lib\reconnect.h	/^enum reconnect_action {$/;"	g
reconnect_activity	.\lib\reconnect.c	/^reconnect_activity(struct reconnect *fsm, long long int now)$/;"	f
reconnect_connect_failed	.\lib\reconnect.c	/^reconnect_connect_failed(struct reconnect *fsm, long long int now, int error)$/;"	f
reconnect_connected	.\lib\reconnect.c	/^reconnect_connected(struct reconnect *fsm, long long int now)$/;"	f
reconnect_connecting	.\lib\reconnect.c	/^reconnect_connecting(struct reconnect *fsm, long long int now)$/;"	f
reconnect_create	.\lib\reconnect.c	/^reconnect_create(long long int now)$/;"	f
reconnect_deadline__	.\lib\reconnect.c	/^reconnect_deadline__(const struct reconnect *fsm)$/;"	f	file:
reconnect_destroy	.\lib\reconnect.c	/^reconnect_destroy(struct reconnect *fsm)$/;"	f
reconnect_disable	.\lib\reconnect.c	/^reconnect_disable(struct reconnect *fsm, long long int now)$/;"	f
reconnect_disconnected	.\lib\reconnect.c	/^reconnect_disconnected(struct reconnect *fsm, long long int now, int error)$/;"	f
reconnect_enable	.\lib\reconnect.c	/^reconnect_enable(struct reconnect *fsm, long long int now)$/;"	f
reconnect_force_reconnect	.\lib\reconnect.c	/^reconnect_force_reconnect(struct reconnect *fsm, long long int now)$/;"	f
reconnect_get_last_connect_elapsed	.\lib\reconnect.c	/^reconnect_get_last_connect_elapsed(const struct reconnect *fsm,$/;"	f
reconnect_get_last_disconnect_elapsed	.\lib\reconnect.c	/^reconnect_get_last_disconnect_elapsed(const struct reconnect *fsm,$/;"	f
reconnect_get_max_backoff	.\lib\reconnect.c	/^reconnect_get_max_backoff(const struct reconnect *fsm)$/;"	f
reconnect_get_max_tries	.\lib\reconnect.c	/^reconnect_get_max_tries(struct reconnect *fsm)$/;"	f
reconnect_get_min_backoff	.\lib\reconnect.c	/^reconnect_get_min_backoff(const struct reconnect *fsm)$/;"	f
reconnect_get_name	.\lib\reconnect.c	/^reconnect_get_name(const struct reconnect *fsm)$/;"	f
reconnect_get_probe_interval	.\lib\reconnect.c	/^reconnect_get_probe_interval(const struct reconnect *fsm)$/;"	f
reconnect_get_stats	.\lib\reconnect.c	/^reconnect_get_stats(const struct reconnect *fsm, long long int now,$/;"	f
reconnect_is_connected	.\lib\reconnect.c	/^reconnect_is_connected(const struct reconnect *fsm)$/;"	f
reconnect_is_enabled	.\lib\reconnect.c	/^reconnect_is_enabled(const struct reconnect *fsm)$/;"	f
reconnect_is_passive	.\lib\reconnect.c	/^reconnect_is_passive(const struct reconnect *fsm)$/;"	f
reconnect_listen_error	.\lib\reconnect.c	/^reconnect_listen_error(struct reconnect *fsm, long long int now, int error)$/;"	f
reconnect_listening	.\lib\reconnect.c	/^reconnect_listening(struct reconnect *fsm, long long int now)$/;"	f
reconnect_may_retry	.\lib\reconnect.c	/^reconnect_may_retry(struct reconnect *fsm)$/;"	f	file:
reconnect_port	.\tests\test-stp.c	/^reconnect_port(struct bridge *b, int port_no, struct lan *new_lan)$/;"	f	file:
reconnect_run	.\lib\reconnect.c	/^reconnect_run(struct reconnect *fsm, long long int now)$/;"	f
reconnect_set_backoff	.\lib\reconnect.c	/^reconnect_set_backoff(struct reconnect *fsm, int min_backoff, int max_backoff)$/;"	f
reconnect_set_max_tries	.\lib\reconnect.c	/^reconnect_set_max_tries(struct reconnect *fsm, unsigned int max_tries)$/;"	f
reconnect_set_name	.\lib\reconnect.c	/^reconnect_set_name(struct reconnect *fsm, const char *name)$/;"	f
reconnect_set_passive	.\lib\reconnect.c	/^reconnect_set_passive(struct reconnect *fsm, bool passive, long long int now)$/;"	f
reconnect_set_probe_interval	.\lib\reconnect.c	/^reconnect_set_probe_interval(struct reconnect *fsm, int probe_interval)$/;"	f
reconnect_set_quiet	.\lib\reconnect.c	/^reconnect_set_quiet(struct reconnect *fsm, bool quiet)$/;"	f
reconnect_state_name__	.\lib\reconnect.c	/^reconnect_state_name__(enum state state)$/;"	f	file:
reconnect_stats	.\lib\reconnect.h	/^struct reconnect_stats {$/;"	s
reconnect_timeout	.\lib\reconnect.c	/^reconnect_timeout(struct reconnect *fsm, long long int now)$/;"	f
reconnect_transition__	.\lib\reconnect.c	/^reconnect_transition__(struct reconnect *fsm, long long int now,$/;"	f	file:
reconnect_wait	.\lib\reconnect.c	/^reconnect_wait(struct reconnect *fsm, long long int now)$/;"	f
recs	.\vswitchd\bridge.c	/^static struct ovsrec_port **recs;$/;"	v	typeref:struct:ovsrec_port	file:
recurse	.\ofproto\ofproto-dpif-xlate.c	/^    int recurse;                \/* Current resubmit nesting depth. *\/$/;"	m	struct:xlate_ctx	file:
recurse	.\python\ovs\fatal_signal.py	/^recurse = False$/;"	v
recurse	.\utilities\ovs-vsctl.c	/^    bool recurse;$/;"	m	struct:cmd_show_table	file:
recv	.\lib\cfm.c	/^    bool recv;           \/* CCM was received since last fault check. *\/$/;"	m	struct:remote_mp	file:
recv	.\lib\dpif-provider.h	/^    int (*recv)(struct dpif *dpif, uint32_t handler_id,$/;"	m	struct:dpif_class
recv	.\lib\stream-provider.h	/^    ssize_t (*recv)(struct stream *stream, void *buffer, size_t n);$/;"	m	struct:stream_class
recv	.\lib\vconn-provider.h	/^    int (*recv)(struct vconn *vconn, struct ofpbuf **msgp);$/;"	m	struct:vconn_class
recv	.\python\ovs\jsonrpc.py	/^    def recv(self):$/;"	m	class:Connection
recv	.\python\ovs\jsonrpc.py	/^    def recv(self):$/;"	m	class:Session
recv	.\python\ovs\stream.py	/^    def recv(self, n):$/;"	m	class:Stream
recv_any_version	.\lib\vconn-provider.h	/^    bool recv_any_version;      \/* True to receive a message of any version. *\/$/;"	m	struct:vconn
recv_block	.\python\ovs\jsonrpc.py	/^    def recv_block(self):$/;"	m	class:Connection
recv_fault	.\lib\cfm.c	/^    enum cfm_fault_reason recv_fault;  \/* Bit mask of faults occurring on$/;"	m	struct:cfm	typeref:enum:cfm::cfm_fault_reason	file:
recv_flow_stats_reply	.\utilities\ovs-ofctl.c	/^recv_flow_stats_reply(struct vconn *vconn, ovs_be32 send_xid,$/;"	f	file:
recv_purge	.\lib\dpif-provider.h	/^    void (*recv_purge)(struct dpif *dpif);$/;"	m	struct:dpif_class
recv_queue	.\lib\netdev-dummy.c	/^    struct list recv_queue;$/;"	m	struct:netdev_rxq_dummy	typeref:struct:netdev_rxq_dummy::list	file:
recv_queue_len	.\lib\netdev-dummy.c	/^    int recv_queue_len;         \/* list_size(&recv_queue). *\/$/;"	m	struct:netdev_rxq_dummy	file:
recv_set	.\lib\dpif-provider.h	/^    int (*recv_set)(struct dpif *dpif, bool enable);$/;"	m	struct:dpif_class
recv_set_enable	.\ofproto\ofproto-dpif.c	/^    bool recv_set_enable; \/* Enables or disables receiving packets. *\/$/;"	m	struct:dpif_backer	file:
recv_wait	.\lib\dpif-provider.h	/^    void (*recv_wait)(struct dpif *dpif, uint32_t handler_id);$/;"	m	struct:dpif_class
recv_wait	.\python\ovs\jsonrpc.py	/^    def recv_wait(self, poller):$/;"	m	class:Connection
recv_wait	.\python\ovs\jsonrpc.py	/^    def recv_wait(self, poller):$/;"	m	class:Session
recv_wait	.\python\ovs\stream.py	/^    def recv_wait(self, poller):$/;"	m	class:Stream
reduce_timeout	.\ofproto\ofproto.c	/^reduce_timeout(uint16_t max, uint16_t *timeout)$/;"	f	file:
refTable	.\lib\ovsdb-types.h	/^            struct ovsdb_table *refTable; \/* Referenced table, if available. *\/$/;"	m	struct:ovsdb_base_type::__anon86::ovsdb_uuid_constraints	typeref:struct:ovsdb_base_type::__anon86::ovsdb_uuid_constraints::ovsdb_table
refTableName	.\lib\ovsdb-types.h	/^            char *refTableName; \/* Name of referenced table, or NULL. *\/$/;"	m	struct:ovsdb_base_type::__anon86::ovsdb_uuid_constraints
refType	.\lib\ovsdb-types.h	/^            enum ovsdb_ref_type refType;  \/* Reference type. *\/$/;"	m	struct:ovsdb_base_type::__anon86::ovsdb_uuid_constraints	typeref:enum:ovsdb_base_type::__anon86::ovsdb_uuid_constraints::ovsdb_ref_type
ref_cnt	.\lib\bfd.c	/^    struct ovs_refcount ref_cnt;$/;"	m	struct:bfd	typeref:struct:bfd::ovs_refcount	file:
ref_cnt	.\lib\cfm.c	/^    struct ovs_refcount ref_cnt;$/;"	m	struct:cfm	typeref:struct:cfm::ovs_refcount	file:
ref_cnt	.\lib\dpif-netdev.c	/^    struct ovs_refcount ref_cnt;$/;"	m	struct:dp_netdev	typeref:struct:dp_netdev::ovs_refcount	file:
ref_cnt	.\lib\dpif-netdev.c	/^    struct ovs_refcount ref_cnt;$/;"	m	struct:dp_netdev_port	typeref:struct:dp_netdev_port::ovs_refcount	file:
ref_cnt	.\lib\lacp.c	/^    struct ovs_refcount ref_cnt;$/;"	m	struct:lacp	typeref:struct:lacp::ovs_refcount	file:
ref_cnt	.\lib\mac-learning.h	/^    struct ovs_refcount ref_cnt;$/;"	m	struct:mac_learning	typeref:struct:mac_learning::ovs_refcount
ref_cnt	.\lib\netdev-provider.h	/^    int ref_cnt;                        \/* Times this devices was opened. *\/$/;"	m	struct:netdev
ref_cnt	.\lib\netdev.c	/^    atomic_int ref_cnt;         \/* Number of 'struct netdev's of this class. *\/$/;"	m	struct:netdev_registered_class	file:
ref_cnt	.\lib\stp.c	/^    struct ovs_refcount ref_cnt;$/;"	m	struct:stp	typeref:struct:stp::ovs_refcount	file:
ref_cnt	.\ofproto\bond.c	/^    struct ovs_refcount ref_cnt;$/;"	m	struct:bond	typeref:struct:bond::ovs_refcount	file:
ref_cnt	.\ofproto\netflow.c	/^    struct ovs_refcount ref_cnt;$/;"	m	struct:netflow	typeref:struct:netflow::ovs_refcount	file:
ref_cnt	.\ofproto\ofproto-dpif-ipfix.c	/^    struct ovs_refcount ref_cnt;$/;"	m	struct:dpif_ipfix	typeref:struct:dpif_ipfix::ovs_refcount	file:
ref_cnt	.\ofproto\ofproto-dpif-mirror.c	/^    struct ovs_refcount ref_cnt;$/;"	m	struct:mbridge	typeref:struct:mbridge::ovs_refcount	file:
ref_cnt	.\ofproto\ofproto-dpif-sflow.c	/^    struct ovs_refcount ref_cnt;$/;"	m	struct:dpif_sflow	typeref:struct:dpif_sflow::ovs_refcount	file:
ref_count	.\datapath\flow.h	/^	int ref_count;$/;"	m	struct:sw_flow_mask
ref_count	.\include\openflow\openflow-1.1.h	/^    ovs_be32 ref_count;        \/* Number of flows or groups that$/;"	m	struct:ofp11_group_stats
ref_count	.\lib\ofp-util.h	/^    uint32_t ref_count;$/;"	m	struct:ofputil_group_stats
ref_count	.\ofproto\ofproto-provider.h	/^    struct ovs_refcount ref_count;$/;"	m	struct:rule	typeref:struct:rule::ovs_refcount
refcount	.\lib\dpif.c	/^    int refcount;$/;"	m	struct:registered_dpif_class	file:
refcount	.\lib\netdev-dpdk.c	/^    int refcount;$/;"	m	struct:dpdk_mp	file:
refcount	.\ofproto\ofproto-dpif.c	/^    int refcount;$/;"	m	struct:dpif_backer	file:
refill	.\tests\test-json.c	/^refill(FILE *file, void *buffer, size_t buffer_size, size_t *n, size_t *used)$/;"	f	file:
refresh_channels	.\lib\dpif-linux.c	/^    bool refresh_channels;$/;"	m	struct:dpif_linux	file:
refresh_controller_status	.\vswitchd\bridge.c	/^refresh_controller_status(void)$/;"	f	file:
refresh_local	.\ofproto\in-band.c	/^refresh_local(struct in_band *ib)$/;"	f	file:
refresh_remote	.\ofproto\in-band.c	/^refresh_remote(struct in_band *ib, struct in_band_remote *r)$/;"	f	file:
refresh_remotes	.\ofproto\in-band.c	/^refresh_remotes(struct in_band *ib)$/;"	f	file:
refresh_rusage	.\lib\timeval.c	/^refresh_rusage(void)$/;"	f	file:
reg_load	.\lib\ofp-actions.c	/^    struct nx_action_reg_load reg_load;$/;"	m	union:ofp_action	typeref:struct:ofp_action::nx_action_reg_load	file:
reg_move	.\lib\ofp-actions.c	/^    struct nx_action_reg_move reg_move;$/;"	m	union:ofp_action	typeref:struct:ofp_action::nx_action_reg_move	file:
register	.\python\compat\argparse.py	/^    def register(self, registry_name, value, object):$/;"	m	class:_ActionsContainer
register	.\python\ovs\poller.py	/^    def register(self, fd, events):$/;"	m	class:_SelectSelect
register_all	.\python\ovs\db\idl.py	/^    def register_all(self):$/;"	m	class:SchemaHelper
register_columns	.\python\ovs\db\idl.py	/^    def register_columns(self, table, columns):$/;"	m	class:SchemaHelper
register_count	.\lib\route-table-bsd.c	/^static unsigned int register_count = 0;$/;"	v	file:
register_count	.\lib\route-table.c	/^static unsigned int register_count = 0;$/;"	v	file:
register_method	.\python\ovs\stream.py	/^    def register_method(method, cls):$/;"	m	class:Stream
register_pernet_device	.\datapath\linux\compat\include\net\net_namespace.h	17;"	d
register_rec	.\vswitchd\bridge.c	/^register_rec(struct ovsrec_port *rec)$/;"	f	file:
register_table	.\python\ovs\db\idl.py	/^    def register_table(self, table):$/;"	m	class:SchemaHelper
registered_dpif_class	.\lib\dpif.c	/^struct registered_dpif_class {$/;"	s	file:
regs	.\lib\flow.h	/^    uint32_t regs[FLOW_N_REGS]; \/* Registers. *\/$/;"	m	struct:flow
reinit_ports	.\ofproto\ofproto.c	/^reinit_ports(struct ofproto *p)$/;"	f	file:
reinsert_bal	.\ofproto\bond.c	/^reinsert_bal(struct list *bals, struct bond_slave *slave)$/;"	f	file:
reject_slave_controller	.\ofproto\ofproto.c	/^reject_slave_controller(struct ofconn *ofconn)$/;"	f	file:
relevant	.\lib\route-table.c	/^    bool relevant;        \/* Should this message be processed? *\/$/;"	m	struct:route_table_msg	file:
reliable	.\lib\rconn.c	/^    bool reliable;$/;"	m	struct:rconn	file:
relop	.\utilities\ovs-vsctl.c	/^enum relop {$/;"	g	file:
relop	.\vtep\vtep-ctl.c	/^enum relop {$/;"	g	file:
remote	.\lib\vtep-idl.h	/^	struct vteprec_physical_locator *remote;$/;"	m	struct:vteprec_tunnel	typeref:struct:vteprec_tunnel::vteprec_physical_locator
remote	.\ovsdb\jsonrpc-server.c	/^    struct ovsdb_jsonrpc_remote *remote;$/;"	m	struct:ovsdb_jsonrpc_session	typeref:struct:ovsdb_jsonrpc_session::ovsdb_jsonrpc_remote	file:
remote_addr	.\ofproto\in-band.c	/^    struct sockaddr_in remote_addr; \/* IP address, in network byte order. *\/$/;"	m	struct:in_band_remote	typeref:struct:in_band_remote::sockaddr_in	file:
remote_addr	.\utilities\ovs-benchmark.c	/^static struct in_addr remote_addr;$/;"	v	typeref:struct:in_addr	file:
remote_cfg	.\vtep\vtep-ctl.c	/^    const struct vteprec_mcast_macs_remote *remote_cfg;$/;"	m	struct:vtep_ctl_mcast_mac	typeref:struct:vtep_ctl_mcast_mac::vteprec_mcast_macs_remote	file:
remote_mac	.\ofproto\in-band.c	/^    uint8_t remote_mac[ETH_ADDR_LEN]; \/* Next-hop MAC, all-zeros if unknown. *\/$/;"	m	struct:in_band_remote	file:
remote_max_port	.\utilities\ovs-benchmark.c	/^static unsigned short int remote_min_port, remote_max_port;$/;"	v	file:
remote_min_port	.\utilities\ovs-benchmark.c	/^static unsigned short int remote_min_port, remote_max_port;$/;"	v	file:
remote_mp	.\lib\cfm.c	/^struct remote_mp {$/;"	s	file:
remote_mps	.\lib\cfm.c	/^    struct hmap remote_mps;   \/* Remote MPs. *\/$/;"	m	struct:cfm	typeref:struct:cfm::hmap	file:
remote_netdev	.\ofproto\in-band.c	/^    struct netdev *remote_netdev; \/* Device to send to next-hop MAC. *\/$/;"	m	struct:in_band_remote	typeref:struct:in_band_remote::netdev	file:
remote_opstate	.\ofproto\ofproto.h	/^    int remote_opstate;$/;"	m	struct:ofproto_cfm_status
remote_opup	.\lib\cfm.c	/^    bool remote_opup;      \/* Remote Operational State. *\/$/;"	m	struct:cfm	file:
remotes	.\ofproto\in-band.c	/^    struct in_band_remote *remotes;$/;"	m	struct:in_band	typeref:struct:in_band::in_band_remote	file:
remotes	.\ovsdb\jsonrpc-server.c	/^    struct shash remotes;      \/* Contains "struct ovsdb_jsonrpc_remote *"s. *\/$/;"	m	struct:ovsdb_jsonrpc_server	typeref:struct:ovsdb_jsonrpc_server::shash	file:
remotes	.\ovsdb\ovsdb-server.c	/^    struct sset *remotes;$/;"	m	struct:server_config	typeref:struct:server_config::sset	file:
remove_file_to_unlink	.\python\ovs\fatal_signal.py	/^def remove_file_to_unlink(file):$/;"	f
render	.\python\ovstest\rpcserver.py	/^    def render(self, request):$/;"	m	class:TestArena
reopen_log_file	.\python\ovs\vlog.py	/^    def reopen_log_file():$/;"	m	class:Vlog
replica	.\ovsdb\file.c	/^    struct ovsdb_replica replica;$/;"	m	struct:ovsdb_file	typeref:struct:ovsdb_file::ovsdb_replica	file:
replica	.\ovsdb\jsonrpc-server.c	/^    struct ovsdb_replica replica;$/;"	m	struct:ovsdb_jsonrpc_monitor	typeref:struct:ovsdb_jsonrpc_monitor::ovsdb_replica	file:
replicas	.\ovsdb\ovsdb.h	/^    struct list replicas;       \/* Contains "struct ovsdb_replica"s. *\/$/;"	m	struct:ovsdb	typeref:struct:ovsdb::list
replies	.\ofproto\ofproto.c	/^    struct list replies;$/;"	m	struct:queue_stats_cbdata	typeref:struct:queue_stats_cbdata::list	file:
reply	.\lib\netlink-socket.h	/^    struct ofpbuf *reply;       \/* Reply (empty if reply was an error code). *\/$/;"	m	struct:nl_transaction	typeref:struct:nl_transaction::ofpbuf
reply	.\python\ovs\unixctl\server.py	/^    def reply(self, body):$/;"	m	class:UnixctlConnection
reply_counter	.\ofproto\connmgr.c	/^    struct rconn_packet_counter *reply_counter;$/;"	m	struct:ofconn	typeref:struct:ofconn::rconn_packet_counter	file:
reply_error	.\python\ovs\unixctl\server.py	/^    def reply_error(self, body):$/;"	m	class:UnixctlConnection
report_error_if_changed	.\ovsdb\ovsdb-server.c	/^report_error_if_changed(char *error, char **last_errorp)$/;"	f	file:
report_hook	.\ofproto\ofproto-dpif-xlate.h	/^    void (*report_hook)(struct xlate_in *, const char *s, int recurse);$/;"	m	struct:xlate_in
report_loss	.\lib\dpif-linux.c	/^report_loss(struct dpif_linux *dpif, struct dpif_channel *ch, uint32_t ch_idx,$/;"	f	file:
request	.\lib\netlink-socket.h	/^    struct ofpbuf *request;     \/* Request to send. *\/$/;"	m	struct:nl_transaction	typeref:struct:nl_transaction::ofpbuf
request	.\ofproto\ofproto.c	/^    struct ofp_header *request; \/* Original request (truncated at 64 bytes). *\/$/;"	m	struct:ofopgroup	typeref:struct:ofopgroup::ofp_header	file:
request	.\ovsdb\trigger.h	/^    struct json *request;       \/* Database request. *\/$/;"	m	struct:ovsdb_trigger	typeref:struct:ovsdb_trigger::json
request_id	.\lib\ovsdb-idl.c	/^    struct json *request_id;$/;"	m	struct:ovsdb_idl_txn	typeref:struct:ovsdb_idl_txn::json	file:
request_id	.\lib\unixctl.c	/^    struct json *request_id;   \/* ID of the currently active request. *\/$/;"	m	struct:unixctl_conn	typeref:struct:unixctl_conn::json	file:
required_argument	.\include\windows\getopt.h	42;"	d
reserve_sfa_size	.\datapath\flow_netlink.c	/^static struct nlattr *reserve_sfa_size(struct sw_flow_actions **sfa,$/;"	f	file:
reserved	.\lib\netlink-protocol.h	/^    uint16_t reserved;$/;"	m	struct:genlmsghdr
reserved_flags	.\datapath\vport-lisp.c	/^	__u8 reserved_flags:3;$/;"	m	struct:lisphdr	file:
reset	.\lib\sflow_poller.c	/^static void reset(SFLPoller *poller)$/;"	f	file:
reset	.\lib\sflow_receiver.c	/^static void reset(SFLReceiver *receiver) {$/;"	f	file:
reset	.\lib\sflow_sampler.c	/^static void reset(SFLSampler *sampler)$/;"	f	file:
reset	.\utilities\ovs-dev.py	/^def reset():$/;"	f
resetSampleCollector	.\lib\sflow_receiver.c	/^static void resetSampleCollector(SFLReceiver *receiver)$/;"	f	file:
resize	.\lib\hmap.c	/^resize(struct hmap *hmap, size_t new_mask, const char *where)$/;"	f	file:
resource	.\python\ovs\daemon.py	/^import resource$/;"	i
restart	.\xenserver\usr_lib_xsconsole_plugins-base_XSFeatureVSwitch.py	/^    def restart(self):$/;"	m	class:VSwitchService
restartService	.\xenserver\usr_lib_xsconsole_plugins-base_XSFeatureVSwitch.py	/^    def restartService(self, name):$/;"	m	class:VSwitchControllerDialogue
restore_all_flags	.\lib\netdev.c	/^restore_all_flags(void *aux OVS_UNUSED)$/;"	f	file:
resubmit	.\lib\ofp-actions.c	/^    struct nx_action_resubmit resubmit;$/;"	m	union:ofp_action	typeref:struct:ofp_action::nx_action_resubmit	file:
resubmit_from_openflow	.\lib\ofp-actions.c	/^resubmit_from_openflow(const struct nx_action_resubmit *nar,$/;"	f	file:
resubmit_hook	.\ofproto\ofproto-dpif-xlate.h	/^    void (*resubmit_hook)(struct xlate_in *, struct rule_dpif *rule,$/;"	m	struct:xlate_in
resubmit_stats	.\ofproto\ofproto-dpif-xlate.h	/^    const struct dpif_flow_stats *resubmit_stats;$/;"	m	struct:xlate_in	typeref:struct:xlate_in::dpif_flow_stats
resubmit_table_from_openflow	.\lib\ofp-actions.c	/^resubmit_table_from_openflow(const struct nx_action_resubmit *nar,$/;"	f	file:
resubmits	.\ofproto\ofproto-dpif-xlate.c	/^    int resubmits;              \/* Total number of resubmits. *\/$/;"	m	struct:xlate_ctx	file:
result	.\lib\jsonrpc.h	/^    struct json *result;        \/* Successful reply only. *\/$/;"	m	struct:jsonrpc_msg	typeref:struct:jsonrpc_msg::json
result	.\ofproto\ofproto-dpif.c	/^    struct ds *result;$/;"	m	struct:trace_ctx	typeref:struct:trace_ctx::ds	file:
result	.\ovsdb\trigger.h	/^    struct json *result;        \/* Result (null if none yet). *\/$/;"	m	struct:ovsdb_trigger	typeref:struct:ovsdb_trigger::json
resumeProducing	.\python\ovstest\tcp.py	/^    def resumeProducing(self):$/;"	m	class:Producer
retry	.\ofproto\connmgr.c	/^    bool retry;                 \/* True if 'blocked' is ready to try again. *\/$/;"	m	struct:ofconn	file:
retry	.\utilities\ovs-vsctl.c	/^static bool retry;$/;"	v	file:
returnUnchanged	.\python\ovs\db\data.py	/^def returnUnchanged(x):$/;"	f
returnUnchanged	.\python\ovs\db\types.py	/^def returnUnchanged(x):$/;"	f
retval	.\lib\netdev-bsd.c	/^    int retval;$/;"	m	struct:pcap_arg	file:
rev_bond	.\ofproto\ofproto-dpif.c	/^COVERAGE_DEFINE(rev_bond);$/;"	v
rev_flow_table	.\ofproto\ofproto-dpif.c	/^COVERAGE_DEFINE(rev_flow_table);$/;"	v
rev_mac_learning	.\ofproto\ofproto-dpif.c	/^COVERAGE_DEFINE(rev_mac_learning);$/;"	v
rev_port_toggled	.\ofproto\ofproto-dpif.c	/^COVERAGE_DEFINE(rev_port_toggled);$/;"	v
rev_reconfigure	.\ofproto\ofproto-dpif.c	/^COVERAGE_DEFINE(rev_reconfigure);$/;"	v
rev_stp	.\ofproto\ofproto-dpif.c	/^COVERAGE_DEFINE(rev_stp);$/;"	v
reval_barrier	.\ofproto\ofproto-dpif-upcall.c	/^    struct ovs_barrier reval_barrier;  \/* Barrier used by revalidators. *\/$/;"	m	struct:udpif	typeref:struct:udpif::ovs_barrier	file:
reval_exit	.\ofproto\ofproto-dpif-upcall.c	/^    bool reval_exit;                   \/* Set by leader on 'exit_latch. *\/$/;"	m	struct:udpif	file:
reval_seq	.\ofproto\ofproto-dpif-upcall.c	/^    struct seq *reval_seq;             \/* Incremented to force revalidation. *\/$/;"	m	struct:udpif	typeref:struct:udpif::seq	file:
revalidate	.\ofproto\ofproto-dpif-upcall.c	/^revalidate(struct revalidator *revalidator)$/;"	f	file:
revalidate_missed_dp_flow	.\ofproto\ofproto-dpif-upcall.c	/^COVERAGE_DEFINE(revalidate_missed_dp_flow);$/;"	v
revalidate_reason	.\ofproto\ofproto-dpif.c	/^enum revalidate_reason {$/;"	g	file:
revalidator	.\ofproto\ofproto-dpif-upcall.c	/^struct revalidator {$/;"	s	file:
revalidator_purge	.\ofproto\ofproto-dpif-upcall.c	/^revalidator_purge(struct revalidator *revalidator)$/;"	f	file:
revalidator_sweep	.\ofproto\ofproto-dpif-upcall.c	/^revalidator_sweep(struct revalidator *revalidator)$/;"	f	file:
revalidators	.\ofproto\ofproto-dpif-upcall.c	/^    struct revalidator *revalidators;  \/* Flow revalidators. *\/$/;"	m	struct:udpif	typeref:struct:udpif::revalidator	file:
reverse	.\tests\test-classifier.c	/^reverse(int *a, int n)$/;"	f	file:
reverse	.\tests\test-heap.c	/^reverse(uint32_t *a, int n)$/;"	f	file:
revert	.\xenserver\opt_xensource_libexec_InterfaceReconfigure.py	/^    def revert(self):$/;"	m	class:ConfigurationFile
rewrite	.\xenserver\opt_xensource_libexec_InterfaceReconfigure.py	/^    def rewrite(cls):$/;"	m	class:Datapath
rewrite	.\xenserver\opt_xensource_libexec_InterfaceReconfigureVswitch.py	/^    def rewrite(cls):$/;"	m	class:DatapathVswitch
rid_map	.\ofproto\ofproto-dpif-rid.c	/^struct rid_map {$/;"	s	file:
rid_node	.\ofproto\ofproto-dpif-rid.c	/^struct rid_node {$/;"	s	file:
rid_pool	.\ofproto\ofproto-dpif-rid.c	/^struct rid_pool {$/;"	s	file:
rid_pool	.\ofproto\ofproto-dpif.c	/^    struct recirc_id_pool *rid_pool;       \/* Recirculation ID pool. *\/$/;"	m	struct:dpif_backer	typeref:struct:dpif_backer::recirc_id_pool	file:
rid_pool_add	.\ofproto\ofproto-dpif-rid.c	/^rid_pool_add(struct rid_pool *rids, uint32_t id)$/;"	f	file:
rid_pool_alloc_id	.\ofproto\ofproto-dpif-rid.c	/^rid_pool_alloc_id(struct rid_pool *rids)$/;"	f	file:
rid_pool_find	.\ofproto\ofproto-dpif-rid.c	/^rid_pool_find(struct rid_pool *rids, uint32_t id)$/;"	f	file:
rid_pool_free_id	.\ofproto\ofproto-dpif-rid.c	/^rid_pool_free_id(struct rid_pool *rids, uint32_t id)$/;"	f	file:
rid_pool_init	.\ofproto\ofproto-dpif-rid.c	/^rid_pool_init(struct rid_pool *rids, uint32_t base, uint32_t n_ids)$/;"	f	file:
rid_pool_uninit	.\ofproto\ofproto-dpif-rid.c	/^rid_pool_uninit(struct rid_pool *rids)$/;"	f	file:
ridmap	.\ofproto\ofproto-dpif-rid.c	/^    struct rid_map ridmap;$/;"	m	struct:rid_pool	typeref:struct:rid_pool::rid_map	file:
rids	.\ofproto\ofproto-dpif-rid.c	/^    struct rid_pool rids;$/;"	m	struct:recirc_id_pool	typeref:struct:recirc_id_pool::rid_pool	file:
rightmost_1bit	.\lib\util.h	/^rightmost_1bit(uintmax_t x)$/;"	f
rightmost_1bit_idx	.\lib\util.h	/^rightmost_1bit_idx(uint32_t x)$/;"	f
rk	.\lib\aes128.h	/^    uint32_t rk[128\/8 + 28];$/;"	m	struct:aes128
rl	.\lib\bfd.c	/^static struct vlog_rate_limit rl = VLOG_RATE_LIMIT_INIT(20, 20);$/;"	v	typeref:struct:vlog_rate_limit	file:
rl	.\lib\cfm.c	/^static struct vlog_rate_limit rl = VLOG_RATE_LIMIT_INIT(20, 30);$/;"	v	typeref:struct:vlog_rate_limit	file:
rl	.\lib\jsonrpc.c	/^static struct vlog_rate_limit rl = VLOG_RATE_LIMIT_INIT(5, 5);$/;"	v	typeref:struct:vlog_rate_limit	file:
rl	.\lib\learning-switch.c	/^static struct vlog_rate_limit rl = VLOG_RATE_LIMIT_INIT(30, 300);$/;"	v	typeref:struct:vlog_rate_limit	file:
rl	.\lib\meta-flow.c	/^static struct vlog_rate_limit rl = VLOG_RATE_LIMIT_INIT(1, 5);$/;"	v	typeref:struct:vlog_rate_limit	file:
rl	.\lib\multipath.c	/^static struct vlog_rate_limit rl = VLOG_RATE_LIMIT_INIT(1, 5);$/;"	v	typeref:struct:vlog_rate_limit	file:
rl	.\lib\netdev-bsd.c	/^static struct vlog_rate_limit rl = VLOG_RATE_LIMIT_INIT(5, 20);$/;"	v	typeref:struct:vlog_rate_limit	file:
rl	.\lib\netdev-dpdk.c	/^static struct vlog_rate_limit rl = VLOG_RATE_LIMIT_INIT(5, 20);$/;"	v	typeref:struct:vlog_rate_limit	file:
rl	.\lib\netdev-linux.c	/^static struct vlog_rate_limit rl = VLOG_RATE_LIMIT_INIT(5, 20);$/;"	v	typeref:struct:vlog_rate_limit	file:
rl	.\lib\netdev.c	/^static struct vlog_rate_limit rl = VLOG_RATE_LIMIT_INIT(5, 20);$/;"	v	typeref:struct:vlog_rate_limit	file:
rl	.\lib\netlink-socket.c	/^static struct vlog_rate_limit rl = VLOG_RATE_LIMIT_INIT(60, 600);$/;"	v	typeref:struct:vlog_rate_limit	file:
rl	.\lib\netlink.c	/^static struct vlog_rate_limit rl = VLOG_RATE_LIMIT_INIT(60, 600);$/;"	v	typeref:struct:vlog_rate_limit	file:
rl	.\lib\nx-match.c	/^static struct vlog_rate_limit rl = VLOG_RATE_LIMIT_INIT(1, 5);$/;"	v	typeref:struct:vlog_rate_limit	file:
rl	.\lib\ofp-actions.c	/^static struct vlog_rate_limit rl = VLOG_RATE_LIMIT_INIT(1, 5);$/;"	v	typeref:struct:vlog_rate_limit	file:
rl	.\lib\route-table.c	/^static struct vlog_rate_limit rl = VLOG_RATE_LIMIT_INIT(5, 20);$/;"	v	typeref:struct:vlog_rate_limit	file:
rl	.\lib\stream-fd-unix.c	/^static struct vlog_rate_limit rl = VLOG_RATE_LIMIT_INIT(10, 25);$/;"	v	typeref:struct:vlog_rate_limit	file:
rl	.\lib\stream-fd-windows.c	/^static struct vlog_rate_limit rl = VLOG_RATE_LIMIT_INIT(10, 25);$/;"	v	typeref:struct:vlog_rate_limit	file:
rl	.\lib\stream-ssl.c	/^static struct vlog_rate_limit rl = VLOG_RATE_LIMIT_INIT(10, 25);$/;"	v	typeref:struct:vlog_rate_limit	file:
rl	.\lib\unixctl.c	/^static struct vlog_rate_limit rl = VLOG_RATE_LIMIT_INIT(5, 5);$/;"	v	typeref:struct:vlog_rate_limit	file:
rl	.\lib\vconn-stream.c	/^static struct vlog_rate_limit rl = VLOG_RATE_LIMIT_INIT(10, 25);$/;"	v	typeref:struct:vlog_rate_limit	file:
rl	.\ofproto\connmgr.c	/^static struct vlog_rate_limit rl = VLOG_RATE_LIMIT_INIT(1, 5);$/;"	v	typeref:struct:vlog_rate_limit	file:
rl	.\ofproto\in-band.c	/^static struct vlog_rate_limit rl = VLOG_RATE_LIMIT_INIT(60, 60);$/;"	v	typeref:struct:vlog_rate_limit	file:
rl	.\ofproto\ofproto-dpif-ipfix.c	/^static struct vlog_rate_limit rl = VLOG_RATE_LIMIT_INIT(1, 5);$/;"	v	typeref:struct:vlog_rate_limit	file:
rl	.\ofproto\ofproto-dpif-sflow.c	/^static struct vlog_rate_limit rl = VLOG_RATE_LIMIT_INIT(1, 5);$/;"	v	typeref:struct:vlog_rate_limit	file:
rl	.\ofproto\ofproto-dpif-upcall.c	/^static struct vlog_rate_limit rl = VLOG_RATE_LIMIT_INIT(1, 5);$/;"	v	typeref:struct:vlog_rate_limit	file:
rl	.\ofproto\ofproto-dpif.c	/^static struct vlog_rate_limit rl = VLOG_RATE_LIMIT_INIT(1, 5);$/;"	v	typeref:struct:vlog_rate_limit	file:
rl	.\ofproto\ofproto.c	/^static struct vlog_rate_limit rl = VLOG_RATE_LIMIT_INIT(1, 5);$/;"	v	typeref:struct:vlog_rate_limit	file:
rl	.\ofproto\tunnel.c	/^static struct vlog_rate_limit rl = VLOG_RATE_LIMIT_INIT(1, 5);$/;"	v	typeref:struct:vlog_rate_limit	file:
rl	.\ovsdb\jsonrpc-server.c	/^static struct vlog_rate_limit rl = VLOG_RATE_LIMIT_INIT(1, 5);$/;"	v	typeref:struct:vlog_rate_limit	file:
rlim_is_finite	.\lib\process.c	/^rlim_is_finite(rlim_t limit)$/;"	f	file:
rmps	.\ofproto\ofproto.h	/^    uint64_t *rmps;$/;"	m	struct:ofproto_cfm_status
rmps_array	.\lib\cfm.c	/^    uint64_t *rmps_array;     \/* Cache of remote_mps. *\/$/;"	m	struct:cfm	file:
rmps_array_len	.\lib\cfm.c	/^    size_t rmps_array_len;    \/* Number of rmps in 'rmps_array'. *\/$/;"	m	struct:cfm	file:
rmt_diag	.\lib\bfd.c	/^    enum diag rmt_diag;           \/* Remote diagnostic. *\/$/;"	m	struct:bfd	typeref:enum:bfd::diag	file:
rmt_disc	.\lib\bfd.c	/^    uint32_t rmt_disc;            \/* bfd.RemoteDiscr. *\/$/;"	m	struct:bfd	file:
rmt_eth_dst	.\lib\bfd.c	/^    uint8_t rmt_eth_dst[ETH_ADDR_LEN];   \/* Remote eth dst address. *\/$/;"	m	struct:bfd	file:
rmt_flags	.\lib\bfd.c	/^    enum flags rmt_flags;         \/* Flags last received. *\/$/;"	m	struct:bfd	typeref:enum:bfd::flags	file:
rmt_min_rx	.\lib\bfd.c	/^    long long int rmt_min_rx;     \/* bfd.RemoteMinRxInterval. *\/$/;"	m	struct:bfd	file:
rmt_min_tx	.\lib\bfd.c	/^    long long int rmt_min_tx;     \/* Remote minimum TX interval. *\/$/;"	m	struct:bfd	file:
rmt_state	.\lib\bfd.c	/^    enum state rmt_state;         \/* bfd.RemoteSessionState. *\/$/;"	m	struct:bfd	typeref:enum:bfd::state	file:
rn_ids	.\datapath\vport.h	/^	struct reciprocal_value rn_ids;$/;"	m	struct:vport_portids	typeref:struct:vport_portids::reciprocal_value
role	.\include\openflow\nicira-ext.h	/^    ovs_be32 role;              \/* One of NX_ROLE_*. *\/$/;"	m	struct:nx_role_request
role	.\include\openflow\openflow-1.2.h	/^    ovs_be32 role;            \/* One of OFPCR12_ROLE_*. *\/$/;"	m	struct:ofp12_role_request
role	.\include\openflow\openflow-1.4.h	/^    ovs_be32 role;              \/* One of OFPCR_ROLE_*. *\/$/;"	m	struct:ofp14_role_status
role	.\lib\ofp-util.h	/^    enum ofp12_controller_role role;$/;"	m	struct:ofputil_role_request	typeref:enum:ofputil_role_request::ofp12_controller_role
role	.\lib\ofp-util.h	/^    enum ofp12_controller_role role;$/;"	m	struct:ofputil_role_status	typeref:enum:ofputil_role_status::ofp12_controller_role
role	.\lib\vswitch-idl.h	/^	char *role;$/;"	m	struct:ovsrec_controller
role	.\ofproto\connmgr.c	/^    enum ofp12_controller_role role;           \/* Role. *\/$/;"	m	struct:ofconn	typeref:enum:ofconn::ofp12_controller_role	file:
role	.\ofproto\ofproto.h	/^    enum ofp12_controller_role role;$/;"	m	struct:ofproto_controller_info	typeref:enum:ofproto_controller_info::ofp12_controller_role
role	.\ofproto\ofproto.h	/^    enum stp_role role;$/;"	m	struct:ofproto_port_stp_status	typeref:enum:ofproto_port_stp_status::stp_role
root	.\lib\classifier.c	/^    struct trie_node *root;       \/* NULL if none. *\/$/;"	m	struct:cls_trie	typeref:struct:cls_trie::trie_node	file:
root_path_cost	.\lib\stp.c	/^    unsigned int root_path_cost;    \/* 8.5.3.2: Cost of path to root. *\/$/;"	m	struct:stp	file:
root_path_cost	.\ofproto\ofproto.h	/^    int root_path_cost;$/;"	m	struct:ofproto_stp_status
root_port	.\lib\stp.c	/^    struct stp_port *root_port;     \/* 8.5.3.3: Lowest cost port to root. *\/$/;"	m	struct:stp	typeref:struct:stp::stp_port	file:
root_prefix	.\xenserver\opt_xensource_libexec_InterfaceReconfigure.py	/^def root_prefix():$/;"	f
root_set_size	.\ovsdb\ovsdb.c	/^root_set_size(const struct ovsdb_schema *schema)$/;"	f	file:
rotate32	.\lib\sha1.c	/^rotate32(uint32_t x, int n)$/;"	f	file:
round_up_pow2	.\lib\multipath.c	/^round_up_pow2(unsigned int x)$/;"	f	file:
rounddown	.\datapath\linux\compat\include\linux\kernel.h	60;"	d
route_data	.\lib\route-table.c	/^struct route_data {$/;"	s	file:
route_map	.\lib\route-table.c	/^static struct hmap route_map;$/;"	v	typeref:struct:hmap	file:
route_map_clear	.\lib\route-table.c	/^route_map_clear(void)$/;"	f	file:
route_node	.\lib\route-table.c	/^struct route_node {$/;"	s	file:
route_node_lookup	.\lib\route-table.c	/^route_node_lookup(const struct route_data *rd)$/;"	f	file:
route_node_lookup_by_ip	.\lib\route-table.c	/^route_node_lookup_by_ip(uint32_t ip)$/;"	f	file:
route_notifier	.\lib\route-table.c	/^static struct nln_notifier *route_notifier = NULL;$/;"	v	typeref:struct:nln_notifier	file:
route_table	.\lib\route-table.c	/^VLOG_DEFINE_THIS_MODULE(route_table);$/;"	v
route_table_change	.\lib\route-table.c	/^route_table_change(const struct route_table_msg *change OVS_UNUSED,$/;"	f	file:
route_table_get_change_seq	.\lib\route-table-bsd.c	/^route_table_get_change_seq(void)$/;"	f
route_table_get_change_seq	.\lib\route-table-stub.c	/^route_table_get_change_seq(void)$/;"	f
route_table_get_change_seq	.\lib\route-table.c	/^route_table_get_change_seq(void)$/;"	f
route_table_get_name	.\lib\route-table-bsd.c	/^route_table_get_name(ovs_be32 ip, char name[IFNAMSIZ])$/;"	f
route_table_get_name	.\lib\route-table-stub.c	/^route_table_get_name(ovs_be32 ip OVS_UNUSED, char name[IFNAMSIZ] OVS_UNUSED)$/;"	f
route_table_handle_msg	.\lib\route-table.c	/^route_table_handle_msg(const struct route_table_msg *change)$/;"	f	file:
route_table_msg	.\lib\route-table.c	/^struct route_table_msg {$/;"	s	file:
route_table_mutex	.\lib\route-table.c	/^    OVS_REQUIRES(route_table_mutex);$/;"	v
route_table_mutex	.\lib\route-table.c	/^static struct ovs_mutex route_table_mutex = OVS_MUTEX_INITIALIZER;$/;"	v	typeref:struct:ovs_mutex	file:
route_table_parse	.\lib\route-table.c	/^route_table_parse(struct ofpbuf *buf, struct route_table_msg *change)$/;"	f	file:
route_table_register	.\lib\route-table-bsd.c	/^route_table_register(void)$/;"	f
route_table_register	.\lib\route-table-stub.c	/^route_table_register(void)$/;"	f
route_table_reset	.\lib\route-table.c	/^route_table_reset(void)$/;"	f	file:
route_table_run	.\lib\route-table-bsd.c	/^route_table_run(void)$/;"	f
route_table_run	.\lib\route-table-stub.c	/^route_table_run(void)$/;"	f
route_table_unregister	.\lib\route-table-bsd.c	/^route_table_unregister(void)$/;"	f
route_table_unregister	.\lib\route-table-stub.c	/^route_table_unregister(void)$/;"	f
route_table_valid	.\lib\route-table.c	/^static bool route_table_valid = false;$/;"	v	file:
route_table_wait	.\lib\route-table-bsd.c	/^route_table_wait(void)$/;"	f
route_table_wait	.\lib\route-table-stub.c	/^route_table_wait(void)$/;"	f
router	.\lib\sflow.h	/^    SFLExtended_router router;$/;"	m	union:_SFLFlow_type
routerEncodingLength	.\lib\sflow_receiver.c	/^inline static u_int32_t routerEncodingLength(SFLExtended_router *router) {$/;"	f	file:
row	.\ovsdb\execution.c	/^    const struct ovsdb_row *row;$/;"	m	struct:update_row_cbdata	typeref:struct:update_row_cbdata::ovsdb_row	file:
row	.\ovsdb\row.h	/^    const struct ovsdb_row *row;$/;"	m	struct:ovsdb_row_hash_node	typeref:struct:ovsdb_row_hash_node::ovsdb_row
row_ids	.\utilities\ovs-vsctl.c	/^    struct vsctl_row_id row_ids[2];$/;"	m	struct:vsctl_table_class	typeref:struct:vsctl_table_class::vsctl_row_id	file:
row_ids	.\vtep\vtep-ctl.c	/^    struct vtep_ctl_row_id row_ids[2];$/;"	m	struct:vtep_ctl_table_class	typeref:struct:vtep_ctl_table_class::vtep_ctl_row_id	file:
row_init	.\lib\ovsdb-idl-provider.h	/^    void (*row_init)(struct ovsdb_idl_row *);$/;"	m	struct:ovsdb_idl_table_class
row_uuids	.\tests\test-ovsdb.c	/^    struct uuid *row_uuids;$/;"	m	struct:do_query_cbdata	typeref:struct:do_query_cbdata::uuid	file:
rows	.\lib\ovsdb-idl-provider.h	/^    struct hmap rows;        \/* Contains "struct ovsdb_idl_row"s. *\/$/;"	m	struct:ovsdb_idl_table	typeref:struct:ovsdb_idl_table::hmap
rows	.\ovsdb\row.h	/^    const struct ovsdb_row **rows;$/;"	m	struct:ovsdb_row_set	typeref:struct:ovsdb_row_set::ovsdb_row
rows	.\ovsdb\row.h	/^    struct hmap rows;$/;"	m	struct:ovsdb_row_hash	typeref:struct:ovsdb_row_hash::hmap
rows	.\ovsdb\table.h	/^    struct hmap rows;           \/* Contains "struct ovsdb_row"s. *\/$/;"	m	struct:ovsdb_table	typeref:struct:ovsdb_table::hmap
rpc	.\lib\jsonrpc.c	/^    struct jsonrpc *rpc;$/;"	m	struct:jsonrpc_session	typeref:struct:jsonrpc_session::jsonrpc	file:
rpc	.\lib\unixctl.c	/^    struct jsonrpc *rpc;$/;"	m	struct:unixctl_conn	typeref:struct:unixctl_conn::jsonrpc	file:
rpc_client	.\python\ovstest\util.py	/^def rpc_client(ip, port):$/;"	f
rpl___genl_register_family	.\datapath\linux\compat\genetlink-openvswitch.c	/^int rpl___genl_register_family(struct rpl_genl_family *f)$/;"	f
rpl___vlan_hwaccel_put_tag	.\datapath\linux\compat\include\linux\if_vlan.h	/^static inline struct sk_buff *rpl___vlan_hwaccel_put_tag(struct sk_buff *skb,$/;"	f
rpl__vlan_put_tag	.\datapath\linux\compat\include\linux\if_vlan.h	/^static inline struct sk_buff *rpl__vlan_put_tag(struct sk_buff *skb, u16 vlan_tci)$/;"	f
rpl_dev_queue_xmit	.\datapath\linux\compat\gso.c	/^int rpl_dev_queue_xmit(struct sk_buff *skb)$/;"	f
rpl_genl_family	.\datapath\linux\compat\include\net\genetlink.h	/^struct rpl_genl_family {$/;"	s
rpl_genl_notify	.\datapath\linux\compat\genetlink-openvswitch.c	/^void rpl_genl_notify(struct rpl_genl_family *family, struct sk_buff *skb,$/;"	f
rpl_genl_register_family	.\datapath\linux\compat\include\net\genetlink.h	/^static inline int rpl_genl_register_family(struct genl_family *family)$/;"	f
rpl_genl_unregister_family	.\datapath\linux\compat\include\net\genetlink.h	/^static inline int rpl_genl_unregister_family(struct genl_family *family)$/;"	f
rpl_genlmsg_put	.\datapath\linux\compat\include\net\genetlink.h	/^static inline void *rpl_genlmsg_put(struct sk_buff *skb, u32 portid, u32 seq,$/;"	f
rpl_getsockopt	.\lib\socket-util.h	/^static inline int rpl_getsockopt(int sock, int level, int optname,$/;"	f
rpl_gre_handle_offloads	.\datapath\linux\compat\include\net\gre.h	/^static inline struct sk_buff *rpl_gre_handle_offloads(struct sk_buff *skb,$/;"	f
rpl_inet_get_local_port_range	.\datapath\linux\compat\include\net\ip.h	/^static inline void rpl_inet_get_local_port_range(struct net *net, int *low,$/;"	f
rpl_ip_local_out	.\datapath\linux\compat\gso.c	/^int rpl_ip_local_out(struct sk_buff *skb)$/;"	f
rpl_iptunnel_xmit	.\datapath\linux\compat\include\net\ip_tunnels.h	/^static inline int rpl_iptunnel_xmit(struct rtable *rt,$/;"	f
rpl_ipv6_find_hdr	.\datapath\linux\compat\exthdrs_core.c	/^int rpl_ipv6_find_hdr(const struct sk_buff *skb, unsigned int *offset,$/;"	f
rpl_ipv6_skip_exthdr	.\datapath\linux\compat\exthdrs_core.c	/^int rpl_ipv6_skip_exthdr(const struct sk_buff *skb, int start,$/;"	f
rpl_netif_needs_gso	.\datapath\linux\compat\include\linux\netdevice.h	/^static inline int rpl_netif_needs_gso(struct sk_buff *skb, int features)$/;"	f
rpl_netif_skb_features	.\datapath\linux\compat\netdevice.c	/^netdev_features_t rpl_netif_skb_features(struct sk_buff *skb)$/;"	f
rpl_pernet_operations	.\datapath\linux\compat\include\net\net_namespace.h	/^struct rpl_pernet_operations {$/;"	s
rpl_setsockopt	.\lib\socket-util.h	/^static inline int rpl_setsockopt(int sock, int level, int optname,$/;"	f
rpl_skb_gso_segment	.\datapath\linux\compat\netdevice.c	/^struct sk_buff *rpl_skb_gso_segment(struct sk_buff *skb,$/;"	f
rpl_vxlan_xmit_skb	.\datapath\linux\compat\include\net\vxlan.h	/^static inline int rpl_vxlan_xmit_skb(struct vxlan_sock *vs,$/;"	f
rpm_code	.\include\windows\netinet\icmp6.h	/^	u_int8_t	rpm_code;$/;"	m	struct:rr_pco_match
rpm_len	.\include\windows\netinet\icmp6.h	/^	u_int8_t	rpm_len;$/;"	m	struct:rr_pco_match
rpm_matchlen	.\include\windows\netinet\icmp6.h	/^	u_int8_t	rpm_matchlen;$/;"	m	struct:rr_pco_match
rpm_maxlen	.\include\windows\netinet\icmp6.h	/^	u_int8_t	rpm_maxlen;$/;"	m	struct:rr_pco_match
rpm_minlen	.\include\windows\netinet\icmp6.h	/^	u_int8_t	rpm_minlen;$/;"	m	struct:rr_pco_match
rpm_ordinal	.\include\windows\netinet\icmp6.h	/^	u_int8_t	rpm_ordinal;$/;"	m	struct:rr_pco_match
rpm_prefix	.\include\windows\netinet\icmp6.h	/^	struct	in6_addr	rpm_prefix;$/;"	m	struct:rr_pco_match	typeref:struct:rr_pco_match::in6_addr
rpm_reserved	.\include\windows\netinet\icmp6.h	/^	u_int16_t	rpm_reserved;$/;"	m	struct:rr_pco_match
rpu_flags	.\include\windows\netinet\icmp6.h	/^	u_int32_t	rpu_flags;$/;"	m	struct:rr_pco_use
rpu_keeplen	.\include\windows\netinet\icmp6.h	/^	u_int8_t	rpu_keeplen;$/;"	m	struct:rr_pco_use
rpu_pltime	.\include\windows\netinet\icmp6.h	/^	u_int32_t	rpu_pltime;$/;"	m	struct:rr_pco_use
rpu_prefix	.\include\windows\netinet\icmp6.h	/^	struct	in6_addr rpu_prefix;$/;"	m	struct:rr_pco_use	typeref:struct:rr_pco_use::in6_addr
rpu_raflags	.\include\windows\netinet\icmp6.h	/^	u_int8_t	rpu_raflags;$/;"	m	struct:rr_pco_use
rpu_ramask	.\include\windows\netinet\icmp6.h	/^	u_int8_t	rpu_ramask;$/;"	m	struct:rr_pco_use
rpu_uselen	.\include\windows\netinet\icmp6.h	/^	u_int8_t	rpu_uselen;$/;"	m	struct:rr_pco_use
rpu_vltime	.\include\windows\netinet\icmp6.h	/^	u_int32_t	rpu_vltime;$/;"	m	struct:rr_pco_use
rq_forward_delay	.\lib\stp.c	/^    int rq_forward_delay;           \/* User-requested forward delay, in ms. *\/$/;"	m	struct:stp	file:
rq_hello_time	.\lib\stp.c	/^    int rq_hello_time;              \/* User-requested hello time, in ms. *\/$/;"	m	struct:stp	file:
rq_max_age	.\lib\stp.c	/^    int rq_max_age;                 \/* User-requested max age, in ms. *\/$/;"	m	struct:stp	file:
rr_cksum	.\include\windows\netinet\icmp6.h	433;"	d
rr_code	.\include\windows\netinet\icmp6.h	432;"	d
rr_flags	.\include\windows\netinet\icmp6.h	/^	u_int8_t	rr_flags;$/;"	m	struct:icmp6_router_renum
rr_hdr	.\include\windows\netinet\icmp6.h	/^	struct icmp6_hdr	rr_hdr;$/;"	m	struct:icmp6_router_renum	typeref:struct:icmp6_router_renum::icmp6_hdr
rr_maxdelay	.\include\windows\netinet\icmp6.h	/^	u_int16_t	rr_maxdelay;$/;"	m	struct:icmp6_router_renum
rr_pco_match	.\include\windows\netinet\icmp6.h	/^struct rr_pco_match {		\/* match prefix part *\/$/;"	s
rr_pco_use	.\include\windows\netinet\icmp6.h	/^struct rr_pco_use {		\/* use prefix part *\/$/;"	s
rr_reserved	.\include\windows\netinet\icmp6.h	/^	u_int32_t	rr_reserved;$/;"	m	struct:icmp6_router_renum
rr_result	.\include\windows\netinet\icmp6.h	/^struct rr_result {		\/* router renumbering result message *\/$/;"	s
rr_segnum	.\include\windows\netinet\icmp6.h	/^	u_int8_t	rr_segnum;$/;"	m	struct:icmp6_router_renum
rr_seqnum	.\include\windows\netinet\icmp6.h	434;"	d
rr_type	.\include\windows\netinet\icmp6.h	431;"	d
rrr_flags	.\include\windows\netinet\icmp6.h	/^	u_int16_t	rrr_flags;$/;"	m	struct:rr_result
rrr_ifid	.\include\windows\netinet\icmp6.h	/^	u_int32_t	rrr_ifid;$/;"	m	struct:rr_result
rrr_matchedlen	.\include\windows\netinet\icmp6.h	/^	u_int8_t	rrr_matchedlen;$/;"	m	struct:rr_result
rrr_ordinal	.\include\windows\netinet\icmp6.h	/^	u_int8_t	rrr_ordinal;$/;"	m	struct:rr_result
rrr_prefix	.\include\windows\netinet\icmp6.h	/^	struct	in6_addr rrr_prefix;$/;"	m	struct:rr_result	typeref:struct:rr_result::in6_addr
rss	.\vswitchd\system-stats.c	/^    unsigned long int rss;      \/* Resident set size, in kB. *\/$/;"	m	struct:process_info	file:
rss	.\vswitchd\system-stats.c	/^    unsigned long int rss;      \/* Resident set size, in kB. *\/$/;"	m	struct:raw_process_info	file:
rstream	.\lib\netdev-dummy.c	/^    struct dummy_packet_stream *rstream;$/;"	m	struct:dummy_packet_rconn	typeref:struct:dummy_packet_rconn::dummy_packet_stream	file:
rt_change_seq	.\lib\route-table.c	/^static uint64_t rt_change_seq;$/;"	v	file:
rt_change_seqno	.\lib\netdev-vport.c	/^static uint64_t rt_change_seqno;$/;"	v	file:
rt_dst	.\datapath\compat.h	35;"	d
rt_dst	.\datapath\compat.h	37;"	d
rta_dst	.\lib\route-table.c	/^    uint32_t rta_dst; \/* Destination in host byte order. 0 if missing. *\/$/;"	m	struct:route_data	file:
rta_oif	.\lib\route-table.c	/^    int rta_oif;      \/* Output interface index. *\/$/;"	m	struct:route_data	file:
rtbsd	.\lib\rtbsd.c	/^VLOG_DEFINE_THIS_MODULE(rtbsd);$/;"	v
rtbsd_change	.\lib\rtbsd.h	/^struct rtbsd_change {$/;"	s
rtbsd_changed	.\lib\rtbsd.c	/^COVERAGE_DEFINE(rtbsd_changed);$/;"	v
rtbsd_notifier	.\lib\rtbsd.h	/^struct rtbsd_notifier {$/;"	s
rtbsd_notifier_register	.\lib\rtbsd.c	/^rtbsd_notifier_register(struct rtbsd_notifier *notifier,$/;"	f
rtbsd_notifier_run	.\lib\rtbsd.c	/^rtbsd_notifier_run(void)$/;"	f
rtbsd_notifier_unregister	.\lib\rtbsd.c	/^rtbsd_notifier_unregister(struct rtbsd_notifier *notifier)$/;"	f
rtbsd_notifier_wait	.\lib\rtbsd.c	/^rtbsd_notifier_wait(void)$/;"	f
rtbsd_notify_func	.\lib\rtbsd.h	/^typedef void rtbsd_notify_func(const struct rtbsd_change *, void *aux);$/;"	t
rtbsd_report_change	.\lib\rtbsd.c	/^rtbsd_report_change(const struct if_msghdr *msg)$/;"	f	file:
rtbsd_report_notify_error	.\lib\rtbsd.c	/^rtbsd_report_notify_error(void)$/;"	f	file:
rte_eal_init_ret	.\lib\netdev-dpdk.c	/^static int rte_eal_init_ret = ENODEV;$/;"	v	file:
rtm_dst_len	.\lib\route-table.c	/^    unsigned char rtm_dst_len;$/;"	m	struct:route_data	file:
rtmsg	.\lib\route-table.c	/^static struct route_table_msg rtmsg;$/;"	v	typeref:struct:route_table_msg	file:
rtn_change	.\lib\rtnetlink-link.c	/^static struct rtnetlink_link_change rtn_change;$/;"	v	typeref:struct:rtnetlink_link_change	file:
rtnetlink_link_change	.\lib\rtnetlink-link.h	/^struct rtnetlink_link_change {$/;"	s
rtnetlink_link_notifier_create	.\lib\rtnetlink-link.c	/^rtnetlink_link_notifier_create(rtnetlink_link_notify_func *cb, void *aux)$/;"	f
rtnetlink_link_notifier_destroy	.\lib\rtnetlink-link.c	/^rtnetlink_link_notifier_destroy(struct nln_notifier *notifier)$/;"	f
rtnetlink_link_notify_func	.\lib\rtnetlink-link.h	/^void rtnetlink_link_notify_func(const struct rtnetlink_link_change *change,$/;"	t
rtnetlink_link_parse	.\lib\rtnetlink-link.c	/^rtnetlink_link_parse(struct ofpbuf *buf,$/;"	f
rtnetlink_link_parse_cb	.\lib\rtnetlink-link.c	/^rtnetlink_link_parse_cb(struct ofpbuf *buf, void *change)$/;"	f	file:
rtnetlink_link_run	.\lib\rtnetlink-link.c	/^rtnetlink_link_run(void)$/;"	f
rtnetlink_link_wait	.\lib\rtnetlink-link.c	/^rtnetlink_link_wait(void)$/;"	f
rtnl_dereference	.\datapath\linux\compat\include\linux\rtnetlink.h	37;"	d
rtnlgrp_link_policy	.\utilities\nlmon.c	/^static const struct nl_policy rtnlgrp_link_policy[] = {$/;"	v	typeref:struct:nl_policy	file:
ru_idrss	.\include\windows\sys\resource.h	/^    long   ru_idrss;         \/* integral unshared data size *\/$/;"	m	struct:rusage
ru_inblock	.\include\windows\sys\resource.h	/^    long   ru_inblock;       \/* block input operations *\/$/;"	m	struct:rusage
ru_isrss	.\include\windows\sys\resource.h	/^    long   ru_isrss;         \/* integral unshared stack size *\/$/;"	m	struct:rusage
ru_ixrss	.\include\windows\sys\resource.h	/^    long   ru_ixrss;         \/* integral shared memory size *\/$/;"	m	struct:rusage
ru_majflt	.\include\windows\sys\resource.h	/^    long   ru_majflt;        \/* page faults (hard page faults) *\/$/;"	m	struct:rusage
ru_maxrss	.\include\windows\sys\resource.h	/^    long   ru_maxrss;        \/* maximum resident set size *\/$/;"	m	struct:rusage
ru_minflt	.\include\windows\sys\resource.h	/^    long   ru_minflt;        \/* page reclaims (soft page faults) *\/$/;"	m	struct:rusage
ru_msgrcv	.\include\windows\sys\resource.h	/^    long   ru_msgrcv;        \/* IPC messages received *\/$/;"	m	struct:rusage
ru_msgsnd	.\include\windows\sys\resource.h	/^    long   ru_msgsnd;        \/* IPC messages sent *\/$/;"	m	struct:rusage
ru_nivcsw	.\include\windows\sys\resource.h	/^    long   ru_nivcsw;        \/* involuntary context switches *\/$/;"	m	struct:rusage
ru_nsignals	.\include\windows\sys\resource.h	/^    long   ru_nsignals;      \/* signals received *\/$/;"	m	struct:rusage
ru_nswap	.\include\windows\sys\resource.h	/^    long   ru_nswap;         \/* swaps *\/$/;"	m	struct:rusage
ru_nvcsw	.\include\windows\sys\resource.h	/^    long   ru_nvcsw;         \/* voluntary context switches *\/$/;"	m	struct:rusage
ru_oublock	.\include\windows\sys\resource.h	/^    long   ru_oublock;       \/* block output operations *\/$/;"	m	struct:rusage
ru_stime	.\include\windows\sys\resource.h	/^    struct timeval ru_stime; \/* system CPU time used *\/$/;"	m	struct:rusage	typeref:struct:rusage::timeval
ru_utime	.\include\windows\sys\resource.h	/^    struct timeval ru_utime; \/* user CPU time used *\/$/;"	m	struct:rusage	typeref:struct:rusage::timeval
rule	.\ofproto\ofproto-dpif-xlate.c	/^            struct rule_dpif *rule;$/;"	m	struct:xc_entry::__anon136::__anon143	typeref:struct:xc_entry::__anon136::__anon143::rule_dpif	file:
rule	.\ofproto\ofproto-dpif-xlate.c	/^        struct rule_dpif *rule;$/;"	m	union:xc_entry::__anon136	typeref:struct:xc_entry::__anon136::rule_dpif	file:
rule	.\ofproto\ofproto-dpif-xlate.c	/^    struct rule_dpif *rule;$/;"	m	struct:xlate_ctx	typeref:struct:xlate_ctx::rule_dpif	file:
rule	.\ofproto\ofproto-dpif-xlate.h	/^    struct rule_dpif *rule;$/;"	m	struct:xlate_in	typeref:struct:xlate_in::rule_dpif
rule	.\ofproto\ofproto-provider.h	/^struct rule {$/;"	s
rule	.\ofproto\ofproto.c	/^    struct rule *rule;          \/* Owns a reference to the rule. *\/$/;"	m	struct:rule_execute	typeref:struct:rule_execute::rule	file:
rule	.\ofproto\ofproto.c	/^    struct rule *rule;          \/* Rule being operated upon. *\/$/;"	m	struct:ofoperation	typeref:struct:ofoperation::rule	file:
rule	.\utilities\ovs-ofctl.c	/^    struct cls_rule rule;       \/* Within a "struct classifier". *\/$/;"	m	struct:fte	typeref:struct:fte::cls_rule	file:
rule_actions	.\ofproto\ofproto-provider.h	/^struct rule_actions {$/;"	s
rule_actions_create	.\ofproto\ofproto.c	/^rule_actions_create(const struct ofproto *ofproto,$/;"	f
rule_actions_destroy	.\ofproto\ofproto.c	/^rule_actions_destroy(const struct rule_actions *actions)$/;"	f
rule_alloc	.\ofproto\ofproto-dpif.c	/^rule_alloc(void)$/;"	f	file:
rule_alloc	.\ofproto\ofproto-provider.h	/^    struct rule *(*rule_alloc)(void);$/;"	m	struct:ofproto_class	typeref:struct:ofproto_class::rule_alloc
rule_choose_table	.\ofproto\ofproto-provider.h	/^    enum ofperr (*rule_choose_table)(const struct ofproto *ofproto,$/;"	m	struct:ofproto_class	typeref:enum:ofproto_class::rule_choose_table
rule_collection	.\ofproto\ofproto-provider.h	/^struct rule_collection {$/;"	s
rule_collection_add	.\ofproto\ofproto.c	/^rule_collection_add(struct rule_collection *rules, struct rule *rule)$/;"	f
rule_collection_destroy	.\ofproto\ofproto.c	/^rule_collection_destroy(struct rule_collection *rules)$/;"	f
rule_collection_init	.\ofproto\ofproto.c	/^rule_collection_init(struct rule_collection *rules)$/;"	f
rule_collection_unref	.\ofproto\ofproto.c	/^rule_collection_unref(struct rule_collection *rules)$/;"	f
rule_construct	.\ofproto\ofproto-provider.h	/^    enum ofperr (*rule_construct)(struct rule *rule)$/;"	m	struct:ofproto_class	typeref:enum:ofproto_class::rule_construct
rule_criteria	.\ofproto\ofproto.c	/^struct rule_criteria {$/;"	s	file:
rule_criteria_destroy	.\ofproto\ofproto.c	/^rule_criteria_destroy(struct rule_criteria *criteria)$/;"	f	file:
rule_criteria_init	.\ofproto\ofproto.c	/^rule_criteria_init(struct rule_criteria *criteria, uint8_t table_id,$/;"	f	file:
rule_dealloc	.\ofproto\ofproto-dpif.c	/^rule_dealloc(struct rule *rule_)$/;"	f	file:
rule_dealloc	.\ofproto\ofproto-provider.h	/^    void (*rule_dealloc)(struct rule *rule);$/;"	m	struct:ofproto_class
rule_delete	.\ofproto\ofproto-provider.h	/^    void (*rule_delete)(struct rule *rule) \/* OVS_REQUIRES(ofproto_mutex) *\/;$/;"	m	struct:ofproto_class
rule_destroy_cb	.\ofproto\ofproto.c	/^rule_destroy_cb(struct rule *rule)$/;"	f	file:
rule_destruct	.\ofproto\ofproto-dpif.c	/^rule_destruct(struct rule *rule_)$/;"	f	file:
rule_destruct	.\ofproto\ofproto-provider.h	/^    void (*rule_destruct)(struct rule *rule);$/;"	m	struct:ofproto_class
rule_dpif	.\ofproto\ofproto-dpif.c	/^struct rule_dpif {$/;"	s	file:
rule_dpif	.\ofproto\ofproto-dpif.h	/^struct OVS_LOCKABLE rule_dpif;$/;"	v	typeref:struct:OVS_LOCKABLE
rule_dpif_cast	.\ofproto\ofproto-dpif.c	/^static struct rule_dpif *rule_dpif_cast(const struct rule *rule)$/;"	f	file:
rule_dpif_credit_stats	.\ofproto\ofproto-dpif.c	/^rule_dpif_credit_stats(struct rule_dpif *rule,$/;"	f
rule_dpif_execute	.\ofproto\ofproto-dpif.c	/^rule_dpif_execute(struct rule_dpif *rule, const struct flow *flow,$/;"	f	file:
rule_dpif_get_actions	.\ofproto\ofproto-dpif.c	/^rule_dpif_get_actions(const struct rule_dpif *rule)$/;"	f
rule_dpif_is_fail_open	.\ofproto\ofproto-dpif.h	/^static inline bool rule_dpif_is_fail_open(const struct rule_dpif *rule)$/;"	f
rule_dpif_is_internal	.\ofproto\ofproto-dpif.h	/^static inline bool rule_dpif_is_internal(const struct rule_dpif *rule)$/;"	f
rule_dpif_is_table_miss	.\ofproto\ofproto-dpif.h	/^static inline bool rule_dpif_is_table_miss(const struct rule_dpif *rule)$/;"	f
rule_dpif_lookup	.\ofproto\ofproto-dpif.c	/^rule_dpif_lookup(struct ofproto_dpif *ofproto, struct flow *flow,$/;"	f
rule_dpif_lookup_from_table	.\ofproto\ofproto-dpif.c	/^rule_dpif_lookup_from_table(struct ofproto_dpif *ofproto,$/;"	f
rule_dpif_lookup_in_table	.\ofproto\ofproto-dpif.c	/^rule_dpif_lookup_in_table(struct ofproto_dpif *ofproto, uint8_t table_id,$/;"	f	file:
rule_dpif_lookup_verdict	.\ofproto\ofproto-dpif.h	/^enum rule_dpif_lookup_verdict {$/;"	g
rule_dpif_reduce_timeouts	.\ofproto\ofproto-dpif.c	/^rule_dpif_reduce_timeouts(struct rule_dpif *rule, uint16_t idle_timeout,$/;"	f
rule_dpif_ref	.\ofproto\ofproto-dpif.h	/^static inline void rule_dpif_ref(struct rule_dpif *rule)$/;"	f
rule_dpif_unref	.\ofproto\ofproto-dpif.h	/^static inline void rule_dpif_unref(struct rule_dpif *rule)$/;"	f
rule_execute	.\ofproto\ofproto-dpif.c	/^rule_execute(struct rule *rule, const struct flow *flow,$/;"	f	file:
rule_execute	.\ofproto\ofproto-provider.h	/^    enum ofperr (*rule_execute)(struct rule *rule, const struct flow *flow,$/;"	m	struct:ofproto_class	typeref:enum:ofproto_class::rule_execute
rule_execute	.\ofproto\ofproto.c	/^struct rule_execute {$/;"	s	file:
rule_execute_destroy	.\ofproto\ofproto.c	/^rule_execute_destroy(struct rule_execute *e)$/;"	f	file:
rule_executes	.\ofproto\ofproto-provider.h	/^    struct guarded_list rule_executes; \/* Contains "struct rule_execute"s. *\/$/;"	m	struct:ofproto	typeref:struct:ofproto::guarded_list
rule_get_stats	.\ofproto\ofproto-dpif.c	/^rule_get_stats(struct rule *rule_, uint64_t *packets, uint64_t *bytes,$/;"	f	file:
rule_get_stats	.\ofproto\ofproto-provider.h	/^    void (*rule_get_stats)(struct rule *rule, uint64_t *packet_count,$/;"	m	struct:ofproto_class
rule_insert	.\ofproto\ofproto-provider.h	/^    void (*rule_insert)(struct rule *rule) \/* OVS_REQUIRES(ofproto_mutex) *\/;$/;"	m	struct:ofproto_class
rule_is_modifiable	.\ofproto\ofproto.c	/^rule_is_modifiable(const struct rule *rule, enum ofputil_flow_mod_flags flags)$/;"	f	file:
rule_matches	.\lib\classifier.c	/^rule_matches(const struct cls_match *rule, const struct cls_rule *target)$/;"	f	file:
rule_modify_actions	.\ofproto\ofproto-provider.h	/^    void (*rule_modify_actions)(struct rule *rule, bool reset_counters)$/;"	m	struct:ofproto_class
rules	.\lib\classifier.c	/^    struct hmap rules;          \/* Contains "struct cls_rule"s. *\/$/;"	m	struct:cls_subtable	typeref:struct:cls_subtable::hmap	file:
rules	.\ofproto\in-band.c	/^    struct hmap rules;          \/* Contains "struct in_band_rule"s. *\/$/;"	m	struct:in_band	typeref:struct:in_band::hmap	file:
rules	.\ofproto\ofproto-provider.h	/^    struct rule **rules;        \/* The rules. *\/$/;"	m	struct:rule_collection	typeref:struct:rule_collection::rule
rules	.\ofproto\ofproto.c	/^    struct heap rules;          \/* Contains "struct rule"s. *\/$/;"	m	struct:eviction_group	typeref:struct:eviction_group::heap	file:
rules	.\ofproto\ofproto.c	/^    struct list rules;          \/* List of "struct rule_dpif"s. *\/$/;"	m	struct:meter	typeref:struct:meter::list	file:
rules	.\tests\test-classifier.c	/^    struct test_rule **rules;$/;"	m	struct:tcls	typeref:struct:tcls::test_rule	file:
run	.\lib\dpif-provider.h	/^    void (*run)(struct dpif *dpif);$/;"	m	struct:dpif_class
run	.\lib\netdev-provider.h	/^    void (*run)(void);$/;"	m	struct:netdev_class
run	.\lib\stream-provider.h	/^    void (*run)(struct stream *stream);$/;"	m	struct:stream_class
run	.\lib\vconn-provider.h	/^    void (*run)(struct vconn *vconn);$/;"	m	struct:vconn_class
run	.\ofproto\ofproto-dpif.c	/^run(struct ofproto *ofproto_)$/;"	f	file:
run	.\ofproto\ofproto-provider.h	/^    int (*run)(struct ofproto *ofproto);$/;"	m	struct:ofproto_class
run	.\python\ovs\db\idl.py	/^    def run(self):$/;"	m	class:Idl
run	.\python\ovs\jsonrpc.py	/^    def run(self):$/;"	m	class:Connection
run	.\python\ovs\jsonrpc.py	/^    def run(self):$/;"	m	class:Session
run	.\python\ovs\reconnect.py	/^        def run(fsm, now):$/;"	m	class:Reconnect.Active
run	.\python\ovs\reconnect.py	/^        def run(fsm, now):$/;"	m	class:Reconnect.Backoff
run	.\python\ovs\reconnect.py	/^        def run(fsm, now):$/;"	m	class:Reconnect.ConnectInProgress
run	.\python\ovs\reconnect.py	/^        def run(fsm, now):$/;"	m	class:Reconnect.Idle
run	.\python\ovs\reconnect.py	/^        def run(fsm, now):$/;"	m	class:Reconnect.Listening
run	.\python\ovs\reconnect.py	/^        def run(fsm, now):$/;"	m	class:Reconnect.Reconnect
run	.\python\ovs\reconnect.py	/^        def run(fsm, now):$/;"	m	class:Reconnect.Void
run	.\python\ovs\reconnect.py	/^    def run(self, now):$/;"	m	class:Reconnect
run	.\python\ovs\stream.py	/^    def run(self):$/;"	m	class:Stream
run	.\python\ovs\unixctl\server.py	/^    def run(self):$/;"	m	class:UnixctlConnection
run	.\python\ovs\unixctl\server.py	/^    def run(self):$/;"	m	class:UnixctlServer
run	.\utilities\ovs-dev.py	/^def run():$/;"	f
run	.\utilities\ovs-dpctl.c	/^static void run(int retval, const char *message, ...)$/;"	f	file:
run	.\utilities\ovs-ofctl.c	/^run(int retval, const char *message, ...)$/;"	f	file:
run	.\utilities\ovs-vsctl.c	/^    void (*run)(struct vsctl_context *ctx);$/;"	m	struct:vsctl_command_syntax	file:
run	.\vtep\vtep-ctl.c	/^    void (*run)(struct vtep_ctl_context *ctx);$/;"	m	struct:vtep_ctl_command_syntax	file:
run_at_exit	.\lib\fatal-signal.c	/^    bool run_at_exit;$/;"	m	struct:hook	file:
run_command	.\lib\command-line.c	/^run_command(int argc, char *argv[], const struct command commands[])$/;"	f
run_command	.\xenserver\opt_xensource_libexec_InterfaceReconfigure.py	/^def run_command(command):$/;"	f
run_connection	.\lib\unixctl.c	/^run_connection(struct unixctl_conn *conn)$/;"	f	file:
run_help	.\tests\test-lockfile.c	/^run_help(void)$/;"	f	file:
run_lock_and_unlock	.\tests\test-lockfile.c	/^run_lock_and_unlock(void)$/;"	f	file:
run_lock_and_unlock_allows_other_process	.\tests\test-lockfile.c	/^run_lock_and_unlock_allows_other_process(void)$/;"	f	file:
run_lock_and_unlock_twice	.\tests\test-lockfile.c	/^run_lock_and_unlock_twice(void)$/;"	f	file:
run_lock_blocks_other_process	.\tests\test-lockfile.c	/^run_lock_blocks_other_process(void)$/;"	f	file:
run_lock_blocks_same_process	.\tests\test-lockfile.c	/^run_lock_blocks_same_process(void)$/;"	f	file:
run_lock_blocks_same_process_twice	.\tests\test-lockfile.c	/^run_lock_blocks_same_process_twice(void)$/;"	f	file:
run_lock_multiple	.\tests\test-lockfile.c	/^run_lock_multiple(void)$/;"	f	file:
run_lock_symlink	.\tests\test-lockfile.c	/^run_lock_symlink(void)$/;"	f	file:
run_lock_symlink_to_dir	.\tests\test-lockfile.c	/^run_lock_symlink_to_dir(void)$/;"	f	file:
run_lock_twice_blocks_other_process	.\tests\test-lockfile.c	/^run_lock_twice_blocks_other_process(void)$/;"	f	file:
run_prerequisites	.\utilities\ovs-vsctl.c	/^run_prerequisites(struct vsctl_command *commands, size_t n_commands,$/;"	f	file:
run_prerequisites	.\vtep\vtep-ctl.c	/^run_prerequisites(struct vtep_ctl_command *commands, size_t n_commands,$/;"	f	file:
run_system_stats	.\vswitchd\bridge.c	/^run_system_stats(void)$/;"	f	file:
run_test	.\tests\test-hindex.c	/^run_test(void (*function)(hash_func *))$/;"	f	file:
run_test	.\tests\test-hmap.c	/^run_test(void (*function)(hash_func *))$/;"	f	file:
run_test	.\tests\test-list.c	/^run_test(void (*function)(void))$/;"	f	file:
run_triggers	.\ovsdb\ovsdb.h	/^    bool run_triggers;$/;"	m	struct:ovsdb
run_wait	.\lib\stream-provider.h	/^    void (*run_wait)(struct stream *stream);$/;"	m	struct:stream_class
run_wait	.\lib\vconn-provider.h	/^    void (*run_wait)(struct vconn *vconn);$/;"	m	struct:vconn_class
run_wait	.\python\ovs\stream.py	/^    def run_wait(self, poller):$/;"	m	class:Stream
rusage	.\include\windows\sys\resource.h	/^struct rusage {$/;"	s
rwlock	.\lib\fat-rwlock.c	/^    struct fat_rwlock *rwlock;  \/* Owner. *\/$/;"	m	struct:fat_rwlock_slot	typeref:struct:fat_rwlock_slot::fat_rwlock	file:
rwlock	.\lib\fat-rwlock.h	/^void fat_rwlock_rdlock(const struct fat_rwlock *rwlock) OVS_ACQ_RDLOCK(rwlock);$/;"	v
rwlock	.\lib\fat-rwlock.h	/^void fat_rwlock_unlock(const struct fat_rwlock *rwlock) OVS_RELEASES(rwlock);$/;"	v
rwlock	.\lib\fat-rwlock.h	/^void fat_rwlock_wrlock(const struct fat_rwlock *rwlock) OVS_ACQ_WRLOCK(rwlock);$/;"	v
rwlock	.\lib\mac-learning.h	/^    struct ovs_rwlock rwlock;$/;"	m	struct:mac_learning	typeref:struct:mac_learning::ovs_rwlock
rwlock	.\lib\ovs-thread.h	/^    OVS_ACQ_RDLOCK(rwlock);$/;"	v
rwlock	.\lib\ovs-thread.h	/^    OVS_ACQ_WRLOCK(rwlock);$/;"	v
rwlock	.\lib\ovs-thread.h	/^void ovs_rwlock_unlock(const struct ovs_rwlock *rwlock) OVS_RELEASES(rwlock);$/;"	v
rwlock	.\ofproto\bond.c	/^    OVS_REQ_RDLOCK(rwlock);$/;"	v
rwlock	.\ofproto\bond.c	/^    OVS_REQ_WRLOCK(rwlock);$/;"	v
rwlock	.\ofproto\bond.c	/^static struct hmap *const all_bonds OVS_GUARDED_BY(rwlock) = &all_bonds__;$/;"	v	file:
rwlock	.\ofproto\bond.c	/^static struct ovs_rwlock rwlock = OVS_RWLOCK_INITIALIZER;$/;"	v	typeref:struct:ovs_rwlock	file:
rwlock	.\ofproto\bond.c	/^static void bond_entry_reset(struct bond *) OVS_REQ_WRLOCK(rwlock);$/;"	v
rwlock	.\ofproto\tunnel.c	/^    OVS_REQ_RDLOCK(rwlock);$/;"	v
rwlock	.\ofproto\tunnel.c	/^static char *tnl_port_fmt(const struct tnl_port *) OVS_REQ_RDLOCK(rwlock);$/;"	v
rwlock	.\ofproto\tunnel.c	/^static struct hmap *ofport_map OVS_GUARDED_BY(rwlock) = &ofport_map__;$/;"	v	typeref:struct:OVS_GUARDED_BY	file:
rwlock	.\ofproto\tunnel.c	/^static struct ovs_rwlock rwlock = OVS_RWLOCK_INITIALIZER;$/;"	v	typeref:struct:ovs_rwlock	file:
rwlock	.\ofproto\tunnel.c	/^static struct tnl_port *tnl_find(const struct flow *) OVS_REQ_RDLOCK(rwlock);$/;"	v
rwlock	.\ofproto\tunnel.c	/^static void tnl_port_del__(const struct ofport_dpif *) OVS_REQ_WRLOCK(rwlock);$/;"	v
rx	.\lib\dpif-netdev.c	/^    struct netdev_rxq *rx;$/;"	m	struct:rxq_poll	typeref:struct:rxq_poll::netdev_rxq	file:
rx	.\lib\lacp.c	/^    struct timer rx;              \/* Expected message receive timer. *\/$/;"	m	struct:slave	typeref:struct:slave::timer	file:
rx	.\ofproto\ofproto-dpif-xlate.c	/^            struct netdev *rx;$/;"	m	struct:xc_entry::__anon136::__anon137	typeref:struct:xc_entry::__anon136::__anon137::netdev	file:
rx_bytes	.\datapath\linux\compat\include\linux\netdevice.h	/^	u64     rx_bytes;$/;"	m	struct:pcpu_sw_netstats
rx_bytes	.\include\linux\openvswitch.h	/^	__u64   rx_bytes;		\/* total bytes received         *\/$/;"	m	struct:ovs_vport_stats
rx_bytes	.\include\openflow\openflow-1.0.h	/^    ovs_32aligned_be64 rx_bytes;       \/* Number of received bytes. *\/$/;"	m	struct:ofp10_port_stats
rx_bytes	.\include\openflow\openflow-1.1.h	/^    ovs_be64 rx_bytes;        \/* Number of received bytes. *\/$/;"	m	struct:ofp11_port_stats
rx_bytes	.\include\openflow\openflow-1.4.h	/^    ovs_be64 rx_bytes;       \/* Number of received bytes. *\/$/;"	m	struct:ofp14_port_stats
rx_bytes	.\lib\netdev.h	/^    uint64_t rx_bytes;          \/* Total bytes received. *\/$/;"	m	struct:netdev_stats
rx_conf	.\lib\netdev-dpdk.c	/^static const struct rte_eth_rxconf rx_conf = {$/;"	v	typeref:struct:rte_eth_rxconf	file:
rx_count	.\lib\stp.c	/^    int rx_count;                   \/* Number of valid BPDUs received. *\/$/;"	m	struct:stp_port	file:
rx_count	.\ofproto\ofproto.h	/^    int rx_count;               \/* Number of valid BPDUs received. *\/$/;"	m	struct:ofproto_port_stp_stats
rx_crc_err	.\include\openflow\openflow-1.0.h	/^    ovs_32aligned_be64 rx_crc_err;   \/* Number of CRC errors. *\/$/;"	m	struct:ofp10_port_stats
rx_crc_err	.\include\openflow\openflow-1.1.h	/^    ovs_be64 rx_crc_err;      \/* Number of CRC errors. *\/$/;"	m	struct:ofp11_port_stats
rx_crc_err	.\include\openflow\openflow-1.4.h	/^    ovs_be64 rx_crc_err;     \/* Number of CRC errors. *\/$/;"	m	struct:ofp14_port_stats_prop_ethernet
rx_crc_errors	.\lib\netdev.h	/^    uint64_t rx_crc_errors;     \/* Recved pkt with crc error. *\/$/;"	m	struct:netdev_stats
rx_dropped	.\datapath\vport.h	/^	u64 rx_dropped;$/;"	m	struct:vport_err_stats
rx_dropped	.\include\linux\openvswitch.h	/^	__u64   rx_dropped;		\/* no space in linux buffers    *\/$/;"	m	struct:ovs_vport_stats
rx_dropped	.\include\openflow\openflow-1.0.h	/^    ovs_32aligned_be64 rx_dropped;     \/* Number of packets dropped by RX. *\/$/;"	m	struct:ofp10_port_stats
rx_dropped	.\include\openflow\openflow-1.1.h	/^    ovs_be64 rx_dropped;      \/* Number of packets dropped by RX. *\/$/;"	m	struct:ofp11_port_stats
rx_dropped	.\include\openflow\openflow-1.4.h	/^    ovs_be64 rx_dropped;     \/* Number of packets dropped by RX. *\/$/;"	m	struct:ofp14_port_stats
rx_dropped	.\lib\netdev.h	/^    uint64_t rx_dropped;        \/* No buffer space. *\/$/;"	m	struct:netdev_stats
rx_errors	.\datapath\vport.h	/^	u64 rx_errors;$/;"	m	struct:vport_err_stats
rx_errors	.\include\linux\openvswitch.h	/^	__u64   rx_errors;		\/* bad packets received         *\/$/;"	m	struct:ovs_vport_stats
rx_errors	.\include\openflow\openflow-1.0.h	/^    ovs_32aligned_be64 rx_errors; \/* Number of receive errors.  This is a$/;"	m	struct:ofp10_port_stats
rx_errors	.\include\openflow\openflow-1.1.h	/^    ovs_be64 rx_errors;       \/* Number of receive errors.  This is a$/;"	m	struct:ofp11_port_stats
rx_errors	.\include\openflow\openflow-1.4.h	/^    ovs_be64 rx_errors;      \/* Number of receive errors.  This is a super-set$/;"	m	struct:ofp14_port_stats
rx_errors	.\lib\netdev.h	/^    uint64_t rx_errors;         \/* Bad packets received. *\/$/;"	m	struct:netdev_stats
rx_fifo_errors	.\lib\netdev.h	/^    uint64_t rx_fifo_errors;    \/* Recv'r fifo overrun . *\/$/;"	m	struct:netdev_stats
rx_frame_err	.\include\openflow\openflow-1.0.h	/^    ovs_32aligned_be64 rx_frame_err; \/* Number of frame alignment errors. *\/$/;"	m	struct:ofp10_port_stats
rx_frame_err	.\include\openflow\openflow-1.1.h	/^    ovs_be64 rx_frame_err;    \/* Number of frame alignment errors. *\/$/;"	m	struct:ofp11_port_stats
rx_frame_err	.\include\openflow\openflow-1.4.h	/^    ovs_be64 rx_frame_err;   \/* Number of frame alignment errors. *\/$/;"	m	struct:ofp14_port_stats_prop_ethernet
rx_frame_errors	.\lib\netdev.h	/^    uint64_t rx_frame_errors;   \/* Recv'd frame alignment error. *\/$/;"	m	struct:netdev_stats
rx_length_errors	.\lib\netdev.h	/^    uint64_t rx_length_errors;$/;"	m	struct:netdev_stats
rx_missed_errors	.\lib\netdev.h	/^    uint64_t rx_missed_errors;  \/* Receiver missed packet. *\/$/;"	m	struct:netdev_stats
rx_over_err	.\include\openflow\openflow-1.0.h	/^    ovs_32aligned_be64 rx_over_err;  \/* Number of packets with RX overrun. *\/$/;"	m	struct:ofp10_port_stats
rx_over_err	.\include\openflow\openflow-1.1.h	/^    ovs_be64 rx_over_err;     \/* Number of packets with RX overrun. *\/$/;"	m	struct:ofp11_port_stats
rx_over_err	.\include\openflow\openflow-1.4.h	/^    ovs_be64 rx_over_err;    \/* Number of packets with RX overrun. *\/$/;"	m	struct:ofp14_port_stats_prop_ethernet
rx_over_errors	.\lib\netdev.h	/^    uint64_t rx_over_errors;    \/* Receiver ring buff overflow. *\/$/;"	m	struct:netdev_stats
rx_packets	.\datapath\linux\compat\include\linux\netdevice.h	/^	u64     rx_packets;$/;"	m	struct:pcpu_sw_netstats
rx_packets	.\include\linux\openvswitch.h	/^	__u64   rx_packets;		\/* total packets received       *\/$/;"	m	struct:ovs_vport_stats
rx_packets	.\include\openflow\openflow-1.0.h	/^    ovs_32aligned_be64 rx_packets;     \/* Number of received packets. *\/$/;"	m	struct:ofp10_port_stats
rx_packets	.\include\openflow\openflow-1.1.h	/^    ovs_be64 rx_packets;      \/* Number of received packets. *\/$/;"	m	struct:ofp11_port_stats
rx_packets	.\include\openflow\openflow-1.4.h	/^    ovs_be64 rx_packets;     \/* Number of received packets. *\/$/;"	m	struct:ofp14_port_stats
rx_packets	.\lib\bfd.c	/^    uint64_t rx_packets;          \/* Packets received by 'netdev'. *\/$/;"	m	struct:bfd	file:
rx_packets	.\lib\cfm.c	/^    uint64_t rx_packets;        \/* Packets received by 'netdev'. *\/$/;"	m	struct:cfm	file:
rx_packets	.\lib\netdev.h	/^    uint64_t rx_packets;        \/* Total packets received. *\/$/;"	m	struct:netdev_stats
rx_want	.\lib\stream-ssl.c	/^    int rx_want, tx_want;$/;"	m	struct:ssl_stream	file:
rxbuf	.\lib\netdev-dummy.c	/^    struct ofpbuf rxbuf;$/;"	m	struct:dummy_packet_stream	typeref:struct:dummy_packet_stream::ofpbuf	file:
rxbuf	.\lib\vconn-stream.c	/^    struct ofpbuf *rxbuf;$/;"	m	struct:vconn_stream	typeref:struct:vconn_stream::ofpbuf	file:
rxq	.\lib\dpif-netdev.c	/^    struct netdev_rxq **rxq;$/;"	m	struct:dp_netdev_port	typeref:struct:dp_netdev_port::netdev_rxq	file:
rxq	.\tests\test-stp.c	/^    struct bpdu rxq[RXQ_SIZE];$/;"	m	struct:bridge	typeref:struct:bridge::bpdu	file:
rxq_alloc	.\lib\netdev-provider.h	/^    struct netdev_rxq *(*rxq_alloc)(void);$/;"	m	struct:netdev_class	typeref:struct:netdev_class::rxq_alloc
rxq_construct	.\lib\netdev-provider.h	/^    int (*rxq_construct)(struct netdev_rxq *);$/;"	m	struct:netdev_class
rxq_dealloc	.\lib\netdev-provider.h	/^    void (*rxq_dealloc)(struct netdev_rxq *);$/;"	m	struct:netdev_class
rxq_destruct	.\lib\netdev-provider.h	/^    void (*rxq_destruct)(struct netdev_rxq *);$/;"	m	struct:netdev_class
rxq_drain	.\lib\netdev-provider.h	/^    int (*rxq_drain)(struct netdev_rxq *rx);$/;"	m	struct:netdev_class
rxq_head	.\tests\test-stp.c	/^    int rxq_head, rxq_tail;$/;"	m	struct:bridge	file:
rxq_poll	.\lib\dpif-netdev.c	/^struct rxq_poll {$/;"	s	file:
rxq_recv	.\lib\netdev-provider.h	/^    int (*rxq_recv)(struct netdev_rxq *rx, struct ofpbuf **pkt, int *cnt);$/;"	m	struct:netdev_class
rxq_tail	.\tests\test-stp.c	/^    int rxq_head, rxq_tail;$/;"	m	struct:bridge	file:
rxq_wait	.\lib\netdev-provider.h	/^    void (*rxq_wait)(struct netdev_rxq *rx);$/;"	m	struct:netdev_class
s	.\lib\hindex.h	/^    struct hindex_node *s;$/;"	m	struct:hindex_node	typeref:struct:hindex_node::hindex_node
s	.\tests\idltest.h	/^	char *s;	\/* Always nonnull. *\/$/;"	m	struct:idltest_simple
s6_addr	.\include\sparse\netinet\in.h	47;"	d
sFlowCpInterval	.\lib\sflow_api.h	/^    time_t sFlowCpInterval;$/;"	m	struct:_SFLPoller
sFlowCpReceiver	.\lib\sflow_api.h	/^    u_int32_t sFlowCpReceiver;$/;"	m	struct:_SFLPoller
sFlowFsMaximumHeaderSize	.\lib\sflow_api.h	/^    u_int32_t sFlowFsMaximumHeaderSize;$/;"	m	struct:_SFLSampler
sFlowFsPacketSamplingRate	.\lib\sflow_api.h	/^    u_int32_t sFlowFsPacketSamplingRate;$/;"	m	struct:_SFLSampler
sFlowFsReceiver	.\lib\sflow_api.h	/^    u_int32_t sFlowFsReceiver;$/;"	m	struct:_SFLSampler
sFlowRcvrAddress	.\lib\sflow_api.h	/^    SFLAddress sFlowRcvrAddress;$/;"	m	struct:_SFLReceiver
sFlowRcvrDatagramVersion	.\lib\sflow_api.h	/^    u_int32_t sFlowRcvrDatagramVersion;$/;"	m	struct:_SFLReceiver
sFlowRcvrMaximumDatagramSize	.\lib\sflow_api.h	/^    u_int32_t sFlowRcvrMaximumDatagramSize;$/;"	m	struct:_SFLReceiver
sFlowRcvrOwner	.\lib\sflow_api.h	/^    char *sFlowRcvrOwner;$/;"	m	struct:_SFLReceiver
sFlowRcvrPort	.\lib\sflow_api.h	/^    u_int32_t sFlowRcvrPort;$/;"	m	struct:_SFLReceiver
sFlowRcvrTimeout	.\lib\sflow_api.h	/^    time_t sFlowRcvrTimeout;$/;"	m	struct:_SFLReceiver
s_addr	.\include\sparse\netinet\in.h	/^    in_addr_t s_addr;$/;"	m	struct:in_addr
sa	.\tests\idltest.h	/^	char **sa;$/;"	m	struct:idltest_simple
sa_data	.\include\sparse\sys\socket.h	/^    char sa_data[64];$/;"	m	struct:sockaddr
sa_data	.\include\sparse\sys\socket.h	/^    char sa_data[64];$/;"	m	struct:sockaddr_storage
sa_family	.\include\sparse\sys\socket.h	/^    sa_family_t sa_family;$/;"	m	struct:sockaddr
sa_family_t	.\include\sparse\sys\socket.h	/^typedef unsigned short int sa_family_t;$/;"	t
sa_family_t	.\include\windows\sys\socket.h	/^typedef unsigned short int sa_family_t;$/;"	t
sample	.\datapath\actions.c	/^static int sample(struct datapath *dp, struct sk_buff *skb,$/;"	f	file:
sample	.\lib\ofp-actions.c	/^    struct nx_action_sample sample;$/;"	m	union:ofp_action	typeref:struct:ofp_action::nx_action_sample	file:
sampleCollector	.\lib\sflow_api.h	/^    SFLSampleCollector sampleCollector;$/;"	m	struct:_SFLReceiver
samplePool	.\lib\sflow_api.h	/^    u_int32_t samplePool;$/;"	m	struct:_SFLSampler
samplePool	.\tests\test-sflow.c	/^    uint32_t samplePool;$/;"	m	struct:sflow_xdr	file:
sample_action_to_attr	.\datapath\flow_netlink.c	/^static int sample_action_to_attr(const struct nlattr *attr, struct sk_buff *skb)$/;"	f	file:
sample_from_openflow	.\lib\ofp-actions.c	/^sample_from_openflow(const struct nx_action_sample *nas,$/;"	f	file:
sample_pool	.\lib\sflow.h	/^    u_int32_t sample_pool;          \/* Total number of packets that could have been$/;"	m	struct:_SFLFlow_sample
sample_pool	.\lib\sflow.h	/^    u_int32_t sample_pool;          \/* Total number of packets that could have been$/;"	m	struct:_SFLFlow_sample_expanded
samplers	.\lib\sflow_api.h	/^    SFLSampler *samplers;   \/* the list of samplers *\/$/;"	m	struct:_SFLAgent
samplesLastTick	.\lib\sflow_api.h	/^    u_int32_t samplesLastTick;$/;"	m	struct:_SFLSampler
samplesThisTick	.\lib\sflow_api.h	/^    u_int32_t samplesThisTick;$/;"	m	struct:_SFLSampler
sampling	.\lib\vswitch-idl.h	/^	int64_t *sampling;$/;"	m	struct:ovsrec_ipfix
sampling	.\lib\vswitch-idl.h	/^	int64_t *sampling;$/;"	m	struct:ovsrec_sflow
sampling_interval	.\lib\netflow.h	/^    ovs_be16 sampling_interval;    \/* Set to zero. *\/$/;"	m	struct:netflow_v5_header
sampling_rate	.\lib\sflow.h	/^    u_int32_t sampling_rate;        \/* fsPacketSamplingRate *\/$/;"	m	struct:_SFLFlow_sample
sampling_rate	.\lib\sflow.h	/^    u_int32_t sampling_rate;        \/* fsPacketSamplingRate *\/$/;"	m	struct:_SFLFlow_sample_expanded
sampling_rate	.\ofproto\ofproto.h	/^    uint32_t sampling_rate;$/;"	m	struct:ofproto_ipfix_bridge_exporter_options
sampling_rate	.\ofproto\ofproto.h	/^    uint32_t sampling_rate;$/;"	m	struct:ofproto_sflow_options
sargc	.\lib\daemon-windows.c	/^static int sargc;$/;"	v	file:
sargvp	.\lib\daemon-windows.c	/^static char ***sargvp;$/;"	v	file:
sat_add	.\lib\sat-math.h	/^sat_add(unsigned int x, unsigned int y)$/;"	f
sat_mul	.\lib\sat-math.h	/^sat_mul(unsigned int x, unsigned int y)$/;"	f
sat_sub	.\lib\sat-math.h	/^sat_sub(unsigned int x, unsigned int y)$/;"	f
save	.\xenserver\opt_xensource_libexec_InterfaceReconfigure.py	/^    def save(self, cache_file):$/;"	m	class:DatabaseCache
save_config	.\ovsdb\ovsdb-server.c	/^save_config(struct server_config *config)$/;"	f	file:
save_config__	.\ovsdb\ovsdb-server.c	/^save_config__(FILE *config_file, const struct sset *remotes,$/;"	f	file:
save_fds	.\lib\daemon.c	/^static bool save_fds[3];$/;"	v	file:
saved_flags	.\lib\netdev.c	/^    enum netdev_flags saved_flags;$/;"	m	struct:netdev_saved_flags	typeref:enum:netdev_saved_flags::netdev_flags	file:
saved_flags_list	.\lib\netdev-provider.h	/^    struct list saved_flags_list; \/* Contains "struct netdev_saved_flags". *\/$/;"	m	struct:netdev	typeref:struct:netdev::list
saved_values	.\lib\netdev.c	/^    enum netdev_flags saved_values;$/;"	m	struct:netdev_saved_flags	typeref:enum:netdev_saved_flags::netdev_flags	file:
scan_chars	.\lib\util.c	/^scan_chars(const char *s, const struct scan_spec *spec, va_list *args)$/;"	f	file:
scan_float	.\lib\util.c	/^scan_float(const char *s, const struct scan_spec *spec, va_list *args)$/;"	f	file:
scan_int	.\lib\util.c	/^scan_int(const char *s, const struct scan_spec *spec, int base, va_list *args)$/;"	f	file:
scan_output_string	.\lib\util.c	/^scan_output_string(const struct scan_spec *spec,$/;"	f	file:
scan_set	.\lib\util.c	/^scan_set(const char *s, const struct scan_spec *spec, const char **pp,$/;"	f	file:
scan_spec	.\lib\util.c	/^struct scan_spec {$/;"	s	file:
scan_string	.\lib\util.c	/^scan_string(const char *s, const struct scan_spec *spec, va_list *args)$/;"	f	file:
schedule_packet_in	.\ofproto\connmgr.c	/^schedule_packet_in(struct ofconn *ofconn, struct ofproto_packet_in pin,$/;"	f	file:
schedulers	.\ofproto\connmgr.c	/^    struct pinsched *schedulers[N_SCHEDULERS];$/;"	m	struct:ofconn	typeref:struct:ofconn::pinsched	file:
schema	.\ovsdb\ovsdb.h	/^    struct ovsdb_schema *schema;$/;"	m	struct:ovsdb	typeref:struct:ovsdb::ovsdb_schema
schema	.\ovsdb\table.h	/^    struct ovsdb_table_schema *schema;$/;"	m	struct:ovsdb_table	typeref:struct:ovsdb_table::ovsdb_table_schema
schema	.\python\ovs\db\idl.py	/^import ovs.db.schema$/;"	i
schema	.\tests\test-ovsdb.py	/^import ovs.db.schema$/;"	i
score_partial_match	.\utilities\ovs-vsctl.c	/^score_partial_match(const char *name, const char *s)$/;"	f	file:
score_partial_match	.\vtep\vtep-ctl.c	/^score_partial_match(const char *name, const char *s)$/;"	f	file:
scs_connecting	.\lib\stream.c	/^scs_connecting(struct stream *stream)$/;"	f	file:
sctp_compute_cksum	.\datapath\linux\compat\include\net\sctp\checksum.h	/^static inline __le32 sctp_compute_cksum(const struct sk_buff *skb,$/;"	f
sctp_csum	.\lib\packets.h	/^    ovs_16aligned_be32 sctp_csum;$/;"	m	struct:sctp_header
sctp_dst	.\include\linux\openvswitch.h	/^	__be16 sctp_dst;$/;"	m	struct:ovs_key_sctp
sctp_dst	.\lib\packets.h	/^    ovs_be16 sctp_dst;$/;"	m	struct:sctp_header
sctp_hdr	.\datapath\linux\compat\include\linux\sctp.h	/^static inline struct sctphdr *sctp_hdr(const struct sk_buff *skb)$/;"	f
sctp_header	.\lib\packets.h	/^struct sctp_header {$/;"	s
sctp_src	.\include\linux\openvswitch.h	/^	__be16 sctp_src;$/;"	m	struct:ovs_key_sctp
sctp_src	.\lib\packets.h	/^    ovs_be16 sctp_src;$/;"	m	struct:sctp_header
sctp_vtag	.\lib\packets.h	/^    ovs_16aligned_be32 sctp_vtag;$/;"	m	struct:sctp_header
sctphdr_ok	.\datapath\flow.c	/^static bool sctphdr_ok(struct sk_buff *skb)$/;"	f	file:
search_name_array	.\lib\vlog.c	/^search_name_array(const char *target, const char *const *names, size_t n_names)$/;"	f	file:
search_subtable	.\lib\classifier.c	/^search_subtable(const struct cls_subtable *subtable,$/;"	f	file:
sec_in_state	.\ofproto\ofproto.h	/^    unsigned int sec_in_state;$/;"	m	struct:ofproto_port_stp_status
sec_since_connect	.\ovsdb\jsonrpc-server.h	/^    unsigned int sec_since_connect;$/;"	m	struct:ovsdb_jsonrpc_remote_status
sec_since_disconnect	.\ovsdb\jsonrpc-server.h	/^    unsigned int sec_since_disconnect;$/;"	m	struct:ovsdb_jsonrpc_remote_status
secret	.\lib\mac-learning.h	/^    uint32_t secret;            \/* Secret for randomizing hash table. *\/$/;"	m	struct:mac_learning
secret	.\ofproto\ofproto-dpif-upcall.c	/^    uint32_t secret;                   \/* Random seed for upcall hash. *\/$/;"	m	struct:udpif	file:
secs	.\lib\dhcp.h	/^    ovs_be16 secs;              \/* Since client started address acquisition. *\/$/;"	m	struct:dhcp_header
select	.\ovsdb\jsonrpc-server.c	/^    enum ovsdb_jsonrpc_monitor_selection select;$/;"	m	struct:ovsdb_jsonrpc_monitor_column	typeref:enum:ovsdb_jsonrpc_monitor_column::ovsdb_jsonrpc_monitor_selection	file:
select	.\ovsdb\jsonrpc-server.c	/^    enum ovsdb_jsonrpc_monitor_selection select;$/;"	m	struct:ovsdb_jsonrpc_monitor_table	typeref:enum:ovsdb_jsonrpc_monitor_table::ovsdb_jsonrpc_monitor_selection	file:
select	.\python\ovs\poller.py	/^import select$/;"	i
select	.\python\ovs\socket_util.py	/^import select$/;"	i
select	.\python\ovstest\util.py	/^import select$/;"	i
select_all	.\lib\vswitch-idl.h	/^	bool select_all;$/;"	m	struct:ovsrec_mirror
select_dst_port	.\lib\vswitch-idl.h	/^	struct ovsrec_port **select_dst_port;$/;"	m	struct:ovsrec_mirror	typeref:struct:ovsrec_mirror::ovsrec_port
select_src_port	.\lib\vswitch-idl.h	/^	struct ovsrec_port **select_src_port;$/;"	m	struct:ovsrec_mirror	typeref:struct:ovsrec_mirror::ovsrec_port
select_vlan	.\lib\vswitch-idl.h	/^	int64_t *select_vlan;$/;"	m	struct:ovsrec_mirror
semantic_rl	.\lib\ovsdb-idl.c	/^static struct vlog_rate_limit semantic_rl = VLOG_RATE_LIMIT_INIT(1, 5);$/;"	v	typeref:struct:vlog_rate_limit	file:
send	.\datapath\vport.h	/^	int (*send)(struct vport *, struct sk_buff *);$/;"	m	struct:vport_ops
send	.\lib\netdev-provider.h	/^    int (*send)(struct netdev *netdev, struct ofpbuf *buffer, bool may_steal);$/;"	m	struct:netdev_class
send	.\lib\stream-provider.h	/^    ssize_t (*send)(struct stream *stream, const void *buffer, size_t n);$/;"	m	struct:stream_class
send	.\lib\vconn-provider.h	/^    int (*send)(struct vconn *vconn, struct ofpbuf *msg);$/;"	m	struct:vconn_class
send	.\python\ovs\jsonrpc.py	/^    def send(self, msg):$/;"	m	class:Connection
send	.\python\ovs\jsonrpc.py	/^    def send(self, msg):$/;"	m	class:Session
send	.\python\ovs\stream.py	/^    def send(self, buf):$/;"	m	class:Stream
sendData	.\python\ovstest\udp.py	/^    def sendData(self):$/;"	m	class:UdpSender
sendFn	.\lib\sflow_api.h	/^    sendFn_t sendFn;$/;"	m	struct:_SFLAgent
sendFn_t	.\lib\sflow_api.h	/^typedef void (*sendFn_t)(void *magic,                 \/* optional override fn to send packet *\/$/;"	t
sendSample	.\lib\sflow_receiver.c	/^static void sendSample(SFLReceiver *receiver)$/;"	f	file:
send_block	.\python\ovs\jsonrpc.py	/^    def send_block(self, msg):$/;"	m	class:Connection
send_bogus_packet_ins	.\ofproto\fail-open.c	/^send_bogus_packet_ins(struct fail_open *fo)$/;"	f	file:
send_bpdu	.\lib\stp.c	/^    void (*send_bpdu)(struct ofpbuf *bpdu, int port_no, void *aux);$/;"	m	struct:stp	file:
send_bpdu	.\tests\test-stp.c	/^send_bpdu(struct ofpbuf *pkt, int port_no, void *b_)$/;"	f	file:
send_bpdu_cb	.\ofproto\ofproto-dpif.c	/^send_bpdu_cb(struct ofpbuf *pkt, int port_num, void *ofproto_)$/;"	f	file:
send_features_request	.\lib\learning-switch.c	/^send_features_request(struct lswitch *sw)$/;"	f	file:
send_learning_packets	.\ofproto\bond.c	/^    bool send_learning_packets;$/;"	m	struct:bond	file:
send_len	.\ofproto\connmgr.h	/^    int send_len;               \/* Length that the action requested sending. *\/$/;"	m	struct:ofproto_packet_in
send_openflow_buffer	.\utilities\ovs-ofctl.c	/^send_openflow_buffer(struct vconn *vconn, struct ofpbuf *buffer)$/;"	f	file:
send_pdu_cb	.\ofproto\ofproto-dpif.c	/^send_pdu_cb(void *port_, const void *pdu, size_t pdu_size)$/;"	f	file:
send_soon	.\ofproto\ofproto-dpif-monitor.c	/^static struct guarded_list send_soon = GUARDED_LIST_INITIALIZER(&send_soon);$/;"	v	typeref:struct:guarded_list	file:
send_soon_entry	.\ofproto\ofproto-dpif-monitor.c	/^struct send_soon_entry {$/;"	s	file:
send_wait	.\lib\netdev-provider.h	/^    void (*send_wait)(struct netdev *netdev);$/;"	m	struct:netdev_class
send_wait	.\python\ovs\stream.py	/^    def send_wait(self, poller):$/;"	m	class:Stream
seq	.\datapath\linux\compat\include\linux\u64_stats_sync.h	/^	seqcount_t	seq;$/;"	m	struct:u64_stats_sync
seq	.\datapath\linux\compat\include\net\ip_tunnels.h	/^	__be32 seq;$/;"	m	struct:tnl_ptk_info
seq	.\lib\cfm.c	/^    uint32_t seq;          \/* The sequence number of our last CCM. *\/$/;"	m	struct:cfm	file:
seq	.\lib\cfm.c	/^    uint32_t seq;        \/* Most recently received sequence number. *\/$/;"	m	struct:remote_mp	file:
seq	.\lib\dpif-netdev.c	/^    struct seq *seq;      \/* Incremented whenever a packet is queued. *\/$/;"	m	struct:dp_netdev_queue	typeref:struct:dp_netdev_queue::seq	file:
seq	.\lib\netdev-dummy.c	/^    struct seq *seq;            \/* Reports newly queued packets. *\/$/;"	m	struct:netdev_rxq_dummy	typeref:struct:netdev_rxq_dummy::seq	file:
seq	.\lib\ovs-thread.h	/^    struct seq *seq;$/;"	m	struct:ovs_barrier	typeref:struct:ovs_barrier::seq
seq	.\lib\packets.h	/^            ovs_be16 seq;$/;"	m	struct:icmp_header::__anon87::__anon88
seq	.\lib\seq.c	/^struct seq {$/;"	s	file:
seq	.\lib\sflow.h	/^	u_int32_t *seq;$/;"	m	union:_SFLExtended_as_path_segment::__anon94
seq_init	.\lib\seq.c	/^seq_init(void)$/;"	f	file:
seq_mutex	.\lib\seq.c	/^static struct ovs_mutex seq_mutex = OVS_MUTEX_INITIALIZER;$/;"	v	typeref:struct:ovs_mutex	file:
seq_mutex	.\lib\seq.c	/^static struct seq_thread *seq_thread_get(void) OVS_REQUIRES(seq_mutex);$/;"	v
seq_mutex	.\lib\seq.c	/^static uint64_t seq_next OVS_GUARDED_BY(seq_mutex) = 1;$/;"	v	file:
seq_mutex	.\lib\seq.c	/^static void seq_thread_exit(void *thread_) OVS_EXCLUDED(seq_mutex);$/;"	v
seq_mutex	.\lib\seq.c	/^static void seq_thread_woke(struct seq_thread *) OVS_REQUIRES(seq_mutex);$/;"	v
seq_mutex	.\lib\seq.c	/^static void seq_waiter_destroy(struct seq_waiter *) OVS_REQUIRES(seq_mutex);$/;"	v
seq_mutex	.\lib\seq.c	/^static void seq_wake_waiters(struct seq *) OVS_REQUIRES(seq_mutex);$/;"	v
seq_no	.\lib\pcap-file.c	/^    uint32_t seq_no;$/;"	m	struct:tcp_stream	file:
seq_number	.\ofproto\ofproto-dpif-ipfix.c	/^    uint32_t seq_number;$/;"	m	struct:dpif_ipfix_exporter	file:
seq_thread	.\lib\seq.c	/^struct seq_thread {$/;"	s	file:
seq_thread_key	.\lib\seq.c	/^static pthread_key_t seq_thread_key;$/;"	v	file:
seq_waiter	.\lib\seq.c	/^struct seq_waiter {$/;"	s	file:
seqno	.\lib\jsonrpc.c	/^    unsigned int seqno;$/;"	m	struct:jsonrpc_session	file:
seqno	.\lib\ovs-rcu.c	/^    uint64_t seqno;$/;"	m	struct:ovsrcu_perthread	file:
seqno	.\lib\rconn.c	/^    unsigned int seqno;$/;"	m	struct:rconn	file:
seqno	.\lib\reconnect.c	/^    unsigned int seqno;$/;"	m	struct:reconnect	file:
seqno	.\lib\reconnect.h	/^    unsigned int seqno;              \/* # of connections + # of disconnections. *\/$/;"	m	struct:reconnect_stats
sequence_number	.\lib\sflow.h	/^    u_int32_t sequence_number;       \/* Incremented with each sample datagram$/;"	m	struct:_SFLSample_datagram_hdr
sequence_number	.\lib\sflow.h	/^    u_int32_t sequence_number;      \/* Incremented with each flow sample$/;"	m	struct:_SFLFlow_sample
sequence_number	.\lib\sflow.h	/^    u_int32_t sequence_number;      \/* Incremented with each flow sample$/;"	m	struct:_SFLFlow_sample_expanded
sequence_number	.\lib\sflow.h	/^    u_int32_t sequence_number;    \/* Incremented with each counters sample$/;"	m	struct:_SFLCounters_sample
sequence_number	.\lib\sflow.h	/^    u_int32_t sequence_number;    \/* Incremented with each counters sample$/;"	m	struct:_SFLCounters_sample_expanded
serial	.\ovsdb\transaction.c	/^    unsigned int serial;        \/* Serial number of in-progress commit. *\/$/;"	m	struct:ovsdb_txn_row	file:
serial	.\ovsdb\transaction.c	/^    unsigned int serial;        \/* Serial number of in-progress iteration. *\/$/;"	m	struct:ovsdb_txn_table	file:
serial	.\ovsdb\transaction.c	/^static unsigned int serial;$/;"	v	file:
serial_desc	.\ofproto\ofproto-provider.h	/^    char *serial_desc;          \/* Serial number (NULL for default). *\/$/;"	m	struct:ofproto
serial_num	.\include\openflow\openflow-common.h	/^    char serial_num[SERIAL_NUM_LEN];   \/* Serial number. *\/$/;"	m	struct:ofp_desc_stats
serialize	.\python\ovs\json.py	/^    def serialize(self, obj):$/;"	m	class:_Serializer
server	.\ovsdb\jsonrpc-server.c	/^    struct ovsdb_jsonrpc_server *server;$/;"	m	struct:ovsdb_jsonrpc_remote	typeref:struct:ovsdb_jsonrpc_remote::ovsdb_jsonrpc_server	file:
server	.\ovsdb\server.h	/^    struct ovsdb_server *server; \/* The containing server. *\/$/;"	m	struct:ovsdb_lock	typeref:struct:ovsdb_lock::ovsdb_server
server	.\ovsdb\server.h	/^    struct ovsdb_server *server;$/;"	m	struct:ovsdb_session	typeref:struct:ovsdb_session::ovsdb_server
server	.\python\ovstest\rpcserver.py	/^from twisted.web import server$/;"	i
server	.\tests\test-unixctl.py	/^import ovs.unixctl.server$/;"	i
server_config	.\ovsdb\ovsdb-server.c	/^struct server_config {$/;"	s	file:
server_endpoint	.\python\ovstest\args.py	/^def server_endpoint(string):$/;"	f
service	.\lib\daemon-windows.c	/^static SC_HANDLE manager, service;$/;"	v	file:
service	.\xenserver\usr_lib_xsconsole_plugins-base_XSFeatureVSwitch.py	/^    service = {}$/;"	v	class:VSwitchService
service_complete	.\lib\daemon-windows.c	/^service_complete(void)$/;"	f	file:
service_create	.\lib\daemon-windows.c	/^static bool service_create;          \/* Was --service specified? *\/$/;"	v	file:
service_start	.\lib\daemon-unix.c	/^service_start(int *argc OVS_UNUSED, char **argv[] OVS_UNUSED)$/;"	f
service_start	.\lib\daemon-windows.c	/^service_start(int *argcp, char **argvp[])$/;"	f
service_started	.\lib\daemon-windows.c	/^static bool service_started;         \/* Have we dispatched service to start? *\/$/;"	v	file:
service_status	.\lib\daemon-windows.c	/^static SERVICE_STATUS service_status;$/;"	v	file:
service_stop	.\lib\daemon-unix.c	/^service_stop(void)$/;"	f
service_stop	.\lib\daemon-windows.c	/^service_stop()$/;"	f
services	.\ofproto\connmgr.c	/^    struct hmap services;       \/* Contains "struct ofservice"s. *\/$/;"	m	struct:connmgr	typeref:struct:connmgr::hmap	file:
session	.\lib\ovsdb-idl.c	/^    struct jsonrpc_session *session;$/;"	m	struct:ovsdb_idl	typeref:struct:ovsdb_idl::jsonrpc_session	file:
session	.\ovsdb\execution.c	/^    const struct ovsdb_session *session;$/;"	m	struct:ovsdb_execution	typeref:struct:ovsdb_execution::ovsdb_session	file:
session	.\ovsdb\jsonrpc-server.c	/^    struct ovsdb_jsonrpc_session *session;$/;"	m	struct:ovsdb_jsonrpc_monitor	typeref:struct:ovsdb_jsonrpc_monitor::ovsdb_jsonrpc_session	file:
session	.\ovsdb\server.h	/^    struct ovsdb_session *session;$/;"	m	struct:ovsdb_lock_waiter	typeref:struct:ovsdb_lock_waiter::ovsdb_session
session	.\ovsdb\trigger.h	/^    struct ovsdb_session *session; \/* Session that owns this trigger. *\/$/;"	m	struct:ovsdb_trigger	typeref:struct:ovsdb_trigger::ovsdb_session
session_node	.\ovsdb\server.h	/^    struct hmap_node session_node; \/* In ->session->locks's hmap. *\/$/;"	m	struct:ovsdb_lock_waiter	typeref:struct:ovsdb_lock_waiter::hmap_node
session_nr	.\lib\stream-ssl.c	/^    unsigned int session_nr;$/;"	m	struct:ssl_stream	file:
session_type	.\lib\stream-ssl.c	/^enum session_type {$/;"	g	file:
sessions	.\ovsdb\jsonrpc-server.c	/^    struct list sessions;       \/* List of "struct ovsdb_jsonrpc_session"s. *\/$/;"	m	struct:ovsdb_jsonrpc_remote	typeref:struct:ovsdb_jsonrpc_remote::list	file:
set	.\include\openflow\nicira-ext.h	/^    uint8_t set;                \/* Nonzero to enable, zero to disable. *\/$/;"	m	struct:nx_flow_mod_table_id
set	.\lib\sflow.h	/^	u_int32_t *set;$/;"	m	union:_SFLExtended_as_path_segment::__anon94
set	.\ovsdb\row.c	/^    struct ovsdb_row_set *set;$/;"	m	struct:ovsdb_row_set_sort_cbdata	typeref:struct:ovsdb_row_set_sort_cbdata::ovsdb_row_set	file:
set_action_to_attr	.\datapath\flow_netlink.c	/^static int set_action_to_attr(const struct nlattr *a, struct sk_buff *skb)$/;"	f	file:
set_advertisements	.\lib\netdev-provider.h	/^    int (*set_advertisements)(struct netdev *netdev,$/;"	m	struct:netdev_class
set_all_rate_limits	.\lib\vlog.c	/^set_all_rate_limits(bool enable)$/;"	f	file:
set_allowed_ofp_versions	.\lib\ofp-version-opt.c	/^set_allowed_ofp_versions(const char *string)$/;"	f
set_arp	.\lib\odp-execute.c	/^set_arp(struct ofpbuf *packet, const struct ovs_key_arp *arp_key)$/;"	f	file:
set_backoff	.\python\ovs\reconnect.py	/^    def set_backoff(self, min_backoff, max_backoff):$/;"	m	class:Reconnect
set_bfd	.\ofproto\ofproto-dpif.c	/^set_bfd(struct ofport *ofport_, const struct smap *cfg)$/;"	f	file:
set_bfd	.\ofproto\ofproto-provider.h	/^    int (*set_bfd)(struct ofport *ofport, const struct smap *cfg);$/;"	m	struct:ofproto_class
set_bit	.\tests\test-hash.c	/^set_bit(uint32_t array[3], int bit)$/;"	f	file:
set_br_external_ids	.\xenserver\opt_xensource_libexec_InterfaceReconfigureVswitch.py	/^def set_br_external_ids(pif):$/;"	f
set_cfm	.\ofproto\ofproto-dpif.c	/^set_cfm(struct ofport *ofport_, const struct cfm_settings *s)$/;"	f	file:
set_cfm	.\ofproto\ofproto-provider.h	/^    int (*set_cfm)(struct ofport *ofport, const struct cfm_settings *s);$/;"	m	struct:ofproto_class
set_column	.\utilities\ovs-vsctl.c	/^set_column(const struct vsctl_table_class *table,$/;"	f	file:
set_column	.\vtep\vtep-ctl.c	/^set_column(const struct vtep_ctl_table_class *table,$/;"	f	file:
set_config	.\lib\netdev-provider.h	/^    int (*set_config)(struct netdev *netdev, const struct smap *args);$/;"	m	struct:netdev_class
set_config_failure_actions	.\lib\daemon-windows.c	/^set_config_failure_actions()$/;"	f	file:
set_defaults	.\python\compat\argparse.py	/^    def set_defaults(self, **kwargs):$/;"	m	class:_ActionsContainer
set_detach	.\lib\daemon-unix.c	/^set_detach(void)$/;"	f
set_detach	.\python\ovs\daemon.py	/^def set_detach():$/;"	f
set_dscp	.\lib\socket-util.c	/^set_dscp(int fd, uint8_t dscp)$/;"	f
set_dscp	.\lib\stream-provider.h	/^    int (*set_dscp)(struct pstream *pstream, uint8_t dscp);$/;"	m	struct:pstream_class
set_dscp	.\python\ovs\socket_util.py	/^def set_dscp(sock, dscp):$/;"	f
set_dscp_cb	.\lib\stream-fd-unix.c	/^    int (*set_dscp_cb)(int fd, uint8_t dscp);$/;"	m	struct:fd_pstream	file:
set_dscp_cb	.\lib\stream-fd-windows.c	/^    int (*set_dscp_cb)(int fd, uint8_t dscp);$/;"	m	struct:fd_pstream	file:
set_eth	.\lib\match.c	/^set_eth(const uint8_t value_src[ETH_ADDR_LEN],$/;"	f	file:
set_eth_addr	.\datapath\actions.c	/^static int set_eth_addr(struct sk_buff *skb,$/;"	f	file:
set_eth_masked	.\lib\match.c	/^set_eth_masked(const uint8_t value_src[ETH_ADDR_LEN],$/;"	f	file:
set_etheraddr	.\lib\netdev-bsd.c	/^set_etheraddr(const char *netdev_name OVS_UNUSED, int hwaddr_family OVS_UNUSED,$/;"	f	file:
set_etheraddr	.\lib\netdev-linux.c	/^set_etheraddr(const char *netdev_name,$/;"	f	file:
set_etheraddr	.\lib\netdev-provider.h	/^    int (*set_etheraddr)(struct netdev *netdev, const uint8_t mac[6]);$/;"	m	struct:netdev_class
set_ethertype	.\lib\packets.c	/^set_ethertype(struct ofpbuf *packet, ovs_be16 eth_type)$/;"	f	file:
set_external_id	.\utilities\ovs-vsctl.c	/^set_external_id(struct smap *old, struct smap *new,$/;"	f	file:
set_facility_level	.\lib\vlog.c	/^set_facility_level(enum vlog_facility facility, struct vlog_module *module,$/;"	f	file:
set_field	.\lib\ofp-actions.c	/^    struct ofp12_action_set_field set_field;$/;"	m	union:ofp_action	typeref:struct:ofp_action::ofp12_action_set_field	file:
set_field_from_openflow	.\lib\ofp-actions.c	/^set_field_from_openflow(const struct ofp12_action_set_field *oasf,$/;"	f	file:
set_field_parse	.\lib\ofp-parse.c	/^set_field_parse(const char *arg, struct ofpbuf *ofpacts,$/;"	f	file:
set_field_parse__	.\lib\ofp-parse.c	/^set_field_parse__(char *arg, struct ofpbuf *ofpacts,$/;"	f	file:
set_field_to_nxast	.\lib\ofp-actions.c	/^set_field_to_nxast(const struct ofpact_set_field *sf, struct ofpbuf *openflow)$/;"	f	file:
set_field_to_openflow	.\lib\ofp-actions.c	/^set_field_to_openflow(const struct ofpact_set_field *sf,$/;"	f	file:
set_field_to_openflow10	.\lib\ofp-actions.c	/^set_field_to_openflow10(const struct ofpact_set_field *sf,$/;"	f	file:
set_field_to_openflow11	.\lib\ofp-actions.c	/^set_field_to_openflow11(const struct ofpact_set_field *sf,$/;"	f	file:
set_field_to_openflow12	.\lib\ofp-actions.c	/^set_field_to_openflow12(const struct ofpact_set_field *sf,$/;"	f	file:
set_fields	.\lib\ofp-util.h	/^            uint64_t set_fields;  \/* Bitmap of MFF_* "set-field" supports. *\/$/;"	m	struct:ofputil_table_features::ofputil_table_instruction_features::ofputil_table_action_features
set_flags	.\lib\netdev-bsd.c	/^set_flags(const char *name, int flags)$/;"	f	file:
set_flags	.\lib\netdev-linux.c	/^set_flags(const char *name, unsigned int flags)$/;"	f	file:
set_flood_vlans	.\ofproto\ofproto-dpif.c	/^set_flood_vlans(struct ofproto *ofproto_, unsigned long *flood_vlans)$/;"	f	file:
set_flood_vlans	.\ofproto\ofproto-provider.h	/^    int (*set_flood_vlans)(struct ofproto *ofproto,$/;"	m	struct:ofproto_class
set_frag_handling	.\ofproto\ofproto-dpif.c	/^set_frag_handling(struct ofproto *ofproto_,$/;"	f	file:
set_frag_handling	.\ofproto\ofproto-provider.h	/^    bool (*set_frag_handling)(struct ofproto *ofproto,$/;"	m	struct:ofproto_class
set_in4	.\lib\netdev-provider.h	/^    int (*set_in4)(struct netdev *netdev, struct in_addr addr,$/;"	m	struct:netdev_class
set_ip_addr	.\datapath\actions.c	/^static void set_ip_addr(struct sk_buff *skb, struct iphdr *nh,$/;"	f	file:
set_ip_ttl	.\datapath\actions.c	/^static void set_ip_ttl(struct sk_buff *skb, struct iphdr *nh, u8 new_ttl)$/;"	f	file:
set_ipfix	.\ofproto\ofproto-dpif.c	/^set_ipfix($/;"	f	file:
set_ipfix	.\ofproto\ofproto-provider.h	/^    int (*set_ipfix)($/;"	m	struct:ofproto_class
set_ipv4	.\datapath\actions.c	/^static int set_ipv4(struct sk_buff *skb, const struct ovs_key_ipv4 *ipv4_key)$/;"	f	file:
set_ipv6	.\datapath\actions.c	/^static int set_ipv6(struct sk_buff *skb, const struct ovs_key_ipv6 *ipv6_key)$/;"	f	file:
set_ipv6_addr	.\datapath\actions.c	/^static void set_ipv6_addr(struct sk_buff *skb, u8 l4_proto,$/;"	f	file:
set_ipv6_fl	.\datapath\actions.c	/^static void set_ipv6_fl(struct ipv6hdr *nh, u32 fl)$/;"	f	file:
set_ipv6_tc	.\datapath\actions.c	/^static void set_ipv6_tc(struct ipv6hdr *nh, u8 tc)$/;"	f	file:
set_level	.\python\ovs\vlog.py	/^    def set_level(module, facility, level):$/;"	m	class:Vlog
set_levels_from_string	.\python\ovs\vlog.py	/^    def set_levels_from_string(s):$/;"	m	class:Vlog
set_lock	.\python\ovs\db\idl.py	/^    def set_lock(self, lock_name):$/;"	m	class:Idl
set_log_destination	.\xenserver\opt_xensource_libexec_InterfaceReconfigure.py	/^def set_log_destination(dest):$/;"	f
set_mac_table_config	.\ofproto\ofproto-dpif.c	/^set_mac_table_config(struct ofproto *ofproto_, unsigned int idle_time,$/;"	f	file:
set_mac_table_config	.\ofproto\ofproto-provider.h	/^    void (*set_mac_table_config)(struct ofproto *ofproto,$/;"	m	struct:ofproto_class
set_max_tries	.\python\ovs\reconnect.py	/^    def set_max_tries(self, max_tries):$/;"	m	class:Reconnect
set_miimon_interval	.\lib\netdev-provider.h	/^    int (*set_miimon_interval)(struct netdev *netdev, long long int interval);$/;"	m	struct:netdev_class
set_monitor	.\python\ovs\daemon.py	/^def set_monitor():$/;"	f
set_mpls_lse	.\lib\packets.c	/^set_mpls_lse(struct ofpbuf *packet, ovs_be32 mpls_lse)$/;"	f
set_mpls_lse_bos	.\lib\packets.c	/^set_mpls_lse_bos(ovs_be32 *lse, uint8_t bos)$/;"	f
set_mpls_lse_label	.\lib\packets.c	/^set_mpls_lse_label(ovs_be32 *lse, ovs_be32 label)$/;"	f
set_mpls_lse_tc	.\lib\packets.c	/^set_mpls_lse_tc(ovs_be32 *lse, uint8_t tc)$/;"	f
set_mpls_lse_ttl	.\lib\packets.c	/^set_mpls_lse_ttl(ovs_be32 *lse, uint8_t ttl)$/;"	f
set_mpls_lse_values	.\lib\packets.c	/^set_mpls_lse_values(uint8_t ttl, uint8_t tc, uint8_t bos, ovs_be32 label)$/;"	f
set_mtu	.\lib\netdev-provider.h	/^    int (*set_mtu)(const struct netdev *netdev, int mtu);$/;"	m	struct:netdev_class
set_name	.\python\ovs\reconnect.py	/^    def set_name(self, name):$/;"	m	class:Reconnect
set_netflow	.\ofproto\ofproto-dpif.c	/^set_netflow(struct ofproto *ofproto_,$/;"	f	file:
set_netflow	.\ofproto\ofproto-provider.h	/^    int (*set_netflow)(struct ofproto *ofproto,$/;"	m	struct:ofproto_class
set_no_chdir	.\lib\daemon-unix.c	/^set_no_chdir(void)$/;"	f
set_no_chdir	.\python\ovs\daemon.py	/^def set_no_chdir():$/;"	f
set_nonblocking	.\lib\socket-util.c	/^set_nonblocking(int fd)$/;"	f
set_nonblocking	.\python\ovs\socket_util.py	/^def set_nonblocking(sock):$/;"	f
set_options	.\datapath\vport.h	/^	int (*set_options)(struct vport *, struct nlattr *);$/;"	m	struct:vport_ops
set_packet_in_format	.\utilities\ovs-ofctl.c	/^set_packet_in_format(struct vconn *vconn,$/;"	f	file:
set_passive	.\python\ovs\reconnect.py	/^    def set_passive(self, passive, now):$/;"	m	class:Reconnect
set_patch_config	.\lib\netdev-vport.c	/^set_patch_config(struct netdev *dev_, const struct smap *args)$/;"	f	file:
set_pattern	.\python\ovs\vlog.py	/^    def set_pattern(facility, pattern):$/;"	m	class:Vlog
set_pidfile	.\lib\daemon.c	/^set_pidfile(const char *name)$/;"	f
set_pidfile	.\python\ovs\daemon.py	/^def set_pidfile(name):$/;"	f
set_pipe_handle	.\lib\daemon-windows.c	/^set_pipe_handle(const char *pipe_handle)$/;"	f
set_policing	.\lib\netdev-provider.h	/^    int (*set_policing)(struct netdev *netdev, unsigned int kbits_rate,$/;"	m	struct:netdev_class
set_probe_interval	.\python\ovs\reconnect.py	/^    def set_probe_interval(self, probe_interval):$/;"	m	class:Reconnect
set_program_name	.\lib\util.h	259;"	d
set_program_name__	.\lib\util.c	/^set_program_name__(const char *argv0, const char *version, const char *date,$/;"	f
set_protocol_for_flow_dump	.\utilities\ovs-ofctl.c	/^set_protocol_for_flow_dump(struct vconn *vconn,$/;"	f	file:
set_pvconns	.\ofproto\connmgr.c	/^set_pvconns(struct pvconn ***pvconnsp, size_t *n_pvconnsp,$/;"	f	file:
set_qos	.\lib\netdev-provider.h	/^    int (*set_qos)(struct netdev *netdev,$/;"	m	struct:netdev_class
set_queue	.\lib\netdev-provider.h	/^    int (*set_queue)(struct netdev *netdev,$/;"	m	struct:netdev_class
set_queue	.\lib\ofp-actions.c	/^    struct nx_action_set_queue set_queue;$/;"	m	union:ofp_action	typeref:struct:ofp_action::nx_action_set_queue	file:
set_queues	.\ofproto\ofproto-dpif.c	/^set_queues(struct ofport *ofport_, const struct ofproto_port_queue *qdscp,$/;"	f	file:
set_queues	.\ofproto\ofproto-provider.h	/^    int (*set_queues)(struct ofport *ofport,$/;"	m	struct:ofproto_class
set_quiet	.\python\ovs\reconnect.py	/^    def set_quiet(self, quiet):$/;"	m	class:Reconnect
set_rate_limits	.\lib\vlog.c	/^set_rate_limits(struct unixctl_conn *conn, int argc,$/;"	f	file:
set_realdev	.\ofproto\ofproto-dpif.c	/^set_realdev(struct ofport *ofport_, ofp_port_t realdev_ofp_port, int vid)$/;"	f	file:
set_realdev	.\ofproto\ofproto-provider.h	/^    int (*set_realdev)(struct ofport *ofport,$/;"	m	struct:ofproto_class
set_root_prefix	.\xenserver\opt_xensource_libexec_InterfaceReconfigure.py	/^def set_root_prefix(prefix):$/;"	f
set_sctp	.\datapath\actions.c	/^static int set_sctp(struct sk_buff *skb,$/;"	f	file:
set_sflow	.\ofproto\ofproto-dpif.c	/^set_sflow(struct ofproto *ofproto_,$/;"	f	file:
set_sflow	.\ofproto\ofproto-provider.h	/^    int (*set_sflow)(struct ofproto *ofproto,$/;"	m	struct:ofproto_class
set_stats	.\lib\netdev-provider.h	/^    int (*set_stats)(struct netdev *netdev, const struct netdev_stats *);$/;"	m	struct:netdev_class
set_stp	.\ofproto\ofproto-dpif.c	/^set_stp(struct ofproto *ofproto_, const struct ofproto_stp_settings *s)$/;"	f	file:
set_stp	.\ofproto\ofproto-provider.h	/^    int (*set_stp)(struct ofproto *ofproto,$/;"	m	struct:ofproto_class
set_stp_port	.\ofproto\ofproto-dpif.c	/^set_stp_port(struct ofport *ofport_,$/;"	f	file:
set_stp_port	.\ofproto\ofproto-provider.h	/^    int (*set_stp_port)(struct ofport *ofport,$/;"	m	struct:ofproto_class
set_subprogram_name	.\lib\util.c	/^set_subprogram_name(const char *format, ...)$/;"	f
set_switch_config	.\utilities\ovs-ofctl.c	/^set_switch_config(struct vconn *vconn, const struct ofp_switch_config *config)$/;"	f	file:
set_tcp	.\datapath\actions.c	/^static int set_tcp(struct sk_buff *skb, const struct ovs_key_tcp *tcp_port_key)$/;"	f	file:
set_tp_port	.\datapath\actions.c	/^static void set_tp_port(struct sk_buff *skb, __be16 *port,$/;"	f	file:
set_tunnel	.\lib\ofp-actions.c	/^    struct nx_action_set_tunnel set_tunnel;$/;"	m	union:ofp_action	typeref:struct:ofp_action::nx_action_set_tunnel	file:
set_tunnel64	.\lib\ofp-actions.c	/^    struct nx_action_set_tunnel64 set_tunnel64;$/;"	m	union:ofp_action	typeref:struct:ofp_action::nx_action_set_tunnel64	file:
set_tunnel_config	.\lib\netdev-vport.c	/^set_tunnel_config(struct netdev *dev_, const struct smap *args)$/;"	f	file:
set_udp	.\datapath\actions.c	/^static int set_udp(struct sk_buff *skb, const struct ovs_key_udp *udp_port_key)$/;"	f	file:
set_udp_port	.\datapath\actions.c	/^static void set_udp_port(struct sk_buff *skb, __be16 *port, __be16 new_port)$/;"	f	file:
set_up_flows	.\tests\test-controller.c	/^static bool set_up_flows = true;$/;"	v	file:
setsockopt	.\lib\socket-util.h	99;"	d
setup_arch_fast_hash	.\datapath\linux\compat\hash-x86.c	/^void setup_arch_fast_hash(struct fast_hash_ops *ops)$/;"	f
setup_arch_fast_hash	.\datapath\linux\compat\include\asm\hash.h	/^static inline void setup_arch_fast_hash(struct fast_hash_ops *ops) { }$/;"	f
sf	.\lib\dpif-netdev.c	/^    struct netdev_saved_flags *sf;$/;"	m	struct:dp_netdev_port	typeref:struct:dp_netdev_port::netdev_saved_flags	file:
sf_acts	.\datapath\flow.h	/^	struct sw_flow_actions __rcu *sf_acts;$/;"	m	struct:sw_flow	typeref:struct:sw_flow::__rcu
sflAlloc	.\lib\sflow_agent.c	/^static void * sflAlloc(SFLAgent *agent, size_t bytes)$/;"	f	file:
sflError	.\lib\sflow_receiver.c	/^static void sflError(SFLReceiver *receiver, char *msg)$/;"	f	file:
sflFree	.\lib\sflow_agent.c	/^static void sflFree(SFLAgent *agent, void *obj)$/;"	f	file:
sfl_agent_addPoller	.\lib\sflow_agent.c	/^SFLPoller *sfl_agent_addPoller(SFLAgent *agent,$/;"	f
sfl_agent_addReceiver	.\lib\sflow_agent.c	/^SFLReceiver *sfl_agent_addReceiver(SFLAgent *agent)$/;"	f
sfl_agent_addSampler	.\lib\sflow_agent.c	/^SFLSampler *sfl_agent_addSampler(SFLAgent *agent, SFLDataSource_instance *pdsi)$/;"	f
sfl_agent_error	.\lib\sflow_agent.c	/^void sfl_agent_error(SFLAgent *agent, char *modName, char *msg)$/;"	f
sfl_agent_getNextPoller	.\lib\sflow_agent.c	/^SFLPoller *sfl_agent_getNextPoller(SFLAgent *agent, SFLDataSource_instance *pdsi)$/;"	f
sfl_agent_getNextReceiver	.\lib\sflow_agent.c	/^SFLReceiver *sfl_agent_getNextReceiver(SFLAgent *agent, u_int32_t receiverIndex)$/;"	f
sfl_agent_getNextSampler	.\lib\sflow_agent.c	/^SFLSampler *sfl_agent_getNextSampler(SFLAgent *agent, SFLDataSource_instance *pdsi)$/;"	f
sfl_agent_getPoller	.\lib\sflow_agent.c	/^SFLPoller *sfl_agent_getPoller(SFLAgent *agent, SFLDataSource_instance *pdsi)$/;"	f
sfl_agent_getReceiver	.\lib\sflow_agent.c	/^SFLReceiver *sfl_agent_getReceiver(SFLAgent *agent, u_int32_t receiverIndex)$/;"	f
sfl_agent_getSampler	.\lib\sflow_agent.c	/^SFLSampler *sfl_agent_getSampler(SFLAgent *agent, SFLDataSource_instance *pdsi)$/;"	f
sfl_agent_getSamplerByIfIndex	.\lib\sflow_agent.c	/^SFLSampler *sfl_agent_getSamplerByIfIndex(SFLAgent *agent, u_int32_t ifIndex)$/;"	f
sfl_agent_init	.\lib\sflow_agent.c	/^void sfl_agent_init(SFLAgent *agent,$/;"	f
sfl_agent_jumpTableAdd	.\lib\sflow_agent.c	/^static void sfl_agent_jumpTableAdd(SFLAgent *agent, SFLSampler *sampler)$/;"	f	file:
sfl_agent_jumpTableRemove	.\lib\sflow_agent.c	/^static void sfl_agent_jumpTableRemove(SFLAgent *agent, SFLSampler *sampler)$/;"	f	file:
sfl_agent_release	.\lib\sflow_agent.c	/^void sfl_agent_release(SFLAgent *agent)$/;"	f
sfl_agent_removePoller	.\lib\sflow_agent.c	/^int sfl_agent_removePoller(SFLAgent *agent, SFLDataSource_instance *pdsi)$/;"	f
sfl_agent_removeSampler	.\lib\sflow_agent.c	/^int sfl_agent_removeSampler(SFLAgent *agent, SFLDataSource_instance *pdsi)$/;"	f
sfl_agent_resetReceiver	.\lib\sflow_agent.c	/^void sfl_agent_resetReceiver(SFLAgent *agent, SFLReceiver *receiver)$/;"	f
sfl_agent_set_agentAddress	.\lib\sflow_agent.c	/^void sfl_agent_set_agentAddress(SFLAgent *agent, SFLAddress *addr)$/;"	f
sfl_agent_set_agentSubId	.\lib\sflow_agent.c	/^void sfl_agent_set_agentSubId(SFLAgent *agent, u_int32_t subId)$/;"	f
sfl_agent_sysError	.\lib\sflow_agent.c	/^void sfl_agent_sysError(SFLAgent *agent, char *modName, char *msg)$/;"	f
sfl_agent_tick	.\lib\sflow_agent.c	/^void sfl_agent_tick(SFLAgent *agent, time_t now)$/;"	f
sfl_dsi_compare	.\lib\sflow_agent.c	/^static inline int sfl_dsi_compare(SFLDataSource_instance *pdsi1, SFLDataSource_instance *pdsi2) {$/;"	f	file:
sfl_poller_get_bridgePort	.\lib\sflow_poller.c	/^u_int32_t sfl_poller_get_bridgePort(SFLPoller *poller) {$/;"	f
sfl_poller_get_sFlowCpInterval	.\lib\sflow_poller.c	/^u_int32_t sfl_poller_get_sFlowCpInterval(SFLPoller *poller) {$/;"	f
sfl_poller_get_sFlowCpReceiver	.\lib\sflow_poller.c	/^u_int32_t sfl_poller_get_sFlowCpReceiver(SFLPoller *poller) {$/;"	f
sfl_poller_init	.\lib\sflow_poller.c	/^void sfl_poller_init(SFLPoller *poller,$/;"	f
sfl_poller_resetCountersSeqNo	.\lib\sflow_poller.c	/^void sfl_poller_resetCountersSeqNo(SFLPoller *poller) {  poller->countersSampleSeqNo = 0; }$/;"	f
sfl_poller_set_bridgePort	.\lib\sflow_poller.c	/^void sfl_poller_set_bridgePort(SFLPoller *poller, u_int32_t port_no) {$/;"	f
sfl_poller_set_sFlowCpInterval	.\lib\sflow_poller.c	/^void sfl_poller_set_sFlowCpInterval(SFLPoller *poller, u_int32_t sFlowCpInterval) {$/;"	f
sfl_poller_set_sFlowCpReceiver	.\lib\sflow_poller.c	/^void sfl_poller_set_sFlowCpReceiver(SFLPoller *poller, u_int32_t sFlowCpReceiver) {$/;"	f
sfl_poller_tick	.\lib\sflow_poller.c	/^void sfl_poller_tick(SFLPoller *poller, time_t now)$/;"	f
sfl_poller_writeCountersSample	.\lib\sflow_poller.c	/^void sfl_poller_writeCountersSample(SFLPoller *poller, SFL_COUNTERS_SAMPLE_TYPE *cs)$/;"	f
sfl_receiver_get_sFlowRcvrAddress	.\lib\sflow_receiver.c	/^SFLAddress *sfl_receiver_get_sFlowRcvrAddress(SFLReceiver *receiver) {$/;"	f
sfl_receiver_get_sFlowRcvrMaximumDatagramSize	.\lib\sflow_receiver.c	/^u_int32_t sfl_receiver_get_sFlowRcvrMaximumDatagramSize(SFLReceiver *receiver) {$/;"	f
sfl_receiver_get_sFlowRcvrOwner	.\lib\sflow_receiver.c	/^char * sfl_receiver_get_sFlowRcvrOwner(SFLReceiver *receiver) {$/;"	f
sfl_receiver_get_sFlowRcvrPort	.\lib\sflow_receiver.c	/^u_int32_t sfl_receiver_get_sFlowRcvrPort(SFLReceiver *receiver) {$/;"	f
sfl_receiver_get_sFlowRcvrTimeout	.\lib\sflow_receiver.c	/^time_t sfl_receiver_get_sFlowRcvrTimeout(SFLReceiver *receiver) {$/;"	f
sfl_receiver_init	.\lib\sflow_receiver.c	/^void sfl_receiver_init(SFLReceiver *receiver, SFLAgent *agent)$/;"	f
sfl_receiver_samplePacketsSent	.\lib\sflow_receiver.c	/^u_int32_t sfl_receiver_samplePacketsSent(SFLReceiver *receiver)$/;"	f
sfl_receiver_set_sFlowRcvrAddress	.\lib\sflow_receiver.c	/^void sfl_receiver_set_sFlowRcvrAddress(SFLReceiver *receiver, SFLAddress *sFlowRcvrAddress) {$/;"	f
sfl_receiver_set_sFlowRcvrMaximumDatagramSize	.\lib\sflow_receiver.c	/^void sfl_receiver_set_sFlowRcvrMaximumDatagramSize(SFLReceiver *receiver, u_int32_t sFlowRcvrMaximumDatagramSize) {$/;"	f
sfl_receiver_set_sFlowRcvrOwner	.\lib\sflow_receiver.c	/^void sfl_receiver_set_sFlowRcvrOwner(SFLReceiver *receiver, char *sFlowRcvrOwner) {$/;"	f
sfl_receiver_set_sFlowRcvrPort	.\lib\sflow_receiver.c	/^void sfl_receiver_set_sFlowRcvrPort(SFLReceiver *receiver, u_int32_t sFlowRcvrPort) {$/;"	f
sfl_receiver_set_sFlowRcvrTimeout	.\lib\sflow_receiver.c	/^void sfl_receiver_set_sFlowRcvrTimeout(SFLReceiver *receiver, time_t sFlowRcvrTimeout) {$/;"	f
sfl_receiver_tick	.\lib\sflow_receiver.c	/^void sfl_receiver_tick(SFLReceiver *receiver, time_t now)$/;"	f
sfl_receiver_writeCountersSample	.\lib\sflow_receiver.c	/^int sfl_receiver_writeCountersSample(SFLReceiver *receiver, SFL_COUNTERS_SAMPLE_TYPE *cs)$/;"	f
sfl_receiver_writeFlowSample	.\lib\sflow_receiver.c	/^int sfl_receiver_writeFlowSample(SFLReceiver *receiver, SFL_FLOW_SAMPLE_TYPE *fs)$/;"	f
sfl_sampler_get_backoffThreshold	.\lib\sflow_sampler.c	/^u_int32_t sfl_sampler_get_backoffThreshold(SFLSampler *sampler) {$/;"	f
sfl_sampler_get_sFlowFsMaximumHeaderSize	.\lib\sflow_sampler.c	/^u_int32_t sfl_sampler_get_sFlowFsMaximumHeaderSize(SFLSampler *sampler) {$/;"	f
sfl_sampler_get_sFlowFsPacketSamplingRate	.\lib\sflow_sampler.c	/^u_int32_t sfl_sampler_get_sFlowFsPacketSamplingRate(SFLSampler *sampler) {$/;"	f
sfl_sampler_get_sFlowFsReceiver	.\lib\sflow_sampler.c	/^u_int32_t sfl_sampler_get_sFlowFsReceiver(SFLSampler *sampler) {$/;"	f
sfl_sampler_get_samplesLastTick	.\lib\sflow_sampler.c	/^u_int32_t sfl_sampler_get_samplesLastTick(SFLSampler *sampler) {$/;"	f
sfl_sampler_init	.\lib\sflow_sampler.c	/^void sfl_sampler_init(SFLSampler *sampler, SFLAgent *agent, SFLDataSource_instance *pdsi)$/;"	f
sfl_sampler_resetFlowSeqNo	.\lib\sflow_sampler.c	/^void sfl_sampler_resetFlowSeqNo(SFLSampler *sampler) { sampler->flowSampleSeqNo = 0; }$/;"	f
sfl_sampler_set_backoffThreshold	.\lib\sflow_sampler.c	/^void sfl_sampler_set_backoffThreshold(SFLSampler *sampler, u_int32_t samplesPerSecond) {$/;"	f
sfl_sampler_set_sFlowFsMaximumHeaderSize	.\lib\sflow_sampler.c	/^void sfl_sampler_set_sFlowFsMaximumHeaderSize(SFLSampler *sampler, u_int32_t sFlowFsMaximumHeaderSize) {$/;"	f
sfl_sampler_set_sFlowFsPacketSamplingRate	.\lib\sflow_sampler.c	/^void sfl_sampler_set_sFlowFsPacketSamplingRate(SFLSampler *sampler, u_int32_t sFlowFsPacketSamplingRate) {$/;"	f
sfl_sampler_set_sFlowFsReceiver	.\lib\sflow_sampler.c	/^void sfl_sampler_set_sFlowFsReceiver(SFLSampler *sampler, u_int32_t sFlowFsReceiver) {$/;"	f
sfl_sampler_takeSample	.\lib\sflow_sampler.c	/^int sfl_sampler_takeSample(SFLSampler *sampler)$/;"	f
sfl_sampler_tick	.\lib\sflow_sampler.c	/^void sfl_sampler_tick(SFLSampler *sampler, time_t now)$/;"	f
sfl_sampler_writeFlowSample	.\lib\sflow_sampler.c	/^void sfl_sampler_writeFlowSample(SFLSampler *sampler, SFL_FLOW_SAMPLE_TYPE *fs)$/;"	f
sflow	.\lib\odp-util.h	/^    } sflow;$/;"	m	union:user_action_cookie	typeref:struct:user_action_cookie::__anon69
sflow	.\lib\vswitch-idl.h	/^	struct ovsrec_sflow *sflow;$/;"	m	struct:ovsrec_bridge	typeref:struct:ovsrec_bridge::ovsrec_sflow
sflow	.\ofproto\ofproto-dpif-sflow.c	/^VLOG_DEFINE_THIS_MODULE(sflow);$/;"	v
sflow	.\ofproto\ofproto-dpif-xlate.c	/^    struct dpif_sflow *sflow;     \/* SFlow handle, or null. *\/$/;"	m	struct:xbridge	typeref:struct:xbridge::dpif_sflow	file:
sflow	.\ofproto\ofproto-dpif.c	/^    struct dpif_sflow *sflow;$/;"	m	struct:ofproto_dpif	typeref:struct:ofproto_dpif::dpif_sflow	file:
sflow_addr	.\tests\test-sflow.c	/^struct sflow_addr {$/;"	s	file:
sflow_agent	.\ofproto\ofproto-dpif-sflow.c	/^    SFLAgent *sflow_agent;$/;"	m	struct:dpif_sflow	file:
sflow_agent_alloc_cb	.\ofproto\ofproto-dpif-sflow.c	/^sflow_agent_alloc_cb(void *magic OVS_UNUSED, SFLAgent *agent OVS_UNUSED,$/;"	f	file:
sflow_agent_error_cb	.\ofproto\ofproto-dpif-sflow.c	/^sflow_agent_error_cb(void *magic OVS_UNUSED, SFLAgent *agent OVS_UNUSED,$/;"	f	file:
sflow_agent_free_cb	.\ofproto\ofproto-dpif-sflow.c	/^sflow_agent_free_cb(void *magic OVS_UNUSED, SFLAgent *agent OVS_UNUSED,$/;"	f	file:
sflow_agent_send_packet_cb	.\ofproto\ofproto-dpif-sflow.c	/^sflow_agent_send_packet_cb(void *ds_, SFLAgent *agent OVS_UNUSED,$/;"	f	file:
sflow_choose_agent_address	.\ofproto\ofproto-dpif-sflow.c	/^sflow_choose_agent_address(const char *agent_device,$/;"	f	file:
sflow_n_outputs	.\ofproto\ofproto-dpif-xlate.c	/^    uint32_t sflow_n_outputs;   \/* Number of output ports. *\/$/;"	m	struct:xlate_ctx	file:
sflow_odp_port	.\ofproto\ofproto-dpif-xlate.c	/^    odp_port_t sflow_odp_port;  \/* Output port for composing sFlow action. *\/$/;"	m	struct:xlate_ctx	file:
sflow_xdr	.\tests\test-sflow.c	/^struct sflow_xdr {$/;"	s	file:
sflowxdr_init	.\tests\test-sflow.c	/^sflowxdr_init(struct sflow_xdr *x, void *buf, size_t len)$/;"	f	file:
sflowxdr_mark	.\tests\test-sflow.c	/^sflowxdr_mark(const struct sflow_xdr *x, uint32_t q)$/;"	f	file:
sflowxdr_mark_ok	.\tests\test-sflow.c	/^sflowxdr_mark_ok(const struct sflow_xdr *x, uint32_t m)$/;"	f	file:
sflowxdr_mark_unique	.\tests\test-sflow.c	/^sflowxdr_mark_unique(struct sflow_xdr *x, uint32_t *pi)$/;"	f	file:
sflowxdr_more	.\tests\test-sflow.c	/^sflowxdr_more(const struct sflow_xdr *x, uint32_t q)$/;"	f	file:
sflowxdr_next	.\tests\test-sflow.c	/^sflowxdr_next(struct sflow_xdr *x)$/;"	f	file:
sflowxdr_next_int64	.\tests\test-sflow.c	/^sflowxdr_next_int64(struct sflow_xdr *x)$/;"	f	file:
sflowxdr_next_n	.\tests\test-sflow.c	/^sflowxdr_next_n(struct sflow_xdr *x)$/;"	f	file:
sflowxdr_setc	.\tests\test-sflow.c	/^sflowxdr_setc(struct sflow_xdr *x, uint32_t j)$/;"	f	file:
sflowxdr_skip	.\tests\test-sflow.c	/^sflowxdr_skip(struct sflow_xdr *x, uint32_t q)$/;"	f	file:
sflowxdr_str	.\tests\test-sflow.c	/^sflowxdr_str(const struct sflow_xdr *x)$/;"	f	file:
sh	.\lib\ovsdb-data.h	/^    struct shash sh;            \/* Maps from name to struct ovsdb_symbol *. *\/$/;"	m	struct:ovsdb_symbol_table	typeref:struct:ovsdb_symbol_table::shash
sh1	.\datapath\linux\compat\include\linux\reciprocal_div.h	/^	u8 sh1, sh2;$/;"	m	struct:reciprocal_value
sh2	.\datapath\linux\compat\include\linux\reciprocal_div.h	/^	u8 sh1, sh2;$/;"	m	struct:reciprocal_value
sha	.\datapath\flow.h	/^				u8 sha[ETH_ALEN];	\/* ARP source hardware address. *\/$/;"	m	struct:sw_flow_key::__anon5::__anon6::__anon8
sha	.\python\compat\uuid.py	/^    import sha$/;"	i
sha1_bytes	.\lib\sha1.c	/^sha1_bytes(const void *data, size_t n, uint8_t digest[SHA1_DIGEST_SIZE])$/;"	f
sha1_ctx	.\lib\sha1.h	/^struct sha1_ctx {$/;"	s
sha1_final	.\lib\sha1.c	/^sha1_final(struct sha1_ctx *ctx, uint8_t digest[SHA1_DIGEST_SIZE])$/;"	f
sha1_from_hex	.\lib\sha1.c	/^sha1_from_hex(uint8_t digest[SHA1_DIGEST_SIZE], const char *hex)$/;"	f
sha1_init	.\lib\sha1.c	/^sha1_init(struct sha1_ctx *sha_info)$/;"	f
sha1_to_hex	.\lib\sha1.c	/^sha1_to_hex(const uint8_t digest[SHA1_DIGEST_SIZE],$/;"	f
sha1_update	.\lib\sha1.c	/^sha1_update(struct sha1_ctx *ctx, const void *buffer_, size_t count)$/;"	f
sha1_update_int	.\lib\uuid.c	/^sha1_update_int(struct sha1_ctx *sha1_ctx, uintmax_t x)$/;"	f	file:
sha_transform	.\lib\sha1.c	/^sha_transform(struct sha1_ctx *sha_info)$/;"	f	file:
shash	.\lib\shash.h	/^struct shash {$/;"	s
shash_add	.\lib\shash.c	/^shash_add(struct shash *sh, const char *name, const void *data)$/;"	f
shash_add_assert	.\lib\shash.c	/^shash_add_assert(struct shash *sh, const char *name, const void *data)$/;"	f
shash_add_nocopy	.\lib\shash.c	/^shash_add_nocopy(struct shash *sh, char *name, const void *data)$/;"	f
shash_add_nocopy__	.\lib\shash.c	/^shash_add_nocopy__(struct shash *sh, char *name, const void *data, size_t hash)$/;"	f	file:
shash_add_once	.\lib\shash.c	/^shash_add_once(struct shash *sh, const char *name, const void *data)$/;"	f
shash_clear	.\lib\shash.c	/^shash_clear(struct shash *sh)$/;"	f
shash_clear_free_data	.\lib\shash.c	/^shash_clear_free_data(struct shash *sh)$/;"	f
shash_count	.\lib\shash.c	/^shash_count(const struct shash *shash)$/;"	f
shash_delete	.\lib\shash.c	/^shash_delete(struct shash *sh, struct shash_node *node)$/;"	f
shash_destroy	.\lib\shash.c	/^shash_destroy(struct shash *sh)$/;"	f
shash_destroy_free_data	.\lib\shash.c	/^shash_destroy_free_data(struct shash *sh)$/;"	f
shash_equal_keys	.\lib\shash.c	/^shash_equal_keys(const struct shash *a, const struct shash *b)$/;"	f
shash_find	.\lib\shash.c	/^shash_find(const struct shash *sh, const char *name)$/;"	f
shash_find__	.\lib\shash.c	/^shash_find__(const struct shash *sh, const char *name, size_t name_len,$/;"	f	file:
shash_find_and_delete	.\lib\shash.c	/^shash_find_and_delete(struct shash *sh, const char *name)$/;"	f
shash_find_and_delete_assert	.\lib\shash.c	/^shash_find_and_delete_assert(struct shash *sh, const char *name)$/;"	f
shash_find_data	.\lib\shash.c	/^shash_find_data(const struct shash *sh, const char *name)$/;"	f
shash_find_len	.\lib\shash.c	/^shash_find_len(const struct shash *sh, const char *name, size_t len)$/;"	f
shash_first	.\lib\shash.c	/^shash_first(const struct shash *shash)$/;"	f
shash_init	.\lib\shash.c	/^shash_init(struct shash *sh)$/;"	f
shash_is_empty	.\lib\shash.c	/^shash_is_empty(const struct shash *shash)$/;"	f
shash_moved	.\lib\shash.c	/^shash_moved(struct shash *sh)$/;"	f
shash_node	.\lib\shash.h	/^struct shash_node {$/;"	s
shash_random_node	.\lib\shash.c	/^shash_random_node(struct shash *sh)$/;"	f
shash_replace	.\lib\shash.c	/^shash_replace(struct shash *sh, const char *name, const void *data)$/;"	f
shash_sort	.\lib\shash.c	/^shash_sort(const struct shash *sh)$/;"	f
shash_steal	.\lib\shash.c	/^shash_steal(struct shash *sh, struct shash_node *node)$/;"	f
shash_swap	.\lib\shash.c	/^shash_swap(struct shash *a, struct shash *b)$/;"	f
shorten_name_via_proc	.\lib\socket-util.c	/^shorten_name_via_proc(const char *name, char short_name[MAX_UN_LEN + 1],$/;"	f	file:
shorten_name_via_symlink	.\lib\socket-util.c	/^shorten_name_via_symlink(const char *name, char short_name[MAX_UN_LEN + 1],$/;"	f	file:
should_log_flow_message	.\lib\dpif.c	/^should_log_flow_message(int error)$/;"	f	file:
should_restart	.\lib\daemon-unix.c	/^should_restart(int status)$/;"	f	file:
should_revalidate	.\ofproto\ofproto-dpif-upcall.c	/^should_revalidate(const struct udpif *udpif, uint64_t packets,$/;"	f	file:
should_send_version_bitmap	.\lib\ofp-util.c	/^should_send_version_bitmap(uint32_t allowed_versions)$/;"	f	file:
should_service_stop	.\lib\daemon-unix.c	/^should_service_stop(void)$/;"	f
should_service_stop	.\lib\daemon-windows.c	/^should_service_stop(void)$/;"	f
show_dpif	.\utilities\ovs-dpctl.c	/^show_dpif(struct dpif *dpif)$/;"	f	file:
show_log_verbosity	.\ovsdb\ovsdb-tool.c	/^static int show_log_verbosity;$/;"	v	file:
shuffle	.\tests\test-classifier.c	/^shuffle(unsigned int *p, size_t n)$/;"	f	file:
shuffle	.\tests\test-heap.c	/^shuffle(uint32_t *p, size_t n)$/;"	f	file:
shuffle	.\tests\test-hindex.c	/^shuffle(int *p, size_t n)$/;"	f	file:
shuffle	.\tests\test-hmap.c	/^shuffle(int *p, size_t n)$/;"	f	file:
shuffle	.\tests\test-util.c	/^shuffle(uint64_t *p, size_t n)$/;"	f	file:
shuffle_u32s	.\tests\test-classifier.c	/^shuffle_u32s(uint32_t *p, size_t n)$/;"	f	file:
shutil	.\utilities\ovs-dev.py	/^import shutil$/;"	i
siaddr	.\lib\dhcp.h	/^    ovs_be32 siaddr;            \/* Next server IP address. *\/$/;"	m	struct:dhcp_header
sigchld_handler	.\lib\process.c	/^sigchld_handler(int signr OVS_UNUSED)$/;"	f	file:
sigfigs	.\lib\pcap-file.c	/^    uint32_t sigfigs;        \/* accuracy of timestamps *\/$/;"	m	struct:pcap_hdr	file:
sigint_intercept	.\python\ovstest\util.py	/^def sigint_intercept():$/;"	f
signal	.\python\ovs\daemon.py	/^import signal$/;"	i
signal	.\python\ovs\fatal_signal.py	/^import signal$/;"	i
signal	.\python\ovs\process.py	/^import signal$/;"	i
signal	.\python\ovstest\util.py	/^import signal$/;"	i
signal	.\tests\appctl.py	/^import signal$/;"	i
signal	.\tests\test-daemon.py	/^import signal$/;"	i
signal	.\tests\test-ovsdb.py	/^import signal$/;"	i
signal	.\tests\test-unix-socket.py	/^import signal$/;"	i
signal_fds	.\lib\fatal-signal.c	/^static int signal_fds[2];$/;"	v	file:
signal_name	.\lib\signals.c	/^signal_name(int signum, char *namebuf, size_t bufsize)$/;"	f
signals	.\lib\signals.c	/^VLOG_DEFINE_THIS_MODULE(signals);$/;"	v
simap	.\lib\simap.h	/^struct simap {$/;"	s
simap_add_nocopy__	.\lib\simap.c	/^simap_add_nocopy__(struct simap *simap, char *name, unsigned int data,$/;"	f	file:
simap_clear	.\lib\simap.c	/^simap_clear(struct simap *simap)$/;"	f
simap_contains	.\lib\simap.c	/^simap_contains(const struct simap *simap, const char *name)$/;"	f
simap_count	.\lib\simap.c	/^simap_count(const struct simap *simap)$/;"	f
simap_delete	.\lib\simap.c	/^simap_delete(struct simap *simap, struct simap_node *node)$/;"	f
simap_destroy	.\lib\simap.c	/^simap_destroy(struct simap *simap)$/;"	f
simap_find	.\lib\simap.c	/^simap_find(const struct simap *simap, const char *name)$/;"	f
simap_find__	.\lib\simap.c	/^simap_find__(const struct simap *simap, const char *name, size_t name_len,$/;"	f	file:
simap_find_and_delete	.\lib\simap.c	/^simap_find_and_delete(struct simap *simap, const char *name)$/;"	f
simap_find_len	.\lib\simap.c	/^simap_find_len(const struct simap *simap, const char *name, size_t len)$/;"	f
simap_get	.\lib\simap.c	/^simap_get(const struct simap *simap, const char *name)$/;"	f
simap_increase	.\lib\simap.c	/^simap_increase(struct simap *simap, const char *name, unsigned int amt)$/;"	f
simap_init	.\lib\simap.c	/^simap_init(struct simap *simap)$/;"	f
simap_is_empty	.\lib\simap.c	/^simap_is_empty(const struct simap *simap)$/;"	f
simap_moved	.\lib\simap.c	/^simap_moved(struct simap *simap)$/;"	f
simap_node	.\lib\simap.h	/^struct simap_node {$/;"	s
simap_put	.\lib\simap.c	/^simap_put(struct simap *simap, const char *name, unsigned int data)$/;"	f
simap_sort	.\lib\simap.c	/^simap_sort(const struct simap *simap)$/;"	f
simap_swap	.\lib\simap.c	/^simap_swap(struct simap *a, struct simap *b)$/;"	f
simple_flow_mod	.\ofproto\ofproto.c	/^simple_flow_mod(struct ofproto *ofproto,$/;"	f	file:
simulate	.\tests\test-stp.c	/^simulate(struct test_case *tc, int granularity)$/;"	f	file:
sin6_addr	.\include\sparse\netinet\in.h	/^    struct in6_addr sin6_addr;  \/* IPv6 address *\/$/;"	m	struct:sockaddr_in6	typeref:struct:sockaddr_in6::in6_addr
sin6_family	.\include\sparse\netinet\in.h	/^    sa_family_t sin6_family;$/;"	m	struct:sockaddr_in6
sin6_flowinfo	.\include\sparse\netinet\in.h	/^    uint32_t sin6_flowinfo;     \/* IPv6 flow information *\/$/;"	m	struct:sockaddr_in6
sin6_port	.\include\sparse\netinet\in.h	/^    in_port_t sin6_port;        \/* Transport layer port # *\/$/;"	m	struct:sockaddr_in6
sin6_scope_id	.\include\sparse\netinet\in.h	/^    uint32_t sin6_scope_id;     \/* IPv6 scope-id *\/$/;"	m	struct:sockaddr_in6
sin_addr	.\include\sparse\netinet\in.h	/^    struct in_addr sin_addr;$/;"	m	struct:sockaddr_in	typeref:struct:sockaddr_in::in_addr
sin_family	.\include\sparse\netinet\in.h	/^    sa_family_t sin_family;$/;"	m	struct:sockaddr_in
sin_port	.\include\sparse\netinet\in.h	/^    in_port_t sin_port;$/;"	m	struct:sockaddr_in
single_threaded	.\lib\ovs-thread.c	/^single_threaded(void)$/;"	f
size	.\datapath\linux\compat\include\net\net_namespace.h	/^	size_t size;$/;"	m	struct:rpl_pernet_operations
size	.\lib\byteq.h	/^    unsigned int size;          \/* Number of bytes allocated for 'buffer'. *\/$/;"	m	struct:byteq
size	.\lib\classifier.c	/^    size_t size;           \/* One past last valid array element. *\/$/;"	m	struct:cls_subtable_cache	file:
size	.\lib\dpif-netdev.c	/^    unsigned int size;          \/* Size of 'actions', in bytes. *\/$/;"	m	struct:dp_netdev_actions	file:
size	.\lib\netdev-bsd.c	/^    int size;$/;"	m	struct:pcap_arg	file:
size	.\lib\ovs-thread.h	/^    uint32_t size;            \/* Number of threads to wait. *\/$/;"	m	struct:ovs_barrier
size	.\tests\test-csum.c	/^    size_t size;                \/* Test requires a multiple of 4. *\/$/;"	m	struct:test_case	file:
size	.\tests\test-sha1.c	/^    size_t size;$/;"	m	struct:test_vector	file:
size	.\tests\test-stp.c	/^    size_t size;$/;"	m	struct:bpdu	file:
size_node	.\ofproto\ofproto.c	/^    struct heap_node size_node; \/* In oftable's "eviction_groups_by_size". *\/$/;"	m	struct:eviction_group	typeref:struct:eviction_group::heap_node	file:
sizeof	.\lib\meta-flow.h	/^BUILD_ASSERT_DECL(sizeof(union mf_value) == sizeof (union mf_subvalue));$/;"	v
sizeof_bool	.\lib\vswitch-idl.c	/^enum { sizeof_bool = 1 };$/;"	e	enum:__anon97	file:
sizeof_bool	.\lib\vswitch-idl.c	/^enum { sizeof_bool = sizeof(bool) };$/;"	e	enum:__anon98	file:
sizeof_bool	.\lib\vtep-idl.c	/^enum { sizeof_bool = 1 };$/;"	e	enum:__anon115	file:
sizeof_bool	.\lib\vtep-idl.c	/^enum { sizeof_bool = sizeof(bool) };$/;"	e	enum:__anon116	file:
sizeof_bool	.\tests\idltest.c	/^enum { sizeof_bool = 1 };$/;"	e	enum:__anon150	file:
sizeof_bool	.\tests\idltest.c	/^enum { sizeof_bool = sizeof(bool) };$/;"	e	enum:__anon151	file:
skb_clear_hash	.\datapath\linux\compat\include\linux\skbuff.h	/^static inline void skb_clear_hash(struct sk_buff *skb)$/;"	f
skb_copy_from_linear_data_offset	.\datapath\linux\compat\include\linux\skbuff.h	/^static inline void skb_copy_from_linear_data_offset(const struct sk_buff *skb,$/;"	f
skb_copy_to_linear_data	.\datapath\linux\compat\include\linux\skbuff.h	/^static inline void skb_copy_to_linear_data(struct sk_buff *skb,$/;"	f
skb_copy_to_linear_data_offset	.\datapath\linux\compat\include\linux\skbuff.h	/^static inline void skb_copy_to_linear_data_offset(struct sk_buff *skb,$/;"	f
skb_cow_head	.\datapath\linux\compat\include\linux\skbuff.h	/^static inline int skb_cow_head(struct sk_buff *skb, unsigned int headroom)$/;"	f
skb_dst	.\datapath\linux\compat\include\linux\skbuff.h	/^static inline struct dst_entry *skb_dst(const struct sk_buff *skb)$/;"	f
skb_dst_drop	.\datapath\linux\compat\include\net\dst.h	/^static inline void skb_dst_drop(struct sk_buff *skb)$/;"	f
skb_dst_set	.\datapath\linux\compat\include\linux\skbuff.h	/^static inline void skb_dst_set(struct sk_buff *skb, struct dst_entry *dst)$/;"	f
skb_flow_dissect	.\datapath\linux\compat\flow_dissector.c	/^static bool skb_flow_dissect(const struct sk_buff *skb, struct flow_keys *flow)$/;"	f	file:
skb_flow_get_ports	.\datapath\linux\compat\flow_dissector.c	/^static __be32 skb_flow_get_ports(const struct sk_buff *skb, int thoff, u8 ip_proto)$/;"	f	file:
skb_frag_page	.\datapath\linux\compat\include\linux\skbuff.h	/^static inline struct page *skb_frag_page(const skb_frag_t *frag)$/;"	f
skb_frag_ref	.\datapath\linux\compat\include\linux\skbuff.h	/^static inline void skb_frag_ref(struct sk_buff *skb, int f)$/;"	f
skb_frag_size_set	.\datapath\linux\compat\include\linux\skbuff.h	/^static inline void skb_frag_size_set(skb_frag_t *frag, unsigned int size)$/;"	f
skb_frag_unref	.\datapath\linux\compat\include\linux\skbuff.h	/^static inline void skb_frag_unref(struct sk_buff *skb, int f)$/;"	f
skb_get_hash	.\datapath\linux\compat\include\linux\skbuff.h	/^static inline __u32 skb_get_hash(struct sk_buff *skb)$/;"	f
skb_get_hash	.\datapath\linux\compat\include\linux\skbuff.h	257;"	d
skb_get_hash	.\datapath\linux\compat\include\linux\skbuff.h	274;"	d
skb_gso_segment	.\datapath\linux\compat\include\linux\netdevice.h	68;"	d
skb_gso_segment	.\datapath\linux\compat\netdevice.c	93;"	d	file:
skb_has_frag_list	.\datapath\linux\compat\include\linux\skbuff.h	308;"	d
skb_hash	.\datapath\flow_table.h	/^	u32 skb_hash;$/;"	m	struct:mask_cache_entry
skb_inner_mac_header	.\datapath\linux\compat\gso.h	/^static inline unsigned char *skb_inner_mac_header(const struct sk_buff *skb)$/;"	f
skb_inner_mac_header	.\datapath\linux\compat\gso.h	29;"	d
skb_inner_mac_header	.\datapath\linux\compat\gso.h	43;"	d
skb_inner_mac_offset	.\datapath\linux\compat\gso.h	/^static inline int skb_inner_mac_offset(const struct sk_buff *skb)$/;"	f
skb_inner_mac_offset	.\datapath\linux\compat\gso.h	57;"	d
skb_inner_network_header	.\datapath\linux\compat\gso.h	/^static inline unsigned char *skb_inner_network_header(const struct sk_buff *skb)$/;"	f
skb_inner_network_header	.\datapath\linux\compat\gso.h	20;"	d
skb_inner_network_header	.\datapath\linux\compat\gso.h	23;"	d
skb_inner_network_header	.\datapath\linux\compat\gso.h	37;"	d
skb_inner_network_offset	.\datapath\linux\compat\gso.h	/^static inline int skb_inner_network_offset(const struct sk_buff *skb)$/;"	f
skb_inner_network_offset	.\datapath\linux\compat\gso.h	51;"	d
skb_mac_header	.\datapath\linux\compat\include\linux\skbuff.h	/^static inline unsigned char *skb_mac_header(const struct sk_buff *skb)$/;"	f
skb_mark	.\datapath\flow.h	/^		u32	skb_mark;	\/* SKB mark. *\/$/;"	m	struct:sw_flow_key::__anon1
skb_network_header	.\datapath\linux\compat\include\linux\skbuff.h	/^static inline unsigned char *skb_network_header(const struct sk_buff *skb)$/;"	f
skb_network_offset	.\datapath\linux\compat\include\linux\skbuff.h	/^static inline int skb_network_offset(const struct sk_buff *skb)$/;"	f
skb_orphan_frags	.\datapath\linux\compat\include\linux\skbuff.h	/^static inline int skb_orphan_frags(struct sk_buff *skb, gfp_t gfp_mask)$/;"	f
skb_priorities	.\ofproto\ofproto-dpif-xlate.c	/^    struct hmap skb_priorities;      \/* Map of 'skb_priority_to_dscp's. *\/$/;"	m	struct:xport	typeref:struct:xport::hmap	file:
skb_priority	.\lib\flow.h	/^    uint32_t skb_priority;      \/* Packet priority for QoS. *\/$/;"	m	struct:flow
skb_priority	.\lib\packets.h	/^    uint32_t skb_priority;      \/* Packet priority for QoS. *\/$/;"	m	struct:pkt_metadata
skb_priority	.\ofproto\ofproto-dpif-xlate.c	/^    uint32_t skb_priority;      \/* Priority of this queue (see struct flow). *\/$/;"	m	struct:skb_priority_to_dscp	file:
skb_priority_to_dscp	.\ofproto\ofproto-dpif-xlate.c	/^struct skb_priority_to_dscp {$/;"	s	file:
skb_reset_inner_headers	.\datapath\linux\compat\gso.h	/^static inline void skb_reset_inner_headers(struct sk_buff *skb)$/;"	f
skb_reset_inner_headers	.\datapath\linux\compat\gso.h	63;"	d
skb_reset_mac_header	.\datapath\linux\compat\include\linux\skbuff.h	/^static inline void skb_reset_mac_header(struct sk_buff *skb)$/;"	f
skb_reset_mac_len	.\datapath\linux\compat\include\linux\skbuff.h	/^static inline void skb_reset_mac_len(struct sk_buff *skb)$/;"	f
skb_reset_network_header	.\datapath\linux\compat\include\linux\skbuff.h	/^static inline void skb_reset_network_header(struct sk_buff *skb)$/;"	f
skb_reset_tail_pointer	.\datapath\linux\compat\include\linux\skbuff.h	/^static inline void skb_reset_tail_pointer(struct sk_buff *skb)$/;"	f
skb_reset_transport_header	.\datapath\linux\compat\include\linux\skbuff.h	/^static inline void skb_reset_transport_header(struct sk_buff *skb)$/;"	f
skb_rtable	.\datapath\linux\compat\include\linux\skbuff.h	/^static inline struct rtable *skb_rtable(const struct sk_buff *skb)$/;"	f
skb_set_mac_header	.\datapath\linux\compat\include\linux\skbuff.h	/^static inline void skb_set_mac_header(struct sk_buff *skb, const int offset)$/;"	f
skb_set_network_header	.\datapath\linux\compat\include\linux\skbuff.h	/^static inline void skb_set_network_header(struct sk_buff *skb, const int offset)$/;"	f
skb_set_transport_header	.\datapath\linux\compat\include\linux\skbuff.h	/^static inline void skb_set_transport_header(struct sk_buff *skb,$/;"	f
skb_transport_header	.\datapath\linux\compat\include\linux\skbuff.h	/^static inline unsigned char *skb_transport_header(const struct sk_buff *skb)$/;"	f
skb_transport_offset	.\datapath\linux\compat\include\linux\skbuff.h	/^static inline int skb_transport_offset(const struct sk_buff *skb)$/;"	f
skb_tx_error	.\datapath\linux\compat\include\linux\skbuff.h	/^static inline void skb_tx_error(struct sk_buff *skb)$/;"	f
skb_unclone	.\datapath\linux\compat\include\linux\skbuff.h	/^static inline int skb_unclone(struct sk_buff *skb, gfp_t pri)$/;"	f
skb_warn_if_lro	.\datapath\linux\compat\include\linux\skbuff.h	/^static inline bool skb_warn_if_lro(const struct sk_buff *skb)$/;"	f
skb_zerocopy	.\datapath\linux\compat\include\linux\skbuff.h	290;"	d
skb_zerocopy	.\datapath\linux\compat\skbuff-openvswitch.c	/^skb_zerocopy(struct sk_buff *to, struct sk_buff *from, int len, int hlen)$/;"	f
skb_zerocopy_headlen	.\datapath\linux\compat\skbuff-openvswitch.c	/^skb_zerocopy_headlen(const struct sk_buff *from)$/;"	f
skip	.\lib\sflow_api.h	/^    u_int32_t skip;$/;"	m	struct:_SFLSampler
skip_digits	.\lib\util.c	/^skip_digits(const char *s)$/;"	f	file:
skip_spaces	.\lib\ovsdb-data.c	/^skip_spaces(const char *p)$/;"	f	file:
skip_spaces	.\lib\util.c	/^skip_spaces(const char *s)$/;"	f	file:
skip_wildcards	.\ofproto\ofproto-dpif-xlate.h	/^    bool skip_wildcards;$/;"	m	struct:xlate_in
slave	.\lib\lacp.c	/^struct slave {$/;"	s	file:
slave	.\ofproto\bond.c	/^    struct bond_slave *slave;   \/* Assigned slave, NULL if unassigned. *\/$/;"	m	struct:bond_entry	typeref:struct:bond_entry::bond_slave	file:
slave	.\tests\test-bundle.c	/^struct slave {$/;"	s	file:
slave_async_config	.\ofproto\connmgr.c	/^    uint32_t slave_async_config[OAM_N_TYPES];  \/* slave *\/$/;"	m	struct:ofconn	file:
slave_enabled_cb	.\ofproto\ofproto-dpif-xlate.c	/^slave_enabled_cb(ofp_port_t ofp_port, void *xbridge_)$/;"	f	file:
slave_enabled_cb	.\tests\test-bundle.c	/^slave_enabled_cb(ofp_port_t slave_id, void *aux)$/;"	f	file:
slave_group	.\tests\test-bundle.c	/^struct slave_group {$/;"	s	file:
slave_id	.\tests\test-bundle.c	/^    ofp_port_t slave_id;$/;"	m	struct:slave	file:
slave_lookup	.\tests\test-bundle.c	/^slave_lookup(struct slave_group *sg, ofp_port_t slave_id)$/;"	f	file:
slave_status	.\lib\lacp.c	/^enum slave_status {$/;"	g	file:
slave_type	.\include\openflow\nicira-ext.h	/^    ovs_be32 slave_type;        \/* NXM_OF_IN_PORT. *\/$/;"	m	struct:nx_action_bundle
slaves	.\lib\lacp.c	/^    struct hmap slaves;      \/* Slaves this LACP object controls. *\/$/;"	m	struct:lacp	typeref:struct:lacp::hmap	file:
slaves	.\lib\ofp-actions.h	/^    ofp_port_t slaves[];$/;"	m	struct:ofpact_bundle
slaves	.\ofproto\bond.c	/^    struct hmap slaves;$/;"	m	struct:bond	typeref:struct:bond::hmap	file:
slaves	.\ofproto\ofproto.h	/^    ofp_port_t *slaves;         \/* OpenFlow port numbers for slaves. *\/$/;"	m	struct:ofproto_bundle_settings
slaves	.\tests\test-bundle.c	/^    struct slave slaves[MAX_SLAVES];$/;"	m	struct:slave_group	typeref:struct:slave_group::slave	file:
sll	.\datapath\flow.h	/^				u8 sll[ETH_ALEN];	\/* ND source link layer address. *\/$/;"	m	struct:sw_flow_key::__anon5::__anon9::__anon11
sll_addr	.\include\sparse\netpacket\packet.h	/^    unsigned char sll_addr[8];$/;"	m	struct:sockaddr_ll
sll_family	.\include\sparse\netpacket\packet.h	/^    unsigned short int sll_family;$/;"	m	struct:sockaddr_ll
sll_halen	.\include\sparse\netpacket\packet.h	/^    unsigned char sll_halen;$/;"	m	struct:sockaddr_ll
sll_hatype	.\include\sparse\netpacket\packet.h	/^    unsigned short int sll_hatype;$/;"	m	struct:sockaddr_ll
sll_ifindex	.\include\sparse\netpacket\packet.h	/^    int sll_ifindex;$/;"	m	struct:sockaddr_ll
sll_pkttype	.\include\sparse\netpacket\packet.h	/^    unsigned char sll_pkttype;$/;"	m	struct:sockaddr_ll
sll_protocol	.\include\sparse\netpacket\packet.h	/^    ovs_be16 sll_protocol;$/;"	m	struct:sockaddr_ll
slot_destructor	.\lib\fat-rwlock.c	/^slot_destructor(void *slot_)$/;"	f	file:
slow	.\ofproto\ofproto-dpif-xlate.h	/^    enum slow_path_reason slow; \/* 0 if fast path may be used. *\/$/;"	m	struct:xlate_out	typeref:enum:xlate_out::slow_path_reason
slow_path	.\lib\odp-util.h	/^    } slow_path;$/;"	m	union:user_action_cookie	typeref:struct:user_action_cookie::__anon70
slow_path	.\lib\timeval.c	/^    atomic_bool slow_path;             \/* True if warped or stopped. *\/$/;"	m	struct:clock	file:
slow_path_buf	.\ofproto\ofproto-dpif-upcall.c	/^    uint64_t slow_path_buf[128 \/ 8];$/;"	m	struct:flow_miss	file:
slow_path_reason	.\lib\odp-util.h	/^enum slow_path_reason {$/;"	g
slow_path_reason_to_explanation	.\lib\odp-util.c	/^slow_path_reason_to_explanation(enum slow_path_reason reason)$/;"	f
slow_path_reason_to_string	.\lib\odp-util.c	/^slow_path_reason_to_string(uint32_t reason)$/;"	f	file:
smap	.\lib\smap.h	/^struct smap {$/;"	s
smap_add	.\lib\smap.c	/^smap_add(struct smap *smap, const char *key, const char *value)$/;"	f
smap_add__	.\lib\smap.c	/^smap_add__(struct smap *smap, char *key, void *value, size_t hash)$/;"	f	file:
smap_add_format	.\lib\smap.c	/^smap_add_format(struct smap *smap, const char *key, const char *format, ...)$/;"	f
smap_add_once	.\lib\smap.c	/^smap_add_once(struct smap *smap, const char *key, const char *value)$/;"	f
smap_clear	.\lib\smap.c	/^smap_clear(struct smap *smap)$/;"	f
smap_clone	.\lib\smap.c	/^smap_clone(struct smap *dst, const struct smap *src)$/;"	f
smap_count	.\lib\smap.c	/^smap_count(const struct smap *smap)$/;"	f
smap_destroy	.\lib\smap.c	/^smap_destroy(struct smap *smap)$/;"	f
smap_find__	.\lib\smap.c	/^smap_find__(const struct smap *smap, const char *key, size_t key_len,$/;"	f	file:
smap_from_json	.\lib\smap.c	/^smap_from_json(struct smap *smap, const struct json *json)$/;"	f
smap_get	.\lib\smap.c	/^smap_get(const struct smap *smap, const char *key)$/;"	f
smap_get_bool	.\lib\smap.c	/^smap_get_bool(const struct smap *smap, const char *key, bool def)$/;"	f
smap_get_int	.\lib\smap.c	/^smap_get_int(const struct smap *smap, const char *key, int def)$/;"	f
smap_get_node	.\lib\smap.c	/^smap_get_node(const struct smap *smap, const char *key)$/;"	f
smap_init	.\lib\smap.c	/^smap_init(struct smap *smap)$/;"	f
smap_is_empty	.\lib\smap.c	/^smap_is_empty(const struct smap *smap)$/;"	f
smap_node	.\lib\smap.h	/^struct smap_node {$/;"	s
smap_remove	.\lib\smap.c	/^smap_remove(struct smap *smap, const char *key)$/;"	f
smap_remove_node	.\lib\smap.c	/^smap_remove_node(struct smap *smap, struct smap_node *node)$/;"	f
smap_replace	.\lib\smap.c	/^smap_replace(struct smap *smap, const char *key, const char *value)$/;"	f
smap_sort	.\lib\smap.c	/^smap_sort(const struct smap *smap)$/;"	f
smap_steal	.\lib\smap.c	/^smap_steal(struct smap *smap, struct smap_node *node,$/;"	f
smap_to_json	.\lib\smap.c	/^smap_to_json(const struct smap *smap)$/;"	f
sname	.\lib\dhcp.h	/^    char sname[64];             \/* Optional server host name. *\/$/;"	m	struct:dhcp_header
snaplen	.\lib\pcap-file.c	/^    uint32_t snaplen;        \/* max length of captured packets *\/$/;"	m	struct:pcap_hdr	file:
snd_portid	.\datapath\linux\compat\include\net\genetlink.h	16;"	d
snoop_preference	.\ofproto\connmgr.c	/^snoop_preference(const struct ofconn *ofconn)$/;"	f	file:
snoops	.\ofproto\connmgr.c	/^    struct pvconn **snoops;$/;"	m	struct:connmgr	typeref:struct:connmgr::pvconn	file:
snprintf	.\lib\stdio.c	23;"	d	file:
sock	.\datapath\linux\compat\include\net\vxlan.h	/^	struct socket	 *sock;$/;"	m	struct:vxlan_sock	typeref:struct:vxlan_sock::socket
sock	.\lib\dpif-linux.c	/^    struct nl_sock *sock;       \/* Netlink socket. *\/$/;"	m	struct:dpif_channel	typeref:struct:dpif_channel::nl_sock	file:
sock	.\lib\netlink-socket.h	/^    struct nl_sock *sock;       \/* Socket being dumped. *\/$/;"	m	struct:nl_dump	typeref:struct:nl_dump::nl_sock
sock_errno	.\lib\socket-util.h	/^static inline int sock_errno(void)$/;"	f
sock_strerror	.\lib\socket-util.c	/^sock_strerror(int error)$/;"	f
sockaddr	.\include\sparse\sys\socket.h	/^struct sockaddr {$/;"	s
sockaddr_in	.\include\sparse\netinet\in.h	/^struct sockaddr_in {$/;"	s
sockaddr_in6	.\include\sparse\netinet\in.h	/^struct sockaddr_in6 {$/;"	s
sockaddr_ll	.\include\sparse\netpacket\packet.h	/^struct sockaddr_ll$/;"	s
sockaddr_nl	.\lib\netlink-protocol.h	/^struct sockaddr_nl {$/;"	s
sockaddr_storage	.\include\sparse\sys\socket.h	/^struct sockaddr_storage {$/;"	s
socket	.\python\compat\uuid.py	/^    import socket$/;"	i
socket	.\python\ovs\poller.py	/^import socket$/;"	i
socket	.\python\ovs\socket_util.py	/^import socket$/;"	i
socket	.\python\ovs\stream.py	/^import socket$/;"	i
socket	.\python\ovs\vlog.py	/^import socket$/;"	i
socket	.\python\ovstest\args.py	/^import socket$/;"	i
socket	.\python\ovstest\util.py	/^import socket$/;"	i
socket	.\tests\test-unix-socket.py	/^import socket$/;"	i
socket	.\xenserver\usr_lib_xsconsole_plugins-base_XSFeatureVSwitch.py	/^import socket$/;"	i
socket_id	.\lib\netdev-dpdk.c	/^    int socket_id;$/;"	m	struct:dpdk_mp	file:
socket_id	.\lib\netdev-dpdk.c	/^    int socket_id;$/;"	m	struct:netdev_dpdk	file:
socket_name_from_target	.\python\ovs\unixctl\__init__.py	/^def socket_name_from_target(target):$/;"	f
socket_util	.\lib\socket-util.c	/^VLOG_DEFINE_THIS_MODULE(socket_util);$/;"	v
socket_util	.\python\ovs\daemon.py	/^import ovs.socket_util$/;"	i
socket_util	.\python\ovs\db\data.py	/^import ovs.socket_util$/;"	i
socket_util	.\python\ovs\stream.py	/^import ovs.socket_util$/;"	i
socket_util	.\tests\test-unix-socket.py	/^import ovs.socket_util$/;"	i
socklen_t	.\include\sparse\sys\socket.h	/^typedef __socklen_t socklen_t;$/;"	t
socks	.\lib\netlink-socket.c	/^    struct nl_sock *socks[16];$/;"	m	struct:nl_pool	typeref:struct:nl_pool::nl_sock	file:
solicit_echo_nonce	.\datapath\vport-lisp.c	/^	__u8 solicit_echo_nonce:1;$/;"	m	struct:lisphdr	file:
sort	.\lib\sort.c	/^sort(size_t count,$/;"	f
sort_criterion	.\utilities\ovs-ofctl.c	/^struct sort_criterion {$/;"	s	file:
sort_order	.\utilities\ovs-ofctl.c	/^enum sort_order { SORT_ASC, SORT_DESC };$/;"	g	file:
sort_output_actions	.\utilities\ovs-dpctl.c	/^sort_output_actions(struct nlattr *actions, size_t length)$/;"	f	file:
sort_output_actions__	.\utilities\ovs-dpctl.c	/^sort_output_actions__(struct nlattr *first, struct nlattr *end)$/;"	f	file:
sort_set	.\tests\uuidfilt.pl	/^sub sort_set {$/;"	s
source	.\lib\ofpbuf.h	/^    enum ofpbuf_source source;  \/* Source of memory allocated as 'base'. *\/$/;"	m	struct:ofpbuf	typeref:enum:ofpbuf::ofpbuf_source
source_id	.\lib\sflow.h	/^    u_int32_t source_id;            \/* fsSourceId *\/$/;"	m	struct:_SFLFlow_sample
source_id	.\lib\sflow.h	/^    u_int32_t source_id;          \/* fsSourceId *\/$/;"	m	struct:_SFLCounters_sample
specs	.\lib\ofp-actions.h	/^    struct ofpact_learn_spec specs[];$/;"	m	struct:ofpact_learn	typeref:struct:ofpact_learn::ofpact_learn_spec
srandom	.\include\windows\windefs.h	42;"	d
src	.\datapath\flow.h	/^				__be32 src;	\/* IP source address. *\/$/;"	m	struct:sw_flow_key::__anon5::__anon6::__anon7
src	.\datapath\flow.h	/^				struct in6_addr src;	\/* IPv6 source address. *\/$/;"	m	struct:sw_flow_key::__anon5::__anon9::__anon10	typeref:struct:sw_flow_key::__anon5::__anon9::__anon10::in6_addr
src	.\datapath\flow.h	/^		__be16 src;		\/* TCP\/UDP\/SCTP source port. *\/$/;"	m	struct:sw_flow_key::__anon4
src	.\datapath\flow.h	/^		u8     src[ETH_ALEN];	\/* Ethernet source address. *\/$/;"	m	struct:sw_flow_key::__anon2
src	.\datapath\linux\compat\include\net\flow_keys.h	/^	__be32 src;$/;"	m	struct:flow_keys
src	.\include\openflow\nicira-ext.h	/^    ovs_be32 src;                   \/* Source register. *\/$/;"	m	struct:nx_action_reg_move
src	.\include\openflow\nicira-ext.h	/^    ovs_be32 src;               \/* Source. *\/$/;"	m	struct:nx_action_output_reg
src	.\lib\ofp-actions.h	/^    struct mf_subfield src;     \/* NX_LEARN_SRC_FIELD only. *\/$/;"	m	struct:ofpact_learn_spec	typeref:struct:ofpact_learn_spec::mf_subfield
src	.\lib\ofp-actions.h	/^    struct mf_subfield src;$/;"	m	struct:ofpact_output_reg	typeref:struct:ofpact_output_reg::mf_subfield
src	.\lib\ofp-actions.h	/^    struct mf_subfield src;$/;"	m	struct:ofpact_reg_move	typeref:struct:ofpact_reg_move::mf_subfield
src	.\lib\ovsdb-idl.c	/^    struct ovsdb_idl_row *src;  \/* Source row. *\/$/;"	m	struct:ovsdb_idl_arc	typeref:struct:ovsdb_idl_arc::ovsdb_idl_row	file:
src	.\lib\sflow.h	/^    SFLAddress src;    \/* Source address *\/$/;"	m	struct:_SFLExtended_nat
src	.\ovsdb\row.h	/^    struct ovsdb_row *src;      \/* Source row. *\/$/;"	m	struct:ovsdb_weak_ref	typeref:struct:ovsdb_weak_ref::ovsdb_row
src_addr	.\lib\netflow.h	/^    ovs_be32 src_addr;             \/* Source IP address. *\/$/;"	m	struct:netflow_v5_record
src_arcs	.\lib\ovsdb-idl-provider.h	/^    struct list src_arcs;       \/* Forward arcs (ovsdb_idl_arc.src_node). *\/$/;"	m	struct:ovsdb_idl_row	typeref:struct:ovsdb_idl_row::list
src_as	.\lib\netflow.h	/^    ovs_be16 src_as;               \/* Source AS ID.  Set to 0. *\/$/;"	m	struct:netflow_v5_record
src_as	.\lib\sflow.h	/^    u_int32_t src_as;                         \/* AS number of source (origin) *\/$/;"	m	struct:_SFLExtended_gateway
src_charset	.\lib\sflow.h	/^    u_int32_t src_charset;  \/* MIBEnum value of character set used to encode a string - See RFC 2978$/;"	m	struct:_SFLExtended_user
src_imm	.\lib\ofp-actions.h	/^    union mf_subvalue src_imm;  \/* NX_LEARN_SRC_IMMEDIATE only. *\/$/;"	m	struct:ofpact_learn_spec	typeref:union:ofpact_learn_spec::mf_subvalue
src_ip	.\lib\sflow.h	/^    SFLIPv4   src_ip;      \/* Source IP Address *\/$/;"	m	struct:_SFLSampled_ipv4
src_ip	.\lib\sflow.h	/^    SFLIPv6   src_ip;       \/* Source IP Address *\/$/;"	m	struct:_SFLSampled_ipv6
src_mac	.\lib\sflow.h	/^    u_int8_t src_mac[8];    \/* 6 bytes + 2 pad *\/$/;"	m	struct:_SFLSampled_ethernet
src_mac	.\lib\vtep-idl.h	/^	char *src_mac;	\/* Always nonnull. *\/$/;"	m	struct:vteprec_arp_sources_local
src_mac	.\lib\vtep-idl.h	/^	char *src_mac;	\/* Always nonnull. *\/$/;"	m	struct:vteprec_arp_sources_remote
src_mask	.\lib\netflow.h	/^    uint8_t  src_mask;             \/* Source mask bits.  Set to 0. *\/$/;"	m	struct:netflow_v5_record
src_mask	.\lib\sflow.h	/^    u_int32_t src_mask;               \/* Source address prefix mask bits *\/$/;"	m	struct:_SFLExtended_router
src_mirrors	.\ofproto\ofproto-dpif-mirror.c	/^    mirror_mask_t src_mirrors;  \/* Mirrors triggered when packet received. *\/$/;"	m	struct:mbundle	file:
src_node	.\lib\ovsdb-idl.c	/^    struct list src_node;       \/* In src->src_arcs list. *\/$/;"	m	struct:ovsdb_idl_arc	typeref:struct:ovsdb_idl_arc::list	file:
src_node	.\ovsdb\row.h	/^    struct list src_node;       \/* In src->src_refs list. *\/$/;"	m	struct:ovsdb_weak_ref	typeref:struct:ovsdb_weak_ref::list
src_ofs	.\include\openflow\nicira-ext.h	/^    ovs_be16 src_ofs;               \/* Starting bit offset in source. *\/$/;"	m	struct:nx_action_reg_move
src_peer_as	.\lib\sflow.h	/^    u_int32_t src_peer_as;                    \/* AS number of source peer *\/$/;"	m	struct:_SFLExtended_gateway
src_port	.\lib\netflow.h	/^    ovs_be16 src_port;$/;"	m	struct:netflow_v5_record
src_port	.\lib\sflow.h	/^    u_int32_t src_port;     \/* TCP\/UDP source port number or equivalent *\/$/;"	m	struct:_SFLSampled_ipv6
src_port	.\lib\sflow.h	/^    u_int32_t src_port;    \/* TCP\/UDP source port number or equivalent *\/$/;"	m	struct:_SFLSampled_ipv4
src_priority	.\lib\sflow.h	/^    u_int32_t src_priority;   \/* The 802.1p priority *\/$/;"	m	struct:_SFLExtended_switch
src_refs	.\ovsdb\row.h	/^    struct list src_refs;       \/* Weak references from this row. *\/$/;"	m	struct:ovsdb_row	typeref:struct:ovsdb_row::list
src_type	.\lib\ofp-actions.h	/^    int src_type;               \/* One of NX_LEARN_SRC_*. *\/$/;"	m	struct:ofpact_learn_spec
src_user	.\lib\sflow.h	/^    SFLString src_user;$/;"	m	struct:_SFLExtended_user
src_vlan	.\lib\sflow.h	/^    u_int32_t src_vlan;       \/* The 802.1Q VLAN id of incomming frame *\/$/;"	m	struct:_SFLExtended_switch
src_vlans	.\ofproto\ofproto.h	/^    unsigned long *src_vlans;   \/* vlan_bitmap, NULL selects all VLANs. *\/$/;"	m	struct:ofproto_mirror_settings
srcdir	.\tests\automake.mk	/^	srcdir='$(srcdir)' $(SHELL) $(srcdir)\/tests\/run-oftest$/;"	m
srcdir	.\tests\automake.mk	/^	srcdir='$(srcdir)' $(SHELL) $(srcdir)\/tests\/run-ryu$/;"	m
srcs	.\ofproto\ofproto-dpif-mirror.c	/^    struct hmapx srcs;          \/* Contains "struct mbundle*"s. *\/$/;"	m	struct:mirror	typeref:struct:mirror::hmapx	file:
srcs	.\ofproto\ofproto.h	/^    void **srcs;                \/* A set of registered ofbundle handles. *\/$/;"	m	struct:ofproto_mirror_settings
ss_family	.\include\sparse\sys\socket.h	/^    sa_family_t ss_family;$/;"	m	struct:sockaddr_storage
ss_format_address	.\lib\socket-util.c	/^ss_format_address(const struct sockaddr_storage *ss,$/;"	f
ss_get_port	.\lib\socket-util.c	/^ss_get_port(const struct sockaddr_storage *ss)$/;"	f
ss_length	.\lib\socket-util.c	/^ss_length(const struct sockaddr_storage *ss)$/;"	f
sset	.\lib\sset.h	/^struct sset {$/;"	s
sset_add	.\lib\sset.c	/^sset_add(struct sset *set, const char *name)$/;"	f
sset_add__	.\lib\sset.c	/^sset_add__(struct sset *set, const char *name, size_t length, size_t hash)$/;"	f	file:
sset_add_and_free	.\lib\sset.c	/^sset_add_and_free(struct sset *set, char *name)$/;"	f
sset_add_array	.\lib\sset.c	/^sset_add_array(struct sset *set, char **names, size_t n)$/;"	f
sset_add_assert	.\lib\sset.c	/^sset_add_assert(struct sset *set, const char *name)$/;"	f
sset_at_position	.\lib\sset.c	/^sset_at_position(const struct sset *set, uint32_t *bucketp, uint32_t *offsetp)$/;"	f
sset_clear	.\lib\sset.c	/^sset_clear(struct sset *set)$/;"	f
sset_clone	.\lib\sset.c	/^sset_clone(struct sset *set, const struct sset *orig)$/;"	f
sset_contains	.\lib\sset.c	/^sset_contains(const struct sset *set, const char *name)$/;"	f
sset_count	.\lib\sset.c	/^sset_count(const struct sset *set)$/;"	f
sset_delete	.\lib\sset.c	/^sset_delete(struct sset *set, struct sset_node *node)$/;"	f
sset_destroy	.\lib\sset.c	/^sset_destroy(struct sset *set)$/;"	f
sset_equals	.\lib\sset.c	/^sset_equals(const struct sset *a, const struct sset *b)$/;"	f
sset_find	.\lib\sset.c	/^sset_find(const struct sset *set, const char *name)$/;"	f
sset_find__	.\lib\sset.c	/^sset_find__(const struct sset *set, const char *name, size_t hash)$/;"	f	file:
sset_find_and_delete	.\lib\sset.c	/^sset_find_and_delete(struct sset *set, const char *name)$/;"	f
sset_find_and_delete_assert	.\lib\sset.c	/^sset_find_and_delete_assert(struct sset *set, const char *name)$/;"	f
sset_from_json	.\ovsdb\ovsdb-server.c	/^sset_from_json(struct sset *sset, const struct json *array)$/;"	f	file:
sset_init	.\lib\sset.c	/^sset_init(struct sset *set)$/;"	f
sset_is_empty	.\lib\sset.c	/^sset_is_empty(const struct sset *set)$/;"	f
sset_moved	.\lib\sset.c	/^sset_moved(struct sset *set)$/;"	f
sset_node	.\lib\sset.h	/^struct sset_node {$/;"	s
sset_pop	.\lib\sset.c	/^sset_pop(struct sset *set)$/;"	f
sset_sort	.\lib\sset.c	/^sset_sort(const struct sset *set)$/;"	f
sset_swap	.\lib\sset.c	/^sset_swap(struct sset *a, struct sset *b)$/;"	f
sset_to_json	.\ovsdb\ovsdb-server.c	/^sset_to_json(const struct sset *sset)$/;"	f	file:
ssize_t	.\include\windows\windefs.h	32;"	d
ssl	.\lib\stream-ssl.c	/^    SSL *ssl;$/;"	m	struct:ssl_stream	file:
ssl	.\lib\vswitch-idl.h	/^	struct ovsrec_ssl *ssl;$/;"	m	struct:ovsrec_open_vswitch	typeref:struct:ovsrec_open_vswitch::ovsrec_ssl
ssl_alert_description_to_string	.\lib\stream-ssl.c	/^ssl_alert_description_to_string(uint8_t type)$/;"	f	file:
ssl_alert_level_to_string	.\lib\stream-ssl.c	/^ssl_alert_level_to_string(uint8_t type)$/;"	f	file:
ssl_clear_txbuf	.\lib\stream-ssl.c	/^ssl_clear_txbuf(struct ssl_stream *sslv)$/;"	f	file:
ssl_close	.\lib\stream-ssl.c	/^ssl_close(struct stream *stream)$/;"	f	file:
ssl_config_file	.\lib\stream-ssl.c	/^struct ssl_config_file {$/;"	s	file:
ssl_connect	.\lib\stream-ssl.c	/^ssl_connect(struct stream *stream)$/;"	f	file:
ssl_do_tx	.\lib\stream-ssl.c	/^ssl_do_tx(struct stream *stream)$/;"	f	file:
ssl_handshake_type_to_string	.\lib\stream-ssl.c	/^ssl_handshake_type_to_string(uint8_t type)$/;"	f	file:
ssl_init	.\lib\stream-ssl.c	/^ssl_init(void)$/;"	f	file:
ssl_open	.\lib\stream-ssl.c	/^ssl_open(const char *name, char *suffix, struct stream **streamp, uint8_t dscp)$/;"	f	file:
ssl_protocol_cb	.\lib\stream-ssl.c	/^ssl_protocol_cb(int write_p, int version OVS_UNUSED, int content_type,$/;"	f	file:
ssl_recv	.\lib\stream-ssl.c	/^ssl_recv(struct stream *stream, void *buffer, size_t n)$/;"	f	file:
ssl_run	.\lib\stream-ssl.c	/^ssl_run(struct stream *stream)$/;"	f	file:
ssl_run_wait	.\lib\stream-ssl.c	/^ssl_run_wait(struct stream *stream)$/;"	f	file:
ssl_send	.\lib\stream-ssl.c	/^ssl_send(struct stream *stream, const void *buffer, size_t n)$/;"	f	file:
ssl_state	.\lib\stream-ssl.c	/^enum ssl_state {$/;"	g	file:
ssl_stream	.\lib\stream-ssl.c	/^struct ssl_stream$/;"	s	file:
ssl_stream_cast	.\lib\stream-ssl.c	/^ssl_stream_cast(struct stream *stream)$/;"	f	file:
ssl_stream_class	.\lib\stream-ssl.c	/^const struct stream_class ssl_stream_class = {$/;"	v	typeref:struct:stream_class
ssl_vconn_class	.\lib\vconn-stream.c	/^const struct vconn_class ssl_vconn_class = STREAM_INIT("ssl");$/;"	v	typeref:struct:vconn_class
ssl_wait	.\lib\stream-ssl.c	/^ssl_wait(struct stream *stream, enum stream_wait_type wait)$/;"	f	file:
ssl_wants_io	.\lib\stream-ssl.c	/^ssl_wants_io(int ssl_error)$/;"	f	file:
stack	.\lib\json.c	/^    struct json_parser_node *stack;$/;"	m	struct:json_parser	typeref:struct:json_parser::json_parser_node	file:
stack	.\lib\ofp-actions.c	/^    struct nx_action_stack stack;$/;"	m	union:ofp_action	typeref:struct:ofp_action::nx_action_stack	file:
stack	.\lib\sflow.h	/^    SFLVlanStack stack;  \/* List of stripped 802.1Q TPID\/TCI layers. Each$/;"	m	struct:_SFLExtended_vlan_tunnel
stack	.\lib\sflow.h	/^    u_int32_t *stack; \/* first entry is top of stack - see RFC 3032 for encoding *\/$/;"	m	struct:_SFLLabelStack
stack	.\ofproto\ofproto-dpif-xlate.c	/^    struct ofpbuf stack;$/;"	m	struct:xlate_ctx	typeref:struct:xlate_ctx::ofpbuf	file:
stack_action_from_openflow__	.\lib\nx-match.c	/^stack_action_from_openflow__(const struct nx_action_stack *nasp,$/;"	f	file:
stack_cost	.\datapath\actions.c	/^	u8 stack_cost;		\/* loop stack cost. *\/$/;"	m	struct:loop_counter	file:
start	.\datapath\flow.h	/^	unsigned short int start;$/;"	m	struct:sw_flow_key_range
start	.\lib\classifier.c	/^    uint8_t start;$/;"	m	struct:range	file:
start	.\lib\ovs-thread.c	/^    void *(*start)(void *);$/;"	m	struct:ovsthread_aux	file:
startProtocol	.\python\ovstest\udp.py	/^    def startProtocol(self):$/;"	m	class:UdpSender
start_local_server	.\python\ovstest\util.py	/^def start_local_server(port):$/;"	f
start_process	.\python\ovstest\util.py	/^def start_process(args):$/;"	f
start_queue_dump	.\lib\netdev-linux.c	/^start_queue_dump(const struct netdev *netdev, struct queue_dump_state *state)$/;"	f	file:
start_rpc_server	.\python\ovstest\rpcserver.py	/^def start_rpc_server(port):$/;"	f
start_section	.\python\compat\argparse.py	/^    def start_section(self, heading):$/;"	m	class:HelpFormatter
stat	.\lib\ofp-msgs.c	/^    uint16_t stat;              \/* From ofp10_stats_msg or ofp11_stats_msg. *\/$/;"	m	struct:ofphdrs	file:
state	.\include\openflow\openflow-1.0.h	/^    ovs_be32 state;         \/* Bitmap of OFPPS_* and OFPPS10_* flags. *\/$/;"	m	struct:ofp10_phy_port
state	.\include\openflow\openflow-1.1.h	/^    ovs_be32 state;         \/* Bitmap of OFPPS_* and OFPPS11_* flags. *\/$/;"	m	struct:ofp11_port
state	.\include\openflow\openflow-1.4.h	/^    ovs_be32 state;         \/* Bitmap of OFPPS_* flags. *\/$/;"	m	struct:ofp14_port
state	.\lib\bfd.c	/^    enum state state;             \/* bfd.SessionState. *\/$/;"	m	struct:bfd	typeref:enum:bfd::state	file:
state	.\lib\bfd.c	/^enum state {$/;"	g	file:
state	.\lib\dpif.h	/^    void *state;$/;"	m	struct:dpif_port_dump
state	.\lib\learning-switch.c	/^    enum lswitch_state state;$/;"	m	struct:lswitch	typeref:enum:lswitch::lswitch_state	file:
state	.\lib\netdev.h	/^    void *state;$/;"	m	struct:netdev_queue_dump
state	.\lib\ofp-util.h	/^    enum ofputil_port_state state;$/;"	m	struct:ofputil_phy_port	typeref:enum:ofputil_phy_port::ofputil_port_state
state	.\lib\rconn.c	/^    enum state state;$/;"	m	struct:rconn	typeref:enum:rconn::state	file:
state	.\lib\rconn.c	/^enum state {$/;"	g	file:
state	.\lib\reconnect.c	/^    enum state state;$/;"	m	struct:reconnect	typeref:enum:reconnect::state	file:
state	.\lib\reconnect.c	/^enum state {$/;"	g	file:
state	.\lib\reconnect.h	/^    const char *state;            \/* FSM state. *\/$/;"	m	struct:reconnect_stats
state	.\lib\stp.c	/^    enum stp_state state;           \/* 8.5.5.2: Current state. *\/$/;"	m	struct:stp_port	typeref:enum:stp_port::stp_state	file:
state	.\lib\stream-provider.h	/^    int state;$/;"	m	struct:stream
state	.\lib\stream-ssl.c	/^    enum ssl_state state;$/;"	m	struct:ssl_stream	typeref:enum:ssl_stream::ssl_state	file:
state	.\lib\vconn-provider.h	/^    int state;$/;"	m	struct:vconn
state	.\ofproto\bundles.c	/^    enum bundle_state state;$/;"	m	struct:ofp_bundle	typeref:enum:ofp_bundle::bundle_state	file:
state	.\ofproto\ofproto-dpif-xlate.c	/^    enum ofputil_port_state state;   \/* OpenFlow port state. *\/$/;"	m	struct:xport	typeref:enum:xport::ofputil_port_state	file:
state	.\ofproto\ofproto-provider.h	/^    int state;$/;"	m	struct:ofproto
state	.\ofproto\ofproto.h	/^    enum stp_state state;$/;"	m	struct:ofproto_port_stp_status	typeref:enum:ofproto_port_stp_status::stp_state
state	.\ofproto\ofproto.h	/^    void *state;$/;"	m	struct:ofproto_port_dump
state	.\ovsdb\jsonrpc-server.h	/^    const char *state;$/;"	m	struct:ovsdb_jsonrpc_remote_status
state_changed	.\lib\stp.c	/^    bool state_changed;$/;"	m	struct:stp_port	file:
state_elapsed	.\lib\reconnect.h	/^    unsigned int state_elapsed;   \/* Time since FSM state entered. *\/$/;"	m	struct:reconnect_stats
state_entered	.\lib\rconn.c	/^    time_t state_entered;$/;"	m	struct:rconn	file:
state_entered	.\lib\reconnect.c	/^    long long int state_entered;$/;"	m	struct:reconnect	file:
state_name	.\lib\rconn.c	/^state_name(enum state state)$/;"	f	file:
static_routes	.\lib\vtep-idl.h	/^	struct smap static_routes;$/;"	m	struct:vteprec_logical_router	typeref:struct:vteprec_logical_router::smap
statistics	.\lib\vswitch-idl.h	/^	struct smap statistics;$/;"	m	struct:ovsrec_open_vswitch	typeref:struct:ovsrec_open_vswitch::smap
stats	.\datapath\flow.h	/^	struct flow_stats __rcu *stats[]; \/* One for each NUMA node.  First one$/;"	m	struct:sw_flow	typeref:struct:sw_flow::__rcu
stats	.\lib\dpif-linux.c	/^    const struct ovs_flow_stats *stats; \/* OVS_FLOW_ATTR_STATS. *\/$/;"	m	struct:dpif_linux_flow	typeref:struct:dpif_linux_flow::ovs_flow_stats	file:
stats	.\lib\dpif-linux.c	/^    struct dpif_flow_stats stats;$/;"	m	struct:dpif_linux_flow_state	typeref:struct:dpif_linux_flow_state::dpif_flow_stats	file:
stats	.\lib\dpif-linux.c	/^    struct ovs_dp_stats stats;         \/* OVS_DP_ATTR_STATS. *\/$/;"	m	struct:dpif_linux_dp	typeref:struct:dpif_linux_dp::ovs_dp_stats	file:
stats	.\lib\dpif-linux.h	/^    const struct ovs_vport_stats *stats;   \/* OVS_VPORT_ATTR_STATS. *\/$/;"	m	struct:dpif_linux_vport	typeref:struct:dpif_linux_vport::ovs_vport_stats
stats	.\lib\dpif-netdev.c	/^    struct dpif_flow_stats stats;$/;"	m	struct:dp_netdev_flow_state	typeref:struct:dp_netdev_flow_state::dpif_flow_stats	file:
stats	.\lib\dpif-netdev.c	/^    struct ovsthread_stats stats; \/* Contains "struct dp_netdev_flow_stats". *\/$/;"	m	struct:dp_netdev_flow	typeref:struct:dp_netdev_flow::ovsthread_stats	file:
stats	.\lib\dpif-netdev.c	/^    struct ovsthread_stats stats; \/* Contains 'struct dp_netdev_stats *'. *\/$/;"	m	struct:dp_netdev	typeref:struct:dp_netdev::ovsthread_stats	file:
stats	.\lib\dpif.h	/^    struct dpif_flow_stats *stats;  \/* Optional flow statistics. *\/$/;"	m	struct:dpif_flow_del	typeref:struct:dpif_flow_del::dpif_flow_stats
stats	.\lib\dpif.h	/^    struct dpif_flow_stats *stats;  \/* Optional flow statistics. *\/$/;"	m	struct:dpif_flow_put	typeref:struct:dpif_flow_put::dpif_flow_stats
stats	.\lib\netdev-dpdk.c	/^    struct netdev_stats stats;$/;"	m	struct:netdev_dpdk	typeref:struct:netdev_dpdk::netdev_stats	file:
stats	.\lib\netdev-vport.c	/^    struct netdev_stats stats;$/;"	m	struct:netdev_vport	typeref:struct:netdev_vport::netdev_stats	file:
stats	.\lib\ofp-util.h	/^    struct netdev_stats stats;$/;"	m	struct:ofputil_port_stats	typeref:struct:ofputil_port_stats::netdev_stats
stats	.\ofproto\ofproto-dpif-upcall.c	/^    struct dpif_flow_stats stats; \/* Stats for 'op'. *\/$/;"	m	struct:dump_op	typeref:struct:dump_op::dpif_flow_stats	file:
stats	.\ofproto\ofproto-dpif-upcall.c	/^    struct dpif_flow_stats stats;$/;"	m	struct:flow_miss	typeref:struct:flow_miss::dpif_flow_stats	file:
stats_last_writer	.\datapath\flow.h	/^	int stats_last_writer;		\/* NUMA-node id of the last writer on$/;"	m	struct:sw_flow
stats_lock	.\datapath\vport.h	/^	spinlock_t stats_lock;$/;"	m	struct:vport
stats_mutex	.\ofproto\ofproto-dpif.c	/^    struct ovs_mutex stats_mutex;$/;"	m	struct:group_dpif	typeref:struct:group_dpif::ovs_mutex	file:
stats_mutex	.\ofproto\ofproto-dpif.c	/^    struct ovs_mutex stats_mutex;$/;"	m	struct:ofproto_dpif	typeref:struct:ofproto_dpif::ovs_mutex	file:
stats_mutex	.\ofproto\ofproto-dpif.c	/^    struct ovs_mutex stats_mutex;$/;"	m	struct:rule_dpif	typeref:struct:rule_dpif::ovs_mutex	file:
stats_offset	.\lib\netdev-dpdk.c	/^    struct netdev_stats stats_offset;$/;"	m	struct:netdev_dpdk	typeref:struct:netdev_dpdk::netdev_stats	file:
stats_percpu	.\datapath\datapath.h	/^	struct dp_stats_percpu __percpu *stats_percpu;$/;"	m	struct:datapath	typeref:struct:datapath::__percpu
stats_timer	.\vswitchd\bridge.c	/^static long long int stats_timer = LLONG_MIN;$/;"	v	file:
stats_timer_interval	.\vswitchd\bridge.c	/^static int stats_timer_interval;$/;"	v	file:
stats_txn	.\vswitchd\bridge.c	/^static struct ovsdb_idl_txn *stats_txn;$/;"	v	typeref:struct:ovsdb_idl_txn	file:
status	.\lib\dpif-linux.c	/^    atomic_int status;$/;"	m	struct:dpif_linux_flow_iter	file:
status	.\lib\dpif-netdev.c	/^    int status;$/;"	m	struct:dp_netdev_flow_iter	file:
status	.\lib\jsonrpc.c	/^    int status;$/;"	m	struct:jsonrpc	file:
status	.\lib\lacp.c	/^    enum slave_status status;     \/* Slave status. *\/$/;"	m	struct:slave	typeref:enum:slave::slave_status	file:
status	.\lib\netlink-socket.h	/^    atomic_uint status;         \/* Low bit set if we read final message.$/;"	m	struct:nl_dump
status	.\lib\ovsdb-idl.c	/^    enum ovsdb_idl_txn_status status;$/;"	m	struct:ovsdb_idl_txn	typeref:enum:ovsdb_idl_txn::ovsdb_idl_txn_status	file:
status	.\lib\process.c	/^    int status;$/;"	m	struct:process	file:
status	.\lib\vswitch-idl.h	/^	struct smap status;$/;"	m	struct:ovsrec_bridge	typeref:struct:ovsrec_bridge::smap
status	.\lib\vswitch-idl.h	/^	struct smap status;$/;"	m	struct:ovsrec_controller	typeref:struct:ovsrec_controller::smap
status	.\lib\vswitch-idl.h	/^	struct smap status;$/;"	m	struct:ovsrec_interface	typeref:struct:ovsrec_interface::smap
status	.\lib\vswitch-idl.h	/^	struct smap status;$/;"	m	struct:ovsrec_manager	typeref:struct:ovsrec_manager::smap
status	.\lib\vswitch-idl.h	/^	struct smap status;$/;"	m	struct:ovsrec_port	typeref:struct:ovsrec_port::smap
status	.\lib\vtep-idl.h	/^	struct smap status;$/;"	m	struct:vteprec_manager	typeref:struct:vteprec_manager::smap
status	.\xenserver\usr_lib_xsconsole_plugins-base_XSFeatureVSwitch.py	/^    def status(self):$/;"	m	class:VSwitchService
status_changed	.\lib\bfd.c	/^    bool status_changed;$/;"	m	struct:bfd	file:
status_changed	.\lib\cfm.c	/^    bool status_changed;$/;"	m	struct:cfm	file:
status_msg	.\python\ovs\process.py	/^def status_msg(status):$/;"	f
status_seq	.\lib\netlink-socket.h	/^    struct seq *status_seq;     \/* Tracks changes to the above 'status'. *\/$/;"	m	struct:nl_dump	typeref:struct:nl_dump::seq
status_to_string	.\python\ovs\db\idl.py	/^    def status_to_string(status):$/;"	m	class:Transaction
status_txn	.\vswitchd\bridge.c	/^static struct ovsdb_idl_txn *status_txn;$/;"	v	typeref:struct:ovsdb_idl_txn	file:
stopProducing	.\python\ovstest\tcp.py	/^    def stopProducing(self):$/;"	m	class:Producer
stopProtocol	.\python\ovstest\udp.py	/^    def stopProtocol(self):$/;"	m	class:UdpSender
stored_sig_nr	.\lib\fatal-signal.c	/^static volatile sig_atomic_t stored_sig_nr = SIG_ATOMIC_MAX;$/;"	v	file:
stp	.\lib\stp.c	/^    struct stp *stp;$/;"	m	struct:stp_port	typeref:struct:stp_port::stp	file:
stp	.\lib\stp.c	/^VLOG_DEFINE_THIS_MODULE(stp);$/;"	v
stp	.\lib\stp.c	/^struct stp {$/;"	s	file:
stp	.\ofproto\ofproto-dpif-xlate.c	/^    struct stp *stp;              \/* STP or null if disabled. *\/$/;"	m	struct:xbridge	typeref:struct:xbridge::stp	file:
stp	.\ofproto\ofproto-dpif.c	/^    struct stp *stp;$/;"	m	struct:ofproto_dpif	typeref:struct:ofproto_dpif::stp	file:
stp	.\tests\test-stp.c	/^    struct stp *stp;$/;"	m	struct:bridge	typeref:struct:bridge::stp	file:
stp_check_and_reset_fdb_flush	.\lib\stp.c	/^stp_check_and_reset_fdb_flush(struct stp *stp)$/;"	f
stp_config_bpdu_flags	.\lib\stp.c	/^enum stp_config_bpdu_flags {$/;"	g	file:
stp_convert_speed_to_cost	.\lib\stp.c	/^stp_convert_speed_to_cost(unsigned int speed)$/;"	f
stp_create	.\lib\stp.c	/^stp_create(const char *name, stp_identifier bridge_id,$/;"	f
stp_enable	.\lib\vswitch-idl.h	/^	bool stp_enable;$/;"	m	struct:ovsrec_bridge
stp_forward_in_state	.\lib\stp.c	/^stp_forward_in_state(enum stp_state state)$/;"	f
stp_get_bridge_id	.\lib\stp.c	/^stp_get_bridge_id(const struct stp *stp)$/;"	f
stp_get_changed_port	.\lib\stp.c	/^stp_get_changed_port(struct stp *stp, struct stp_port **portp)$/;"	f
stp_get_designated_root	.\lib\stp.c	/^stp_get_designated_root(const struct stp *stp)$/;"	f
stp_get_forward_delay	.\lib\stp.c	/^stp_get_forward_delay(const struct stp *stp)$/;"	f
stp_get_hello_time	.\lib\stp.c	/^stp_get_hello_time(const struct stp *stp)$/;"	f
stp_get_max_age	.\lib\stp.c	/^stp_get_max_age(const struct stp *stp)$/;"	f
stp_get_name	.\lib\stp.c	/^stp_get_name(const struct stp *stp)$/;"	f
stp_get_port	.\lib\stp.c	/^stp_get_port(struct stp *stp, int port_no)$/;"	f
stp_get_root_path_cost	.\lib\stp.c	/^stp_get_root_path_cost(const struct stp *stp)$/;"	f
stp_get_root_port	.\lib\stp.c	/^stp_get_root_port(struct stp *stp)$/;"	f
stp_identifier	.\lib\stp.h	/^typedef uint64_t stp_identifier;$/;"	t
stp_init	.\lib\stp.c	/^stp_init(void)$/;"	f
stp_is_root_bridge	.\lib\stp.c	/^stp_is_root_bridge(const struct stp *stp)$/;"	f
stp_last_tick	.\ofproto\ofproto-dpif.c	/^    long long int stp_last_tick;$/;"	m	struct:ofproto_dpif	file:
stp_learn_in_state	.\lib\stp.c	/^stp_learn_in_state(enum stp_state state)$/;"	f
stp_port	.\lib\stp.c	/^struct stp_port {$/;"	s	file:
stp_port	.\ofproto\ofproto-dpif.c	/^    struct stp_port *stp_port;  \/* Spanning Tree Protocol, if any. *\/$/;"	m	struct:ofport_dpif	typeref:struct:ofport_dpif::stp_port	file:
stp_port_disable	.\lib\stp.c	/^stp_port_disable(struct stp_port *p)$/;"	f
stp_port_disable_change_detection	.\lib\stp.c	/^stp_port_disable_change_detection(struct stp_port *p)$/;"	f
stp_port_enable	.\lib\stp.c	/^stp_port_enable(struct stp_port *p)$/;"	f
stp_port_enable_change_detection	.\lib\stp.c	/^stp_port_enable_change_detection(struct stp_port *p)$/;"	f
stp_port_get_aux	.\lib\stp.c	/^stp_port_get_aux(struct stp_port *p)$/;"	f
stp_port_get_counts	.\lib\stp.c	/^stp_port_get_counts(const struct stp_port *p,$/;"	f
stp_port_get_id	.\lib\stp.c	/^stp_port_get_id(const struct stp_port *p)$/;"	f
stp_port_get_role	.\lib\stp.c	/^stp_port_get_role(const struct stp_port *p)$/;"	f
stp_port_get_state	.\lib\stp.c	/^stp_port_get_state(const struct stp_port *p)$/;"	f
stp_port_get_stp	.\lib\stp.c	/^stp_port_get_stp(struct stp_port *p)$/;"	f
stp_port_no	.\lib\stp.c	/^stp_port_no(const struct stp_port *p)$/;"	f
stp_port_no	.\ofproto\ofproto-dpif-xlate.c	/^    int stp_port_no;                 \/* STP port number or -1 if not in use. *\/$/;"	m	struct:xport	file:
stp_port_set_aux	.\lib\stp.c	/^stp_port_set_aux(struct stp_port *p, void *aux)$/;"	f
stp_port_set_path_cost	.\lib\stp.c	/^stp_port_set_path_cost(struct stp_port *p, uint16_t path_cost)$/;"	f
stp_port_set_priority	.\lib\stp.c	/^stp_port_set_priority(struct stp_port *p, uint8_t new_priority)$/;"	f
stp_port_set_speed	.\lib\stp.c	/^stp_port_set_speed(struct stp_port *p, unsigned int speed)$/;"	f
stp_process_packet	.\ofproto\ofproto-dpif-xlate.c	/^stp_process_packet(const struct xport *xport, const struct ofpbuf *packet)$/;"	f	file:
stp_received_bpdu	.\lib\stp.c	/^stp_received_bpdu(struct stp_port *p, const void *bpdu, size_t bpdu_size)$/;"	f
stp_ref	.\lib\stp.c	/^stp_ref(const struct stp *stp_)$/;"	f
stp_role	.\lib\stp.h	/^enum stp_role {$/;"	g
stp_role_name	.\lib\stp.c	/^stp_role_name(enum stp_role role)$/;"	f
stp_run	.\ofproto\ofproto-dpif.c	/^stp_run(struct ofproto_dpif *ofproto)$/;"	f	file:
stp_set_bridge_id	.\lib\stp.c	/^stp_set_bridge_id(struct stp *stp, stp_identifier bridge_id)$/;"	f
stp_set_bridge_priority	.\lib\stp.c	/^stp_set_bridge_priority(struct stp *stp, uint16_t new_priority)$/;"	f
stp_set_forward_delay	.\lib\stp.c	/^stp_set_forward_delay(struct stp *stp, int ms)$/;"	f
stp_set_hello_time	.\lib\stp.c	/^stp_set_hello_time(struct stp *stp, int ms)$/;"	f
stp_set_max_age	.\lib\stp.c	/^stp_set_max_age(struct stp *stp, int ms)$/;"	f
stp_should_forward_bpdu	.\lib\stp.c	/^stp_should_forward_bpdu(enum stp_state state)$/;"	f
stp_should_process_flow	.\ofproto\ofproto-dpif-xlate.c	/^stp_should_process_flow(const struct flow *flow, struct flow_wildcards *wc)$/;"	f	file:
stp_state	.\lib\stp.h	/^enum stp_state {$/;"	g
stp_state	.\ofproto\ofproto-dpif.c	/^    enum stp_state stp_state;   \/* Always STP_DISABLED if STP not in use. *\/$/;"	m	struct:ofport_dpif	typeref:enum:ofport_dpif::stp_state	file:
stp_state_entered	.\ofproto\ofproto-dpif.c	/^    long long int stp_state_entered;$/;"	m	struct:ofport_dpif	file:
stp_state_name	.\lib\stp.c	/^stp_state_name(enum stp_state state)$/;"	f
stp_tick	.\lib\stp.c	/^stp_tick(struct stp *stp, int ms)$/;"	f
stp_timer	.\lib\stp.c	/^struct stp_timer {$/;"	s	file:
stp_unixctl_tcn	.\lib\stp.c	/^stp_unixctl_tcn(struct unixctl_conn *conn, int argc,$/;"	f	file:
stp_unref	.\lib\stp.c	/^stp_unref(struct stp *stp)$/;"	f
stp_wait	.\ofproto\ofproto-dpif.c	/^stp_wait(struct ofproto_dpif *ofproto)$/;"	f	file:
str	.\lib\sflow.h	/^    char *str;$/;"	m	struct:_SFLString
str_ip	.\python\ovstest\util.py	/^def str_ip(ip_address):$/;"	f
str_to_be64	.\lib\ofp-parse.c	/^str_to_be64(const char *str, ovs_be64 *valuep)$/;"	f	file:
str_to_double	.\lib\util.c	/^str_to_double(const char *s, double *d)$/;"	f
str_to_inst_ofpacts	.\lib\ofp-parse.c	/^str_to_inst_ofpacts(char *str, struct ofpbuf *ofpacts,$/;"	f	file:
str_to_int	.\lib\util.c	/^str_to_int(const char *s, int base, int *i)$/;"	f
str_to_ip	.\lib\ofp-parse.c	/^str_to_ip(const char *str, ovs_be32 *ip)$/;"	f	file:
str_to_llong	.\lib\util.c	/^str_to_llong(const char *s, int base, long long *x)$/;"	f
str_to_long	.\lib\util.c	/^str_to_long(const char *s, int base, long *li)$/;"	f
str_to_mac	.\lib\ofp-parse.c	/^str_to_mac(const char *str, uint8_t mac[6])$/;"	f	file:
str_to_ofp	.\utilities\ovs-ofctl.c	/^str_to_ofp(const char *s, ofp_port_t *ofp_port)$/;"	f	file:
str_to_ofpact__	.\lib\ofp-parse.c	/^str_to_ofpact__(char *pos, char *act, char *arg,$/;"	f	file:
str_to_ofpacts	.\lib\ofp-parse.c	/^str_to_ofpacts(char *str, struct ofpbuf *ofpacts,$/;"	f	file:
str_to_ofpacts__	.\lib\ofp-parse.c	/^str_to_ofpacts__(char *str, struct ofpbuf *ofpacts,$/;"	f	file:
str_to_port_no	.\utilities\ovs-ofctl.c	/^str_to_port_no(const char *vconn_name, const char *port_name)$/;"	f	file:
str_to_u16	.\lib\ofp-parse.c	/^str_to_u16(const char *str, const char *name, uint16_t *valuep)$/;"	f	file:
str_to_u32	.\lib\ofp-parse.c	/^str_to_u32(const char *str, uint32_t *valuep)$/;"	f	file:
str_to_u64	.\lib\ofp-parse.c	/^str_to_u64(const char *str, uint64_t *valuep)$/;"	f	file:
str_to_u8	.\lib\ofp-parse.c	/^str_to_u8(const char *str, const char *name, uint8_t *valuep)$/;"	f	file:
str_to_uint	.\lib\util.c	/^str_to_uint(const char *s, int base, unsigned int *u)$/;"	f
stream	.\lib\jsonrpc.c	/^    struct stream *stream;$/;"	m	struct:jsonrpc	typeref:struct:jsonrpc::stream	file:
stream	.\lib\jsonrpc.c	/^    struct stream *stream;$/;"	m	struct:jsonrpc_session	typeref:struct:jsonrpc_session::stream	file:
stream	.\lib\netdev-dummy.c	/^    struct stream *stream;$/;"	m	struct:dummy_packet_stream	typeref:struct:dummy_packet_stream::stream	file:
stream	.\lib\stream-fd-unix.c	/^    struct stream stream;$/;"	m	struct:stream_fd	typeref:struct:stream_fd::stream	file:
stream	.\lib\stream-fd-windows.c	/^    struct stream stream;$/;"	m	struct:stream_fd	typeref:struct:stream_fd::stream	file:
stream	.\lib\stream-provider.h	/^struct stream {$/;"	s
stream	.\lib\stream-ssl.c	/^    struct stream stream;$/;"	m	struct:ssl_stream	typeref:struct:ssl_stream::stream	file:
stream	.\lib\stream.c	/^VLOG_DEFINE_THIS_MODULE(stream);$/;"	v
stream	.\lib\vconn-stream.c	/^    struct stream *stream;$/;"	m	struct:vconn_stream	typeref:struct:vconn_stream::stream	file:
stream	.\ovsdb\log.c	/^    FILE *stream;$/;"	m	struct:ovsdb_log	file:
stream	.\python\ovs\jsonrpc.py	/^import ovs.stream$/;"	i
stream	.\python\ovs\unixctl\client.py	/^import ovs.stream$/;"	i
stream	.\python\ovs\unixctl\server.py	/^import ovs.stream$/;"	i
stream	.\tests\test-jsonrpc.py	/^import ovs.stream$/;"	i
stream_assert_class	.\lib\stream-provider.h	/^static inline void stream_assert_class(const struct stream *stream,$/;"	f
stream_class	.\lib\stream-provider.h	/^struct stream_class {$/;"	s
stream_classes	.\lib\stream.c	/^static const struct stream_class *stream_classes[] = {$/;"	v	typeref:struct:stream_class	file:
stream_close	.\lib\stream.c	/^stream_close(struct stream *stream)$/;"	f
stream_connect	.\lib\stream.c	/^stream_connect(struct stream *stream)$/;"	f
stream_connect_wait	.\lib\stream.c	/^stream_connect_wait(struct stream *stream)$/;"	f
stream_content_type	.\lib\stream.h	/^enum stream_content_type {$/;"	g
stream_content_type_to_string	.\lib\stream.c	/^stream_content_type_to_string(enum stream_content_type type)$/;"	f	file:
stream_fd	.\lib\stream-fd-unix.c	/^VLOG_DEFINE_THIS_MODULE(stream_fd);$/;"	v
stream_fd	.\lib\stream-fd-unix.c	/^struct stream_fd$/;"	s	file:
stream_fd	.\lib\stream-fd-windows.c	/^struct stream_fd$/;"	s	file:
stream_fd_cast	.\lib\stream-fd-unix.c	/^stream_fd_cast(struct stream *stream)$/;"	f	file:
stream_fd_cast	.\lib\stream-fd-windows.c	/^stream_fd_cast(struct stream *stream)$/;"	f	file:
stream_fd_class	.\lib\stream-fd-unix.c	/^static const struct stream_class stream_fd_class = {$/;"	v	typeref:struct:stream_class	file:
stream_fd_class	.\lib\stream-fd-unix.c	/^static const struct stream_class stream_fd_class;$/;"	v	typeref:struct:stream_class	file:
stream_fd_class	.\lib\stream-fd-windows.c	/^static const struct stream_class stream_fd_class = {$/;"	v	typeref:struct:stream_class	file:
stream_fd_class	.\lib\stream-fd-windows.c	/^static const struct stream_class stream_fd_class;$/;"	v	typeref:struct:stream_class	file:
stream_fd_windows	.\lib\stream-fd-windows.c	/^VLOG_DEFINE_THIS_MODULE(stream_fd_windows);$/;"	v
stream_get_name	.\lib\stream.c	/^stream_get_name(const struct stream *stream)$/;"	f
stream_guess_content	.\lib\stream.c	/^stream_guess_content(const uint8_t *data, ssize_t size)$/;"	f	file:
stream_init	.\lib\stream.c	/^stream_init(struct stream *stream, const struct stream_class *class,$/;"	f
stream_lookup_class	.\lib\stream.c	/^stream_lookup_class(const char *name, const struct stream_class **classp)$/;"	f	file:
stream_nossl	.\lib\stream-nossl.c	/^VLOG_DEFINE_THIS_MODULE(stream_nossl);$/;"	v
stream_open	.\lib\stream.c	/^COVERAGE_DEFINE(stream_open);$/;"	v
stream_open	.\lib\stream.c	/^stream_open(const char *name, struct stream **streamp, uint8_t dscp)$/;"	f
stream_open_block	.\lib\stream.c	/^stream_open_block(int error, struct stream **streamp)$/;"	f
stream_open_with_default_port	.\lib\stream.c	/^stream_open_with_default_port(const char *name_,$/;"	f
stream_or_pstream_needs_probes	.\lib\stream.c	/^stream_or_pstream_needs_probes(const char *name)$/;"	f
stream_or_pstream_needs_probes	.\python\ovs\stream.py	/^def stream_or_pstream_needs_probes(name):$/;"	f
stream_parse_target_with_default_port	.\lib\stream.c	/^stream_parse_target_with_default_port(const char *target,$/;"	f
stream_recv	.\lib\stream.c	/^stream_recv(struct stream *stream, void *buffer, size_t n)$/;"	f
stream_recv_wait	.\lib\stream.c	/^stream_recv_wait(struct stream *stream)$/;"	f
stream_report_content	.\lib\stream.c	/^stream_report_content(const void *data, ssize_t size,$/;"	f
stream_run	.\lib\stream.c	/^stream_run(struct stream *stream)$/;"	f
stream_run_wait	.\lib\stream.c	/^stream_run_wait(struct stream *stream)$/;"	f
stream_send	.\lib\stream.c	/^stream_send(struct stream *stream, const void *buffer, size_t n)$/;"	f
stream_send_wait	.\lib\stream.c	/^stream_send_wait(struct stream *stream)$/;"	f
stream_ssl	.\lib\stream-ssl.c	/^VLOG_DEFINE_THIS_MODULE(stream_ssl);$/;"	v
stream_ssl_is_configured	.\lib\stream-nossl.c	/^stream_ssl_is_configured(void)$/;"	f
stream_ssl_is_configured	.\lib\stream-ssl.c	/^stream_ssl_is_configured(void)$/;"	f
stream_ssl_set_ca_cert_file	.\lib\stream-nossl.c	/^stream_ssl_set_ca_cert_file(const char *file_name, bool bootstrap OVS_UNUSED)$/;"	f
stream_ssl_set_ca_cert_file	.\lib\stream-ssl.c	/^stream_ssl_set_ca_cert_file(const char *file_name, bool bootstrap)$/;"	f
stream_ssl_set_ca_cert_file__	.\lib\stream-ssl.c	/^stream_ssl_set_ca_cert_file__(const char *file_name,$/;"	f	file:
stream_ssl_set_certificate_file	.\lib\stream-nossl.c	/^stream_ssl_set_certificate_file(const char *file_name)$/;"	f
stream_ssl_set_certificate_file	.\lib\stream-ssl.c	/^stream_ssl_set_certificate_file(const char *file_name)$/;"	f
stream_ssl_set_certificate_file__	.\lib\stream-ssl.c	/^stream_ssl_set_certificate_file__(const char *file_name)$/;"	f	file:
stream_ssl_set_key_and_cert	.\lib\stream-nossl.c	/^stream_ssl_set_key_and_cert(const char *private_key_file,$/;"	f
stream_ssl_set_key_and_cert	.\lib\stream-ssl.c	/^stream_ssl_set_key_and_cert(const char *private_key_file,$/;"	f
stream_ssl_set_peer_ca_cert_file	.\lib\stream-nossl.c	/^stream_ssl_set_peer_ca_cert_file(const char *file_name)$/;"	f
stream_ssl_set_peer_ca_cert_file	.\lib\stream-ssl.c	/^stream_ssl_set_peer_ca_cert_file(const char *file_name)$/;"	f
stream_ssl_set_private_key_file	.\lib\stream-nossl.c	/^stream_ssl_set_private_key_file(const char *file_name)$/;"	f
stream_ssl_set_private_key_file	.\lib\stream-ssl.c	/^stream_ssl_set_private_key_file(const char *file_name)$/;"	f
stream_ssl_set_private_key_file__	.\lib\stream-ssl.c	/^stream_ssl_set_private_key_file__(const char *file_name)$/;"	f	file:
stream_state	.\lib\stream.c	/^enum stream_state {$/;"	g	file:
stream_tcp	.\lib\stream-tcp.c	/^VLOG_DEFINE_THIS_MODULE(stream_tcp);$/;"	v
stream_unix	.\lib\stream-unix.c	/^VLOG_DEFINE_THIS_MODULE(stream_unix);$/;"	v
stream_usage	.\lib\stream.c	/^stream_usage(const char *name, bool active, bool passive,$/;"	f
stream_vconn_class	.\lib\vconn-stream.c	/^static const struct vconn_class stream_vconn_class = STREAM_INIT("stream");$/;"	v	typeref:struct:vconn_class	file:
stream_vconn_class	.\lib\vconn-stream.c	/^static const struct vconn_class stream_vconn_class;$/;"	v	typeref:struct:vconn_class	file:
stream_verify_name	.\lib\stream.c	/^stream_verify_name(const char *name)$/;"	f
stream_wait	.\lib\stream.c	/^stream_wait(struct stream *stream, enum stream_wait_type wait)$/;"	f
stream_wait_type	.\lib\stream.h	/^enum stream_wait_type {$/;"	g
streams	.\lib\netdev-dummy.c	/^    struct dummy_packet_stream *streams;$/;"	m	struct:dummy_packet_pconn	typeref:struct:dummy_packet_pconn::dummy_packet_stream	file:
streams	.\lib\pcap-file.c	/^    struct hmap streams;$/;"	m	struct:tcp_reader	typeref:struct:tcp_reader::hmap	file:
strftime_msec	.\lib\timeval.c	/^strftime_msec(char *s, size_t max, const char *format,$/;"	f
strict	.\utilities\ovs-ofctl.c	/^static bool strict;$/;"	v	file:
string	.\lib\dynamic-string.h	/^    char *string;       \/* Null-terminated string. *\/$/;"	m	struct:ds
string	.\lib\json.c	/^        const char *string;$/;"	m	union:json_token::__anon48	file:
string	.\lib\json.h	/^        char *string;$/;"	m	union:json::__anon49
string	.\lib\meta-flow.h	/^    enum mf_string string;$/;"	m	struct:mf_field	typeref:enum:mf_field::mf_string
string	.\lib\ovsdb-data.h	/^    char *string;$/;"	m	union:ovsdb_atom
string	.\lib\ovsdb-types.h	/^        } string;$/;"	m	union:ovsdb_base_type::__anon86	typeref:struct:ovsdb_base_type::__anon86::ovsdb_string_constraints
stringEncodingLength	.\lib\sflow_receiver.c	/^inline static u_int32_t stringEncodingLength(SFLString *s) {$/;"	f	file:
string_needs_quotes	.\lib\ovsdb-data.c	/^string_needs_quotes(const char *s)$/;"	f	file:
stripped	.\lib\sflow.h	/^    u_int32_t stripped;                   \/* header\/trailer bytes stripped by sender *\/$/;"	m	struct:_SFLSampled_header
strnlen	.\lib\string.c	/^strnlen(const char *s, size_t maxlen)$/;"	f
strong_ref	.\lib\ovsdb-data.h	/^    bool strong_ref;            \/* Parsed a strong reference to this row? *\/$/;"	m	struct:ovsdb_symbol
strsep	.\lib\strsep.c	/^strsep(char **stringp, const char *delim)$/;"	f
strtypes	.\python\ovs\unixctl\__init__.py	/^strtypes = types.StringTypes$/;"	v
strtypes	.\python\ovs\unixctl\client.py	/^strtypes = types.StringTypes$/;"	v
strtypes	.\python\ovs\unixctl\server.py	/^strtypes = types.StringTypes$/;"	v
struct	.\python\ovstest\udp.py	/^import struct$/;"	i
struct	.\python\ovstest\util.py	/^import struct$/;"	i
stub	.\ofproto\ofproto-provider.h	/^    struct rule *stub[64];      \/* Preallocated rules to avoid malloc(). *\/$/;"	m	struct:rule_collection	typeref:struct:rule_collection::rule
subAgentId	.\tests\test-sflow.c	/^    uint32_t subAgentId;$/;"	m	struct:sflow_xdr	file:
subId	.\lib\sflow_api.h	/^    u_int32_t subId;        \/* sub_agent_id *\/$/;"	m	struct:_SFLAgent
sub_agent_id	.\lib\sflow.h	/^    u_int32_t sub_agent_id;          \/* Used to distinguishing between datagram$/;"	m	struct:_SFLSample_datagram_hdr
sub_double	.\ovsdb\mutation.c	/^sub_double(double *x, double y)$/;"	f	file:
sub_id	.\ofproto\ofproto.h	/^    uint32_t sub_id;$/;"	m	struct:ofproto_sflow_options
sub_int	.\ovsdb\mutation.c	/^sub_int(int64_t *x, int64_t y)$/;"	f	file:
sub_mutation	.\ovsdb\mutation.c	/^static const struct ovsdb_scalar_mutation sub_mutation = {$/;"	v	typeref:struct:ovsdb_scalar_mutation	file:
sub_mutation	.\ovsdb\mutation.c	/^static const struct ovsdb_scalar_mutation sub_mutation;$/;"	v	typeref:struct:ovsdb_scalar_mutation	file:
subfield	.\lib\ofp-actions.h	/^    struct mf_subfield subfield;$/;"	m	struct:ofpact_stack	typeref:struct:ofpact_stack::mf_subfield
subprocess	.\python\ovstest\util.py	/^import subprocess$/;"	i
subprocess	.\python\ovstest\vswitch.py	/^import subprocess$/;"	i
subprocess	.\utilities\ovs-dev.py	/^import subprocess$/;"	i
subprocess	.\xenserver\opt_xensource_libexec_InterfaceReconfigureVswitch.py	/^import subprocess$/;"	i
subprocess	.\xenserver\usr_lib_xsconsole_plugins-base_XSFeatureVSwitch.py	/^import subprocess$/;"	i
substitute_uuids	.\lib\ovsdb-idl.c	/^substitute_uuids(struct json *json, const struct ovsdb_idl_txn *txn)$/;"	f	file:
substitute_uuids	.\tests\test-ovsdb.c	/^substitute_uuids(struct json *json, const struct ovsdb_symbol_table *symtab)$/;"	f	file:
substitute_uuids	.\tests\test-ovsdb.py	/^def substitute_uuids(json, symtab):$/;"	f
subtable	.\lib\classifier.c	/^    struct cls_subtable *subtable;$/;"	m	struct:cls_subtable_entry	typeref:struct:cls_subtable_entry::cls_subtable	file:
subtable	.\lib\classifier.h	/^    const struct cls_subtable *subtable;$/;"	m	struct:cls_cursor	typeref:struct:cls_cursor::cls_subtable
subtables	.\lib\classifier.c	/^    struct cls_subtable_entry *subtables;$/;"	m	struct:cls_subtable_cache	typeref:struct:cls_subtable_cache::cls_subtable_entry	file:
subtables	.\lib\classifier.c	/^    struct hmap subtables;      \/* Contains "struct cls_subtable"s.  *\/$/;"	m	struct:cls_classifier	typeref:struct:cls_classifier::hmap	file:
subtables_priority	.\lib\classifier.c	/^    struct cls_subtable_cache subtables_priority;$/;"	m	struct:cls_classifier	typeref:struct:cls_classifier::cls_subtable_cache	file:
subtype	.\include\openflow\nicira-ext.h	/^    ovs_be16 subtype;               \/* NXAST_*. *\/$/;"	m	struct:nx_action_header
subtype	.\include\openflow\nicira-ext.h	/^    ovs_be16 subtype;               \/* NXAST_CONTROLLER. *\/$/;"	m	struct:nx_action_controller
subtype	.\include\openflow\nicira-ext.h	/^    ovs_be16 subtype;               \/* NXAST_NOTE. *\/$/;"	m	struct:nx_action_note
subtype	.\include\openflow\nicira-ext.h	/^    ovs_be16 subtype;               \/* NXAST_POP_MPLS. *\/$/;"	m	struct:nx_action_pop_mpls
subtype	.\include\openflow\nicira-ext.h	/^    ovs_be16 subtype;               \/* NXAST_POP_QUEUE. *\/$/;"	m	struct:nx_action_pop_queue
subtype	.\include\openflow\nicira-ext.h	/^    ovs_be16 subtype;               \/* NXAST_PUSH_MPLS. *\/$/;"	m	struct:nx_action_push_mpls
subtype	.\include\openflow\nicira-ext.h	/^    ovs_be16 subtype;               \/* NXAST_REG_LOAD. *\/$/;"	m	struct:nx_action_reg_load
subtype	.\include\openflow\nicira-ext.h	/^    ovs_be16 subtype;               \/* NXAST_REG_MOVE. *\/$/;"	m	struct:nx_action_reg_move
subtype	.\include\openflow\nicira-ext.h	/^    ovs_be16 subtype;               \/* NXAST_RESUBMIT. *\/$/;"	m	struct:nx_action_resubmit
subtype	.\include\openflow\nicira-ext.h	/^    ovs_be16 subtype;               \/* NXAST_SAMPLE. *\/$/;"	m	struct:nx_action_sample
subtype	.\include\openflow\nicira-ext.h	/^    ovs_be16 subtype;               \/* NXAST_SET_MPLS_LABEL. *\/$/;"	m	struct:nx_action_mpls_label
subtype	.\include\openflow\nicira-ext.h	/^    ovs_be16 subtype;               \/* NXAST_SET_MPLS_TC. *\/$/;"	m	struct:nx_action_mpls_tc
subtype	.\include\openflow\nicira-ext.h	/^    ovs_be16 subtype;               \/* NXAST_SET_MPLS_TTL. *\/$/;"	m	struct:nx_action_mpls_ttl
subtype	.\include\openflow\nicira-ext.h	/^    ovs_be16 subtype;               \/* NXAST_SET_QUEUE. *\/$/;"	m	struct:nx_action_set_queue
subtype	.\include\openflow\nicira-ext.h	/^    ovs_be16 subtype;               \/* NXAST_SET_TUNNEL. *\/$/;"	m	struct:nx_action_set_tunnel
subtype	.\include\openflow\nicira-ext.h	/^    ovs_be16 subtype;               \/* NXAST_SET_TUNNEL64. *\/$/;"	m	struct:nx_action_set_tunnel64
subtype	.\include\openflow\nicira-ext.h	/^    ovs_be16 subtype;               \/* NXAST_STACK_PUSH or NXAST_STACK_POP. *\/$/;"	m	struct:nx_action_stack
subtype	.\include\openflow\nicira-ext.h	/^    ovs_be16 subtype;               \/* NXAST_WRITE_METADATA. *\/$/;"	m	struct:nx_action_write_metadata
subtype	.\include\openflow\nicira-ext.h	/^    ovs_be16 subtype;           \/* NXAST_BUNDLE or NXAST_BUNDLE_LOAD. *\/$/;"	m	struct:nx_action_bundle
subtype	.\include\openflow\nicira-ext.h	/^    ovs_be16 subtype;           \/* NXAST_DEC_TTL_CNT_IDS. *\/$/;"	m	struct:nx_action_cnt_ids
subtype	.\include\openflow\nicira-ext.h	/^    ovs_be16 subtype;           \/* NXAST_FIN_TIMEOUT. *\/$/;"	m	struct:nx_action_fin_timeout
subtype	.\include\openflow\nicira-ext.h	/^    ovs_be16 subtype;           \/* NXAST_LEARN. *\/$/;"	m	struct:nx_action_learn
subtype	.\include\openflow\nicira-ext.h	/^    ovs_be16 subtype;           \/* NXAST_MULTIPATH. *\/$/;"	m	struct:nx_action_multipath
subtype	.\include\openflow\nicira-ext.h	/^    ovs_be16 subtype;           \/* NXAST_OUTPUT_REG. *\/$/;"	m	struct:nx_action_output_reg
subtype	.\include\openflow\nicira-ext.h	/^    ovs_be32 subtype;           \/* One of NXST_* below. *\/$/;"	m	struct:nicira10_stats_msg
subtype	.\include\openflow\nicira-ext.h	/^    ovs_be32 subtype;           \/* One of NXST_* below. *\/$/;"	m	struct:nicira11_stats_msg
subtype	.\include\openflow\nicira-ext.h	/^    ovs_be32 subtype;           \/* See the NXT numbers in ofp-msgs.h. *\/$/;"	m	struct:nicira_header
subtype	.\lib\ofp-msgs.c	/^    uint32_t subtype;           \/* From nicira_header, nicira10_stats_msg, or$/;"	m	struct:ofphdrs	file:
subvalue	.\lib\ofp-actions.h	/^    union mf_subvalue subvalue; \/* Least-significant bits are used. *\/$/;"	m	struct:ofpact_reg_load	typeref:union:ofpact_reg_load::mf_subvalue
sum_of_squares	.\tests\test-util.c	/^sum_of_squares(int n)$/;"	f	file:
supported	.\include\openflow\openflow-1.0.h	/^    ovs_be32 supported;     \/* Features supported by the port. *\/$/;"	m	struct:ofp10_phy_port
supported	.\include\openflow\openflow-1.1.h	/^    ovs_be32 supported;     \/* Features supported by the port. *\/$/;"	m	struct:ofp11_port
supported	.\include\openflow\openflow-1.4.h	/^    ovs_be32 supported;     \/* Features supported by the port. *\/$/;"	m	struct:ofp14_port_desc_prop_ethernet
supported	.\lib\netdev-linux.c	/^    enum netdev_features supported;  \/* Cached from ETHTOOL_GSET. *\/$/;"	m	struct:netdev_linux	typeref:enum:netdev_linux::netdev_features	file:
supported	.\lib\ofp-util.h	/^    enum netdev_features supported;  \/* Features supported by the port. *\/$/;"	m	struct:ofputil_phy_port	typeref:enum:ofputil_phy_port::netdev_features
svec	.\lib\svec.c	/^VLOG_DEFINE_THIS_MODULE(svec);$/;"	v
svec	.\lib\svec.h	/^struct svec {$/;"	s
svec_add	.\lib\svec.c	/^svec_add(struct svec *svec, const char *name)$/;"	f
svec_add_nocopy	.\lib\svec.c	/^svec_add_nocopy(struct svec *svec, char *name)$/;"	f
svec_append	.\lib\svec.c	/^svec_append(struct svec *svec, const struct svec *other)$/;"	f
svec_back	.\lib\svec.c	/^svec_back(const struct svec *svec)$/;"	f
svec_clear	.\lib\svec.c	/^svec_clear(struct svec *svec)$/;"	f
svec_clone	.\lib\svec.c	/^svec_clone(struct svec *svec, const struct svec *other)$/;"	f
svec_compact	.\lib\svec.c	/^svec_compact(struct svec *svec)$/;"	f
svec_contains	.\lib\svec.c	/^svec_contains(const struct svec *svec, const char *name)$/;"	f
svec_del	.\lib\svec.c	/^svec_del(struct svec *svec, const char *name)$/;"	f
svec_destroy	.\lib\svec.c	/^svec_destroy(struct svec *svec)$/;"	f
svec_diff	.\lib\svec.c	/^svec_diff(const struct svec *a, const struct svec *b,$/;"	f
svec_equal	.\lib\svec.c	/^svec_equal(const struct svec *a, const struct svec *b)$/;"	f
svec_expand	.\lib\svec.c	/^svec_expand(struct svec *svec)$/;"	f	file:
svec_find	.\lib\svec.c	/^svec_find(const struct svec *svec, const char *name)$/;"	f
svec_get_duplicate	.\lib\svec.c	/^svec_get_duplicate(const struct svec *svec)$/;"	f
svec_init	.\lib\svec.c	/^svec_init(struct svec *svec)$/;"	f
svec_is_empty	.\lib\svec.c	/^svec_is_empty(const struct svec *svec)$/;"	f
svec_is_sorted	.\lib\svec.c	/^svec_is_sorted(const struct svec *svec)$/;"	f
svec_is_unique	.\lib\svec.c	/^svec_is_unique(const struct svec *svec)$/;"	f
svec_join	.\lib\svec.c	/^svec_join(const struct svec *svec,$/;"	f
svec_parse_words	.\lib\svec.c	/^svec_parse_words(struct svec *svec, const char *words)$/;"	f
svec_pop_back	.\lib\svec.c	/^svec_pop_back(struct svec *svec)$/;"	f
svec_print	.\lib\svec.c	/^svec_print(const struct svec *svec, const char *title)$/;"	f
svec_sort	.\lib\svec.c	/^svec_sort(struct svec *svec)$/;"	f
svec_sort_unique	.\lib\svec.c	/^svec_sort_unique(struct svec *svec)$/;"	f
svec_swap	.\lib\svec.c	/^svec_swap(struct svec *a, struct svec *b)$/;"	f
svec_terminate	.\lib\svec.c	/^svec_terminate(struct svec *svec)$/;"	f
svec_unique	.\lib\svec.c	/^svec_unique(struct svec *svec)$/;"	f
sw	.\lib\sflow.h	/^    SFLExtended_switch sw;$/;"	m	union:_SFLFlow_type
sw_desc	.\include\openflow\openflow-common.h	/^    char sw_desc[DESC_STR_LEN];        \/* Software description. *\/$/;"	m	struct:ofp_desc_stats
sw_desc	.\ofproto\ofproto-provider.h	/^    char *sw_desc;              \/* Software version (NULL for default). *\/$/;"	m	struct:ofproto
sw_flow	.\datapath\flow.h	/^struct sw_flow {$/;"	s
sw_flow_actions	.\datapath\flow.h	/^struct sw_flow_actions {$/;"	s
sw_flow_key	.\datapath\flow.h	/^struct sw_flow_key {$/;"	s
sw_flow_key_range	.\datapath\flow.h	/^struct sw_flow_key_range {$/;"	s
sw_flow_mask	.\datapath\flow.h	/^struct sw_flow_mask {$/;"	s
sw_flow_mask_set	.\datapath\flow_netlink.c	/^static void sw_flow_mask_set(struct sw_flow_mask *mask,$/;"	f	file:
sw_flow_match	.\datapath\flow.h	/^struct sw_flow_match {$/;"	s
swap	.\tests\test-classifier.c	/^swap(int *a, int *b)$/;"	f	file:
swap	.\tests\test-heap.c	/^swap(uint32_t *a, uint32_t *b)$/;"	f	file:
swap_nodes	.\lib\heap.c	/^swap_nodes(struct heap *heap, size_t i, size_t j)$/;"	f	file:
swap_rows	.\ovsdb\ovsdb-client.c	/^swap_rows(size_t a_y, size_t b_y, void *aux_)$/;"	f	file:
swap_uint64	.\lib\netdev-linux.c	/^swap_uint64(uint64_t *a, uint64_t *b)$/;"	f	file:
switch_	.\tests\test-controller.c	/^struct switch_ {$/;"	s	file:
switch_fault_status	.\lib\vtep-idl.h	/^	char **switch_fault_status;$/;"	m	struct:vteprec_physical_switch
switches	.\lib\vtep-idl.h	/^	struct vteprec_physical_switch **switches;$/;"	m	struct:vteprec_global	typeref:struct:vteprec_global::vteprec_physical_switch
symtab	.\ovsdb\execution.c	/^    struct ovsdb_symbol_table *symtab;$/;"	m	struct:ovsdb_execution	typeref:struct:ovsdb_execution::ovsdb_symbol_table	file:
symtab	.\utilities\ovs-vsctl.c	/^    struct ovsdb_symbol_table *symtab;$/;"	m	struct:vsctl_context	typeref:struct:vsctl_context::ovsdb_symbol_table	file:
symtab	.\vtep\vtep-ctl.c	/^    struct ovsdb_symbol_table *symtab;$/;"	m	struct:vtep_ctl_context	typeref:struct:vtep_ctl_context::ovsdb_symbol_table	file:
sync	.\datapath\datapath.h	/^	struct u64_stats_sync sync;$/;"	m	struct:dp_stats_percpu	typeref:struct:dp_stats_percpu::u64_stats_sync
syncController	.\xenserver\usr_lib_xsconsole_plugins-base_XSFeatureVSwitch.py	/^    def syncController(self):$/;"	m	class:VSwitchControllerDialogue
syncp	.\datapath\linux\compat\include\linux\netdevice.h	/^	struct u64_stats_sync   syncp;$/;"	m	struct:pcpu_sw_netstats	typeref:struct:pcpu_sw_netstats::u64_stats_sync
syntax	.\lib\ovsdb-error.c	/^    char *syntax;               \/* String for "syntax" member. *\/$/;"	m	struct:ovsdb_error	file:
syntax	.\utilities\ovs-vsctl.c	/^    const struct vsctl_command_syntax *syntax;$/;"	m	struct:vsctl_command	typeref:struct:vsctl_command::vsctl_command_syntax	file:
syntax	.\vtep\vtep-ctl.c	/^    const struct vtep_ctl_command_syntax *syntax;$/;"	m	struct:vtep_ctl_command	typeref:struct:vtep_ctl_command::vtep_ctl_command_syntax	file:
syntax_rl	.\lib\ovsdb-idl.c	/^static struct vlog_rate_limit syntax_rl = VLOG_RATE_LIMIT_INIT(1, 5);$/;"	v	typeref:struct:vlog_rate_limit	file:
synth_local_iface	.\vswitchd\bridge.c	/^    struct ovsrec_interface synth_local_iface;$/;"	m	struct:bridge	typeref:struct:bridge::ovsrec_interface	file:
synth_local_ifacep	.\vswitchd\bridge.c	/^    struct ovsrec_interface *synth_local_ifacep;$/;"	m	struct:bridge	typeref:struct:bridge::ovsrec_interface	file:
synth_local_port	.\vswitchd\bridge.c	/^    struct ovsrec_port synth_local_port;$/;"	m	struct:bridge	typeref:struct:bridge::ovsrec_port	file:
synthesize_splinter_port	.\vswitchd\bridge.c	/^synthesize_splinter_port(const char *real_dev_name,$/;"	f	file:
sys	.\python\compat\uuid.py	/^    import sys$/;"	i
sys	.\python\ovs\daemon.py	/^import sys$/;"	i
sys	.\python\ovs\db\schema.py	/^import sys$/;"	i
sys	.\python\ovs\db\types.py	/^import sys$/;"	i
sys	.\python\ovs\json.py	/^import sys$/;"	i
sys	.\python\ovs\socket_util.py	/^import sys$/;"	i
sys	.\python\ovs\util.py	/^import sys$/;"	i
sys	.\python\ovs\vlog.py	/^import sys$/;"	i
sys	.\python\ovstest\args.py	/^import sys$/;"	i
sys	.\python\ovstest\rpcserver.py	/^import sys$/;"	i
sys	.\tests\appctl.py	/^import sys$/;"	i
sys	.\tests\test-daemon.py	/^import sys$/;"	i
sys	.\tests\test-json.py	/^import sys$/;"	i
sys	.\tests\test-jsonrpc.py	/^import sys$/;"	i
sys	.\tests\test-ovsdb.py	/^import sys$/;"	i
sys	.\tests\test-reconnect.py	/^import sys$/;"	i
sys	.\tests\test-unix-socket.py	/^import sys$/;"	i
sys	.\tests\test-unixctl.py	/^import sys$/;"	i
sys	.\utilities\ovs-dev.py	/^import sys$/;"	i
sys	.\xenserver\opt_xensource_libexec_InterfaceReconfigure.py	/^import sys$/;"	i
sys	.\xenserver\opt_xensource_libexec_InterfaceReconfigureBridge.py	/^import sys$/;"	i
sys_id	.\lib\lacp.c	/^    uint8_t sys_id[ETH_ADDR_LEN]; \/* System ID. *\/$/;"	m	struct:lacp	file:
sys_priority	.\lib\lacp.c	/^    uint16_t sys_priority;        \/* System Priority. *\/$/;"	m	struct:lacp	file:
sysconfdir	.\python\ovs\dirs.py	/^    sysconfdir = os.environ.get("OVS_SYSCONFDIR")$/;"	v
sysfs_bonding_masters	.\xenserver\opt_xensource_libexec_InterfaceReconfigureBridge.py	/^sysfs_bonding_masters = root_prefix() + "\/sys\/class\/net\/bonding_masters"$/;"	v
syslog	.\include\windows\syslog.h	/^syslog(int priority OVS_UNUSED, const char *format OVS_UNUSED, ...)$/;"	f
syslog	.\xenserver\opt_xensource_libexec_InterfaceReconfigure.py	/^import syslog$/;"	i
syslog_levels	.\lib\vlog.c	/^static const int syslog_levels[VLL_N_LEVELS] = {$/;"	v	file:
system_id	.\ofproto\ofproto.h	/^    stp_identifier system_id;$/;"	m	struct:ofproto_stp_settings
system_stats	.\vswitchd\system-stats.c	/^VLOG_DEFINE_THIS_MODULE(system_stats);$/;"	v
system_stats_enable	.\vswitchd\system-stats.c	/^system_stats_enable(bool enable)$/;"	f
system_stats_run	.\vswitchd\system-stats.c	/^system_stats_run(void)$/;"	f
system_stats_thread_func	.\vswitchd\system-stats.c	/^system_stats_thread_func(void *arg OVS_UNUSED)$/;"	f	file:
system_stats_wait	.\vswitchd\system-stats.c	/^system_stats_wait(void)$/;"	f
system_type	.\lib\vswitch-idl.h	/^	char *system_type;$/;"	m	struct:ovsrec_open_vswitch
system_version	.\lib\vswitch-idl.h	/^	char *system_version;$/;"	m	struct:ovsrec_open_vswitch
sysuptime	.\lib\netflow.h	/^    ovs_be32 sysuptime;            \/* System uptime in milliseconds. *\/$/;"	m	struct:netflow_v5_header
t	.\lib\timer.h	/^    long long int t;$/;"	m	struct:timer
table	.\datapath\datapath.h	/^	struct flow_table table;$/;"	m	struct:datapath	typeref:struct:datapath::flow_table
table	.\include\openflow\nicira-ext.h	/^    uint8_t table;                  \/* NXAST_RESUBMIT_TABLE: table to use. *\/$/;"	m	struct:nx_action_resubmit
table	.\lib\mac-learning.h	/^    struct hmap table;          \/* Learning table. *\/$/;"	m	struct:mac_learning	typeref:struct:mac_learning::hmap
table	.\lib\ovsdb-idl-provider.h	/^    struct ovsdb_idl_table *table; \/* Containing table. *\/$/;"	m	struct:ovsdb_idl_row	typeref:struct:ovsdb_idl_row::ovsdb_idl_table
table	.\lib\table.h	/^struct table {$/;"	s
table	.\ovsdb\execution.c	/^    const struct ovsdb_table *table;$/;"	m	struct:delete_row_cbdata	typeref:struct:delete_row_cbdata::ovsdb_table	file:
table	.\ovsdb\file.c	/^    struct ovsdb_table *table;  \/* Table described in 'table_json'.  *\/$/;"	m	struct:ovsdb_file_txn	typeref:struct:ovsdb_file_txn::ovsdb_table	file:
table	.\ovsdb\jsonrpc-server.c	/^    const struct ovsdb_table *table;$/;"	m	struct:ovsdb_jsonrpc_monitor_table	typeref:struct:ovsdb_jsonrpc_monitor_table::ovsdb_table	file:
table	.\ovsdb\ovsdb-client.c	/^    struct ovsdb_table_schema *table;$/;"	m	struct:monitored_table	typeref:struct:monitored_table::ovsdb_table_schema	file:
table	.\ovsdb\row.h	/^    struct ovsdb_table *table;     \/* Table to which this belongs. *\/$/;"	m	struct:ovsdb_row	typeref:struct:ovsdb_row::ovsdb_table
table	.\ovsdb\transaction.c	/^    struct ovsdb_table *table;$/;"	m	struct:ovsdb_txn_row	typeref:struct:ovsdb_txn_row::ovsdb_table	file:
table	.\ovsdb\transaction.c	/^    struct ovsdb_table *table;$/;"	m	struct:ovsdb_txn_table	typeref:struct:ovsdb_txn_table::ovsdb_table	file:
table	.\utilities\ovs-vsctl.c	/^    const struct ovsdb_idl_table_class *table;$/;"	m	struct:cmd_show_table	typeref:struct:cmd_show_table::ovsdb_idl_table_class	file:
table	.\utilities\ovs-vsctl.c	/^    const struct ovsdb_idl_table_class *table;$/;"	m	struct:vsctl_row_id	typeref:struct:vsctl_row_id::ovsdb_idl_table_class	file:
table	.\utilities\ovs-vsctl.c	/^    struct table *table;$/;"	m	struct:vsctl_command	typeref:struct:vsctl_command::table	file:
table	.\utilities\ovs-vsctl.c	/^    struct table *table;$/;"	m	struct:vsctl_context	typeref:struct:vsctl_context::table	file:
table	.\vtep\vtep-ctl.c	/^    const struct ovsdb_idl_table_class *table;$/;"	m	struct:vtep_ctl_row_id	typeref:struct:vtep_ctl_row_id::ovsdb_idl_table_class	file:
table	.\vtep\vtep-ctl.c	/^    struct table *table;$/;"	m	struct:vtep_ctl_command	typeref:struct:vtep_ctl_command::table	file:
table	.\vtep\vtep-ctl.c	/^    struct table *table;$/;"	m	struct:vtep_ctl_context	typeref:struct:vtep_ctl_context::table	file:
table_action_features_equal	.\lib\ofp-print.c	/^table_action_features_equal(const struct ofputil_table_action_features *a,$/;"	f	file:
table_add_cell	.\lib\table.c	/^table_add_cell(struct table *table)$/;"	f
table_add_column	.\lib\table.c	/^table_add_column(struct table *table, const char *heading, ...)$/;"	f
table_add_row	.\lib\table.c	/^table_add_row(struct table *table)$/;"	f
table_by_name	.\lib\ovsdb-idl.c	/^    struct shash table_by_name;$/;"	m	struct:ovsdb_idl	typeref:struct:ovsdb_idl::shash	file:
table_cell__	.\lib\table.c	/^table_cell__(const struct table *table, size_t row, size_t column)$/;"	f	file:
table_destroy	.\lib\table.c	/^table_destroy(struct table *table)$/;"	f
table_escape_html_text__	.\lib\table.c	/^table_escape_html_text__(const char *s, size_t n)$/;"	f	file:
table_format	.\lib\table.h	/^enum table_format {$/;"	g
table_format_timestamp__	.\lib\table.c	/^table_format_timestamp__(void)$/;"	f	file:
table_id	.\include\openflow\nicira-ext.h	/^    uint8_t table_id;           \/* ID of flow's table. *\/$/;"	m	struct:nx_flow_update_full
table_id	.\include\openflow\nicira-ext.h	/^    uint8_t table_id;           \/* One table's ID or 0xff for all tables. *\/$/;"	m	struct:nx_flow_monitor_request
table_id	.\include\openflow\nicira-ext.h	/^    uint8_t table_id;           \/* Table to insert flow entry. *\/$/;"	m	struct:nx_action_learn
table_id	.\include\openflow\nicira-ext.h	/^    uint8_t table_id;         \/* Flow's former table ID, plus one. *\/$/;"	m	struct:nx_flow_removed
table_id	.\include\openflow\nicira-ext.h	/^    uint8_t table_id;         \/* ID of table flow came from. *\/$/;"	m	struct:nx_flow_stats
table_id	.\include\openflow\nicira-ext.h	/^    uint8_t table_id;         \/* ID of table to read (from ofp_table_stats)$/;"	m	struct:nx_aggregate_stats_request
table_id	.\include\openflow\nicira-ext.h	/^    uint8_t table_id;         \/* ID of table to read (from ofp_table_stats)$/;"	m	struct:nx_flow_stats_request
table_id	.\include\openflow\nicira-ext.h	/^    uint8_t table_id;         \/* ID of the table that was looked up. *\/$/;"	m	struct:nx_packet_in
table_id	.\include\openflow\openflow-1.0.h	/^    uint8_t table_id;         \/* ID of table flow came from. *\/$/;"	m	struct:ofp10_flow_stats
table_id	.\include\openflow\openflow-1.0.h	/^    uint8_t table_id;         \/* ID of table to read (from ofp_table_stats)$/;"	m	struct:ofp10_flow_stats_request
table_id	.\include\openflow\openflow-1.0.h	/^    uint8_t table_id;        \/* Identifier of table.  Lower numbered tables$/;"	m	struct:ofp10_table_stats
table_id	.\include\openflow\openflow-1.1.h	/^    uint8_t table_id;              \/* Set next table in the lookup pipeline *\/$/;"	m	struct:ofp11_instruction_goto_table
table_id	.\include\openflow\openflow-1.1.h	/^    uint8_t table_id;            \/* ID of the table to put the flow in *\/$/;"	m	struct:ofp11_flow_mod
table_id	.\include\openflow\openflow-1.1.h	/^    uint8_t table_id;          \/* ID of table flow came from. *\/$/;"	m	struct:ofp11_flow_stats
table_id	.\include\openflow\openflow-1.1.h	/^    uint8_t table_id;         \/* ID of table to read (from ofp_table_stats),$/;"	m	struct:ofp11_flow_stats_request
table_id	.\include\openflow\openflow-1.1.h	/^    uint8_t table_id;         \/* ID of the table *\/$/;"	m	struct:ofp11_flow_removed
table_id	.\include\openflow\openflow-1.1.h	/^    uint8_t table_id;        \/* Identifier of table. Lower numbered tables$/;"	m	struct:ofp11_table_stats
table_id	.\include\openflow\openflow-1.1.h	/^    uint8_t table_id;       \/* ID of the table that was looked up *\/$/;"	m	struct:ofp11_packet_in
table_id	.\include\openflow\openflow-1.1.h	/^    uint8_t table_id;       \/* ID of the table, 0xFF indicates all tables *\/$/;"	m	struct:ofp11_table_mod
table_id	.\include\openflow\openflow-1.2.h	/^    uint8_t table_id;         \/* ID of the table *\/$/;"	m	struct:ofp12_flow_removed
table_id	.\include\openflow\openflow-1.2.h	/^    uint8_t table_id;        \/* Identifier of table.  Lower numbered tables$/;"	m	struct:ofp12_table_stats
table_id	.\include\openflow\openflow-1.2.h	/^    uint8_t table_id;       \/* ID of the table that was looked up *\/$/;"	m	struct:ofp12_packet_in
table_id	.\include\openflow\openflow-1.3.h	/^    uint8_t  table_id;      \/* Identifier of table. Lower numbered tables are$/;"	m	struct:ofp13_action_self_learning::ofp13_table_stats
table_id	.\include\openflow\openflow-1.3.h	/^    uint8_t table_id;         \/* Identifier of table. Lower numbered tables$/;"	m	struct:ofp13_action_self_learning::ofp13_table_features
table_id	.\include\openflow\openflow-1.4.h	/^    uint8_t table_id;     \/* ID of the table, OFPTT_ALL indicates all tables *\/$/;"	m	struct:ofp14_table_mod
table_id	.\lib\ofp-actions.h	/^    uint8_t table_id;           \/* Table to insert flow entry. *\/$/;"	m	struct:ofpact_learn
table_id	.\lib\ofp-actions.h	/^    uint8_t table_id;$/;"	m	struct:ofpact_goto_table
table_id	.\lib\ofp-actions.h	/^    uint8_t table_id;$/;"	m	struct:ofpact_resubmit
table_id	.\lib\ofp-util.h	/^    uint8_t table_id;                    \/* OpenFlow table ID. *\/$/;"	m	struct:ofputil_packet_in
table_id	.\lib\ofp-util.h	/^    uint8_t table_id;           \/* 255 if message didn't include table ID. *\/$/;"	m	struct:ofputil_flow_removed
table_id	.\lib\ofp-util.h	/^    uint8_t table_id;         \/* ID of the table, 0xff indicates all tables. *\/$/;"	m	struct:ofputil_table_mod
table_id	.\lib\ofp-util.h	/^    uint8_t table_id;         \/* Identifier of table. Lower numbered tables$/;"	m	struct:ofputil_table_features
table_id	.\lib\ofp-util.h	/^    uint8_t table_id;$/;"	m	struct:ofputil_flow_mod
table_id	.\lib\ofp-util.h	/^    uint8_t table_id;$/;"	m	struct:ofputil_flow_monitor_request
table_id	.\lib\ofp-util.h	/^    uint8_t table_id;$/;"	m	struct:ofputil_flow_stats
table_id	.\lib\ofp-util.h	/^    uint8_t table_id;$/;"	m	struct:ofputil_flow_stats_request
table_id	.\lib\ofp-util.h	/^    uint8_t table_id;$/;"	m	struct:ofputil_flow_update
table_id	.\ofproto\connmgr.h	/^    uint8_t table_id;$/;"	m	struct:ofmonitor
table_id	.\ofproto\ofproto-dpif-xlate.c	/^    uint8_t table_id;           \/* OpenFlow table ID where flow was found. *\/$/;"	m	struct:xlate_ctx	file:
table_id	.\ofproto\ofproto-provider.h	/^    const uint8_t table_id;        \/* Index in ofproto's 'tables' array. *\/$/;"	m	struct:rule
table_id	.\ofproto\ofproto.c	/^    uint8_t table_id;$/;"	m	struct:rule_criteria	file:
table_init	.\lib\table.c	/^table_init(struct table *table)$/;"	f
table_instance	.\datapath\flow_table.h	/^struct table_instance {$/;"	s
table_instance_alloc	.\datapath\flow_table.c	/^static struct table_instance *table_instance_alloc(int new_size)$/;"	f	file:
table_instance_destroy	.\datapath\flow_table.c	/^static void table_instance_destroy(struct table_instance *ti, bool deferred)$/;"	f	file:
table_instance_expand	.\datapath\flow_table.c	/^static struct table_instance *table_instance_expand(struct table_instance *ti)$/;"	f	file:
table_instance_insert	.\datapath\flow_table.c	/^static void table_instance_insert(struct table_instance *ti, struct sw_flow *flow)$/;"	f	file:
table_instance_rehash	.\datapath\flow_table.c	/^static struct table_instance *table_instance_rehash(struct table_instance *ti,$/;"	f	file:
table_instruction_features_equal	.\lib\ofp-print.c	/^table_instruction_features_equal($/;"	f	file:
table_is_internal	.\ofproto\ofproto-dpif.c	/^table_is_internal(uint8_t table_id)$/;"	f
table_json	.\ovsdb\file.c	/^    struct json *table_json;    \/* JSON for 'table''s transaction. *\/$/;"	m	struct:ovsdb_file_txn	typeref:struct:ovsdb_file_txn::json	file:
table_mod	.\ofproto\ofproto.c	/^table_mod(struct ofproto *ofproto, const struct ofputil_table_mod *tm)$/;"	f	file:
table_parse_cell_format	.\lib\table.c	/^table_parse_cell_format(struct table_style *style, const char *format)$/;"	f
table_parse_format	.\lib\table.c	/^table_parse_format(struct table_style *style, const char *format)$/;"	f
table_print	.\lib\table.c	/^table_print(const struct table *table, const struct table_style *style)$/;"	f
table_print_csv__	.\lib\table.c	/^table_print_csv__(const struct table *table, const struct table_style *style)$/;"	f	file:
table_print_csv_cell__	.\lib\table.c	/^table_print_csv_cell__(const char *content)$/;"	f	file:
table_print_html__	.\lib\table.c	/^table_print_html__(const struct table *table, const struct table_style *style)$/;"	f	file:
table_print_html_cell__	.\lib\table.c	/^table_print_html_cell__(const char *element, const char *content)$/;"	f	file:
table_print_json__	.\lib\table.c	/^table_print_json__(const struct table *table, const struct table_style *style)$/;"	f	file:
table_print_list__	.\lib\table.c	/^table_print_list__(const struct table *table, const struct table_style *style)$/;"	f	file:
table_print_table__	.\lib\table.c	/^table_print_table__(const struct table *table, const struct table_style *style)$/;"	f	file:
table_print_table_line__	.\lib\table.c	/^table_print_table_line__(struct ds *line)$/;"	f	file:
table_print_timestamp__	.\lib\table.c	/^table_print_timestamp__(const struct table *table)$/;"	f	file:
table_set_caption	.\lib\table.c	/^table_set_caption(struct table *table, char *caption)$/;"	f
table_set_timestamp	.\lib\table.c	/^table_set_timestamp(struct table *table, bool timestamp)$/;"	f
table_style	.\lib\table.h	/^struct table_style {$/;"	s
table_style	.\ovsdb\ovsdb-client.c	/^static struct table_style table_style = TABLE_STYLE_DEFAULT;$/;"	v	typeref:struct:table_style	file:
table_style	.\utilities\ovs-vsctl.c	/^static struct table_style table_style = TABLE_STYLE_DEFAULT;$/;"	v	typeref:struct:table_style	file:
table_style	.\vtep\vtep-ctl.c	/^static struct table_style table_style = TABLE_STYLE_DEFAULT;$/;"	v	typeref:struct:table_style	file:
tables	.\lib\ovsdb-idl-provider.h	/^    const struct ovsdb_idl_table_class *tables;$/;"	m	struct:ovsdb_idl_class	typeref:struct:ovsdb_idl_class::ovsdb_idl_table_class
tables	.\lib\ovsdb-idl.c	/^    struct ovsdb_idl_table *tables; \/* Contains "struct ovsdb_idl_table *"s.*\/$/;"	m	struct:ovsdb_idl	typeref:struct:ovsdb_idl::ovsdb_idl_table	file:
tables	.\ofproto\ofproto-provider.h	/^    struct oftable *tables;$/;"	m	struct:ofproto	typeref:struct:ofproto::oftable
tables	.\ovsdb\jsonrpc-server.c	/^    struct shash tables;     \/* Holds "struct ovsdb_jsonrpc_monitor_table"s. *\/$/;"	m	struct:ovsdb_jsonrpc_monitor	typeref:struct:ovsdb_jsonrpc_monitor::shash	file:
tables	.\ovsdb\ovsdb.h	/^    struct shash tables;        \/* Contains "struct ovsdb_table *"s. *\/$/;"	m	struct:ovsdb	typeref:struct:ovsdb::shash
tables	.\ovsdb\ovsdb.h	/^    struct shash tables;        \/* Contains "struct ovsdb_table_schema *"s. *\/$/;"	m	struct:ovsdb_schema	typeref:struct:ovsdb_schema::shash
tables	.\utilities\ovs-vsctl.c	/^static const struct vsctl_table_class tables[] = {$/;"	v	typeref:struct:vsctl_table_class	file:
tables	.\vtep\vtep-ctl.c	/^static const struct vtep_ctl_table_class tables[] = {$/;"	v	typeref:struct:vtep_ctl_table_class	file:
tag	.\lib\classifier.c	/^    tag_type tag;               \/* Tag generated from mask for partitioning. *\/$/;"	m	struct:cls_subtable	file:
tag	.\lib\classifier.c	/^    tag_type tag;$/;"	m	struct:cls_subtable_entry	file:
tag	.\lib\ovsdb-error.c	/^    const char *tag;            \/* String for "error" member. *\/$/;"	m	struct:ovsdb_error	file:
tag	.\lib\sflow.h	/^    u_int32_t tag;  \/* SFLFlow_type_tag *\/$/;"	m	struct:_SFLFlow_sample_element
tag	.\lib\sflow.h	/^    u_int32_t tag; \/* SFLCounters_type_tag *\/$/;"	m	struct:_SFLCounters_sample_element
tag	.\lib\vswitch-idl.h	/^	int64_t *tag;$/;"	m	struct:ovsrec_port
tag	.\utilities\ovs-dev.py	/^def tag():$/;"	f
tag_create_deterministic	.\lib\tag.c	/^tag_create_deterministic(uint32_t seed)$/;"	f
tag_intersects	.\lib\tag.h	/^tag_intersects(tag_type a, tag_type b)$/;"	f
tag_tracker	.\lib\tag.h	/^struct tag_tracker {$/;"	s
tag_tracker_add	.\lib\tag.c	/^tag_tracker_add(struct tag_tracker *tracker, tag_type *tags, tag_type add)$/;"	f
tag_tracker_init	.\lib\tag.c	/^tag_tracker_init(struct tag_tracker *tracker)$/;"	f
tag_tracker_subtract	.\lib\tag.c	/^tag_tracker_subtract(struct tag_tracker *tracker, tag_type *tags, tag_type sub)$/;"	f
tag_type	.\lib\tag.h	/^typedef uint32_t tag_type;$/;"	t
tags	.\lib\classifier.c	/^    tag_type tags;              \/* OR of each flow's cls_subtable tag. *\/$/;"	m	struct:cls_partition	file:
tail	.\lib\byteq.h	/^    unsigned int tail;          \/* Chases the head. *\/$/;"	m	struct:byteq
take_action	.\python\compat\argparse.py	/^        def take_action(action, argument_strings, option_string=None):$/;"	f	function:ArgumentParser._parse_known_args
tap_fd	.\lib\netdev-bsd.c	/^    int tap_fd;         \/* TAP character device, if any, otherwise -1. *\/$/;"	m	struct:netdev_bsd	file:
tap_fd	.\lib\netdev-linux.c	/^    int tap_fd;$/;"	m	struct:netdev_linux	file:
target	.\datapath\flow.h	/^				struct in6_addr target;	\/* ND target address. *\/$/;"	m	struct:sw_flow_key::__anon5::__anon9::__anon11	typeref:struct:sw_flow_key::__anon5::__anon9::__anon11::in6_addr
target	.\lib\classifier.h	/^    const struct cls_rule *target;$/;"	m	struct:cls_cursor	typeref:struct:cls_cursor::cls_rule
target	.\lib\rconn.c	/^    char *target;               \/* vconn name, passed to vconn_open(). *\/$/;"	m	struct:rconn	file:
target	.\lib\vswitch-idl.h	/^	char *target;	\/* Always nonnull. *\/$/;"	m	struct:ovsrec_controller
target	.\lib\vswitch-idl.h	/^	char *target;	\/* Always nonnull. *\/$/;"	m	struct:ovsrec_manager
target	.\lib\vtep-idl.h	/^	char *target;	\/* Always nonnull. *\/$/;"	m	struct:vteprec_manager
target	.\ofproto\ofproto.h	/^    char *target;               \/* e.g. "tcp:127.0.0.1" *\/$/;"	m	struct:ofproto_controller
targets	.\lib\vswitch-idl.h	/^	char **targets;$/;"	m	struct:ovsrec_ipfix
targets	.\lib\vswitch-idl.h	/^	char **targets;$/;"	m	struct:ovsrec_netflow
targets	.\lib\vswitch-idl.h	/^	char **targets;$/;"	m	struct:ovsrec_sflow
targets	.\ofproto\ofproto.h	/^    struct sset targets;$/;"	m	struct:ofproto_ipfix_bridge_exporter_options	typeref:struct:ofproto_ipfix_bridge_exporter_options::sset
targets	.\ofproto\ofproto.h	/^    struct sset targets;$/;"	m	struct:ofproto_ipfix_flow_exporter_options	typeref:struct:ofproto_ipfix_flow_exporter_options::sset
targets	.\ofproto\ofproto.h	/^    struct sset targets;$/;"	m	struct:ofproto_sflow_options	typeref:struct:ofproto_sflow_options::sset
tbl_mask_array_alloc	.\datapath\flow_table.c	/^static struct mask_array *tbl_mask_array_alloc(int size)$/;"	f	file:
tbl_mask_array_delete_mask	.\datapath\flow_table.c	/^static void tbl_mask_array_delete_mask(struct mask_array *ma,$/;"	f	file:
tbl_mask_array_realloc	.\datapath\flow_table.c	/^static int tbl_mask_array_realloc(struct flow_table *tbl, int size)$/;"	f	file:
tc	.\include\openflow\nicira-ext.h	/^    uint8_t  tc;                    \/* TC *\/$/;"	m	struct:nx_action_mpls_tc
tc	.\lib\netdev-linux.c	/^    struct tc *tc;$/;"	m	struct:netdev_linux	typeref:struct:netdev_linux::tc	file:
tc	.\lib\netdev-linux.c	/^    struct tc tc;$/;"	m	struct:hfsc	typeref:struct:hfsc::tc	file:
tc	.\lib\netdev-linux.c	/^    struct tc tc;$/;"	m	struct:htb	typeref:struct:htb::tc	file:
tc	.\lib\netdev-linux.c	/^struct tc {$/;"	s	file:
tc	.\lib\ofp-actions.h	/^    uint8_t tc;$/;"	m	struct:ofpact_mpls_tc
tc	.\tests\test-stp.c	/^    struct test_case *tc;$/;"	m	struct:bridge	typeref:struct:bridge::test_case	file:
tc	.\tests\test-stp.c	/^    struct test_case *tc;$/;"	m	struct:lan	typeref:struct:lan::test_case	file:
tc_add_del_ingress_qdisc	.\lib\netdev-linux.c	/^tc_add_del_ingress_qdisc(struct netdev *netdev, bool add)$/;"	f	file:
tc_add_policer	.\lib\netdev-linux.c	/^tc_add_policer(struct netdev *netdev, int kbits_rate, int kbits_burst)$/;"	f	file:
tc_buffer_per_jiffy	.\lib\netdev-linux.c	/^tc_buffer_per_jiffy(unsigned int rate)$/;"	f	file:
tc_bytes_to_ticks	.\lib\netdev-linux.c	/^tc_bytes_to_ticks(unsigned int rate, unsigned int size)$/;"	f	file:
tc_calc_buffer	.\lib\netdev-linux.c	/^tc_calc_buffer(unsigned int Bps, int mtu, uint64_t burst_bytes)$/;"	f	file:
tc_calc_cell_log	.\lib\netdev-linux.c	/^tc_calc_cell_log(unsigned int mtu)$/;"	f	file:
tc_del_qdisc	.\lib\netdev-linux.c	/^tc_del_qdisc(struct netdev *netdev_)$/;"	f	file:
tc_delete_class	.\lib\netdev-linux.c	/^tc_delete_class(const struct netdev *netdev, unsigned int handle)$/;"	f	file:
tc_destroy	.\lib\netdev-linux.c	/^    void (*tc_destroy)(struct tc *tc);$/;"	m	struct:tc_ops	file:
tc_destroy	.\lib\netdev-linux.c	/^tc_destroy(struct tc *tc)$/;"	f	file:
tc_fill_rate	.\lib\netdev-linux.c	/^tc_fill_rate(struct tc_ratespec *rate, uint64_t Bps, int mtu)$/;"	f	file:
tc_find_queue	.\lib\netdev-linux.c	/^tc_find_queue(const struct netdev *netdev, unsigned int queue_id)$/;"	f	file:
tc_find_queue__	.\lib\netdev-linux.c	/^tc_find_queue__(const struct netdev *netdev_, unsigned int queue_id,$/;"	f	file:
tc_get_major	.\lib\netdev-linux.c	/^tc_get_major(unsigned int handle)$/;"	f	file:
tc_get_minor	.\lib\netdev-linux.c	/^tc_get_minor(unsigned int handle)$/;"	f	file:
tc_init	.\lib\netdev-linux.c	/^tc_init(struct tc *tc, const struct tc_ops *ops)$/;"	f	file:
tc_install	.\lib\netdev-linux.c	/^    int (*tc_install)(struct netdev *netdev, const struct smap *details);$/;"	m	struct:tc_ops	file:
tc_load	.\lib\netdev-linux.c	/^    int (*tc_load)(struct netdev *netdev, struct ofpbuf *nlmsg);$/;"	m	struct:tc_ops	file:
tc_lookup_linux_name	.\lib\netdev-linux.c	/^tc_lookup_linux_name(const char *name)$/;"	f	file:
tc_lookup_ovs_name	.\lib\netdev-linux.c	/^tc_lookup_ovs_name(const char *name)$/;"	f	file:
tc_make_handle	.\lib\netdev-linux.c	/^tc_make_handle(unsigned int major, unsigned int minor)$/;"	f	file:
tc_make_request	.\lib\netdev-linux.c	/^tc_make_request(const struct netdev *netdev, int type, unsigned int flags,$/;"	f	file:
tc_ops	.\lib\netdev-linux.c	/^struct tc_ops {$/;"	s	file:
tc_ops_default	.\lib\netdev-linux.c	/^static const struct tc_ops tc_ops_default = {$/;"	v	typeref:struct:tc_ops	file:
tc_ops_default	.\lib\netdev-linux.c	/^static const struct tc_ops tc_ops_default;$/;"	v	typeref:struct:tc_ops	file:
tc_ops_hfsc	.\lib\netdev-linux.c	/^static const struct tc_ops tc_ops_hfsc = {$/;"	v	typeref:struct:tc_ops	file:
tc_ops_hfsc	.\lib\netdev-linux.c	/^static const struct tc_ops tc_ops_hfsc;$/;"	v	typeref:struct:tc_ops	file:
tc_ops_htb	.\lib\netdev-linux.c	/^static const struct tc_ops tc_ops_htb = {$/;"	v	typeref:struct:tc_ops	file:
tc_ops_htb	.\lib\netdev-linux.c	/^static const struct tc_ops tc_ops_htb;$/;"	v	typeref:struct:tc_ops	file:
tc_ops_other	.\lib\netdev-linux.c	/^static const struct tc_ops tc_ops_other = {$/;"	v	typeref:struct:tc_ops	file:
tc_ops_other	.\lib\netdev-linux.c	/^static const struct tc_ops tc_ops_other;$/;"	v	typeref:struct:tc_ops	file:
tc_parse_class	.\lib\netdev-linux.c	/^tc_parse_class(const struct ofpbuf *msg, unsigned int *handlep,$/;"	f	file:
tc_parse_qdisc	.\lib\netdev-linux.c	/^tc_parse_qdisc(const struct ofpbuf *msg, const char **kind,$/;"	f	file:
tc_put_rtab	.\lib\netdev-linux.c	/^tc_put_rtab(struct ofpbuf *msg, uint16_t type, const struct tc_ratespec *rate)$/;"	f	file:
tc_query_class	.\lib\netdev-linux.c	/^tc_query_class(const struct netdev *netdev,$/;"	f	file:
tc_query_qdisc	.\lib\netdev-linux.c	/^tc_query_qdisc(const struct netdev *netdev_)$/;"	f	file:
tc_queue	.\lib\netdev-linux.c	/^    struct tc_queue tc_queue;$/;"	m	struct:hfsc_class	typeref:struct:hfsc_class::tc_queue	file:
tc_queue	.\lib\netdev-linux.c	/^    struct tc_queue tc_queue;$/;"	m	struct:htb_class	typeref:struct:htb_class::tc_queue	file:
tc_queue	.\lib\netdev-linux.c	/^struct tc_queue {$/;"	s	file:
tc_ticks_to_bytes	.\lib\netdev-linux.c	/^tc_ticks_to_bytes(unsigned int rate, unsigned int ticks)$/;"	f	file:
tc_transact	.\lib\netdev-linux.c	/^tc_transact(struct ofpbuf *request, struct ofpbuf **replyp)$/;"	f	file:
tci	.\datapath\flow.h	/^		__be16 tci;		\/* 0 if no VLAN, VLAN_TAG_PRESENT set otherwise. *\/$/;"	m	struct:sw_flow_key::__anon2
tcls	.\tests\test-classifier.c	/^struct tcls {$/;"	s	file:
tcls_delete_matches	.\tests\test-classifier.c	/^tcls_delete_matches(struct tcls *cls, const struct cls_rule *target)$/;"	f	file:
tcls_destroy	.\tests\test-classifier.c	/^tcls_destroy(struct tcls *tcls)$/;"	f	file:
tcls_init	.\tests\test-classifier.c	/^tcls_init(struct tcls *tcls)$/;"	f	file:
tcls_insert	.\tests\test-classifier.c	/^tcls_insert(struct tcls *tcls, const struct test_rule *rule)$/;"	f	file:
tcls_is_empty	.\tests\test-classifier.c	/^tcls_is_empty(const struct tcls *tcls)$/;"	f	file:
tcls_lookup	.\tests\test-classifier.c	/^tcls_lookup(const struct tcls *cls, const struct flow *flow)$/;"	f	file:
tcls_remove	.\tests\test-classifier.c	/^tcls_remove(struct tcls *cls, const struct test_rule *rule)$/;"	f	file:
tcn_timer	.\lib\stp.c	/^    struct stp_timer tcn_timer;     \/* 8.5.4.2: Topology change timer. *\/$/;"	m	struct:stp	typeref:struct:stp::stp_timer	file:
tcp	.\python\ovstest\rpcserver.py	/^import tcp$/;"	i
tcp_ack	.\lib\packets.h	/^    ovs_16aligned_be32 tcp_ack;$/;"	m	struct:tcp_header
tcp_csum	.\lib\packets.h	/^    ovs_be16 tcp_csum;$/;"	m	struct:tcp_header
tcp_ctl	.\lib\packets.h	/^    ovs_be16 tcp_ctl;$/;"	m	struct:tcp_header
tcp_dst	.\include\linux\openvswitch.h	/^	__be16 tcp_dst;$/;"	m	struct:ovs_key_tcp
tcp_dst	.\lib\packets.h	/^    ovs_be16 tcp_dst;$/;"	m	struct:tcp_header
tcp_flags	.\datapath\flow.h	/^	__be16 tcp_flags;		\/* Union of seen TCP flags. *\/$/;"	m	struct:flow_stats
tcp_flags	.\lib\dpif-linux.c	/^    const uint8_t *tcp_flags;           \/* OVS_FLOW_ATTR_TCP_FLAGS. *\/$/;"	m	struct:dpif_linux_flow	file:
tcp_flags	.\lib\dpif.h	/^    uint16_t tcp_flags;$/;"	m	struct:dpif_flow_stats
tcp_flags	.\lib\flow.h	/^    ovs_be16 tcp_flags;         \/* TCP flags. With L3 to avoid matching L4. *\/$/;"	m	struct:flow
tcp_flags	.\lib\netflow.h	/^    uint8_t  tcp_flags;            \/* Union of seen TCP flags. *\/$/;"	m	struct:netflow_v5_record
tcp_flags	.\lib\sflow.h	/^    u_int32_t tcp_flags;    \/* TCP flags *\/$/;"	m	struct:_SFLSampled_ipv6
tcp_flags	.\lib\sflow.h	/^    u_int32_t tcp_flags;   \/* TCP flags *\/$/;"	m	struct:_SFLSampled_ipv4
tcp_flags	.\ofproto\netflow.c	/^    uint16_t tcp_flags;           \/* Bitwise-OR of all TCP flags seen. *\/$/;"	m	struct:netflow_flow	file:
tcp_flags	.\ofproto\ofproto-dpif-xlate.h	/^    uint16_t tcp_flags;$/;"	m	struct:xlate_in
tcp_hdr	.\datapath\linux\compat\include\linux\tcp.h	/^static inline struct tcphdr *tcp_hdr(const struct sk_buff *skb)$/;"	f
tcp_hdrlen	.\datapath\linux\compat\include\linux\tcp.h	/^static inline unsigned int tcp_hdrlen(const struct sk_buff *skb)$/;"	f
tcp_header	.\lib\packets.h	/^struct tcp_header {$/;"	s
tcp_key	.\lib\pcap-file.c	/^struct tcp_key {$/;"	s	file:
tcp_open	.\lib\stream-tcp.c	/^tcp_open(const char *name, char *suffix, struct stream **streamp, uint8_t dscp)$/;"	f	file:
tcp_reader	.\lib\pcap-file.c	/^struct tcp_reader {$/;"	s	file:
tcp_reader_close	.\lib\pcap-file.c	/^tcp_reader_close(struct tcp_reader *r)$/;"	f
tcp_reader_open	.\lib\pcap-file.c	/^tcp_reader_open(void)$/;"	f
tcp_reader_run	.\lib\pcap-file.c	/^tcp_reader_run(struct tcp_reader *r, const struct flow *flow,$/;"	f
tcp_seq	.\lib\packets.h	/^    ovs_16aligned_be32 tcp_seq;$/;"	m	struct:tcp_header
tcp_src	.\include\linux\openvswitch.h	/^	__be16 tcp_src;$/;"	m	struct:ovs_key_tcp
tcp_src	.\lib\packets.h	/^    ovs_be16 tcp_src;$/;"	m	struct:tcp_header
tcp_stream	.\lib\pcap-file.c	/^struct tcp_stream {$/;"	s	file:
tcp_stream_class	.\lib\stream-tcp.c	/^const struct stream_class tcp_stream_class = {$/;"	v	typeref:struct:stream_class
tcp_stream_destroy	.\lib\pcap-file.c	/^tcp_stream_destroy(struct tcp_reader *r, struct tcp_stream *stream)$/;"	f	file:
tcp_stream_lookup	.\lib\pcap-file.c	/^tcp_stream_lookup(struct tcp_reader *r,$/;"	f	file:
tcp_stream_new	.\lib\pcap-file.c	/^tcp_stream_new(struct tcp_reader *r, const struct tcp_key *key, uint32_t hash)$/;"	f	file:
tcp_urg	.\lib\packets.h	/^    ovs_be16 tcp_urg;$/;"	m	struct:tcp_header
tcp_vconn_class	.\lib\vconn-stream.c	/^const struct vconn_class tcp_vconn_class = STREAM_INIT("tcp");$/;"	v	typeref:struct:vconn_class
tcp_winsz	.\lib\packets.h	/^    ovs_be16 tcp_winsz;$/;"	m	struct:tcp_header
tcphdr_ok	.\datapath\flow.c	/^static bool tcphdr_ok(struct sk_buff *skb)$/;"	f	file:
tcs	.\lib\netdev-linux.c	/^static const struct tc_ops *const tcs[] = {$/;"	v	file:
tempfile	.\utilities\ovs-dev.py	/^import tempfile$/;"	i
template_id	.\ofproto\ofproto-dpif-ipfix.c	/^    uint16_t template_id;$/;"	m	struct:ipfix_flow_key	file:
test	.\tests\test-lockfile.c	/^struct test {$/;"	s	file:
test_accept_then_close	.\tests\test-vconn.c	/^test_accept_then_close(int argc OVS_UNUSED, char *argv[])$/;"	f	file:
test_aes128_main	.\tests\test-aes128.c	/^test_aes128_main(int argc, char *argv[])$/;"	f	file:
test_assert	.\tests\test-util.c	/^test_assert(int argc OVS_UNUSED, char *argv[] OVS_UNUSED)$/;"	f	file:
test_atomic_flag	.\tests\test-atomic.c	/^test_atomic_flag(void)$/;"	f	file:
test_atomic_main	.\tests\test-atomic.c	/^test_atomic_main(int argc OVS_UNUSED, char *argv[] OVS_UNUSED)$/;"	f	file:
test_big_vector	.\tests\test-sha1.c	/^test_big_vector(void)$/;"	f	file:
test_bitwise_copy	.\tests\test-util.c	/^test_bitwise_copy(int argc OVS_UNUSED, char *argv[] OVS_UNUSED)$/;"	f	file:
test_bitwise_is_all_zeros	.\tests\test-util.c	/^test_bitwise_is_all_zeros(int argc OVS_UNUSED, char *argv[] OVS_UNUSED)$/;"	f	file:
test_bitwise_one	.\tests\test-util.c	/^test_bitwise_one(int argc OVS_UNUSED, char *argv[] OVS_UNUSED)$/;"	f	file:
test_bitwise_zero	.\tests\test-util.c	/^test_bitwise_zero(int argc OVS_UNUSED, char *argv[] OVS_UNUSED)$/;"	f	file:
test_bundle_main	.\tests\test-bundle.c	/^test_bundle_main(int argc, char *argv[])$/;"	f	file:
test_byte_order_main	.\tests\test-byte-order.c	/^test_byte_order_main(int argc OVS_UNUSED, char *argv[] OVS_UNUSED)$/;"	f	file:
test_case	.\tests\test-csum.c	/^struct test_case {$/;"	s	file:
test_case	.\tests\test-stp.c	/^struct test_case {$/;"	s	file:
test_cases	.\tests\test-csum.c	/^static const struct test_case test_cases[] = {$/;"	v	typeref:struct:test_case	file:
test_classifier_main	.\tests\test-classifier.c	/^test_classifier_main(int argc, char *argv[])$/;"	f	file:
test_clz	.\tests\test-util.c	/^test_clz(int argc OVS_UNUSED, char *argv[] OVS_UNUSED)$/;"	f	file:
test_count_1bits	.\tests\test-util.c	/^test_count_1bits(int argc OVS_UNUSED, char *argv[] OVS_UNUSED)$/;"	f	file:
test_crc32c	.\tests\test-csum.c	/^test_crc32c(void)$/;"	f	file:
test_csum_main	.\tests\test-csum.c	/^test_csum_main(int argc OVS_UNUSED, char *argv[] OVS_UNUSED)$/;"	f	file:
test_ctz	.\tests\test-util.c	/^test_ctz(int argc OVS_UNUSED, char *argv[] OVS_UNUSED)$/;"	f	file:
test_destroy_null	.\tests\test-classifier.c	/^test_destroy_null(int argc OVS_UNUSED, char *argv[] OVS_UNUSED)$/;"	f	file:
test_empty	.\tests\test-classifier.c	/^test_empty(int argc OVS_UNUSED, char *argv[] OVS_UNUSED)$/;"	f	file:
test_filename_main	.\tests\test-file_name.c	/^test_filename_main(int argc, char *argv[])$/;"	f	file:
test_flows_main	.\tests\test-flows.c	/^test_flows_main(int argc OVS_UNUSED, char *argv[] OVS_UNUSED)$/;"	f	file:
test_follow_symlinks	.\tests\test-util.c	/^test_follow_symlinks(int argc, char *argv[])$/;"	f	file:
test_hash_main	.\tests\test-hash.c	/^test_hash_main(int argc OVS_UNUSED, char *argv[] OVS_UNUSED)$/;"	f	file:
test_heap_insert_delete_every_order	.\tests\test-heap.c	/^test_heap_insert_delete_every_order(int argc OVS_UNUSED,$/;"	f	file:
test_heap_insert_delete_reverse_order	.\tests\test-heap.c	/^test_heap_insert_delete_reverse_order(int argc OVS_UNUSED,$/;"	f	file:
test_heap_insert_delete_same_order	.\tests\test-heap.c	/^test_heap_insert_delete_same_order(int argc OVS_UNUSED,$/;"	f	file:
test_heap_insert_delete_same_order_with_dups	.\tests\test-heap.c	/^test_heap_insert_delete_same_order_with_dups(int argc OVS_UNUSED,$/;"	f	file:
test_heap_main	.\tests\test-heap.c	/^test_heap_main(int argc, char *argv[])$/;"	f	file:
test_heap_raw_delete	.\tests\test-heap.c	/^test_heap_raw_delete(int argc OVS_UNUSED, char *argv[] OVS_UNUSED)$/;"	f	file:
test_heap_raw_insert	.\tests\test-heap.c	/^test_heap_raw_insert(int argc OVS_UNUSED, char *argv[] OVS_UNUSED)$/;"	f	file:
test_hindex_for_each_safe	.\tests\test-hindex.c	/^test_hindex_for_each_safe(hash_func *hash)$/;"	f	file:
test_hindex_insert_delete	.\tests\test-hindex.c	/^test_hindex_insert_delete(hash_func *hash)$/;"	f	file:
test_hindex_main	.\tests\test-hindex.c	/^test_hindex_main(int argc OVS_UNUSED, char *argv[] OVS_UNUSED)$/;"	f	file:
test_hindex_reserve_shrink	.\tests\test-hindex.c	/^test_hindex_reserve_shrink(hash_func *hash)$/;"	f	file:
test_hmap_for_each_safe	.\tests\test-hmap.c	/^test_hmap_for_each_safe(hash_func *hash)$/;"	f	file:
test_hmap_insert_delete	.\tests\test-hmap.c	/^test_hmap_insert_delete(hash_func *hash)$/;"	f	file:
test_hmap_main	.\tests\test-hmap.c	/^test_hmap_main(int argc OVS_UNUSED, char *argv[] OVS_UNUSED)$/;"	f	file:
test_hmap_reserve_shrink	.\tests\test-hmap.c	/^test_hmap_reserve_shrink(hash_func *hash)$/;"	f	file:
test_insert_delete__	.\tests\test-heap.c	/^test_insert_delete__(struct element *elements,$/;"	f	file:
test_insert_delete_raw__	.\tests\test-heap.c	/^test_insert_delete_raw__(struct element *elements,$/;"	f	file:
test_ipv4_cidr	.\tests\test-packets.c	/^test_ipv4_cidr(void)$/;"	f	file:
test_ipv6_cidr	.\tests\test-packets.c	/^test_ipv6_cidr(void)$/;"	f	file:
test_ipv6_masking	.\tests\test-packets.c	/^test_ipv6_masking(void)$/;"	f	file:
test_ipv6_static_masks	.\tests\test-packets.c	/^test_ipv6_static_masks(void)$/;"	f	file:
test_json_main	.\tests\test-json.c	/^test_json_main(int argc, char *argv[])$/;"	f	file:
test_jsonrpc_main	.\tests\test-jsonrpc.c	/^test_jsonrpc_main(int argc, char *argv[])$/;"	f	file:
test_list_construction	.\tests\test-list.c	/^test_list_construction(void)$/;"	f	file:
test_list_for_each_safe	.\tests\test-list.c	/^test_list_for_each_safe(void)$/;"	f	file:
test_list_main	.\tests\test-list.c	/^test_list_main(int argc OVS_UNUSED, char *argv[] OVS_UNUSED)$/;"	f	file:
test_lockfile_main	.\tests\test-lockfile.c	/^test_lockfile_main(int argc, char *argv[])$/;"	f	file:
test_log_2_floor	.\tests\test-util.c	/^test_log_2_floor(int argc OVS_UNUSED, char *argv[] OVS_UNUSED)$/;"	f	file:
test_many_rules_in_five_tables	.\tests\test-classifier.c	/^test_many_rules_in_five_tables(int argc OVS_UNUSED, char *argv[] OVS_UNUSED)$/;"	f	file:
test_many_rules_in_n_tables	.\tests\test-classifier.c	/^test_many_rules_in_n_tables(int n_tables)$/;"	f	file:
test_many_rules_in_one_list	.\tests\test-classifier.c	/^test_many_rules_in_one_list (int argc OVS_UNUSED, char *argv[] OVS_UNUSED)$/;"	f	file:
test_many_rules_in_one_table	.\tests\test-classifier.c	/^test_many_rules_in_one_table(int argc OVS_UNUSED, char *argv[] OVS_UNUSED)$/;"	f	file:
test_many_rules_in_two_tables	.\tests\test-classifier.c	/^test_many_rules_in_two_tables(int argc OVS_UNUSED, char *argv[] OVS_UNUSED)$/;"	f	file:
test_miniflow	.\tests\test-classifier.c	/^test_miniflow(int argc OVS_UNUSED, char *argv[] OVS_UNUSED)$/;"	f	file:
test_minimask_combine	.\tests\test-classifier.c	/^test_minimask_combine(int argc OVS_UNUSED, char *argv[] OVS_UNUSED)$/;"	f	file:
test_minimask_has_extra	.\tests\test-classifier.c	/^test_minimask_has_extra(int argc OVS_UNUSED, char *argv[] OVS_UNUSED)$/;"	f	file:
test_multipath_main	.\tests\test-multipath.c	/^test_multipath_main(int argc, char *argv[])$/;"	f	file:
test_netflow_exit	.\tests\test-netflow.c	/^static unixctl_cb_func test_netflow_exit;$/;"	v	file:
test_netflow_exit	.\tests\test-netflow.c	/^test_netflow_exit(struct unixctl_conn *conn,$/;"	f	file:
test_netflow_main	.\tests\test-netflow.c	/^test_netflow_main(int argc, char *argv[])$/;"	f	file:
test_odp_main	.\tests\test-odp.c	/^test_odp_main(int argc, char *argv[])$/;"	f	file:
test_one	.\tests\test-sha1.c	/^test_one(const struct test_vector *vec)$/;"	f	file:
test_ovs_scan	.\tests\test-util.c	/^test_ovs_scan(int argc OVS_UNUSED, char *argv[] OVS_UNUSED)$/;"	f	file:
test_packets_main	.\tests\test-packets.c	/^test_packets_main(int argc OVS_UNUSED, char *argv[] OVS_UNUSED)$/;"	f	file:
test_random_main	.\tests\test-random.c	/^test_random_main(int argc OVS_UNUSED, char *argv[] OVS_UNUSED)$/;"	f	file:
test_read_hello	.\tests\test-vconn.c	/^test_read_hello(int argc OVS_UNUSED, char *argv[])$/;"	f	file:
test_reconnect_main	.\tests\test-reconnect.c	/^test_reconnect_main(int argc OVS_UNUSED, char *argv[] OVS_UNUSED)$/;"	f	file:
test_refuse_connection	.\tests\test-vconn.c	/^test_refuse_connection(int argc OVS_UNUSED, char *argv[])$/;"	f	file:
test_rfc1624	.\tests\test-csum.c	/^test_rfc1624(void)$/;"	f	file:
test_round_down_pow2	.\tests\test-util.c	/^test_round_down_pow2(int argc OVS_UNUSED, char *argv[] OVS_UNUSED)$/;"	f	file:
test_round_up_pow2	.\tests\test-util.c	/^test_round_up_pow2(int argc OVS_UNUSED, char *argv[] OVS_UNUSED)$/;"	f	file:
test_rule	.\tests\test-classifier.c	/^struct test_rule {$/;"	s	file:
test_rule_destroy	.\tests\test-classifier.c	/^test_rule_destroy(struct test_rule *rule)$/;"	f	file:
test_rule_from_cls_rule	.\tests\test-classifier.c	/^test_rule_from_cls_rule(const struct cls_rule *rule)$/;"	f	file:
test_rule_replacement	.\tests\test-classifier.c	/^test_rule_replacement(int argc OVS_UNUSED, char *argv[] OVS_UNUSED)$/;"	f	file:
test_send_echo_hello	.\tests\test-vconn.c	/^test_send_echo_hello(int argc OVS_UNUSED, char *argv[])$/;"	f	file:
test_send_hello	.\tests\test-vconn.c	/^test_send_hello(const char *type, const void *out, size_t out_size,$/;"	f	file:
test_send_invalid_version_hello	.\tests\test-vconn.c	/^test_send_invalid_version_hello(int argc OVS_UNUSED, char *argv[])$/;"	f	file:
test_send_long_hello	.\tests\test-vconn.c	/^test_send_long_hello(int argc OVS_UNUSED, char *argv[])$/;"	f	file:
test_send_plain_hello	.\tests\test-vconn.c	/^test_send_plain_hello(int argc OVS_UNUSED, char *argv[])$/;"	f	file:
test_send_short_hello	.\tests\test-vconn.c	/^test_send_short_hello(int argc OVS_UNUSED, char *argv[])$/;"	f	file:
test_sflow_exit	.\tests\test-sflow.c	/^static unixctl_cb_func test_sflow_exit;$/;"	v	file:
test_sflow_exit	.\tests\test-sflow.c	/^test_sflow_exit(struct unixctl_conn *conn,$/;"	f	file:
test_sflow_main	.\tests\test-sflow.c	/^test_sflow_main(int argc, char *argv[])$/;"	f	file:
test_shar1_main	.\tests\test-sha1.c	/^test_shar1_main(int argc OVS_UNUSED, char *argv[] OVS_UNUSED)$/;"	f	file:
test_single_rule	.\tests\test-classifier.c	/^test_single_rule(int argc OVS_UNUSED, char *argv[] OVS_UNUSED)$/;"	f	file:
test_snprintf	.\tests\test-util.c	/^test_snprintf(int argc OVS_UNUSED, char *argv[] OVS_UNUSED)$/;"	f	file:
test_stp_main	.\tests\test-stp.c	/^test_stp_main(int argc, char *argv[])$/;"	f	file:
test_trigger	.\tests\test-ovsdb.c	/^struct test_trigger {$/;"	s	file:
test_unix_socket_main	.\tests\test-unix-socket.c	/^test_unix_socket_main(int argc, char *argv[])$/;"	f	file:
test_util_main	.\tests\test-util.c	/^test_util_main(int argc, char *argv[])$/;"	f	file:
test_uuid_main	.\tests\test-uuid.c	/^test_uuid_main(int argc, char *argv[])$/;"	f	file:
test_vconn_main	.\tests\test-vconn.c	/^test_vconn_main(int argc, char *argv[])$/;"	f	file:
test_vector	.\tests\test-sha1.c	/^struct test_vector {$/;"	s	file:
tests	.\tests\test-lockfile.c	/^static const struct test tests[] = {$/;"	v	typeref:struct:test	file:
tests_ovstest_LDADD	.\tests\automake.mk	/^tests_ovstest_LDADD = lib\/libopenvswitch.la$/;"	m
tests_ovstest_SOURCES	.\tests\automake.mk	/^tests_ovstest_SOURCES = \\$/;"	m
tests_test_controller_LDADD	.\tests\automake.mk	/^tests_test_controller_LDADD = lib\/libopenvswitch.la$/;"	m
tests_test_controller_SOURCES	.\tests\automake.mk	/^tests_test_controller_SOURCES = tests\/test-controller.c$/;"	m
tests_test_ovsdb_LDADD	.\tests\automake.mk	/^tests_test_ovsdb_LDADD = ovsdb\/libovsdb.la lib\/libopenvswitch.la$/;"	m
tests_test_ovsdb_SOURCES	.\tests\automake.mk	/^tests_test_ovsdb_SOURCES = \\$/;"	m
tests_test_strtok_r_SOURCES	.\tests\automake.mk	/^tests_test_strtok_r_SOURCES = tests\/test-strtok_r.c$/;"	m
tests_test_type_props_SOURCES	.\tests\automake.mk	/^tests_test_type_props_SOURCES = tests\/test-type-props.c$/;"	m
text	.\lib\table.h	/^    char *text;$/;"	m	struct:cell
tha	.\datapath\flow.h	/^				u8 tha[ETH_ALEN];	\/* ARP target hardware address. *\/$/;"	m	struct:sw_flow_key::__anon5::__anon6::__anon8
the_idl	.\utilities\ovs-vsctl.c	/^static struct ovsdb_idl *the_idl;$/;"	v	typeref:struct:ovsdb_idl	file:
the_idl	.\vtep\vtep-ctl.c	/^static struct ovsdb_idl *the_idl;$/;"	v	typeref:struct:ovsdb_idl	file:
the_idl_txn	.\utilities\ovs-vsctl.c	/^static struct ovsdb_idl_txn *the_idl_txn;$/;"	v	typeref:struct:ovsdb_idl_txn	file:
the_idl_txn	.\vtep\vtep-ctl.c	/^static struct ovsdb_idl_txn *the_idl_txn;$/;"	v	typeref:struct:ovsdb_idl_txn	file:
the_root_prefix	.\xenserver\opt_xensource_libexec_InterfaceReconfigure.py	/^the_root_prefix = ""$/;"	v
this_cpu_ptr	.\datapath\linux\compat\include\asm\percpu.h	7;"	d
thiszone	.\lib\pcap-file.c	/^    int32_t thiszone;        \/* GMT to local correction *\/$/;"	m	struct:pcap_hdr	file:
thoff	.\datapath\linux\compat\include\net\flow_keys.h	/^	u16 thoff;$/;"	m	struct:flow_keys
thread	.\lib\dpif-netdev.c	/^    pthread_t thread;$/;"	m	struct:pmd_thread	file:
thread	.\ofproto\ofproto-dpif-upcall.c	/^    pthread_t thread;                  \/* Thread ID. *\/$/;"	m	struct:handler	file:
thread	.\ofproto\ofproto-dpif-upcall.c	/^    pthread_t thread;                  \/* Thread ID. *\/$/;"	m	struct:revalidator	file:
thread_local	.\lib\ovs-thread.h	274;"	d
threading	.\python\ovs\vlog.py	/^import threading$/;"	i
ti	.\datapath\flow_table.h	/^	struct table_instance __rcu *ti;$/;"	m	struct:flow_table	typeref:struct:flow_table::__rcu
ticks_per_s	.\lib\netdev-linux.c	/^static double ticks_per_s;$/;"	v	file:
ticks_to_ms	.\vswitchd\system-stats.c	/^ticks_to_ms(unsigned long long int ticks)$/;"	f	file:
time	.\python\compat\uuid.py	/^    import time$/;"	i
time	.\python\compat\uuid.py	/^    time = property(get_time)$/;"	v	class:UUID
time	.\python\ovs\daemon.py	/^import time$/;"	i
time	.\python\ovs\timeval.py	/^import time$/;"	i
time	.\python\ovstest\tcp.py	/^import time$/;"	i
time	.\python\ovstest\tests.py	/^import time$/;"	i
time	.\python\ovstest\udp.py	/^import time$/;"	i
time	.\tests\test-daemon.py	/^import time$/;"	i
time	.\xenserver\opt_xensource_libexec_InterfaceReconfigureBridge.py	/^import time$/;"	i
time_after64	.\datapath\linux\compat\include\linux\jiffies.h	13;"	d
time_after_eq64	.\datapath\linux\compat\include\linux\jiffies.h	24;"	d
time_alarm	.\lib\timeval.c	/^time_alarm(unsigned int secs)$/;"	f
time_before64	.\datapath\linux\compat\include\linux\jiffies.h	20;"	d
time_before_eq64	.\datapath\linux\compat\include\linux\jiffies.h	31;"	d
time_boot_msec	.\lib\timeval.c	/^time_boot_msec(void)$/;"	f
time_hi_version	.\python\compat\uuid.py	/^    time_hi_version = property(get_time_hi_version)$/;"	v	class:UUID
time_in_msec	.\utilities\ovs-benchmark.c	/^time_in_msec(void)$/;"	f	file:
time_init	.\lib\timeval.c	/^time_init(void)$/;"	f	file:
time_low	.\python\compat\uuid.py	/^    time_low = property(get_time_low)$/;"	v	class:UUID
time_mid	.\python\compat\uuid.py	/^    time_mid = property(get_time_mid)$/;"	v	class:UUID
time_msec	.\lib\timeval.c	/^time_msec(void)$/;"	f
time_msec__	.\lib\timeval.c	/^time_msec__(struct clock *c)$/;"	f	file:
time_now	.\lib\timeval.c	/^time_now(void)$/;"	f
time_poll	.\lib\timeval.c	/^time_poll(struct pollfd *pollfds, int n_pollfds, HANDLE *handles OVS_UNUSED,$/;"	f
time_sec__	.\lib\timeval.c	/^time_sec__(struct clock *c)$/;"	f	file:
time_timespec	.\lib\timeval.c	/^time_timespec(struct timespec *ts)$/;"	f
time_timespec__	.\lib\timeval.c	/^time_timespec__(struct clock *c, struct timespec *ts)$/;"	f	file:
time_wall	.\lib\timeval.c	/^time_wall(void)$/;"	f
time_wall_msec	.\lib\timeval.c	/^time_wall_msec(void)$/;"	f
time_wall_timespec	.\lib\timeval.c	/^time_wall_timespec(struct timespec *ts)$/;"	f
timeout	.\ofproto\pktbuf.c	/^    long long int timeout;$/;"	m	struct:packet	file:
timeout	.\python\ovs\reconnect.py	/^    def timeout(self, now):$/;"	m	class:Reconnect
timeout	.\utilities\ovs-benchmark.c	/^static double timeout;$/;"	v	file:
timeout	.\utilities\ovs-vsctl.c	/^static int timeout;$/;"	v	file:
timeout	.\vtep\vtep-ctl.c	/^static int timeout;$/;"	v	file:
timeout_msec	.\ovsdb\execution.c	/^    long long int timeout_msec;$/;"	m	struct:ovsdb_execution	file:
timeout_msec	.\ovsdb\trigger.h	/^    long long int timeout_msec; \/* Max wait duration. *\/$/;"	m	struct:ovsdb_trigger
timeout_when	.\lib\poll-loop.c	/^    long long int timeout_when; \/* In msecs as returned by time_msec(). *\/$/;"	m	struct:poll_loop	file:
timeout_where	.\lib\poll-loop.c	/^    const char *timeout_where;  \/* Where 'timeout_when' was set. *\/$/;"	m	struct:poll_loop	file:
timer	.\lib\timer.h	/^struct timer {$/;"	s
timer_end	.\utilities\ovs-benchmark.c	/^timer_end(long long int start, bool error,$/;"	f	file:
timer_expired	.\lib\timer.h	/^timer_expired(const struct timer *timer)$/;"	f
timer_is_infinite	.\lib\timer.h	/^timer_is_infinite(const struct timer *timer)$/;"	f
timer_msecs_until_expired	.\lib\timer.c	/^timer_msecs_until_expired(const struct timer *timer)$/;"	f
timer_set_duration	.\lib\timer.h	/^timer_set_duration(struct timer *timer, long long int duration)$/;"	f
timer_set_expired	.\lib\timer.h	/^timer_set_expired(struct timer *timer)$/;"	f
timer_set_infinite	.\lib\timer.h	/^timer_set_infinite(struct timer *timer)$/;"	f
timer_to_ms	.\lib\stp.c	/^timer_to_ms(int timer)$/;"	f	file:
timer_wait	.\lib\timer.h	31;"	d
timer_wait	.\python\ovs\poller.py	/^    def timer_wait(self, msec):$/;"	m	class:Poller
timer_wait_at	.\lib\timer.c	/^timer_wait_at(const struct timer *timer, const char *where)$/;"	f
timer_wait_until	.\python\ovs\poller.py	/^    def timer_wait_until(self, msec):$/;"	m	class:Poller
timespec_add	.\lib\timeval.c	/^timespec_add(struct timespec *sum,$/;"	f	file:
timespec_to_msec	.\lib\timeval.c	/^timespec_to_msec(const struct timespec *ts)$/;"	f
timestamp	.\lib\table.h	/^    bool timestamp;$/;"	m	struct:table
timestamp	.\ovsdb\ovsdb-client.c	/^static bool timestamp;$/;"	v	file:
timestamp	.\utilities\ovs-ofctl.c	/^static bool timestamp;$/;"	v	file:
timeval	.\lib\timeval.c	/^VLOG_DEFINE_THIS_MODULE(timeval);$/;"	v
timeval	.\python\ovs\daemon.py	/^import ovs.timeval$/;"	i
timeval	.\python\ovs\jsonrpc.py	/^import ovs.timeval$/;"	i
timeval	.\python\ovs\poller.py	/^import ovs.timeval$/;"	i
timeval_diff_msec	.\lib\timeval.c	/^timeval_diff_msec(const struct timeval *a, const struct timeval *b)$/;"	f	file:
timeval_dummy_register	.\lib\timeval.c	/^timeval_dummy_register(void)$/;"	f
timeval_stop_cb	.\lib\timeval.c	/^timeval_stop_cb(struct unixctl_conn *conn,$/;"	f	file:
timeval_to_msec	.\lib\timeval.c	/^timeval_to_msec(const struct timeval *tv)$/;"	f
timeval_warp_cb	.\lib\timeval.c	/^timeval_warp_cb(struct unixctl_conn *conn,$/;"	f	file:
timewarp_enabled	.\lib\timeval.c	/^static bool timewarp_enabled;$/;"	v	file:
timewarp_seq	.\lib\timeval.c	/^static struct seq *timewarp_seq;$/;"	v	typeref:struct:seq	file:
timewarp_wait	.\lib\timeval.c	/^timewarp_wait(void)$/;"	f
tll	.\datapath\flow.h	/^				u8 tll[ETH_ALEN];	\/* ND target link layer address. *\/$/;"	m	struct:sw_flow_key::__anon5::__anon9::__anon11
tm	.\lib\timeval.h	/^  struct tm tm;$/;"	m	struct:tm_msec	typeref:struct:tm_msec::tm
tm_msec	.\lib\timeval.h	/^struct tm_msec {$/;"	s
tmp	.\lib\dpif-linux.c	/^    struct ofpbuf *tmp;           \/* Used if kernel does not supply actions. *\/$/;"	m	struct:dpif_linux_flow_state	typeref:struct:dpif_linux_flow_state::ofpbuf	file:
tmp_dh_callback	.\lib\stream-ssl.c	/^tmp_dh_callback(SSL *ssl OVS_UNUSED, int is_export OVS_UNUSED, int keylength)$/;"	f	file:
tnl_backers	.\ofproto\ofproto-dpif.c	/^    struct simap tnl_backers;      \/* Set of dpif ports backing tunnels. *\/$/;"	m	struct:dpif_backer	typeref:struct:dpif_backer::simap	file:
tnl_cfg	.\lib\netdev-vport.c	/^    struct netdev_tunnel_config tnl_cfg;$/;"	m	struct:netdev_vport	typeref:struct:netdev_vport::netdev_tunnel_config	file:
tnl_ecn_ok	.\ofproto\tunnel.c	/^tnl_ecn_ok(const struct flow *base_flow, struct flow *flow,$/;"	f	file:
tnl_flags_to_gre_flags	.\datapath\linux\compat\include\net\gre.h	/^static inline __be16 tnl_flags_to_gre_flags(__be16 tflags)$/;"	f
tnl_hash	.\ofproto\tunnel.c	/^tnl_hash(struct tnl_match *match)$/;"	f	file:
tnl_match	.\ofproto\tunnel.c	/^struct tnl_match {$/;"	s	file:
tnl_match_map	.\ofproto\tunnel.c	/^tnl_match_map(const struct tnl_match *m)$/;"	f	file:
tnl_port	.\ofproto\tunnel.c	/^struct tnl_port {$/;"	s	file:
tnl_port_should_receive	.\ofproto\tunnel.h	/^tnl_port_should_receive(const struct flow *flow)$/;"	f
tnl_ptk_info	.\datapath\linux\compat\include\net\ip_tunnels.h	/^struct tnl_ptk_info {$/;"	s
tnl_skb_gso_segment	.\datapath\linux\compat\gso.c	/^static struct sk_buff *tnl_skb_gso_segment(struct sk_buff *skb,$/;"	f	file:
tnl_xlate_init	.\ofproto\tunnel.c	/^tnl_xlate_init(const struct flow *base_flow, struct flow *flow,$/;"	f
toAtomicType	.\python\ovs\db\types.py	/^    def toAtomicType(self):$/;"	m	class:BaseType
toCType	.\python\ovs\db\types.py	/^    def toCType(self, prefix):$/;"	m	class:BaseType
toEnglish	.\python\ovs\db\data.py	/^    def toEnglish(self, escapeLiteral=returnUnchanged):$/;"	m	class:Atom
toEnglish	.\python\ovs\db\types.py	/^    def toEnglish(self, escapeLiteral=returnUnchanged):$/;"	m	class:BaseType
toEnglish	.\python\ovs\db\types.py	/^    def toEnglish(self, escapeLiteral=returnUnchanged):$/;"	m	class:Type
to_c_assignment	.\python\ovs\ovsuuid.py	/^def to_c_assignment(uuid_, var):$/;"	f
to_file	.\python\ovs\json.py	/^def to_file(obj, name, pretty=False, sort_keys=True):$/;"	f
to_json	.\python\ovs\db\data.py	/^    def to_json(self):$/;"	m	class:Atom
to_json	.\python\ovs\db\data.py	/^    def to_json(self):$/;"	m	class:Datum
to_json	.\python\ovs\db\schema.py	/^    def to_json(self):$/;"	m	class:ColumnSchema
to_json	.\python\ovs\db\schema.py	/^    def to_json(self):$/;"	m	class:DbSchema
to_json	.\python\ovs\db\schema.py	/^    def to_json(self, default_is_root=False):$/;"	m	class:TableSchema
to_json	.\python\ovs\db\types.py	/^    def to_json(self):$/;"	m	class:AtomicType
to_json	.\python\ovs\db\types.py	/^    def to_json(self):$/;"	m	class:BaseType
to_json	.\python\ovs\db\types.py	/^    def to_json(self):$/;"	m	class:Type
to_json	.\python\ovs\jsonrpc.py	/^    def to_json(self):$/;"	m	class:Message
to_json	.\python\ovs\ovsuuid.py	/^def to_json(uuid_):$/;"	f
to_lower_and_underscores	.\utilities\ovs-vsctl.c	/^to_lower_and_underscores(unsigned c)$/;"	f	file:
to_lower_and_underscores	.\vtep\vtep-ctl.c	/^to_lower_and_underscores(unsigned c)$/;"	f	file:
to_net_dev	.\datapath\linux\compat\include\linux\netdevice.h	12;"	d
to_python	.\python\ovs\db\data.py	/^    def to_python(self, uuid_to_row):$/;"	m	class:Datum
to_stream	.\python\ovs\json.py	/^def to_stream(obj, stream, pretty=False, sort_keys=True):$/;"	f
to_string	.\python\ovs\db\data.py	/^    def to_string(self):$/;"	m	class:Atom
to_string	.\python\ovs\db\data.py	/^    def to_string(self):$/;"	m	class:Datum
to_string	.\python\ovs\db\types.py	/^    def to_string(self):$/;"	m	class:AtomicType
to_string	.\python\ovs\json.py	/^def to_string(obj, pretty=False, sort_keys=True):$/;"	f
toggle_masked_flow_bits	.\tests\test-classifier.c	/^toggle_masked_flow_bits(struct flow *flow, const struct flow_wildcards *mask)$/;"	f	file:
token	.\tests\test-stp.c	/^static char *pos, *token;$/;"	v	file:
token_bucket	.\lib\token-bucket.h	/^struct token_bucket {$/;"	s
token_bucket	.\lib\vlog.h	/^    struct token_bucket token_bucket;$/;"	m	struct:vlog_rate_limit	typeref:struct:vlog_rate_limit::token_bucket
token_bucket	.\ofproto\pinsched.c	/^    struct token_bucket token_bucket;$/;"	m	struct:pinsched	typeref:struct:pinsched::token_bucket	file:
token_bucket_init	.\lib\token-bucket.c	/^token_bucket_init(struct token_bucket *tb,$/;"	f
token_bucket_set	.\lib\token-bucket.c	/^token_bucket_set(struct token_bucket *tb,$/;"	f
token_bucket_wait	.\lib\token-bucket.c	/^token_bucket_wait(struct token_bucket *tb, unsigned int n)$/;"	f
token_bucket_withdraw	.\lib\token-bucket.c	/^token_bucket_withdraw(struct token_bucket *tb, unsigned int n)$/;"	f
tokenring	.\lib\sflow.h	/^    SFLTokenring_counters tokenring;$/;"	m	union:_SFLCounters_type
tokens	.\lib\token-bucket.h	/^    unsigned int tokens;        \/* Current number of tokens. *\/$/;"	m	struct:token_bucket
too_many_output_actions	.\ofproto\ofproto-dpif-xlate.c	/^too_many_output_actions(const struct ofpbuf *odp_actions)$/;"	f	file:
topology_change	.\lib\stp.c	/^    bool topology_change;           \/* 8.5.3.12: Received topology change? *\/$/;"	m	struct:stp	file:
topology_change_ack	.\lib\stp.c	/^    bool topology_change_ack;       \/* 8.5.5.8: Flag for next config BPDU. *\/$/;"	m	struct:stp_port	file:
topology_change_detected	.\lib\stp.c	/^    bool topology_change_detected;  \/* 8.5.3.11: Detected a topology change? *\/$/;"	m	struct:stp	file:
topology_change_timer	.\lib\stp.c	/^    struct stp_timer topology_change_timer; \/* 8.5.4.3. *\/$/;"	m	struct:stp	typeref:struct:stp::stp_timer	file:
tos	.\datapath\flow.h	/^		u8     tos;		\/* IP ToS. *\/$/;"	m	struct:sw_flow_key::__anon3
tos	.\lib\netdev.h	/^    uint8_t tos;$/;"	m	struct:netdev_tunnel_config
tos	.\lib\sflow.h	/^    u_int32_t tos;         \/* IP type of service *\/$/;"	m	struct:_SFLSampled_ipv4
tos_inherit	.\lib\netdev.h	/^    bool tos_inherit;$/;"	m	struct:netdev_tunnel_config
total	.\lib\coverage.h	/^    unsigned long long int total;      \/* Total count. *\/$/;"	m	struct:coverage_counter
total_connected_duration	.\lib\reconnect.c	/^    unsigned int total_connected_duration;$/;"	m	struct:reconnect	file:
total_connected_duration	.\lib\reconnect.h	/^    unsigned int total_connected_duration; \/* Sum of all connections. *\/$/;"	m	struct:reconnect_stats
total_len	.\include\openflow\nicira-ext.h	/^    ovs_be16 total_len;       \/* Full length of frame. *\/$/;"	m	struct:nx_packet_in
total_len	.\include\openflow\openflow-1.0.h	/^    ovs_be16 total_len;     \/* Full length of frame. *\/$/;"	m	struct:ofp10_packet_in
total_len	.\include\openflow\openflow-1.1.h	/^    ovs_be16 total_len;     \/* Full length of frame. *\/$/;"	m	struct:ofp11_packet_in
total_len	.\include\openflow\openflow-1.2.h	/^    ovs_be16 total_len;     \/* Full length of frame. *\/$/;"	m	struct:ofp12_packet_in
total_len	.\lib\ofp-util.h	/^    size_t total_len;           \/* Size of packet, pre-truncation. *\/$/;"	m	struct:ofputil_packet_in
total_nr_elements	.\datapath\linux\compat\include\linux\flex_array.h	/^			int total_nr_elements;$/;"	m	struct:flex_array::__anon12::__anon13
total_time_connected	.\lib\rconn.c	/^    unsigned long int total_time_connected;$/;"	m	struct:rconn	file:
tp	.\datapath\flow.h	/^	} tp;$/;"	m	struct:sw_flow_key	typeref:struct:sw_flow_key::__anon4
tp_dst	.\include\openflow\openflow-1.0.h	/^    ovs_be16 tp_dst;           \/* TCP\/UDP destination port. *\/$/;"	m	struct:ofp10_match
tp_dst	.\include\openflow\openflow-1.1.h	/^    ovs_be16 tp_dst;           \/* TCP\/UDP\/SCTP destination port. *\/$/;"	m	struct:ofp11_match
tp_dst	.\lib\flow.h	/^    ovs_be16 tp_dst;            \/* TCP\/UDP\/SCTP destination port.$/;"	m	struct:flow
tp_dst	.\lib\pcap-file.c	/^    ovs_be16 tp_src, tp_dst;$/;"	m	struct:tcp_key	file:
tp_dst	.\ofproto\netflow.c	/^    ovs_be16 tp_dst;              \/* TCP\/UDP\/SCTP destination port. *\/$/;"	m	struct:netflow_flow	file:
tp_dst_values	.\tests\test-classifier.c	/^static ovs_be16 tp_dst_values[] = { CONSTANT_HTONS(6667), CONSTANT_HTONS(22) };$/;"	v	file:
tp_len	.\lib\netdev-linux.c	/^    uint32_t tp_len;$/;"	m	struct:tpacket_auxdata	file:
tp_mac	.\lib\netdev-linux.c	/^    uint16_t tp_mac;$/;"	m	struct:tpacket_auxdata	file:
tp_net	.\lib\netdev-linux.c	/^    uint16_t tp_net;$/;"	m	struct:tpacket_auxdata	file:
tp_port	.\include\openflow\openflow-common.h	/^    ovs_be16 tp_port;               \/* TCP\/UDP port. *\/$/;"	m	struct:ofp_action_tp_port
tp_port	.\lib\ofp-actions.c	/^    struct ofp_action_tp_port tp_port;$/;"	m	union:ofp_action	typeref:struct:ofp_action::ofp_action_tp_port	file:
tp_snaplen	.\lib\netdev-linux.c	/^    uint32_t tp_snaplen;$/;"	m	struct:tpacket_auxdata	file:
tp_src	.\include\openflow\openflow-1.0.h	/^    ovs_be16 tp_src;           \/* TCP\/UDP source port. *\/$/;"	m	struct:ofp10_match
tp_src	.\include\openflow\openflow-1.1.h	/^    ovs_be16 tp_src;           \/* TCP\/UDP\/SCTP source port. *\/$/;"	m	struct:ofp11_match
tp_src	.\lib\flow.h	/^    ovs_be16 tp_src;            \/* TCP\/UDP\/SCTP source port. *\/$/;"	m	struct:flow
tp_src	.\lib\pcap-file.c	/^    ovs_be16 tp_src, tp_dst;$/;"	m	struct:tcp_key	file:
tp_src	.\ofproto\netflow.c	/^    ovs_be16 tp_src;              \/* TCP\/UDP\/SCTP source port. *\/$/;"	m	struct:netflow_flow	file:
tp_src_values	.\tests\test-classifier.c	/^static ovs_be16 tp_src_values[] = { CONSTANT_HTONS(49362),$/;"	v	file:
tp_status	.\lib\netdev-linux.c	/^    uint32_t tp_status;$/;"	m	struct:tpacket_auxdata	file:
tp_vlan_tci	.\lib\netdev-linux.c	/^    uint16_t tp_vlan_tci;$/;"	m	struct:tpacket_auxdata	file:
tp_vlan_tpid	.\lib\netdev-linux.c	/^    uint16_t tp_vlan_tpid;$/;"	m	struct:tpacket_auxdata	file:
tpacket_auxdata	.\lib\netdev-linux.c	/^struct tpacket_auxdata {$/;"	s	file:
tpacket_auxdata	.\lib\netdev-linux.c	128;"	d	file:
tpacket_auxdata	.\lib\netdev-linux.c	129;"	d	file:
trace_ctx	.\ofproto\ofproto-dpif.c	/^struct trace_ctx {$/;"	s	file:
trace_format_flow	.\ofproto\ofproto-dpif.c	/^trace_format_flow(struct ds *result, int level, const char *title,$/;"	f	file:
trace_format_megaflow	.\ofproto\ofproto-dpif.c	/^trace_format_megaflow(struct ds *result, int level, const char *title,$/;"	f	file:
trace_format_odp	.\ofproto\ofproto-dpif.c	/^trace_format_odp(struct ds *result, int level, const char *title,$/;"	f	file:
trace_format_regs	.\ofproto\ofproto-dpif.c	/^trace_format_regs(struct ds *result, int level, const char *title,$/;"	f	file:
trace_format_rule	.\ofproto\ofproto-dpif.c	/^trace_format_rule(struct ds *result, int level, const struct rule_dpif *rule)$/;"	f	file:
trace_report	.\ofproto\ofproto-dpif.c	/^trace_report(struct xlate_in *xin, const char *s, int recurse)$/;"	f	file:
trace_resubmit	.\ofproto\ofproto-dpif.c	/^trace_resubmit(struct xlate_in *xin, struct rule_dpif *rule, int recurse)$/;"	f	file:
tracker	.\lib\classifier.c	/^    struct tag_tracker tracker; \/* Tracks the bits in 'tags'. *\/$/;"	m	struct:cls_partition	typeref:struct:cls_partition::tag_tracker	file:
transact	.\ovsdb\ovsdb-tool.c	/^transact(bool read_only, int argc, char *argv[])$/;"	f	file:
transact	.\python\ovs\unixctl\client.py	/^    def transact(self, command, argv):$/;"	m	class:UnixctlClient
transact	.\python\ovs\unixctl\server.py	/^    def transact(self, command, argv):$/;"	m	class:UnixctlClient
transact_block	.\python\ovs\jsonrpc.py	/^    def transact_block(self, request):$/;"	m	class:Connection
transact_multiple_noreply	.\utilities\ovs-ofctl.c	/^transact_multiple_noreply(struct vconn *vconn, struct list *requests)$/;"	f	file:
transact_noreply	.\utilities\ovs-ofctl.c	/^transact_noreply(struct vconn *vconn, struct ofpbuf *request)$/;"	f	file:
tree	.\tests\test-stp.c	/^tree(struct test_case *tc)$/;"	f	file:
trie	.\lib\classifier.c	/^    const struct cls_trie *trie;$/;"	m	struct:trie_ctx	typeref:struct:trie_ctx::cls_trie	file:
trie_branch_create	.\lib\classifier.c	/^trie_branch_create(const ovs_be32 *prefix, unsigned int ofs, unsigned int plen,$/;"	f	file:
trie_ctx	.\lib\classifier.c	/^struct trie_ctx {$/;"	s	file:
trie_ctx_init	.\lib\classifier.c	/^trie_ctx_init(struct trie_ctx *ctx, const struct cls_trie *trie)$/;"	f	file:
trie_destroy	.\lib\classifier.c	/^trie_destroy(struct trie_node *node)$/;"	f	file:
trie_fields	.\tests\test-classifier.c	/^static enum mf_field_id trie_fields[2] = {$/;"	v	typeref:enum:mf_field_id	file:
trie_get_prefix	.\lib\classifier.c	/^trie_get_prefix(const ovs_be32 pr[], unsigned int ofs, unsigned int plen)$/;"	f	file:
trie_init	.\lib\classifier.c	/^trie_init(struct cls_classifier *cls, int trie_idx,$/;"	f	file:
trie_insert	.\lib\classifier.c	/^trie_insert(struct cls_trie *trie, const struct cls_rule *rule, int mlen)$/;"	f	file:
trie_insert_prefix	.\lib\classifier.c	/^trie_insert_prefix(struct trie_node **edge, const ovs_be32 *prefix, int mlen)$/;"	f	file:
trie_is_leaf	.\lib\classifier.c	/^trie_is_leaf(const struct trie_node *trie)$/;"	f	file:
trie_lookup	.\lib\classifier.c	/^trie_lookup(const struct cls_trie *trie, const struct flow *flow,$/;"	f	file:
trie_lookup_value	.\lib\classifier.c	/^trie_lookup_value(const struct trie_node *node, const ovs_be32 value[],$/;"	f	file:
trie_next_edge	.\lib\classifier.c	/^trie_next_edge(struct trie_node *node, const ovs_be32 value[],$/;"	f	file:
trie_next_node	.\lib\classifier.c	/^trie_next_node(const struct trie_node *node, const ovs_be32 value[],$/;"	f	file:
trie_node	.\lib\classifier.c	/^struct trie_node {$/;"	s	file:
trie_node_destroy	.\lib\classifier.c	/^trie_node_destroy(struct trie_node *node)$/;"	f	file:
trie_plen	.\lib\classifier.c	/^    unsigned int trie_plen[CLS_MAX_TRIES];  \/* Trie prefix length in 'mask'. *\/$/;"	m	struct:cls_subtable	file:
trie_prefix_equal_bits	.\lib\classifier.c	/^trie_prefix_equal_bits(const struct trie_node *node, const ovs_be32 prefix[],$/;"	f	file:
trie_remove	.\lib\classifier.c	/^trie_remove(struct cls_trie *trie, const struct cls_rule *rule, int mlen)$/;"	f	file:
trie_remove_prefix	.\lib\classifier.c	/^trie_remove_prefix(struct trie_node **root, const ovs_be32 *prefix, int mlen)$/;"	f	file:
tries	.\lib\classifier.c	/^    struct cls_trie tries[CLS_MAX_TRIES]; \/* Prefix tries. *\/$/;"	m	struct:cls_classifier	typeref:struct:cls_classifier::cls_trie	file:
trigger	.\ovsdb\jsonrpc-server.c	/^    struct ovsdb_trigger trigger;$/;"	m	struct:ovsdb_jsonrpc_trigger	typeref:struct:ovsdb_jsonrpc_trigger::ovsdb_trigger	file:
trigger	.\tests\test-ovsdb.c	/^    struct ovsdb_trigger trigger;$/;"	m	struct:test_trigger	typeref:struct:test_trigger::ovsdb_trigger	file:
trigger_duration	.\ofproto\fail-open.c	/^trigger_duration(const struct fail_open *fo)$/;"	f	file:
triggers	.\ovsdb\jsonrpc-server.c	/^    struct hmap triggers;       \/* Hmap of "struct ovsdb_jsonrpc_trigger"s. *\/$/;"	m	struct:ovsdb_jsonrpc_session	typeref:struct:ovsdb_jsonrpc_session::hmap	file:
triggers	.\ovsdb\ovsdb.h	/^    struct list triggers;       \/* Contains "struct ovsdb_trigger"s. *\/$/;"	m	struct:ovsdb	typeref:struct:ovsdb::list
triplet	.\lib\ofp-errors.c	/^struct triplet {$/;"	s	file:
true	.\datapath\linux\compat\include\linux\stddef.h	/^	true    = 1$/;"	e	enum:__anon14
trunks	.\lib\vswitch-idl.h	/^	int64_t *trunks;$/;"	m	struct:ovsrec_port
trunks	.\ofproto\ofproto-dpif-xlate.c	/^    unsigned long *trunks;         \/* Bitmap of trunked VLANs, if 'vlan' == -1.$/;"	m	struct:xbundle	file:
trunks	.\ofproto\ofproto-dpif.c	/^    unsigned long *trunks;      \/* Bitmap of trunked VLANs, if 'vlan' == -1.$/;"	m	struct:ofbundle	file:
trunks	.\ofproto\ofproto.h	/^    unsigned long *trunks;      \/* vlan_bitmap, except for PORT_VLAN_ACCESS. *\/$/;"	m	struct:ofproto_bundle_settings
try_again	.\utilities\ovs-vsctl.c	/^    bool try_again;$/;"	m	struct:vsctl_context	file:
try_again	.\vtep\vtep-ctl.c	/^    bool try_again;$/;"	m	struct:vtep_ctl_context	file:
try_set_protocol	.\utilities\ovs-ofctl.c	/^try_set_protocol(struct vconn *vconn, enum ofputil_protocol want,$/;"	f	file:
ts_sec	.\lib\pcap-file.c	/^    uint32_t ts_sec;         \/* timestamp seconds *\/$/;"	m	struct:pcaprec_hdr	file:
ts_usec	.\lib\pcap-file.c	/^    uint32_t ts_usec;        \/* timestamp microseconds *\/$/;"	m	struct:pcaprec_hdr	file:
tsc	.\lib\netdev-dpdk.c	/^    uint64_t tsc;$/;"	m	struct:dpdk_tx_queue	file:
tsd_key	.\lib\ovs-thread.c	/^static pthread_key_t tsd_key;$/;"	v	file:
ttl	.\datapath\flow.h	/^		u8     ttl;		\/* IP TTL\/hop limit. *\/$/;"	m	struct:sw_flow_key::__anon3
ttl	.\include\openflow\nicira-ext.h	/^    uint8_t  ttl;                   \/* TTL *\/$/;"	m	struct:nx_action_mpls_ttl
ttl	.\lib\netdev.h	/^    uint8_t ttl;$/;"	m	struct:netdev_tunnel_config
ttl	.\lib\ofp-actions.h	/^    uint8_t ttl;$/;"	m	struct:ofpact_ip_ttl
ttl	.\lib\ofp-actions.h	/^    uint8_t ttl;$/;"	m	struct:ofpact_mpls_ttl
ttl_inherit	.\lib\netdev.h	/^    bool ttl_inherit;$/;"	m	struct:netdev_tunnel_config
tun_flags	.\datapath\flow.h	/^	__be16 tun_flags;$/;"	m	struct:ovs_key_ipv4_tunnel
tun_id	.\datapath\flow.h	/^	__be64 tun_id;$/;"	m	struct:ovs_key_ipv4_tunnel
tun_id	.\include\openflow\nicira-ext.h	/^    ovs_be32 tun_id;                \/* Tunnel ID. *\/$/;"	m	struct:nx_action_set_tunnel
tun_id	.\include\openflow\nicira-ext.h	/^    ovs_be64 tun_id;                \/* Tunnel ID. *\/$/;"	m	struct:nx_action_set_tunnel64
tun_id	.\lib\ofp-actions.h	/^    uint64_t tun_id;$/;"	m	struct:ofpact_tunnel
tun_id	.\lib\packets.h	/^    ovs_be64 tun_id;$/;"	m	struct:flow_tnl
tun_id_values	.\tests\test-classifier.c	/^static ovs_be64 tun_id_values[] = {$/;"	v	file:
tun_key	.\datapath\datapath.h	/^	struct ovs_key_ipv4_tunnel  *tun_key;$/;"	m	struct:ovs_skb_cb	typeref:struct:ovs_skb_cb::ovs_key_ipv4_tunnel
tun_key	.\datapath\flow.h	/^	struct ovs_key_ipv4_tunnel tun_key;  \/* Encapsulating tunnel key. *\/$/;"	m	struct:sw_flow_key	typeref:struct:sw_flow_key::ovs_key_ipv4_tunnel
tun_key_to_attr	.\lib\odp-util.c	/^tun_key_to_attr(struct ofpbuf *a, const struct flow_tnl *tun_key)$/;"	f	file:
tunnel	.\lib\flow.h	/^    struct flow_tnl tunnel;     \/* Encapsulating tunnel parameters. *\/$/;"	m	struct:flow	typeref:struct:flow::flow_tnl
tunnel	.\lib\packets.h	/^    struct flow_tnl tunnel;     \/* Encapsulating tunnel parameters. *\/$/;"	m	struct:pkt_metadata	typeref:struct:pkt_metadata::flow_tnl
tunnel	.\ofproto\tunnel.c	/^VLOG_DEFINE_THIS_MODULE(tunnel);$/;"	v
tunnel_cos	.\lib\sflow.h	/^    u_int32_t tunnel_cos;       \/* Tunnel COS value *\/$/;"	m	struct:_SFLExtended_mpls_tunnel
tunnel_get_status	.\lib\netdev-vport.c	/^tunnel_get_status(const struct netdev *netdev_, struct smap *smap)$/;"	f	file:
tunnel_id	.\lib\sflow.h	/^    u_int32_t tunnel_id;        \/* Tunnel ID *\/$/;"	m	struct:_SFLExtended_mpls_tunnel
tunnel_id_to_instance_id	.\datapath\vport-lisp.c	/^static void tunnel_id_to_instance_id(__be64 tun_id, __u8 *iid)$/;"	f	file:
tunnel_ips	.\lib\vtep-idl.h	/^	char **tunnel_ips;$/;"	m	struct:vteprec_physical_switch
tunnel_key	.\lib\vtep-idl.h	/^	int64_t *tunnel_key;$/;"	m	struct:vteprec_logical_switch
tunnel_key_attr_len	.\lib\odp-util.c	/^tunnel_key_attr_len(int type)$/;"	f	file:
tunnel_lsp_name	.\lib\sflow.h	/^    SFLString tunnel_lsp_name;  \/* Tunnel name *\/$/;"	m	struct:_SFLExtended_mpls_tunnel
tunnel_types	.\python\ovstest\args.py	/^def tunnel_types(string):$/;"	f
tunnels	.\lib\vtep-idl.h	/^	struct vteprec_tunnel **tunnels;$/;"	m	struct:vteprec_physical_switch	typeref:struct:vteprec_physical_switch::vteprec_tunnel
tx	.\lib\lacp.c	/^    struct timer tx;              \/* Next message transmission timer. *\/$/;"	m	struct:slave	typeref:struct:slave::timer	file:
tx	.\ofproto\ofproto-dpif-xlate.c	/^            struct netdev *tx;$/;"	m	struct:xc_entry::__anon136::__anon137	typeref:struct:xc_entry::__anon136::__anon137::netdev	file:
tx_aborted_errors	.\lib\netdev.h	/^    uint64_t tx_aborted_errors;$/;"	m	struct:netdev_stats
tx_bytes	.\datapath\linux\compat\include\linux\netdevice.h	/^	u64     tx_bytes;$/;"	m	struct:pcpu_sw_netstats
tx_bytes	.\include\linux\openvswitch.h	/^	__u64   tx_bytes;		\/* total bytes transmitted      *\/$/;"	m	struct:ovs_vport_stats
tx_bytes	.\include\openflow\openflow-1.0.h	/^    ovs_32aligned_be64 tx_bytes;       \/* Number of transmitted bytes. *\/$/;"	m	struct:ofp10_port_stats
tx_bytes	.\include\openflow\openflow-1.0.h	/^    ovs_32aligned_be64 tx_bytes;   \/* Number of transmitted bytes. *\/$/;"	m	struct:ofp10_queue_stats
tx_bytes	.\include\openflow\openflow-1.1.h	/^    ovs_be64 tx_bytes;         \/* Number of transmitted bytes. *\/$/;"	m	struct:ofp11_queue_stats
tx_bytes	.\include\openflow\openflow-1.1.h	/^    ovs_be64 tx_bytes;        \/* Number of transmitted bytes. *\/$/;"	m	struct:ofp11_port_stats
tx_bytes	.\include\openflow\openflow-1.4.h	/^    ovs_be64 tx_bytes;       \/* Number of transmitted bytes. *\/$/;"	m	struct:ofp14_port_stats
tx_bytes	.\lib\netdev.h	/^    uint64_t tx_bytes;          \/* Total bytes transmitted. *\/$/;"	m	struct:netdev_stats
tx_bytes	.\lib\netdev.h	/^    uint64_t tx_bytes;$/;"	m	struct:netdev_queue_stats
tx_bytes	.\lib\ofp-util.h	/^    uint64_t tx_bytes;$/;"	m	struct:ofputil_queue_stats
tx_bytes	.\ofproto\bond.c	/^    uint64_t tx_bytes;          \/* Sum across 'tx_bytes' of entries. *\/$/;"	m	struct:bond_slave	file:
tx_carrier_errors	.\lib\netdev.h	/^    uint64_t tx_carrier_errors;$/;"	m	struct:netdev_stats
tx_conf	.\lib\netdev-dpdk.c	/^static const struct rte_eth_txconf tx_conf = {$/;"	v	typeref:struct:rte_eth_txconf	file:
tx_count	.\lib\stp.c	/^    int tx_count;                   \/* Number of BPDUs transmitted. *\/$/;"	m	struct:stp_port	file:
tx_count	.\ofproto\ofproto.h	/^    int tx_count;               \/* Number of BPDUs transmitted. *\/$/;"	m	struct:ofproto_port_stp_stats
tx_dropped	.\datapath\vport.h	/^	u64 tx_dropped;$/;"	m	struct:vport_err_stats
tx_dropped	.\include\linux\openvswitch.h	/^	__u64   tx_dropped;		\/* no space available in linux  *\/$/;"	m	struct:ovs_vport_stats
tx_dropped	.\include\openflow\openflow-1.0.h	/^    ovs_32aligned_be64 tx_dropped;     \/* Number of packets dropped by TX. *\/$/;"	m	struct:ofp10_port_stats
tx_dropped	.\include\openflow\openflow-1.1.h	/^    ovs_be64 tx_dropped;      \/* Number of packets dropped by TX. *\/$/;"	m	struct:ofp11_port_stats
tx_dropped	.\include\openflow\openflow-1.4.h	/^    ovs_be64 tx_dropped;     \/* Number of packets dropped by TX. *\/$/;"	m	struct:ofp14_port_stats
tx_dropped	.\lib\netdev.h	/^    uint64_t tx_dropped;        \/* No buffer space. *\/$/;"	m	struct:netdev_stats
tx_errors	.\datapath\vport.h	/^	u64 tx_errors;$/;"	m	struct:vport_err_stats
tx_errors	.\include\linux\openvswitch.h	/^	__u64   tx_errors;		\/* packet transmit problems     *\/$/;"	m	struct:ovs_vport_stats
tx_errors	.\include\openflow\openflow-1.0.h	/^    ovs_32aligned_be64 tx_errors;  \/* # of packets dropped due to overrun. *\/$/;"	m	struct:ofp10_queue_stats
tx_errors	.\include\openflow\openflow-1.0.h	/^    ovs_32aligned_be64 tx_errors; \/* Number of transmit errors.  This is a$/;"	m	struct:ofp10_port_stats
tx_errors	.\include\openflow\openflow-1.1.h	/^    ovs_be64 tx_errors;        \/* # of packets dropped due to overrun. *\/$/;"	m	struct:ofp11_queue_stats
tx_errors	.\include\openflow\openflow-1.1.h	/^    ovs_be64 tx_errors;       \/* Number of transmit errors.  This is a$/;"	m	struct:ofp11_port_stats
tx_errors	.\include\openflow\openflow-1.4.h	/^    ovs_be64 tx_errors;      \/* Number of transmit errors.  This is a super-set$/;"	m	struct:ofp14_port_stats
tx_errors	.\lib\netdev.h	/^    uint64_t tx_errors;         \/* Packet transmit problems. *\/$/;"	m	struct:netdev_stats
tx_errors	.\lib\netdev.h	/^    uint64_t tx_errors;$/;"	m	struct:netdev_queue_stats
tx_errors	.\lib\ofp-util.h	/^    uint64_t tx_errors;$/;"	m	struct:ofputil_queue_stats
tx_fifo_errors	.\lib\netdev.h	/^    uint64_t tx_fifo_errors;$/;"	m	struct:netdev_stats
tx_heartbeat_errors	.\lib\netdev.h	/^    uint64_t tx_heartbeat_errors;$/;"	m	struct:netdev_stats
tx_lock	.\lib\netdev-dpdk.c	/^    rte_spinlock_t tx_lock;$/;"	m	struct:dpdk_tx_queue	file:
tx_packets	.\datapath\linux\compat\include\linux\netdevice.h	/^	u64     tx_packets;$/;"	m	struct:pcpu_sw_netstats
tx_packets	.\include\linux\openvswitch.h	/^	__u64   tx_packets;		\/* total packets transmitted    *\/$/;"	m	struct:ovs_vport_stats
tx_packets	.\include\openflow\openflow-1.0.h	/^    ovs_32aligned_be64 tx_packets;     \/* Number of transmitted packets. *\/$/;"	m	struct:ofp10_port_stats
tx_packets	.\include\openflow\openflow-1.0.h	/^    ovs_32aligned_be64 tx_packets; \/* Number of transmitted packets. *\/$/;"	m	struct:ofp10_queue_stats
tx_packets	.\include\openflow\openflow-1.1.h	/^    ovs_be64 tx_packets;       \/* Number of transmitted packets. *\/$/;"	m	struct:ofp11_queue_stats
tx_packets	.\include\openflow\openflow-1.1.h	/^    ovs_be64 tx_packets;      \/* Number of transmitted packets. *\/$/;"	m	struct:ofp11_port_stats
tx_packets	.\include\openflow\openflow-1.4.h	/^    ovs_be64 tx_packets;     \/* Number of transmitted packets. *\/$/;"	m	struct:ofp14_port_stats
tx_packets	.\lib\netdev.h	/^    uint64_t tx_packets;        \/* Total packets transmitted. *\/$/;"	m	struct:netdev_stats
tx_packets	.\lib\netdev.h	/^    uint64_t tx_packets;$/;"	m	struct:netdev_queue_stats
tx_packets	.\lib\ofp-util.h	/^    uint64_t tx_packets;$/;"	m	struct:ofputil_queue_stats
tx_pcap	.\lib\netdev-dummy.c	/^    FILE *tx_pcap, *rxq_pcap OVS_GUARDED;$/;"	m	struct:netdev_dummy	file:
tx_q	.\lib\netdev-dpdk.c	/^    struct dpdk_tx_queue tx_q[NR_QUEUE];$/;"	m	struct:netdev_dpdk	typeref:struct:netdev_dpdk::dpdk_tx_queue	file:
tx_timer	.\lib\cfm.c	/^    struct timer tx_timer;    \/* Send CCM when expired. *\/$/;"	m	struct:cfm	typeref:struct:cfm::timer	file:
tx_want	.\lib\stream-ssl.c	/^    int rx_want, tx_want;$/;"	m	struct:ssl_stream	file:
tx_window_errors	.\lib\netdev.h	/^    uint64_t tx_window_errors;$/;"	m	struct:netdev_stats
txbuf	.\lib\stream-ssl.c	/^    struct ofpbuf *txbuf;$/;"	m	struct:ssl_stream	typeref:struct:ssl_stream::ofpbuf	file:
txbuf	.\lib\vconn-stream.c	/^    struct ofpbuf *txbuf;$/;"	m	struct:vconn_stream	typeref:struct:vconn_stream::ofpbuf	file:
txn	.\lib\ovsdb-idl.c	/^    struct ovsdb_idl_txn *txn;$/;"	m	struct:ovsdb_idl	typeref:struct:ovsdb_idl::ovsdb_idl_txn	file:
txn	.\ovsdb\execution.c	/^    struct ovsdb_txn *txn;$/;"	m	struct:delete_row_cbdata	typeref:struct:delete_row_cbdata::ovsdb_txn	file:
txn	.\ovsdb\execution.c	/^    struct ovsdb_txn *txn;$/;"	m	struct:mutate_row_cbdata	typeref:struct:mutate_row_cbdata::ovsdb_txn	file:
txn	.\ovsdb\execution.c	/^    struct ovsdb_txn *txn;$/;"	m	struct:ovsdb_execution	typeref:struct:ovsdb_execution::ovsdb_txn	file:
txn	.\ovsdb\execution.c	/^    struct ovsdb_txn *txn;$/;"	m	struct:update_row_cbdata	typeref:struct:update_row_cbdata::ovsdb_txn	file:
txn	.\ovsdb\ovsdb-server.c	/^    struct ovsdb_txn *txn;$/;"	m	struct:db	typeref:struct:db::ovsdb_txn	file:
txn	.\utilities\ovs-vsctl.c	/^    struct ovsdb_idl_txn *txn;$/;"	m	struct:vsctl_context	typeref:struct:vsctl_context::ovsdb_idl_txn	file:
txn	.\vtep\vtep-ctl.c	/^    struct ovsdb_idl_txn *txn;$/;"	m	struct:vtep_ctl_context	typeref:struct:vtep_ctl_context::ovsdb_idl_txn	file:
txn_aborted	.\lib\ovsdb-idl.c	/^COVERAGE_DEFINE(txn_aborted);$/;"	v
txn_error	.\lib\ovsdb-idl.c	/^COVERAGE_DEFINE(txn_error);$/;"	v
txn_incomplete	.\lib\ovsdb-idl.c	/^COVERAGE_DEFINE(txn_incomplete);$/;"	v
txn_indexes	.\ovsdb\transaction.c	/^    struct hmap *txn_indexes;$/;"	m	struct:ovsdb_txn_table	typeref:struct:ovsdb_txn_table::hmap	file:
txn_node	.\lib\ovsdb-idl-provider.h	/^    struct hmap_node txn_node;  \/* Node in ovsdb_idl_txn's list. *\/$/;"	m	struct:ovsdb_idl_row	typeref:struct:ovsdb_idl_row::hmap_node
txn_not_locked	.\lib\ovsdb-idl.c	/^COVERAGE_DEFINE(txn_not_locked);$/;"	v
txn_row	.\ovsdb\row.h	/^    struct ovsdb_txn_row *txn_row; \/* Transaction that row is in, if any. *\/$/;"	m	struct:ovsdb_row	typeref:struct:ovsdb_row::ovsdb_txn_row
txn_rows	.\lib\ovsdb-idl.c	/^    struct hmap txn_rows;$/;"	m	struct:ovsdb_idl_txn	typeref:struct:ovsdb_idl_txn::hmap	file:
txn_rows	.\ovsdb\transaction.c	/^    struct hmap txn_rows;       \/* Contains "struct ovsdb_txn_row"s. *\/$/;"	m	struct:ovsdb_txn_table	typeref:struct:ovsdb_txn_table::hmap	file:
txn_success	.\lib\ovsdb-idl.c	/^COVERAGE_DEFINE(txn_success);$/;"	v
txn_table	.\ovsdb\table.h	/^    struct ovsdb_txn_table *txn_table; \/* Only if table is in a transaction. *\/$/;"	m	struct:ovsdb_table	typeref:struct:ovsdb_table::ovsdb_txn_table
txn_tables	.\ovsdb\transaction.c	/^    struct list txn_tables;     \/* Contains "struct ovsdb_txn_table"s. *\/$/;"	m	struct:ovsdb_txn	typeref:struct:ovsdb_txn::list	file:
txn_try_again	.\lib\ovsdb-idl.c	/^COVERAGE_DEFINE(txn_try_again);$/;"	v
txn_unchanged	.\lib\ovsdb-idl.c	/^COVERAGE_DEFINE(txn_unchanged);$/;"	v
txn_uncommitted	.\lib\ovsdb-idl.c	/^COVERAGE_DEFINE(txn_uncommitted);$/;"	v
txq	.\lib\netdev-dummy.c	/^    struct list txq;$/;"	m	struct:dummy_packet_stream	typeref:struct:dummy_packet_stream::list	file:
txq	.\lib\rconn.c	/^    struct list txq;            \/* Contains "struct ofpbuf"s. *\/$/;"	m	struct:rconn	typeref:struct:rconn::list	file:
type	.\datapath\flow.h	/^		__be16 type;		\/* Ethernet frame type. *\/$/;"	m	struct:sw_flow_key::__anon2
type	.\datapath\vport.h	/^	enum ovs_vport_type type;$/;"	m	struct:vport_ops	typeref:enum:vport_ops::ovs_vport_type
type	.\datapath\vport.h	/^	enum ovs_vport_type type;$/;"	m	struct:vport_parms	typeref:enum:vport_parms::ovs_vport_type
type	.\include\openflow\nicira-ext.h	/^    ovs_be16 type;                  \/* OFPAT_VENDOR. *\/$/;"	m	struct:nx_action_controller
type	.\include\openflow\nicira-ext.h	/^    ovs_be16 type;                  \/* OFPAT_VENDOR. *\/$/;"	m	struct:nx_action_header
type	.\include\openflow\nicira-ext.h	/^    ovs_be16 type;                  \/* OFPAT_VENDOR. *\/$/;"	m	struct:nx_action_mpls_label
type	.\include\openflow\nicira-ext.h	/^    ovs_be16 type;                  \/* OFPAT_VENDOR. *\/$/;"	m	struct:nx_action_mpls_tc
type	.\include\openflow\nicira-ext.h	/^    ovs_be16 type;                  \/* OFPAT_VENDOR. *\/$/;"	m	struct:nx_action_mpls_ttl
type	.\include\openflow\nicira-ext.h	/^    ovs_be16 type;                  \/* OFPAT_VENDOR. *\/$/;"	m	struct:nx_action_note
type	.\include\openflow\nicira-ext.h	/^    ovs_be16 type;                  \/* OFPAT_VENDOR. *\/$/;"	m	struct:nx_action_pop_mpls
type	.\include\openflow\nicira-ext.h	/^    ovs_be16 type;                  \/* OFPAT_VENDOR. *\/$/;"	m	struct:nx_action_pop_queue
type	.\include\openflow\nicira-ext.h	/^    ovs_be16 type;                  \/* OFPAT_VENDOR. *\/$/;"	m	struct:nx_action_push_mpls
type	.\include\openflow\nicira-ext.h	/^    ovs_be16 type;                  \/* OFPAT_VENDOR. *\/$/;"	m	struct:nx_action_reg_load
type	.\include\openflow\nicira-ext.h	/^    ovs_be16 type;                  \/* OFPAT_VENDOR. *\/$/;"	m	struct:nx_action_reg_move
type	.\include\openflow\nicira-ext.h	/^    ovs_be16 type;                  \/* OFPAT_VENDOR. *\/$/;"	m	struct:nx_action_resubmit
type	.\include\openflow\nicira-ext.h	/^    ovs_be16 type;                  \/* OFPAT_VENDOR. *\/$/;"	m	struct:nx_action_sample
type	.\include\openflow\nicira-ext.h	/^    ovs_be16 type;                  \/* OFPAT_VENDOR. *\/$/;"	m	struct:nx_action_set_queue
type	.\include\openflow\nicira-ext.h	/^    ovs_be16 type;                  \/* OFPAT_VENDOR. *\/$/;"	m	struct:nx_action_set_tunnel
type	.\include\openflow\nicira-ext.h	/^    ovs_be16 type;                  \/* OFPAT_VENDOR. *\/$/;"	m	struct:nx_action_set_tunnel64
type	.\include\openflow\nicira-ext.h	/^    ovs_be16 type;                  \/* OFPAT_VENDOR. *\/$/;"	m	struct:nx_action_stack
type	.\include\openflow\nicira-ext.h	/^    ovs_be16 type;                  \/* OFPAT_VENDOR. *\/$/;"	m	struct:nx_action_write_metadata
type	.\include\openflow\nicira-ext.h	/^    ovs_be16 type;              \/* OFPAT_VENDOR. *\/$/;"	m	struct:nx_action_bundle
type	.\include\openflow\nicira-ext.h	/^    ovs_be16 type;              \/* OFPAT_VENDOR. *\/$/;"	m	struct:nx_action_cnt_ids
type	.\include\openflow\nicira-ext.h	/^    ovs_be16 type;              \/* OFPAT_VENDOR. *\/$/;"	m	struct:nx_action_fin_timeout
type	.\include\openflow\nicira-ext.h	/^    ovs_be16 type;              \/* OFPAT_VENDOR. *\/$/;"	m	struct:nx_action_learn
type	.\include\openflow\nicira-ext.h	/^    ovs_be16 type;              \/* OFPAT_VENDOR. *\/$/;"	m	struct:nx_action_multipath
type	.\include\openflow\nicira-ext.h	/^    ovs_be16 type;              \/* OFPAT_VENDOR. *\/$/;"	m	struct:nx_action_output_reg
type	.\include\openflow\nicira-ext.h	/^    ovs_be16 type;              \/* Vendor-defined type. *\/$/;"	m	struct:nx_vendor_error
type	.\include\openflow\openflow-1.0.h	/^    ovs_be16 type;                  \/* OFPAT10_OUTPUT. *\/$/;"	m	struct:ofp10_action_output
type	.\include\openflow\openflow-1.0.h	/^    ovs_be16 type;              \/* One of the OFPST_* constants. *\/$/;"	m	struct:ofp10_stats_msg
type	.\include\openflow\openflow-1.0.h	/^    ovs_be16 type;            \/* OFPAT10_ENQUEUE. *\/$/;"	m	struct:ofp10_action_enqueue
type	.\include\openflow\openflow-1.1.h	/^    ovs_be16 type;                    \/* OFPAT11_GROUP. *\/$/;"	m	struct:ofp11_action_group
type	.\include\openflow\openflow-1.1.h	/^    ovs_be16 type;                    \/* OFPAT11_OUTPUT. *\/$/;"	m	struct:ofp11_action_output
type	.\include\openflow\openflow-1.1.h	/^    ovs_be16 type;                    \/* OFPAT11_POP_MPLS. *\/$/;"	m	struct:ofp11_action_pop_mpls
type	.\include\openflow\openflow-1.1.h	/^    ovs_be16 type;                    \/* OFPAT11_PUSH_VLAN\/MPLS. *\/$/;"	m	struct:ofp11_action_push
type	.\include\openflow\openflow-1.1.h	/^    ovs_be16 type;                    \/* OFPAT11_SET_MPLS_LABEL. *\/$/;"	m	struct:ofp11_action_mpls_label
type	.\include\openflow\openflow-1.1.h	/^    ovs_be16 type;                    \/* OFPAT11_SET_MPLS_TC. *\/$/;"	m	struct:ofp11_action_mpls_tc
type	.\include\openflow\openflow-1.1.h	/^    ovs_be16 type;                    \/* OFPAT11_SET_MPLS_TTL. *\/$/;"	m	struct:ofp11_action_mpls_ttl
type	.\include\openflow\openflow-1.1.h	/^    ovs_be16 type;                    \/* OFPAT11_SET_NW_TTL. *\/$/;"	m	struct:ofp11_action_nw_ttl
type	.\include\openflow\openflow-1.1.h	/^    ovs_be16 type;                    \/* OFPAT11_SET_QUEUE. *\/$/;"	m	struct:ofp11_action_set_queue
type	.\include\openflow\openflow-1.1.h	/^    ovs_be16 type;                    \/* OFPAT11_SET_TW_SRC\/DST. *\/$/;"	m	struct:ofp11_action_nw_ecn
type	.\include\openflow\openflow-1.1.h	/^    ovs_be16 type;                 \/* OFPIT_GOTO_TABLE *\/$/;"	m	struct:ofp11_instruction_goto_table
type	.\include\openflow\openflow-1.1.h	/^    ovs_be16 type;              \/* Instruction type *\/$/;"	m	struct:ofp11_instruction
type	.\include\openflow\openflow-1.1.h	/^    ovs_be16 type;              \/* OFPIT11_EXPERIMENTER *\/$/;"	m	struct:ofp11_instruction_experimenter
type	.\include\openflow\openflow-1.1.h	/^    ovs_be16 type;              \/* OFPIT_WRITE_METADATA *\/$/;"	m	struct:ofp11_instruction_write_metadata
type	.\include\openflow\openflow-1.1.h	/^    ovs_be16 type;              \/* One of OFPIT_*_ACTIONS *\/$/;"	m	struct:ofp11_instruction_actions
type	.\include\openflow\openflow-1.1.h	/^    ovs_be16 type;              \/* One of the OFPST_* constants. *\/$/;"	m	struct:ofp11_stats_msg
type	.\include\openflow\openflow-1.1.h	/^    ovs_be16 type;             \/* One of OFPMT_* *\/$/;"	m	struct:ofp11_match_header
type	.\include\openflow\openflow-1.1.h	/^    uint8_t type;                 \/* One of OFPGT11_*. *\/$/;"	m	struct:ofp11_group_mod
type	.\include\openflow\openflow-1.1.h	/^    uint8_t type;               \/* One of OFPGT11_*. *\/$/;"	m	struct:ofp11_group_desc_stats
type	.\include\openflow\openflow-1.2.h	/^    ovs_be16 type;                  \/* OFPAT12_SET_FIELD. *\/$/;"	m	struct:ofp12_action_set_field
type	.\include\openflow\openflow-1.3.h	/^    ovs_be16    type;        \/* OFPMBT_DROP. *\/$/;"	m	struct:ofp13_action_self_learning::ofp13_meter_band_drop
type	.\include\openflow\openflow-1.3.h	/^    ovs_be16    type;        \/* OFPMBT_DSCP_REMARK. *\/$/;"	m	struct:ofp13_action_self_learning::ofp13_meter_band_dscp_remark
type	.\include\openflow\openflow-1.3.h	/^    ovs_be16    type;        \/* OFPMBT_EXPERIMENTER. *\/$/;"	m	struct:ofp13_action_self_learning::ofp13_meter_band_experimenter
type	.\include\openflow\openflow-1.3.h	/^    ovs_be16    type;     \/* One of OFPTFPT13_EXPERIMENTER,$/;"	m	struct:ofp13_action_self_learning::ofp13_table_feature_prop_experimenter
type	.\include\openflow\openflow-1.3.h	/^    ovs_be16    type;    \/* One of OFPTFPT13_INSTRUCTIONS,$/;"	m	struct:ofp13_action_self_learning::ofp13_table_feature_prop_instructions
type	.\include\openflow\openflow-1.3.h	/^    ovs_be16    type;   \/* One of OFPTFPT13_MATCH, OFPTFPT13_WILDCARDS,$/;"	m	struct:ofp13_action_self_learning::ofp13_table_feature_prop_oxm
type	.\include\openflow\openflow-1.3.h	/^    ovs_be16    type;   \/* One of OFPTFPT13_NEXT_TABLES,$/;"	m	struct:ofp13_action_self_learning::ofp13_table_feature_prop_next_tables
type	.\include\openflow\openflow-1.3.h	/^    ovs_be16    type;   \/* One of OFPTFPT13_WRITE_ACTIONS,$/;"	m	struct:ofp13_action_self_learning::ofp13_table_feature_prop_actions
type	.\include\openflow\openflow-1.3.h	/^    ovs_be16    type;   \/* One of OFPTFPT_*. *\/$/;"	m	struct:ofp13_action_self_learning::ofp13_table_feature_prop_header
type	.\include\openflow\openflow-1.3.h	/^    ovs_be16 type;                  \/* OFPAT11_SELF_LEARNING. *\/$/;"	m	struct:ofp13_action_self_learning
type	.\include\openflow\openflow-1.3.h	/^    ovs_be16 type;              \/* OFPIT13_METER *\/$/;"	m	struct:ofp13_instruction_meter
type	.\include\openflow\openflow-1.3.h	/^    ovs_be16 type;       \/* One of OFPMBT_*. *\/$/;"	m	struct:ofp13_action_self_learning::ofp13_meter_band_header
type	.\include\openflow\openflow-1.4.h	/^    ovs_be16         type;    \/* OFPPDPT14_ETHERNET. *\/$/;"	m	struct:ofp14_port_desc_prop_ethernet
type	.\include\openflow\openflow-1.4.h	/^    ovs_be16         type;    \/* OFPPSPT14_ETHERNET. *\/$/;"	m	struct:ofp14_port_stats_prop_ethernet
type	.\include\openflow\openflow-1.4.h	/^    ovs_be16         type;    \/* OFPTMPT14_EVICTION. *\/$/;"	m	struct:ofp14_table_mod_prop_eviction
type	.\include\openflow\openflow-1.4.h	/^    ovs_be16         type;   \/* OFPTMPT14_VACANCY. *\/$/;"	m	struct:ofp14_table_mod_prop_vacancy
type	.\include\openflow\openflow-1.4.h	/^    ovs_be16        type;       \/* One of OFPRPT_EXPERIMENTER. *\/$/;"	m	struct:ofp14_role_prop_experimenter
type	.\include\openflow\openflow-1.4.h	/^    ovs_be16        type;       \/* One of OFPTFPT_EXPERIMENTER_SLAVE,$/;"	m	struct:ofp14_async_config_prop_experimenter
type	.\include\openflow\openflow-1.4.h	/^    ovs_be16      type;       \/* OFPPMPT14_ETHERNET. *\/$/;"	m	struct:ofp14_port_mod_prop_ethernet
type	.\include\openflow\openflow-1.4.h	/^    ovs_be16    type;       \/* One of OFPACPT_*. *\/$/;"	m	struct:ofp14_async_config_prop_header
type	.\include\openflow\openflow-1.4.h	/^    ovs_be16    type;$/;"	m	struct:ofp14_async_config_prop_reasons
type	.\include\openflow\openflow-1.4.h	/^    ovs_be16 type;          \/* OFPT_BUNDLE_CONTROL: one of OFPBCT_*.$/;"	m	struct:ofp14_bundle_ctrl_msg
type	.\include\openflow\openflow-1.4.h	/^    ovs_be16 type;   \/* One of OFPRPT_*. *\/$/;"	m	struct:ofp14_role_prop_header
type	.\include\openflow\openflow-common.h	/^    ovs_be16    type;        \/* One of OFPHET_*. *\/$/;"	m	struct:ofp_hello_elem_header
type	.\include\openflow\openflow-common.h	/^    ovs_be16 type;                  \/* OFPAT10_VENDOR. *\/$/;"	m	struct:ofp_action_vendor_header
type	.\include\openflow\openflow-common.h	/^    ovs_be16 type;                  \/* One of OFPAT*. *\/$/;"	m	struct:ofp_action_header
type	.\include\openflow\openflow-common.h	/^    ovs_be16 type;                  \/* Type. *\/$/;"	m	struct:ofp_action_dl_addr
type	.\include\openflow\openflow-common.h	/^    ovs_be16 type;                  \/* Type. *\/$/;"	m	struct:ofp_action_nw_addr
type	.\include\openflow\openflow-common.h	/^    ovs_be16 type;                  \/* Type. *\/$/;"	m	struct:ofp_action_tp_port
type	.\include\openflow\openflow-common.h	/^    ovs_be16 type;                  \/* Type. *\/$/;"	m	struct:ofp_action_vlan_pcp
type	.\include\openflow\openflow-common.h	/^    ovs_be16 type;                  \/* Type. *\/$/;"	m	struct:ofp_action_vlan_vid
type	.\include\openflow\openflow-common.h	/^    ovs_be16 type;                  \/* Type.. *\/$/;"	m	struct:ofp_action_nw_tos
type	.\include\openflow\openflow-common.h	/^    ovs_be16 type;$/;"	m	struct:ofp_error_msg
type	.\include\openflow\openflow-common.h	/^    uint8_t type;       \/* One of the OFPT_ constants. *\/$/;"	m	struct:ofp_header
type	.\lib\dpif-linux.h	/^    enum ovs_vport_type type;$/;"	m	struct:dpif_linux_vport	typeref:enum:dpif_linux_vport::ovs_vport_type
type	.\lib\dpif-netdev.c	/^    char *type;                 \/* Port type as requested by user. *\/$/;"	m	struct:dp_netdev_port	file:
type	.\lib\dpif-provider.h	/^    const char *type;$/;"	m	struct:dpif_class
type	.\lib\dpif.h	/^    char *type;                 \/* Network device type, e.g. "system". *\/$/;"	m	struct:dpif_port
type	.\lib\dpif.h	/^    enum dpif_op_type type;$/;"	m	struct:dpif_op	typeref:enum:dpif_op::dpif_op_type
type	.\lib\dpif.h	/^    enum dpif_upcall_type type;$/;"	m	struct:dpif_upcall	typeref:enum:dpif_upcall::dpif_upcall_type
type	.\lib\json.c	/^    enum json_token_type type;$/;"	m	struct:json_token	typeref:enum:json_token::json_token_type	file:
type	.\lib\json.h	/^    enum json_type type;$/;"	m	struct:json	typeref:enum:json::json_type
type	.\lib\jsonrpc.h	/^    enum jsonrpc_msg_type type;$/;"	m	struct:jsonrpc_msg	typeref:enum:jsonrpc_msg::jsonrpc_msg_type
type	.\lib\netdev-dummy.c	/^    enum dummy_packet_conn_type type;$/;"	m	struct:dummy_packet_conn	typeref:enum:dummy_packet_conn::dummy_packet_conn_type	file:
type	.\lib\netdev-provider.h	/^    const char *type;$/;"	m	struct:netdev_class
type	.\lib\netlink.h	/^    enum nl_attr_type type;$/;"	m	struct:nl_policy	typeref:enum:nl_policy::nl_attr_type
type	.\lib\odp-util.h	/^        uint16_t type;          \/* USER_ACTION_COOKIE_FLOW_SAMPLE. *\/$/;"	m	struct:user_action_cookie::__anon71
type	.\lib\odp-util.h	/^        uint16_t type;          \/* USER_ACTION_COOKIE_IPFIX. *\/$/;"	m	struct:user_action_cookie::__anon72
type	.\lib\odp-util.h	/^        uint16_t type;          \/* USER_ACTION_COOKIE_SFLOW. *\/$/;"	m	struct:user_action_cookie::__anon69
type	.\lib\odp-util.h	/^        uint16_t type;          \/* USER_ACTION_COOKIE_SLOW_PATH. *\/$/;"	m	struct:user_action_cookie::__anon70
type	.\lib\odp-util.h	/^    uint16_t type;              \/* enum user_action_cookie_type. *\/$/;"	m	union:user_action_cookie
type	.\lib\ofp-actions.c	/^    enum ovs_instruction_type type;$/;"	m	struct:instruction_type_info	typeref:enum:instruction_type_info::ovs_instruction_type	file:
type	.\lib\ofp-actions.c	/^    ovs_be16 type;$/;"	m	union:ofp_action	file:
type	.\lib\ofp-actions.h	/^    enum ofpact_type type;      \/* OFPACT_*. *\/$/;"	m	struct:ofpact	typeref:enum:ofpact::ofpact_type
type	.\lib\ofp-errors.c	/^    int type, code;$/;"	m	struct:triplet	file:
type	.\lib\ofp-msgs.c	/^    enum ofptype type;$/;"	m	struct:raw_info	typeref:enum:raw_info::ofptype	file:
type	.\lib\ofp-msgs.c	/^    uint8_t type;               \/* From ofp_header. *\/$/;"	m	struct:ofphdrs	file:
type	.\lib\ofp-util.c	/^    ovs_be16 type;$/;"	m	struct:ofp_prop_header	file:
type	.\lib\ofp-util.h	/^    uint16_t    type;$/;"	m	struct:ofputil_bundle_ctrl_msg
type	.\lib\ofp-util.h	/^    uint16_t type;$/;"	m	struct:ofputil_meter_band
type	.\lib\ofp-util.h	/^    uint8_t type;                 \/* One of OFPGT11_*. *\/$/;"	m	struct:ofputil_group_mod
type	.\lib\ofp-util.h	/^    uint8_t type;               \/* One of OFPGT_*. *\/$/;"	m	struct:ofputil_group_desc
type	.\lib\ovsdb-idl-provider.h	/^    struct ovsdb_type type;$/;"	m	struct:ovsdb_idl_column	typeref:struct:ovsdb_idl_column::ovsdb_type
type	.\lib\ovsdb-types.h	/^    enum ovsdb_atomic_type type;$/;"	m	struct:ovsdb_base_type	typeref:enum:ovsdb_base_type::ovsdb_atomic_type
type	.\lib\sflow.h	/^    u_int32_t type;           \/* enum SFLAddress_type *\/$/;"	m	struct:_SFLAddress
type	.\lib\sflow.h	/^    u_int32_t type;   \/* enum SFLExtended_as_path_segment_type *\/$/;"	m	struct:_SFLExtended_as_path_segment
type	.\lib\stream-ssl.c	/^    enum session_type type;$/;"	m	struct:ssl_stream	typeref:enum:ssl_stream::session_type	file:
type	.\lib\table.h	/^    const struct ovsdb_type *type;$/;"	m	struct:cell	typeref:struct:cell::ovsdb_type
type	.\lib\util.c	/^    } type;$/;"	m	struct:scan_spec	typeref:enum:scan_spec::__anon96	file:
type	.\lib\vswitch-idl.h	/^	char *type;	\/* Always nonnull. *\/$/;"	m	struct:ovsrec_interface
type	.\lib\vswitch-idl.h	/^	char *type;	\/* Always nonnull. *\/$/;"	m	struct:ovsrec_qos
type	.\ofproto\connmgr.c	/^    enum ofconn_type type;      \/* Type. *\/$/;"	m	struct:ofconn	typeref:enum:ofconn::ofconn_type	file:
type	.\ofproto\ofproto-dpif-xlate.c	/^    enum xc_type type;$/;"	m	struct:xc_entry	typeref:enum:xc_entry::xc_type	file:
type	.\ofproto\ofproto-dpif.c	/^    char *type;$/;"	m	struct:dpif_backer	file:
type	.\ofproto\ofproto-provider.h	/^    char *type;                 \/* Datapath type. *\/$/;"	m	struct:ofproto
type	.\ofproto\ofproto-provider.h	/^    enum ofp11_group_type type; \/* One of OFPGT_*. *\/$/;"	m	struct:ofgroup	typeref:enum:ofgroup::ofp11_group_type
type	.\ofproto\ofproto.c	/^    enum ofoperation_type type; \/* Type of operation. *\/$/;"	m	struct:ofoperation	typeref:enum:ofoperation::ofoperation_type	file:
type	.\ofproto\ofproto.h	/^    char *type;                 \/* Network device type, e.g. "system". *\/$/;"	m	struct:ofproto_port
type	.\ovsdb\column.h	/^    struct ovsdb_type type;$/;"	m	struct:ovsdb_column	typeref:struct:ovsdb_column::ovsdb_type
type	.\ovsdb\mutation.h	/^    struct ovsdb_type type;$/;"	m	struct:ovsdb_mutation	typeref:struct:ovsdb_mutation::ovsdb_type
type	.\tests\test-sflow.c	/^    } type;$/;"	m	struct:sflow_addr	typeref:enum:sflow_addr::__anon158	file:
type	.\tests\test-vconn.c	/^    const char *type;$/;"	m	struct:fake_pvconn	file:
type	.\vswitchd\bridge.c	/^    char *type;                 \/* Datapath type. *\/$/;"	m	struct:bridge	file:
type	.\vswitchd\bridge.c	/^    const char *type;           \/* Usually same as cfg->type. *\/$/;"	m	struct:iface	file:
type_get_memory_usage	.\ofproto\ofproto-dpif.c	/^type_get_memory_usage(const char *type, struct simap *usage)$/;"	f	file:
type_get_memory_usage	.\ofproto\ofproto-provider.h	/^    void (*type_get_memory_usage)(const char *type, struct simap *usage);$/;"	m	struct:ofproto_class
type_mismatch	.\ovsdb\mutation.c	/^type_mismatch(const struct ovsdb_mutation *m, const struct json *json)$/;"	f	file:
type_run	.\ofproto\ofproto-dpif.c	/^type_run(const char *type)$/;"	f	file:
type_run	.\ofproto\ofproto-provider.h	/^    int (*type_run)(const char *type);$/;"	m	struct:ofproto_class
type_to_string	.\python\ovs\jsonrpc.py	/^    def type_to_string(type_):$/;"	m	class:Message
type_wait	.\ofproto\ofproto-dpif.c	/^type_wait(const char *type)$/;"	f	file:
type_wait	.\ofproto\ofproto-provider.h	/^    void (*type_wait)(const char *type);$/;"	m	struct:ofproto_class
types	.\include\openflow\openflow-1.2.h	/^    ovs_be32  types;           \/* Bitmap of OFPGT11_* values supported. *\/$/;"	m	struct:ofp12_group_features_stats
types	.\lib\ofp-util.h	/^    uint32_t  types;           \/* Bitmap of OFPGT_* values supported. *\/$/;"	m	struct:ofputil_group_features
types	.\python\ovs\db\data.py	/^import ovs.db.types$/;"	i
types	.\python\ovs\db\schema.py	/^from ovs.db import types$/;"	i
types	.\python\ovs\unixctl\__init__.py	/^import types$/;"	i
types	.\python\ovs\unixctl\client.py	/^import types$/;"	i
types	.\python\ovs\unixctl\server.py	/^import types$/;"	i
types	.\tests\test-ovsdb.py	/^from ovs.db import types$/;"	i
u	.\include\sparse\netinet\in.h	/^    } u;$/;"	m	struct:in6_addr	typeref:union:in6_addr::__anon25
u	.\lib\dpif.h	/^    } u;$/;"	m	struct:dpif_op	typeref:union:dpif_op::__anon45
u	.\lib\json.c	/^    } u;$/;"	m	struct:json_token	typeref:union:json_token::__anon48	file:
u	.\lib\json.h	/^    } u;$/;"	m	struct:json	typeref:union:json::__anon49
u	.\lib\netdev-dummy.c	/^    } u;$/;"	m	struct:dummy_packet_conn	typeref:union:dummy_packet_conn::__anon57	file:
u	.\lib\ovsdb-types.h	/^    } u;$/;"	m	struct:ovsdb_base_type	typeref:union:ovsdb_base_type::__anon86
u	.\ofproto\ofproto-dpif-xlate.c	/^    } u;$/;"	m	struct:xc_entry	typeref:union:xc_entry::__anon136	file:
u	.\tests\idltest.h	/^	struct uuid u;$/;"	m	struct:idltest_simple	typeref:struct:idltest_simple::uuid
u1	.\datapath\vport-lisp.c	/^	} u1;$/;"	m	struct:lisphdr	typeref:union:lisphdr::__anon17	file:
u2	.\datapath\vport-lisp.c	/^	} u2;$/;"	m	struct:lisphdr	typeref:union:lisphdr::__anon18	file:
u64_stats_fetch_begin	.\datapath\linux\compat\include\linux\u64_stats_sync.h	/^static inline unsigned int u64_stats_fetch_begin(const struct u64_stats_sync *syncp)$/;"	f
u64_stats_fetch_begin_irq	.\datapath\linux\compat\include\linux\u64_stats_sync.h	/^static inline unsigned int u64_stats_fetch_begin_irq(const struct u64_stats_sync *syncp)$/;"	f
u64_stats_fetch_retry	.\datapath\linux\compat\include\linux\u64_stats_sync.h	/^static inline bool u64_stats_fetch_retry(const struct u64_stats_sync *syncp,$/;"	f
u64_stats_fetch_retry_irq	.\datapath\linux\compat\include\linux\u64_stats_sync.h	/^static inline bool u64_stats_fetch_retry_irq(const struct u64_stats_sync *syncp,$/;"	f
u64_stats_init	.\datapath\linux\compat\include\linux\u64_stats_sync.h	78;"	d
u64_stats_init	.\datapath\linux\compat\include\linux\u64_stats_sync.h	80;"	d
u64_stats_sync	.\datapath\linux\compat\include\linux\u64_stats_sync.h	/^struct u64_stats_sync {$/;"	s
u64_stats_update_begin	.\datapath\linux\compat\include\linux\u64_stats_sync.h	/^static inline void u64_stats_update_begin(struct u64_stats_sync *syncp)$/;"	f
u64_stats_update_end	.\datapath\linux\compat\include\linux\u64_stats_sync.h	/^static inline void u64_stats_update_end(struct u64_stats_sync *syncp)$/;"	f
u8	.\lib\meta-flow.h	/^    uint8_t u8;$/;"	m	union:mf_value
u8	.\lib\meta-flow.h	/^    uint8_t u8[16];$/;"	m	union:mf_subvalue
u_int16_t	.\include\windows\windefs.h	34;"	d
u_int32_t	.\include\windows\windefs.h	35;"	d
u_int64_t	.\include\windows\windefs.h	36;"	d
u_int8_t	.\include\windows\windefs.h	33;"	d
u_s6_addr	.\include\sparse\netinet\in.h	/^        uint8_t u_s6_addr[16];$/;"	m	union:in6_addr::__anon25
ua	.\tests\idltest.h	/^	struct uuid *ua;$/;"	m	struct:idltest_simple	typeref:struct:idltest_simple::uuid
uc_array_size	.\lib\dpif-linux.c	/^    int uc_array_size;             \/* Size of 'handler->channels' and *\/$/;"	m	struct:dpif_linux	file:
uc_is_code_point	.\lib\unicode.h	/^uc_is_code_point(int c)$/;"	f
uc_is_leading_surrogate	.\lib\unicode.h	/^uc_is_leading_surrogate(int c)$/;"	f
uc_is_surrogate	.\lib\unicode.h	/^uc_is_surrogate(int c)$/;"	f
uc_is_trailing_surrogate	.\lib\unicode.h	/^uc_is_trailing_surrogate(int c)$/;"	f
ucastPkts	.\lib\sflow.h	/^    u_int32_t ucastPkts;$/;"	m	struct:_SFLVlan_counters
ucast_local	.\vtep\vtep-ctl.c	/^    struct shash ucast_local;   \/* Maps from mac to vteprec_ucast_macs_local. *\/$/;"	m	struct:vtep_ctl_lswitch	typeref:struct:vtep_ctl_lswitch::shash	file:
ucast_remote	.\vtep\vtep-ctl.c	/^    struct shash ucast_remote;  \/* Maps from mac to vteprec_ucast_macs_remote.*\/$/;"	m	struct:vtep_ctl_lswitch	typeref:struct:vtep_ctl_lswitch::shash	file:
udp	.\python\ovstest\rpcserver.py	/^import udp$/;"	i
udp_csum	.\lib\packets.h	/^    ovs_be16 udp_csum;$/;"	m	struct:udp_header
udp_dst	.\include\linux\openvswitch.h	/^	__be16 udp_dst;$/;"	m	struct:ovs_key_udp
udp_dst	.\lib\packets.h	/^    ovs_be16 udp_dst;$/;"	m	struct:udp_header
udp_encap_enable	.\datapath\linux\compat\include\linux\udp.h	/^static inline void udp_encap_enable(void)$/;"	f
udp_hdr	.\datapath\linux\compat\include\linux\udp.h	/^static inline struct udphdr *udp_hdr(const struct sk_buff *skb)$/;"	f
udp_header	.\lib\packets.h	/^struct udp_header {$/;"	s
udp_len	.\lib\packets.h	/^    ovs_be16 udp_len;$/;"	m	struct:udp_header
udp_src	.\include\linux\openvswitch.h	/^	__be16 udp_src;$/;"	m	struct:ovs_key_udp
udp_src	.\lib\bfd.c	/^    uint16_t udp_src;             \/* UDP source port. *\/$/;"	m	struct:bfd	file:
udp_src	.\lib\packets.h	/^    ovs_be16 udp_src;$/;"	m	struct:udp_header
udphdr_ok	.\datapath\flow.c	/^static bool udphdr_ok(struct sk_buff *skb)$/;"	f	file:
udpif	.\ofproto\ofproto-dpif-upcall.c	/^    struct udpif *udpif;               \/* Parent udpif. *\/$/;"	m	struct:handler	typeref:struct:handler::udpif	file:
udpif	.\ofproto\ofproto-dpif-upcall.c	/^    struct udpif *udpif;               \/* Parent udpif. *\/$/;"	m	struct:revalidator	typeref:struct:revalidator::udpif	file:
udpif	.\ofproto\ofproto-dpif-upcall.c	/^struct udpif {$/;"	s	file:
udpif	.\ofproto\ofproto-dpif.c	/^    struct udpif *udpif;$/;"	m	struct:dpif_backer	typeref:struct:dpif_backer::udpif	file:
udpif_create	.\ofproto\ofproto-dpif-upcall.c	/^udpif_create(struct dpif_backer *backer, struct dpif *dpif)$/;"	f
udpif_destroy	.\ofproto\ofproto-dpif-upcall.c	/^udpif_destroy(struct udpif *udpif)$/;"	f
udpif_dump_seq	.\ofproto\ofproto-dpif-upcall.c	/^udpif_dump_seq(struct udpif *udpif)$/;"	f
udpif_flush	.\ofproto\ofproto-dpif-upcall.c	/^udpif_flush(struct udpif *udpif)$/;"	f
udpif_flush_all_datapaths	.\ofproto\ofproto-dpif-upcall.c	/^udpif_flush_all_datapaths(void)$/;"	f	file:
udpif_get_memory_usage	.\ofproto\ofproto-dpif-upcall.c	/^udpif_get_memory_usage(struct udpif *udpif, struct simap *usage)$/;"	f
udpif_get_n_flows	.\ofproto\ofproto-dpif-upcall.c	/^udpif_get_n_flows(struct udpif *udpif)$/;"	f	file:
udpif_insert_ukey	.\ofproto\ofproto-dpif-upcall.c	/^udpif_insert_ukey(struct udpif *udpif, struct udpif_key *ukey, uint32_t hash)$/;"	f	file:
udpif_key	.\ofproto\ofproto-dpif-upcall.c	/^struct udpif_key {$/;"	s	file:
udpif_revalidate	.\ofproto\ofproto-dpif-upcall.c	/^udpif_revalidate(struct udpif *udpif)$/;"	f
udpif_revalidator	.\ofproto\ofproto-dpif-upcall.c	/^udpif_revalidator(void *arg)$/;"	f	file:
udpif_set_threads	.\ofproto\ofproto-dpif-upcall.c	/^udpif_set_threads(struct udpif *udpif, size_t n_handlers,$/;"	f
udpif_start_threads	.\ofproto\ofproto-dpif-upcall.c	/^udpif_start_threads(struct udpif *udpif, size_t n_handlers,$/;"	f	file:
udpif_stop_threads	.\ofproto\ofproto-dpif-upcall.c	/^udpif_stop_threads(struct udpif *udpif)$/;"	f	file:
udpif_synchronize	.\ofproto\ofproto-dpif-upcall.c	/^udpif_synchronize(struct udpif *udpif)$/;"	f
udpif_upcall_handler	.\ofproto\ofproto-dpif-upcall.c	/^udpif_upcall_handler(void *arg)$/;"	f	file:
uint32	.\lib\ofp-util.h	/^typedef struct { uint32_t uint32; } ofproto_meter_id;$/;"	m	struct:__anon77
uint32_byteswap	.\lib\byte-order.h	/^uint32_byteswap(uint32_t crc) {$/;"	f
ukey	.\ofproto\ofproto-dpif-upcall.c	/^    struct udpif_key *ukey;$/;"	m	struct:dump_op	typeref:struct:dump_op::udpif_key	file:
ukey_create	.\ofproto\ofproto-dpif-upcall.c	/^ukey_create(const struct nlattr *key, size_t key_len, long long int used)$/;"	f	file:
ukey_lookup	.\ofproto\ofproto-dpif-upcall.c	/^ukey_lookup(struct udpif *udpif, const struct nlattr *key, size_t key_len,$/;"	f	file:
ukey_lookup__	.\ofproto\ofproto-dpif-upcall.c	/^ukey_lookup__(struct udpif *udpif, const struct nlattr *key, size_t key_len,$/;"	f	file:
ukeys	.\ofproto\ofproto-dpif-upcall.c	/^    struct hmap *ukeys;                \/* Points into udpif->ukeys for this$/;"	m	struct:revalidator	typeref:struct:revalidator::hmap	file:
ukeys	.\ofproto\ofproto-dpif-upcall.c	/^    } *ukeys;$/;"	m	struct:udpif	typeref:struct:udpif::__anon135	file:
uname	.\python\ovstest\util.py	/^def uname():$/;"	f
uname	.\utilities\ovs-dev.py	/^def uname():$/;"	f
unbox_json	.\tests\test-ovsdb.c	/^unbox_json(struct json *json)$/;"	f	file:
unbox_json	.\tests\test-ovsdb.py	/^def unbox_json(json):$/;"	f
unique_hash	.\tests\test-hindex.c	/^unique_hash(int value)$/;"	f	file:
unix_epoch	.\lib\timeval.c	/^static ULARGE_INTEGER unix_epoch;$/;"	v	file:
unix_nsecs	.\lib\netflow.h	/^    ovs_be32 unix_nsecs;           \/* Number of residual nanoseconds$/;"	m	struct:netflow_v5_header
unix_open	.\lib\stream-unix.c	/^unix_open(const char *name, char *suffix, struct stream **streamp,$/;"	f	file:
unix_secs	.\lib\netflow.h	/^    ovs_be32 unix_secs;            \/* Number of seconds since Unix epoch. *\/$/;"	m	struct:netflow_v5_header
unix_stream_class	.\lib\stream-unix.c	/^const struct stream_class unix_stream_class = {$/;"	v	typeref:struct:stream_class
unix_vconn_class	.\lib\vconn-stream.c	/^const struct vconn_class unix_vconn_class = STREAM_INIT("unix");$/;"	v	typeref:struct:vconn_class
unixctl	.\lib\unixctl.c	/^VLOG_DEFINE_THIS_MODULE(unixctl);$/;"	v
unixctl	.\python\ovs\unixctl\server.py	/^import ovs.unixctl$/;"	i
unixctl	.\python\ovs\vlog.py	/^import ovs.unixctl$/;"	i
unixctl	.\tests\appctl.py	/^import ovs.unixctl$/;"	i
unixctl	.\tests\appctl.py	/^import ovs.unixctl.client$/;"	i
unixctl	.\tests\test-unixctl.py	/^import ovs.unixctl$/;"	i
unixctl	.\tests\test-unixctl.py	/^import ovs.unixctl.server$/;"	i
unixctl_block	.\tests\test-unixctl.py	/^def unixctl_block(conn, unused_argv, unused_aux):$/;"	f
unixctl_cb_func	.\lib\unixctl.h	/^typedef void unixctl_cb_func(struct unixctl_conn *,$/;"	t
unixctl_client_create	.\lib\unixctl.c	/^unixctl_client_create(const char *path, struct jsonrpc **client)$/;"	f
unixctl_client_transact	.\lib\unixctl.c	/^unixctl_client_transact(struct jsonrpc *client, const char *command, int argc,$/;"	f
unixctl_command	.\lib\unixctl.c	/^struct unixctl_command {$/;"	s	file:
unixctl_command_register	.\lib\unixctl.c	/^unixctl_command_register(const char *name, const char *usage,$/;"	f
unixctl_command_reply	.\lib\unixctl.c	/^unixctl_command_reply(struct unixctl_conn *conn, const char *result)$/;"	f
unixctl_command_reply__	.\lib\unixctl.c	/^unixctl_command_reply__(struct unixctl_conn *conn,$/;"	f	file:
unixctl_command_reply_error	.\lib\unixctl.c	/^unixctl_command_reply_error(struct unixctl_conn *conn, const char *error)$/;"	f
unixctl_conn	.\lib\unixctl.c	/^struct unixctl_conn {$/;"	s	file:
unixctl_echo	.\tests\test-unixctl.py	/^def unixctl_echo(conn, argv, aux):$/;"	f
unixctl_echo_error	.\tests\test-unixctl.py	/^def unixctl_echo_error(conn, argv, aux):$/;"	f
unixctl_exit	.\tests\test-unixctl.py	/^def unixctl_exit(conn, unused_argv, aux):$/;"	f
unixctl_help	.\lib\unixctl.c	/^unixctl_help(struct unixctl_conn *conn, int argc OVS_UNUSED,$/;"	f	file:
unixctl_log	.\tests\test-unixctl.py	/^def unixctl_log(conn, argv, unused_aux):$/;"	f
unixctl_path	.\tests\test-controller.c	/^static char *unixctl_path = NULL;$/;"	v	file:
unixctl_path	.\utilities\ovs-ofctl.c	/^static char *unixctl_path;$/;"	v	file:
unixctl_received	.\lib\unixctl.c	/^COVERAGE_DEFINE(unixctl_received);$/;"	v
unixctl_replied	.\lib\unixctl.c	/^COVERAGE_DEFINE(unixctl_replied);$/;"	v
unixctl_server	.\lib\unixctl.c	/^struct unixctl_server {$/;"	s	file:
unixctl_server_create	.\lib\unixctl.c	/^unixctl_server_create(const char *path, struct unixctl_server **serverp)$/;"	f
unixctl_server_destroy	.\lib\unixctl.c	/^unixctl_server_destroy(struct unixctl_server *server)$/;"	f
unixctl_server_run	.\lib\unixctl.c	/^unixctl_server_run(struct unixctl_server *server)$/;"	f
unixctl_server_wait	.\lib\unixctl.c	/^unixctl_server_wait(struct unixctl_server *server)$/;"	f
unixctl_version	.\lib\unixctl.c	/^unixctl_version(struct unixctl_conn *conn, int argc OVS_UNUSED,$/;"	f	file:
unknown_to_zero	.\lib\ofp-util.c	/^unknown_to_zero(uint64_t count)$/;"	f	file:
unlink_file_now	.\python\ovs\fatal_signal.py	/^def unlink_file_now(file):$/;"	f
unlink_files	.\lib\fatal-signal.c	/^unlink_files(void *aux OVS_UNUSED)$/;"	f	file:
unlink_path	.\lib\stream-fd-unix.c	/^    char *unlink_path;$/;"	m	struct:fd_pstream	file:
unlink_path	.\lib\stream-fd-windows.c	/^    char *unlink_path;$/;"	m	struct:fd_pstream	file:
unlink_pidfile	.\lib\daemon-windows.c	/^unlink_pidfile(void)$/;"	f	file:
unmasked_key	.\datapath\flow.h	/^	struct sw_flow_key unmasked_key;$/;"	m	struct:sw_flow	typeref:struct:sw_flow::sw_flow_key
unparse	.\lib\ovsdb-idl-provider.h	/^    void (*unparse)(struct ovsdb_idl_row *);$/;"	m	struct:ovsdb_idl_column
unregister_pernet_device	.\datapath\linux\compat\include\net\net_namespace.h	18;"	d
unused	.\lib\odp-util.h	/^        uint16_t unused;$/;"	m	struct:user_action_cookie::__anon70
unwrap_json	.\lib\ovsdb-data.c	/^unwrap_json(const struct json *json, const char *name,$/;"	f	file:
unwrap_json	.\python\ovs\db\parser.py	/^def unwrap_json(json, name, types, desc):$/;"	f
up	.\lib\netdev-bsd.c	/^    struct netdev up;$/;"	m	struct:netdev_bsd	typeref:struct:netdev_bsd::netdev	file:
up	.\lib\netdev-bsd.c	/^    struct netdev_rxq up;$/;"	m	struct:netdev_rxq_bsd	typeref:struct:netdev_rxq_bsd::netdev_rxq	file:
up	.\lib\netdev-dpdk.c	/^    struct netdev up;$/;"	m	struct:netdev_dpdk	typeref:struct:netdev_dpdk::netdev	file:
up	.\lib\netdev-dpdk.c	/^    struct netdev_rxq up;$/;"	m	struct:netdev_rxq_dpdk	typeref:struct:netdev_rxq_dpdk::netdev_rxq	file:
up	.\lib\netdev-dummy.c	/^    struct netdev up;$/;"	m	struct:netdev_dummy	typeref:struct:netdev_dummy::netdev	file:
up	.\lib\netdev-dummy.c	/^    struct netdev_rxq up;$/;"	m	struct:netdev_rxq_dummy	typeref:struct:netdev_rxq_dummy::netdev_rxq	file:
up	.\lib\netdev-linux.c	/^    struct netdev up;$/;"	m	struct:netdev_linux	typeref:struct:netdev_linux::netdev	file:
up	.\lib\netdev-linux.c	/^    struct netdev_rxq up;$/;"	m	struct:netdev_rxq_linux	typeref:struct:netdev_rxq_linux::netdev_rxq	file:
up	.\lib\netdev-vport.c	/^    struct netdev up;$/;"	m	struct:netdev_vport	typeref:struct:netdev_vport::netdev	file:
up	.\ofproto\connmgr.h	/^    struct ofputil_packet_in up;$/;"	m	struct:ofproto_packet_in	typeref:struct:ofproto_packet_in::ofputil_packet_in
up	.\ofproto\ofproto-dpif.c	/^    struct ofgroup up;$/;"	m	struct:group_dpif	typeref:struct:group_dpif::ofgroup	file:
up	.\ofproto\ofproto-dpif.c	/^    struct ofport up;$/;"	m	struct:ofport_dpif	typeref:struct:ofport_dpif::ofport	file:
up	.\ofproto\ofproto-dpif.c	/^    struct ofproto up;$/;"	m	struct:ofproto_dpif	typeref:struct:ofproto_dpif::ofproto	file:
up	.\ofproto\ofproto-dpif.c	/^    struct rule up;$/;"	m	struct:rule_dpif	typeref:struct:rule_dpif::rule	file:
up	.\ovsdb\jsonrpc-server.c	/^    struct ovsdb_server up;$/;"	m	struct:ovsdb_jsonrpc_server	typeref:struct:ovsdb_jsonrpc_server::ovsdb_server	file:
up	.\ovsdb\jsonrpc-server.c	/^    struct ovsdb_session up;$/;"	m	struct:ovsdb_jsonrpc_session	typeref:struct:ovsdb_jsonrpc_session::ovsdb_session	file:
up_delay	.\ofproto\bond.h	/^    int up_delay;               \/* ms before enabling an up slave. *\/$/;"	m	struct:bond_settings
upcall	.\lib\dpif-netdev.c	/^    struct dpif_upcall upcall;  \/* Queued upcall information. *\/$/;"	m	struct:dp_netdev_upcall	typeref:struct:dp_netdev_upcall::dpif_upcall	file:
upcall	.\ofproto\ofproto-dpif-upcall.c	/^struct upcall {$/;"	s	file:
upcall_buf	.\ofproto\ofproto-dpif-upcall.c	/^    struct ofpbuf upcall_buf;       \/* Owns some data in 'dpif_upcall'. *\/$/;"	m	struct:upcall	typeref:struct:upcall::ofpbuf	file:
upcall_duplicate_flow	.\ofproto\ofproto-dpif-upcall.c	/^COVERAGE_DEFINE(upcall_duplicate_flow);$/;"	v
upcall_lock	.\lib\dpif-linux.c	/^    struct fat_rwlock upcall_lock;$/;"	m	struct:dpif_linux	typeref:struct:dpif_linux::fat_rwlock	file:
upcall_msg_size	.\datapath\datapath.c	/^static size_t upcall_msg_size(const struct nlattr *userdata,$/;"	f	file:
upcall_pid	.\lib\dpif-linux.c	/^    const uint32_t *upcall_pid;        \/* OVS_DP_ATTR_UPCALL_PID. *\/$/;"	m	struct:dpif_linux_dp	file:
upcall_pids	.\lib\dpif-linux.h	/^    const uint32_t *upcall_pids;           \/* OVS_VPORT_ATTR_UPCALL_PID. *\/$/;"	m	struct:dpif_linux_vport
upcall_portids	.\datapath\vport.h	/^	struct nlattr *upcall_portids;$/;"	m	struct:vport_parms	typeref:struct:vport_parms::nlattr
upcall_portids	.\datapath\vport.h	/^	struct vport_portids __rcu *upcall_portids;$/;"	m	struct:vport	typeref:struct:vport::__rcu
upcall_stub	.\ofproto\ofproto-dpif-upcall.c	/^    uint64_t upcall_stub[512 \/ 8];  \/* Buffer to reduce need for malloc(). *\/$/;"	m	struct:upcall	file:
upcall_type	.\ofproto\ofproto-dpif-upcall.c	/^    enum dpif_upcall_type upcall_type;$/;"	m	struct:flow_miss	typeref:enum:flow_miss::dpif_upcall_type	file:
upcall_type	.\ofproto\ofproto-dpif-upcall.c	/^enum upcall_type {$/;"	g	file:
upcall_unixctl_disable_megaflows	.\ofproto\ofproto-dpif-upcall.c	/^upcall_unixctl_disable_megaflows(struct unixctl_conn *conn,$/;"	f	file:
upcall_unixctl_enable_megaflows	.\ofproto\ofproto-dpif-upcall.c	/^upcall_unixctl_enable_megaflows(struct unixctl_conn *conn,$/;"	f	file:
upcall_unixctl_set_flow_limit	.\ofproto\ofproto-dpif-upcall.c	/^upcall_unixctl_set_flow_limit(struct unixctl_conn *conn,$/;"	f	file:
upcall_unixctl_show	.\ofproto\ofproto-dpif-upcall.c	/^upcall_unixctl_show(struct unixctl_conn *conn, int argc OVS_UNUSED,$/;"	f	file:
update	.\lib\lacp.c	/^    bool update;             \/* True if lacp_update() needs to be called. *\/$/;"	m	struct:lacp	file:
update_flags	.\lib\netdev-provider.h	/^    int (*update_flags)(struct netdev *netdev, enum netdev_flags off,$/;"	m	struct:netdev_class
update_in_band_remotes	.\ofproto\connmgr.c	/^update_in_band_remotes(struct connmgr *mgr)$/;"	f	file:
update_ipv6_checksum	.\datapath\actions.c	/^static void update_ipv6_checksum(struct sk_buff *skb, u8 l4_proto,$/;"	f	file:
update_learning_table	.\ofproto\ofproto-dpif-xlate.c	/^update_learning_table(const struct xbridge *xbridge,$/;"	f	file:
update_monitor_row_data	.\ovsdb\jsonrpc-server.c	/^update_monitor_row_data(const struct ovsdb_jsonrpc_monitor_table *mt,$/;"	f	file:
update_mtu	.\ofproto\ofproto.c	/^update_mtu(struct ofproto *p, struct ofport *port)$/;"	f	file:
update_port	.\ofproto\ofproto.c	/^update_port(struct ofproto *ofproto, const char *name)$/;"	f	file:
update_port_config	.\ofproto\ofproto.c	/^update_port_config(struct ofconn *ofconn, struct ofport *port,$/;"	f	file:
update_range__	.\datapath\flow_netlink.c	/^static void update_range__(struct sw_flow_match *match,$/;"	f	file:
update_recirc_rules	.\ofproto\bond.c	/^update_recirc_rules(struct bond *bond)$/;"	f	file:
update_ref_counts	.\ovsdb\transaction.c	/^update_ref_counts(struct ovsdb_txn *txn)$/;"	f	file:
update_remote_row	.\ovsdb\ovsdb-server.c	/^update_remote_row(const struct ovsdb_row *row, struct ovsdb_txn *txn,$/;"	f	file:
update_remote_rows	.\ovsdb\ovsdb-server.c	/^update_remote_rows(const struct shash *all_dbs,$/;"	f	file:
update_remote_status	.\ovsdb\ovsdb-server.c	/^update_remote_status(const struct ovsdb_jsonrpc_server *jsonrpc,$/;"	f	file:
update_rhel_spec	.\rhel\automake.mk	/^update_rhel_spec = \\$/;"	m
update_row_cb	.\ovsdb\execution.c	/^update_row_cb(const struct ovsdb_row *row, void *ur_)$/;"	f	file:
update_row_cbdata	.\ovsdb\execution.c	/^struct update_row_cbdata {$/;"	s	file:
update_row_ref_count	.\ovsdb\transaction.c	/^update_row_ref_count(struct ovsdb_txn *txn, struct ovsdb_txn_row *r)$/;"	f	file:
update_rules	.\ofproto\in-band.c	/^update_rules(struct in_band *ib)$/;"	f	file:
update_ssl_config	.\lib\stream-ssl.c	/^update_ssl_config(struct ssl_config_file *config, const char *file_name)$/;"	f	file:
update_stp_port_state	.\ofproto\ofproto-dpif.c	/^update_stp_port_state(struct ofport_dpif *ofport)$/;"	f	file:
update_subtables_after_insertion	.\lib\classifier.c	/^update_subtables_after_insertion(struct cls_classifier *cls,$/;"	f	file:
update_subtables_after_removal	.\lib\classifier.c	/^update_subtables_after_removal(struct cls_classifier *cls,$/;"	f	file:
updelay	.\ofproto\bond.c	/^    int updelay, downdelay;     \/* Delay before slave goes up\/down, in ms. *\/$/;"	m	struct:bond	file:
uptime	.\lib\sflow.h	/^    u_int32_t uptime;                \/* Current time (in milliseconds since device$/;"	m	struct:_SFLSample_datagram_hdr
uptime	.\vswitchd\system-stats.c	/^    long long int uptime;       \/* ms since last (re)started by monitor. *\/$/;"	m	struct:process_info	file:
uptime	.\vswitchd\system-stats.c	/^    long long int uptime;       \/* ms since started. *\/$/;"	m	struct:raw_process_info	file:
uptime_mS	.\tests\test-sflow.c	/^    uint32_t uptime_mS;$/;"	m	struct:sflow_xdr	file:
urandom	.\lib\entropy.c	/^static const char urandom[] = "\/dev\/urandom";$/;"	v	file:
url	.\lib\sflow.h	/^    SFLExtended_url url;$/;"	m	union:_SFLFlow_type
url	.\lib\sflow.h	/^    SFLString url;         \/* URL associated with the packet flow.$/;"	m	struct:_SFLExtended_url
urlEncodingLength	.\lib\sflow_receiver.c	/^inline static u_int32_t urlEncodingLength(SFLExtended_url *url) {$/;"	f	file:
urn	.\python\compat\uuid.py	/^    urn = property(get_urn)$/;"	v	class:UUID
usable_protocols	.\lib\learning-switch.c	/^    enum ofputil_protocol usable_protocols;$/;"	m	struct:lswitch	typeref:enum:lswitch::ofputil_protocol	file:
usable_protocols	.\lib\learning-switch.h	/^    enum ofputil_protocol usable_protocols;$/;"	m	struct:lswitch_config	typeref:enum:lswitch_config::ofputil_protocol
usable_protocols	.\lib\meta-flow.h	/^    enum ofputil_protocol usable_protocols; \/* If fully\/cidr masked. *\/$/;"	m	struct:mf_field	typeref:enum:mf_field::ofputil_protocol
usable_protocols	.\tests\test-controller.c	/^static enum ofputil_protocol usable_protocols;$/;"	v	typeref:enum:ofputil_protocol	file:
usable_protocols_bitwise	.\lib\meta-flow.h	/^    enum ofputil_protocol usable_protocols_bitwise;$/;"	m	struct:mf_field	typeref:enum:mf_field::ofputil_protocol
usage	.\lib\unixctl.c	/^    const char *usage;$/;"	m	struct:unixctl_command	file:
usage	.\ovsdb\ovsdb-client.c	/^usage(void)$/;"	f	file:
usage	.\ovsdb\ovsdb-server.c	/^usage(void)$/;"	f	file:
usage	.\ovsdb\ovsdb-tool.c	/^usage(void)$/;"	f	file:
usage	.\python\ovs\daemon.py	/^def usage():$/;"	f
usage	.\python\ovs\stream.py	/^def usage(name):$/;"	f
usage	.\tests\test-controller.c	/^usage(void)$/;"	f	file:
usage	.\tests\test-jsonrpc.c	/^usage(void)$/;"	f	file:
usage	.\tests\test-netflow.c	/^usage(void)$/;"	f	file:
usage	.\tests\test-ovsdb.c	/^usage(void)$/;"	f	file:
usage	.\tests\test-ovsdb.py	/^def usage():$/;"	f
usage	.\tests\test-sflow.c	/^usage(void)$/;"	f	file:
usage	.\utilities\ovs-appctl.c	/^usage(void)$/;"	f	file:
usage	.\utilities\ovs-benchmark.c	/^usage(void)$/;"	f	file:
usage	.\utilities\ovs-dpctl.c	/^usage(void)$/;"	f	file:
usage	.\utilities\ovs-ofctl.c	/^usage(void)$/;"	f	file:
usage	.\utilities\ovs-vlan-bug-workaround.c	/^usage(void)$/;"	f	file:
usage	.\utilities\ovs-vsctl.c	/^usage(void)$/;"	f	file:
usage	.\vswitchd\ovs-vswitchd.c	/^usage(void)$/;"	f	file:
usage	.\vtep\vtep-ctl.c	/^usage(void)$/;"	f	file:
usage_to_timeval	.\lib\getrusage-windows.c	/^usage_to_timeval(FILETIME *ft, struct timeval *tv)$/;"	f	file:
use_priority_tags	.\ofproto\ofproto-dpif-xlate.c	/^    bool use_priority_tags;        \/* Use 802.1p tag for frames in VLAN 0? *\/$/;"	m	struct:xbundle	file:
use_priority_tags	.\ofproto\ofproto-dpif.c	/^    bool use_priority_tags;     \/* Use 802.1p tag for frames in VLAN 0? *\/$/;"	m	struct:ofbundle	file:
use_priority_tags	.\ofproto\ofproto.h	/^    bool use_priority_tags;     \/* Use 802.1p tag for frames in VLAN 0? *\/$/;"	m	struct:ofproto_bundle_settings
use_recirc	.\ofproto\ofproto-dpif-xlate.c	/^    bool use_recirc;            \/* Should generate recirc? *\/$/;"	m	struct:xlate_ctx	file:
used	.\datapath\flow.h	/^	unsigned long used;		\/* Last used time (in jiffies). *\/$/;"	m	struct:flow_stats
used	.\lib\dpif-linux.c	/^    const ovs_32aligned_u64 *used;      \/* OVS_FLOW_ATTR_USED. *\/$/;"	m	struct:dpif_linux_flow	file:
used	.\lib\dpif.h	/^    long long int used;$/;"	m	struct:dpif_flow_stats
used	.\lib\ovsdb-parser.h	/^    struct sset used;           \/* Already-parsed names from 'object'. *\/$/;"	m	struct:ovsdb_parser	typeref:struct:ovsdb_parser::sset
used	.\ofproto\netflow.c	/^    long long int used;           \/* Last-used time (0 if never used). *\/$/;"	m	struct:netflow_flow	file:
used_time	.\lib\netflow.h	/^    ovs_be32 used_time;            \/* Value of sysuptime on last packet. *\/$/;"	m	struct:netflow_v5_record
user	.\lib\sflow.h	/^    SFLExtended_user user;$/;"	m	union:_SFLFlow_type
userEncodingLength	.\lib\sflow_receiver.c	/^inline static u_int32_t userEncodingLength(SFLExtended_user *user) {$/;"	f	file:
user_action_cookie	.\lib\odp-util.h	/^union user_action_cookie {$/;"	u
user_action_cookie_type	.\lib\odp-util.h	/^enum user_action_cookie_type {$/;"	g
user_cookie_offset	.\ofproto\ofproto-dpif-xlate.c	/^    uint16_t user_cookie_offset;\/* Used for user_action_cookie fixup. *\/$/;"	m	struct:xlate_ctx	file:
user_features	.\datapath\datapath.h	/^	u32 user_features;$/;"	m	struct:datapath
user_features	.\lib\dpif-linux.c	/^    uint32_t user_features;            \/* OVS_DP_ATTR_USER_FEATURES *\/$/;"	m	struct:dpif_linux_dp	file:
userdata	.\datapath\datapath.h	/^	const struct nlattr *userdata;$/;"	m	struct:dp_upcall_info	typeref:struct:dp_upcall_info::nlattr
userdata	.\lib\dpif.h	/^    struct nlattr *userdata;    \/* Argument to OVS_ACTION_ATTR_USERSPACE. *\/$/;"	m	struct:dpif_upcall	typeref:struct:dpif_upcall::nlattr
utf16_decode_surrogate_pair	.\lib\unicode.c	/^utf16_decode_surrogate_pair(int leading, int trailing)$/;"	f
utf8_length	.\lib\unicode.c	/^utf8_length(const char *s_)$/;"	f
utf8_sequence	.\lib\unicode.c	/^struct utf8_sequence {$/;"	s	file:
utf8_validate	.\lib\unicode.c	/^utf8_validate(const char *s_, size_t *lengthp)$/;"	f
util	.\lib\util.c	/^VLOG_DEFINE_THIS_MODULE(util);$/;"	v
util	.\python\compat\uuid.py	/^    import ctypes, ctypes.util$/;"	i
util	.\python\ovs\daemon.py	/^import ovs.util$/;"	i
util	.\python\ovs\jsonrpc.py	/^import ovs.util$/;"	i
util	.\python\ovs\reconnect.py	/^import ovs.util$/;"	i
util	.\python\ovs\unixctl\__init__.py	/^import ovs.util$/;"	i
util	.\python\ovs\unixctl\client.py	/^import ovs.util$/;"	i
util	.\python\ovs\unixctl\server.py	/^import ovs.util$/;"	i
util	.\python\ovs\vlog.py	/^import ovs.util$/;"	i
util	.\python\ovstest\rpcserver.py	/^import util$/;"	i
util	.\python\ovstest\tests.py	/^import ovstest.util as util$/;"	i
util	.\python\ovstest\vswitch.py	/^import util$/;"	i
util	.\tests\appctl.py	/^import ovs.util$/;"	i
util	.\tests\test-daemon.py	/^import ovs.util$/;"	i
util	.\tests\test-ovsdb.py	/^import ovs.util$/;"	i
util_xalloc	.\lib\util.c	/^COVERAGE_DEFINE(util_xalloc);$/;"	v
utilities_nlmon_LDADD	.\utilities\automake.mk	/^utilities_nlmon_LDADD = lib\/libopenvswitch.la$/;"	m
utilities_nlmon_SOURCES	.\utilities\automake.mk	/^utilities_nlmon_SOURCES = utilities\/nlmon.c$/;"	m
utilities_ovs_appctl_LDADD	.\utilities\automake.mk	/^utilities_ovs_appctl_LDADD = lib\/libopenvswitch.la$/;"	m
utilities_ovs_appctl_SOURCES	.\utilities\automake.mk	/^utilities_ovs_appctl_SOURCES = utilities\/ovs-appctl.c$/;"	m
utilities_ovs_benchmark_LDADD	.\utilities\automake.mk	/^utilities_ovs_benchmark_LDADD = lib\/libopenvswitch.la$/;"	m
utilities_ovs_benchmark_SOURCES	.\utilities\automake.mk	/^utilities_ovs_benchmark_SOURCES = utilities\/ovs-benchmark.c$/;"	m
utilities_ovs_dpctl_LDADD	.\utilities\automake.mk	/^utilities_ovs_dpctl_LDADD = lib\/libopenvswitch.la$/;"	m
utilities_ovs_dpctl_SOURCES	.\utilities\automake.mk	/^utilities_ovs_dpctl_SOURCES = utilities\/ovs-dpctl.c$/;"	m
utilities_ovs_ofctl_LDADD	.\utilities\automake.mk	/^utilities_ovs_ofctl_LDADD = \\$/;"	m
utilities_ovs_ofctl_SOURCES	.\utilities\automake.mk	/^utilities_ovs_ofctl_SOURCES = utilities\/ovs-ofctl.c$/;"	m
utilities_ovs_vlan_bug_workaround_LDADD	.\utilities\automake.mk	/^utilities_ovs_vlan_bug_workaround_LDADD = lib\/libopenvswitch.la$/;"	m
utilities_ovs_vlan_bug_workaround_SOURCES	.\utilities\automake.mk	/^utilities_ovs_vlan_bug_workaround_SOURCES = utilities\/ovs-vlan-bug-workaround.c$/;"	m
utilities_ovs_vsctl_LDADD	.\utilities\automake.mk	/^utilities_ovs_vsctl_LDADD = lib\/libopenvswitch.la$/;"	m
utilities_ovs_vsctl_SOURCES	.\utilities\automake.mk	/^utilities_ovs_vsctl_SOURCES = utilities\/ovs-vsctl.c$/;"	m
uuid	.\lib\ovsdb-data.h	/^    struct uuid uuid;           \/* The UUID that the symbol represents. *\/$/;"	m	struct:ovsdb_symbol	typeref:struct:ovsdb_symbol::uuid
uuid	.\lib\ovsdb-data.h	/^    struct uuid uuid;$/;"	m	union:ovsdb_atom	typeref:struct:ovsdb_atom::uuid
uuid	.\lib\ovsdb-idl-provider.h	/^    struct uuid uuid;           \/* Row "_uuid" field. *\/$/;"	m	struct:ovsdb_idl_row	typeref:struct:ovsdb_idl_row::uuid
uuid	.\lib\ovsdb-types.h	/^        } uuid;$/;"	m	union:ovsdb_base_type::__anon86	typeref:struct:ovsdb_base_type::__anon86::ovsdb_uuid_constraints
uuid	.\lib\uuid.h	/^struct uuid {$/;"	s
uuid	.\ovsdb\jsonrpc-server.c	/^    struct uuid uuid;           \/* UUID of row that changed. *\/$/;"	m	struct:ovsdb_jsonrpc_monitor_row	typeref:struct:ovsdb_jsonrpc_monitor_row::uuid	file:
uuid	.\ovsdb\transaction.c	/^    struct uuid uuid;$/;"	m	struct:ovsdb_txn_row	typeref:struct:ovsdb_txn_row::uuid	file:
uuid	.\python\ovs\db\data.py	/^import uuid$/;"	i
uuid	.\python\ovs\db\idl.py	/^import uuid$/;"	i
uuid	.\python\ovs\db\types.py	/^import uuid$/;"	i
uuid	.\python\ovs\ovsuuid.py	/^import uuid$/;"	i
uuid	.\tests\test-ovsdb.c	/^    struct uuid uuid;$/;"	m	struct:do_query_distinct_row	typeref:struct:do_query_distinct_row::uuid	file:
uuid	.\tests\test-ovsdb.py	/^import uuid$/;"	i
uuid	.\vswitchd\bridge.c	/^    struct uuid uuid;           \/* UUID of this "mirror" record in database. *\/$/;"	m	struct:mirror	typeref:struct:mirror::uuid	file:
uuid1	.\python\compat\uuid.py	/^def uuid1(node=None, clock_seq=None):$/;"	f
uuid3	.\python\compat\uuid.py	/^def uuid3(namespace, name):$/;"	f
uuid4	.\python\compat\uuid.py	/^def uuid4():$/;"	f
uuid5	.\python\compat\uuid.py	/^def uuid5(namespace, name):$/;"	f
uuidRE	.\python\ovs\ovsuuid.py	/^uuidRE = re.compile("^xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx$"$/;"	v
uuid_column	.\utilities\ovs-vsctl.c	/^    const struct ovsdb_idl_column *uuid_column;$/;"	m	struct:vsctl_row_id	typeref:struct:vsctl_row_id::ovsdb_idl_column	file:
uuid_column	.\vtep\vtep-ctl.c	/^    const struct ovsdb_idl_column *uuid_column;$/;"	m	struct:vtep_ctl_row_id	typeref:struct:vtep_ctl_row_id::ovsdb_idl_column	file:
uuid_compare_3way	.\lib\uuid.c	/^uuid_compare_3way(const struct uuid *a, const struct uuid *b)$/;"	f
uuid_equals	.\lib\uuid.h	/^uuid_equals(const struct uuid *a, const struct uuid *b)$/;"	f
uuid_from_integer	.\tests\test-ovsdb.c	/^uuid_from_integer(int integer, struct uuid *uuid)$/;"	f	file:
uuid_from_string	.\lib\uuid.c	/^uuid_from_string(struct uuid *uuid, const char *s)$/;"	f
uuid_from_string_prefix	.\lib\uuid.c	/^uuid_from_string_prefix(struct uuid *uuid, const char *s)$/;"	f
uuid_generate	.\lib\uuid.c	/^uuid_generate(struct uuid *uuid)$/;"	f
uuid_hash	.\lib\uuid.h	/^uuid_hash(const struct uuid *uuid)$/;"	f
uuid_init	.\lib\uuid.c	/^uuid_init(void)$/;"	f
uuid_is_zero	.\lib\uuid.c	/^uuid_is_zero(const struct uuid *uuid)$/;"	f
uuid_name_from_uuid	.\lib\ovsdb-idl.c	/^uuid_name_from_uuid(const struct uuid *uuid)$/;"	f	file:
uuid_zero	.\lib\uuid.c	/^uuid_zero(struct uuid *uuid)$/;"	f
va_copy	.\lib\util.h	35;"	d
va_copy	.\lib\util.h	37;"	d
vacancy	.\include\openflow\openflow-1.4.h	/^    uint8_t vacancy;      \/* Current vacancy (%) - only in ofp14_table_desc. *\/$/;"	m	struct:ofp14_table_mod_prop_vacancy
vacancy_down	.\include\openflow\openflow-1.4.h	/^    uint8_t vacancy_down;    \/* Vacancy threshold when space decreases (%). *\/$/;"	m	struct:ofp14_table_mod_prop_vacancy
vacancy_up	.\include\openflow\openflow-1.4.h	/^    uint8_t vacancy_up;      \/* Vacancy threshold when space increases (%). *\/$/;"	m	struct:ofp14_table_mod_prop_vacancy
val	.\include\windows\getopt.h	/^	int val;$/;"	m	struct:option
valgrind_wrappers	.\tests\automake.mk	/^valgrind_wrappers = \\$/;"	m
validate_and_copy_sample	.\datapath\flow_netlink.c	/^static int validate_and_copy_sample(const struct nlattr *attr,$/;"	f	file:
validate_and_copy_set_tun	.\datapath\flow_netlink.c	/^static int validate_and_copy_set_tun(const struct nlattr *attr,$/;"	f	file:
validate_set	.\datapath\flow_netlink.c	/^static int validate_set(const struct nlattr *a,$/;"	f	file:
validate_tp_port	.\datapath\flow_netlink.c	/^static int validate_tp_port(const struct sw_flow_key *flow_key)$/;"	f	file:
validate_userspace	.\datapath\flow_netlink.c	/^static int validate_userspace(const struct nlattr *attr)$/;"	f	file:
value	.\include\openflow\nicira-ext.h	/^    ovs_be64 value;                 \/* Immediate value. *\/$/;"	m	struct:nx_action_reg_load
value	.\lib\meta-flow.c	/^    uint8_t value;$/;"	m	struct:frag_handling	file:
value	.\lib\ofp-actions.h	/^    union mf_value value;$/;"	m	struct:ofpact_set_field	typeref:union:ofpact_set_field::mf_value
value	.\lib\ovsdb-types.h	/^    struct ovsdb_base_type value;$/;"	m	struct:ovsdb_type	typeref:struct:ovsdb_type::ovsdb_base_type
value	.\lib\smap.h	/^    char *value;$/;"	m	struct:smap_node
value	.\lib\stp.c	/^    int value;                   \/* Current value of timer, counting up. *\/$/;"	m	struct:stp_timer	file:
value	.\tests\test-hindex.c	/^    int value;$/;"	m	struct:element	file:
value	.\tests\test-hmap.c	/^    int value;$/;"	m	struct:element	file:
value	.\tests\test-list.c	/^    int value;$/;"	m	struct:element	file:
value_flow_tables	.\lib\vswitch-idl.h	/^	struct ovsrec_flow_table **value_flow_tables;$/;"	m	struct:ovsrec_bridge	typeref:struct:ovsrec_bridge::ovsrec_flow_table
value_queues	.\lib\vswitch-idl.h	/^	struct ovsrec_queue **value_queues;$/;"	m	struct:ovsrec_qos	typeref:struct:ovsrec_qos::ovsrec_queue
value_statistics	.\lib\vswitch-idl.h	/^	int64_t *value_statistics;$/;"	m	struct:ovsrec_interface
value_statistics	.\lib\vswitch-idl.h	/^	int64_t *value_statistics;$/;"	m	struct:ovsrec_mirror
value_statistics	.\lib\vswitch-idl.h	/^	int64_t *value_statistics;$/;"	m	struct:ovsrec_port
value_switch_binding	.\lib\vtep-idl.h	/^	struct vteprec_logical_switch **value_switch_binding;$/;"	m	struct:vteprec_logical_router	typeref:struct:vteprec_logical_router::vteprec_logical_switch
value_type	.\lib\ovsdb-data.c	/^    enum ovsdb_atomic_type value_type;$/;"	m	struct:ovsdb_datum_sort_cbdata	typeref:enum:ovsdb_datum_sort_cbdata::ovsdb_atomic_type	file:
value_vlan_bindings	.\lib\vtep-idl.h	/^	struct vteprec_logical_switch **value_vlan_bindings;$/;"	m	struct:vteprec_physical_port	typeref:struct:vteprec_physical_port::vteprec_logical_switch
value_vlan_stats	.\lib\vtep-idl.h	/^	struct vteprec_logical_binding_stats **value_vlan_stats;$/;"	m	struct:vteprec_physical_port	typeref:struct:vteprec_physical_port::vteprec_logical_binding_stats
values	.\lib\ovsdb-data.h	/^    union ovsdb_atom *values;   \/* Each of the ovsdb_type's 'value_type'. *\/$/;"	m	struct:ovsdb_datum	typeref:union:ovsdb_datum::ovsdb_atom
values	.\ofproto\ofproto.h	/^        const char *values[4];$/;"	m	struct:ofproto_controller_info::__anon148
values	.\tests\test-classifier.c	/^static void *values[CLS_N_FIELDS][2];$/;"	v	file:
variable_length_userdata	.\ofproto\ofproto-dpif-xlate.c	/^    bool variable_length_userdata;$/;"	m	struct:xbridge	file:
variable_length_userdata	.\ofproto\ofproto-dpif.c	/^    bool variable_length_userdata;$/;"	m	struct:dpif_backer	file:
variant	.\python\compat\uuid.py	/^    variant = property(get_variant)$/;"	v	class:UUID
vc_instance_name	.\lib\sflow.h	/^    SFLString vc_instance_name; \/* VC instance name *\/$/;"	m	struct:_SFLExtended_mpls_vc
vc_label_cos	.\lib\sflow.h	/^    u_int32_t vc_label_cos;     \/* VC Label COS value *\/$/;"	m	struct:_SFLExtended_mpls_vc
vconn	.\lib\rconn.c	/^    struct vconn *vconn;$/;"	m	struct:rconn	typeref:struct:rconn::vconn	file:
vconn	.\lib\vconn-provider.h	/^struct vconn {$/;"	s
vconn	.\lib\vconn-stream.c	/^    struct vconn vconn;$/;"	m	struct:vconn_stream	typeref:struct:vconn_stream::vconn	file:
vconn	.\lib\vconn.c	/^VLOG_DEFINE_THIS_MODULE(vconn);$/;"	v
vconn	.\utilities\ovs-ofctl.c	/^    struct vconn *vconn;        \/* OpenFlow connection for sending barrier. *\/$/;"	m	struct:barrier_aux	typeref:struct:barrier_aux::vconn	file:
vconn_assert_class	.\lib\vconn-provider.h	/^static inline void vconn_assert_class(const struct vconn *vconn,$/;"	f
vconn_class	.\lib\vconn-provider.h	/^struct vconn_class {$/;"	s
vconn_classes	.\lib\vconn.c	/^static const struct vconn_class *vconn_classes[] = {$/;"	v	typeref:struct:vconn_class	file:
vconn_close	.\lib\vconn.c	/^vconn_close(struct vconn *vconn)$/;"	f
vconn_connect	.\lib\vconn.c	/^vconn_connect(struct vconn *vconn)$/;"	f
vconn_connect_block	.\lib\vconn.c	/^vconn_connect_block(struct vconn *vconn)$/;"	f
vconn_connect_wait	.\lib\vconn.c	/^vconn_connect_wait(struct vconn *vconn)$/;"	f
vconn_get_allowed_versions	.\lib\vconn.c	/^vconn_get_allowed_versions(const struct vconn *vconn)$/;"	f
vconn_get_name	.\lib\vconn.c	/^vconn_get_name(const struct vconn *vconn)$/;"	f
vconn_get_status	.\lib\vconn.c	/^vconn_get_status(const struct vconn *vconn)$/;"	f
vconn_get_version	.\lib\vconn.c	/^vconn_get_version(const struct vconn *vconn)$/;"	f
vconn_init	.\lib\vconn.c	/^vconn_init(struct vconn *vconn, const struct vconn_class *class,$/;"	f
vconn_lookup_class	.\lib\vconn.c	/^vconn_lookup_class(const char *name, const struct vconn_class **classp)$/;"	f	file:
vconn_name	.\tests\test-vconn.c	/^    char *vconn_name;$/;"	m	struct:fake_pvconn	file:
vconn_open	.\lib\vconn.c	/^COVERAGE_DEFINE(vconn_open);$/;"	v
vconn_open	.\lib\vconn.c	/^vconn_open(const char *name, uint32_t allowed_versions, uint8_t dscp,$/;"	f
vconn_open_block	.\lib\vconn.c	/^vconn_open_block(const char *name, uint32_t allowed_versions, uint8_t dscp,$/;"	f
vconn_received	.\lib\vconn.c	/^COVERAGE_DEFINE(vconn_received);$/;"	v
vconn_recv	.\lib\vconn.c	/^vconn_recv(struct vconn *vconn, struct ofpbuf **msgp)$/;"	f
vconn_recv_block	.\lib\vconn.c	/^vconn_recv_block(struct vconn *vconn, struct ofpbuf **msgp)$/;"	f
vconn_recv_wait	.\lib\vconn.c	/^vconn_recv_wait(struct vconn *vconn)$/;"	f
vconn_recv_xid	.\lib\vconn.c	/^vconn_recv_xid(struct vconn *vconn, ovs_be32 xid, struct ofpbuf **replyp)$/;"	f
vconn_run	.\lib\vconn.c	/^vconn_run(struct vconn *vconn)$/;"	f
vconn_run_wait	.\lib\vconn.c	/^vconn_run_wait(struct vconn *vconn)$/;"	f
vconn_send	.\lib\vconn.c	/^vconn_send(struct vconn *vconn, struct ofpbuf *msg)$/;"	f
vconn_send_block	.\lib\vconn.c	/^vconn_send_block(struct vconn *vconn, struct ofpbuf *msg)$/;"	f
vconn_send_wait	.\lib\vconn.c	/^vconn_send_wait(struct vconn *vconn)$/;"	f
vconn_sent	.\lib\vconn.c	/^COVERAGE_DEFINE(vconn_sent);$/;"	v
vconn_set_allowed_versions	.\lib\vconn.c	/^vconn_set_allowed_versions(struct vconn *vconn, uint32_t allowed_versions)$/;"	f
vconn_set_recv_any_version	.\lib\vconn.c	/^vconn_set_recv_any_version(struct vconn *vconn)$/;"	f
vconn_state	.\lib\vconn.c	/^enum vconn_state {$/;"	g	file:
vconn_stream	.\lib\vconn-stream.c	/^VLOG_DEFINE_THIS_MODULE(vconn_stream);$/;"	v
vconn_stream	.\lib\vconn-stream.c	/^struct vconn_stream$/;"	s	file:
vconn_stream_cast	.\lib\vconn-stream.c	/^vconn_stream_cast(struct vconn *vconn)$/;"	f	file:
vconn_stream_clear_txbuf	.\lib\vconn-stream.c	/^vconn_stream_clear_txbuf(struct vconn_stream *s)$/;"	f	file:
vconn_stream_close	.\lib\vconn-stream.c	/^vconn_stream_close(struct vconn *vconn)$/;"	f	file:
vconn_stream_connect	.\lib\vconn-stream.c	/^vconn_stream_connect(struct vconn *vconn)$/;"	f	file:
vconn_stream_new	.\lib\vconn-stream.c	/^vconn_stream_new(struct stream *stream, int connect_status,$/;"	f	file:
vconn_stream_open	.\lib\vconn-stream.c	/^vconn_stream_open(const char *name, uint32_t allowed_versions,$/;"	f	file:
vconn_stream_recv	.\lib\vconn-stream.c	/^vconn_stream_recv(struct vconn *vconn, struct ofpbuf **bufferp)$/;"	f	file:
vconn_stream_recv__	.\lib\vconn-stream.c	/^vconn_stream_recv__(struct vconn_stream *s, int rx_len)$/;"	f	file:
vconn_stream_run	.\lib\vconn-stream.c	/^vconn_stream_run(struct vconn *vconn)$/;"	f	file:
vconn_stream_run_wait	.\lib\vconn-stream.c	/^vconn_stream_run_wait(struct vconn *vconn)$/;"	f	file:
vconn_stream_send	.\lib\vconn-stream.c	/^vconn_stream_send(struct vconn *vconn, struct ofpbuf *buffer)$/;"	f	file:
vconn_stream_wait	.\lib\vconn-stream.c	/^vconn_stream_wait(struct vconn *vconn, enum vconn_wait_type wait)$/;"	f	file:
vconn_transact	.\lib\vconn.c	/^vconn_transact(struct vconn *vconn, struct ofpbuf *request,$/;"	f
vconn_transact_multiple_noreply	.\lib\vconn.c	/^vconn_transact_multiple_noreply(struct vconn *vconn, struct list *requests,$/;"	f
vconn_transact_noreply	.\lib\vconn.c	/^vconn_transact_noreply(struct vconn *vconn, struct ofpbuf *request,$/;"	f
vconn_usage	.\lib\vconn.c	/^vconn_usage(bool active, bool passive, bool bootstrap OVS_UNUSED)$/;"	f
vconn_verify_name	.\lib\vconn.c	/^vconn_verify_name(const char *name)$/;"	f
vconn_wait	.\lib\vconn.c	/^vconn_wait(struct vconn *vconn, enum vconn_wait_type wait)$/;"	f
vconn_wait_type	.\lib\vconn.h	/^enum vconn_wait_type {$/;"	g
vcs_connecting	.\lib\vconn.c	/^vcs_connecting(struct vconn *vconn)$/;"	f	file:
vcs_recv_hello	.\lib\vconn.c	/^vcs_recv_hello(struct vconn *vconn)$/;"	f	file:
vcs_send_error	.\lib\vconn.c	/^vcs_send_error(struct vconn *vconn)$/;"	f	file:
vcs_send_hello	.\lib\vconn.c	/^vcs_send_hello(struct vconn *vconn)$/;"	f	file:
vd_add	.\lib\vlandev.c	/^    int (*vd_add)(const char *real_dev, int vid);$/;"	m	struct:vlandev_class	file:
vd_class	.\lib\vlandev.c	/^static const struct vlandev_class *vd_class;$/;"	v	typeref:struct:vlandev_class	file:
vd_del	.\lib\vlandev.c	/^    int (*vd_del)(const char *vlan_dev);$/;"	m	struct:vlandev_class	file:
vd_refresh	.\lib\vlandev.c	/^    int (*vd_refresh)(void);$/;"	m	struct:vlandev_class	file:
vectors	.\tests\test-sha1.c	/^static const struct test_vector vectors[] = {$/;"	v	typeref:struct:test_vector	file:
vendor	.\include\openflow\nicira-ext.h	/^    ovs_be32 vendor;                \/* NX_VENDOR_ID. *\/$/;"	m	struct:nx_action_controller
vendor	.\include\openflow\nicira-ext.h	/^    ovs_be32 vendor;                \/* NX_VENDOR_ID. *\/$/;"	m	struct:nx_action_header
vendor	.\include\openflow\nicira-ext.h	/^    ovs_be32 vendor;                \/* NX_VENDOR_ID. *\/$/;"	m	struct:nx_action_mpls_label
vendor	.\include\openflow\nicira-ext.h	/^    ovs_be32 vendor;                \/* NX_VENDOR_ID. *\/$/;"	m	struct:nx_action_mpls_tc
vendor	.\include\openflow\nicira-ext.h	/^    ovs_be32 vendor;                \/* NX_VENDOR_ID. *\/$/;"	m	struct:nx_action_mpls_ttl
vendor	.\include\openflow\nicira-ext.h	/^    ovs_be32 vendor;                \/* NX_VENDOR_ID. *\/$/;"	m	struct:nx_action_note
vendor	.\include\openflow\nicira-ext.h	/^    ovs_be32 vendor;                \/* NX_VENDOR_ID. *\/$/;"	m	struct:nx_action_pop_mpls
vendor	.\include\openflow\nicira-ext.h	/^    ovs_be32 vendor;                \/* NX_VENDOR_ID. *\/$/;"	m	struct:nx_action_pop_queue
vendor	.\include\openflow\nicira-ext.h	/^    ovs_be32 vendor;                \/* NX_VENDOR_ID. *\/$/;"	m	struct:nx_action_push_mpls
vendor	.\include\openflow\nicira-ext.h	/^    ovs_be32 vendor;                \/* NX_VENDOR_ID. *\/$/;"	m	struct:nx_action_reg_load
vendor	.\include\openflow\nicira-ext.h	/^    ovs_be32 vendor;                \/* NX_VENDOR_ID. *\/$/;"	m	struct:nx_action_reg_move
vendor	.\include\openflow\nicira-ext.h	/^    ovs_be32 vendor;                \/* NX_VENDOR_ID. *\/$/;"	m	struct:nx_action_resubmit
vendor	.\include\openflow\nicira-ext.h	/^    ovs_be32 vendor;                \/* NX_VENDOR_ID. *\/$/;"	m	struct:nx_action_sample
vendor	.\include\openflow\nicira-ext.h	/^    ovs_be32 vendor;                \/* NX_VENDOR_ID. *\/$/;"	m	struct:nx_action_set_queue
vendor	.\include\openflow\nicira-ext.h	/^    ovs_be32 vendor;                \/* NX_VENDOR_ID. *\/$/;"	m	struct:nx_action_set_tunnel
vendor	.\include\openflow\nicira-ext.h	/^    ovs_be32 vendor;                \/* NX_VENDOR_ID. *\/$/;"	m	struct:nx_action_set_tunnel64
vendor	.\include\openflow\nicira-ext.h	/^    ovs_be32 vendor;                \/* NX_VENDOR_ID. *\/$/;"	m	struct:nx_action_stack
vendor	.\include\openflow\nicira-ext.h	/^    ovs_be32 vendor;                \/* NX_VENDOR_ID. *\/$/;"	m	struct:nx_action_write_metadata
vendor	.\include\openflow\nicira-ext.h	/^    ovs_be32 vendor;            \/* NX_VENDOR_ID. *\/$/;"	m	struct:nicira_header
vendor	.\include\openflow\nicira-ext.h	/^    ovs_be32 vendor;            \/* NX_VENDOR_ID. *\/$/;"	m	struct:nx_action_bundle
vendor	.\include\openflow\nicira-ext.h	/^    ovs_be32 vendor;            \/* NX_VENDOR_ID. *\/$/;"	m	struct:nx_action_cnt_ids
vendor	.\include\openflow\nicira-ext.h	/^    ovs_be32 vendor;            \/* NX_VENDOR_ID. *\/$/;"	m	struct:nx_action_fin_timeout
vendor	.\include\openflow\nicira-ext.h	/^    ovs_be32 vendor;            \/* NX_VENDOR_ID. *\/$/;"	m	struct:nx_action_learn
vendor	.\include\openflow\nicira-ext.h	/^    ovs_be32 vendor;            \/* NX_VENDOR_ID. *\/$/;"	m	struct:nx_action_multipath
vendor	.\include\openflow\nicira-ext.h	/^    ovs_be32 vendor;            \/* NX_VENDOR_ID. *\/$/;"	m	struct:nx_action_output_reg
vendor	.\include\openflow\nicira-ext.h	/^    ovs_be32 vendor;            \/* Vendor ID as in struct ofp_vendor_header. *\/$/;"	m	struct:nx_vendor_error
vendor	.\include\openflow\openflow-1.0.h	/^    ovs_be32 vendor;            \/* Vendor ID:$/;"	m	struct:ofp10_vendor_stats_msg
vendor	.\include\openflow\openflow-1.1.h	/^    ovs_be32 vendor;            \/* Vendor ID:$/;"	m	struct:ofp11_vendor_stats_msg
vendor	.\include\openflow\openflow-common.h	/^    ovs_be32 vendor;                \/* Vendor ID, which takes the same form$/;"	m	struct:ofp_action_vendor_header
vendor	.\include\openflow\openflow-common.h	/^    ovs_be32 vendor;            \/* Vendor ID:$/;"	m	struct:ofp_vendor_header
vendor	.\lib\ofp-actions.c	/^    struct ofp_action_vendor_header vendor;$/;"	m	union:ofp_action	typeref:struct:ofp_action::ofp_action_vendor_header	file:
vendor	.\lib\ofp-errors.c	/^    uint32_t vendor;$/;"	m	struct:triplet	file:
vendor	.\lib\ofp-msgs.c	/^    uint32_t vendor;            \/* From ofp_vendor_header,$/;"	m	struct:ofphdrs	file:
verbosity	.\utilities\ovs-dpctl.c	/^static int verbosity;$/;"	v	file:
verbosity	.\utilities\ovs-ofctl.c	/^static int verbosity;$/;"	v	file:
verified_ports	.\utilities\ovs-vsctl.c	/^    bool verified_ports;$/;"	m	struct:vsctl_context	file:
verified_ports	.\vtep\vtep-ctl.c	/^    bool verified_ports;$/;"	m	struct:vtep_ctl_context	file:
verify	.\python\ovs\db\idl.py	/^    def verify(self, column_name):$/;"	m	class:Row
verify_controllers	.\utilities\ovs-vsctl.c	/^verify_controllers(struct ovsrec_bridge *bridge)$/;"	f	file:
verify_managers	.\utilities\ovs-vsctl.c	/^verify_managers(const struct ovsrec_open_vswitch *ovs)$/;"	f	file:
verify_managers	.\vtep\vtep-ctl.c	/^verify_managers(const struct vteprec_global *vtep_global)$/;"	f	file:
verify_peer_cert	.\lib\stream-ssl.c	/^static bool verify_peer_cert = true;$/;"	v	file:
verify_ports	.\utilities\ovs-vsctl.c	/^verify_ports(struct vsctl_context *ctx)$/;"	f	file:
verify_ports	.\vtep\vtep-ctl.c	/^verify_ports(struct vtep_ctl_context *ctx)$/;"	f	file:
verify_write_only	.\lib\ovsdb-idl.c	/^    bool verify_write_only;$/;"	m	struct:ovsdb_idl	file:
vers_diag	.\lib\bfd.c	/^    uint8_t vers_diag;    \/* Version and diagnostic. *\/$/;"	m	struct:msg	file:
version	.\datapath\linux\compat\include\net\genetlink.h	/^	unsigned int            version;$/;"	m	struct:rpl_genl_family
version	.\include\openflow\openflow-common.h	/^    uint8_t version;    \/* An OpenFlow version number, e.g. OFP10_VERSION. *\/$/;"	m	struct:ofp_header
version	.\lib\netflow.h	/^    ovs_be16 version;              \/* NetFlow version is 5. *\/$/;"	m	struct:netflow_v5_header
version	.\lib\netlink-protocol.h	/^    uint8_t version;$/;"	m	struct:genlmsghdr
version	.\lib\ofp-msgs.c	/^    uint8_t version;            \/* From ofp_header. *\/$/;"	m	struct:ofphdrs	file:
version	.\lib\vconn-provider.h	/^    enum ofp_version version;   \/* Negotiated version (or 0). *\/$/;"	m	struct:vconn	typeref:enum:vconn::ofp_version
version	.\ovsdb\ovsdb.h	/^    char *version;$/;"	m	struct:ovsdb_schema
version	.\python\compat\uuid.py	/^    version = property(get_version)$/;"	v	class:UUID
version	.\python\ovs\unixctl\server.py	/^import ovs.version$/;"	i
version	.\xenserver\usr_lib_xsconsole_plugins-base_XSFeatureVSwitch.py	/^    def version(self):$/;"	m	class:VSwitchService
version_bitmap_from_version	.\lib\ofp-util.c	/^version_bitmap_from_version(uint8_t ofp_version)$/;"	f	file:
version_bitmap_to_string	.\lib\vconn.c	/^version_bitmap_to_string(uint32_t bitmap)$/;"	f	file:
version_major	.\lib\pcap-file.c	/^    uint16_t version_major;  \/* major version number *\/$/;"	m	struct:pcap_hdr	file:
version_minor	.\lib\pcap-file.c	/^    uint16_t version_minor;  \/* minor version number *\/$/;"	m	struct:pcap_hdr	file:
versions	.\utilities\ovs-ofctl.c	/^    struct fte_version *versions[2];$/;"	m	struct:fte	typeref:struct:fte::fte_version	file:
vg	.\lib\sflow.h	/^    SFLVg_counters vg;$/;"	m	union:_SFLCounters_type
vid	.\lib\vlandev.h	/^    int vid;                        \/* VLAN ID, e.g. 10. *\/$/;"	m	struct:vlan_dev
vid	.\ofproto\ofproto-dpif-xlate.c	/^            uint16_t vid;$/;"	m	struct:xc_entry::__anon136::__anon140	file:
vid	.\ofproto\ofproto-dpif.c	/^    int vid;$/;"	m	struct:vlan_splinter	file:
vlan	.\lib\mac-learning.h	/^    uint16_t vlan;              \/* VLAN tag. *\/$/;"	m	struct:mac_entry
vlan	.\lib\sflow.h	/^    SFLVlan_counters vlan;$/;"	m	union:_SFLCounters_type
vlan	.\ofproto\ofproto-dpif-xlate.c	/^            int vlan;$/;"	m	struct:xc_entry::__anon136::__anon142	file:
vlan	.\ofproto\ofproto-dpif-xlate.c	/^    int vlan;                      \/* -1=trunk port, else a 12-bit VLAN ID. *\/$/;"	m	struct:xbundle	file:
vlan	.\ofproto\ofproto-dpif.c	/^    int vlan;                   \/* -1=trunk port, else a 12-bit VLAN ID. *\/$/;"	m	struct:ofbundle	file:
vlan	.\ofproto\ofproto.h	/^    int vlan;                   \/* VLAN VID, except for PORT_VLAN_TRUNK. *\/$/;"	m	struct:ofproto_bundle_settings
vlan	.\utilities\ovs-vsctl.c	/^    int vlan;                    \/* VLAN VID (0...4095), or 0. *\/$/;"	m	struct:vsctl_bridge	file:
vlanTunnelEncodingLength	.\lib\sflow_receiver.c	/^inline static u_int32_t vlanTunnelEncodingLength(SFLExtended_vlan_tunnel *vlanTunnel) {$/;"	f	file:
vlan_bitmap	.\ofproto\ofproto-provider.h	/^    unsigned long int *vlan_bitmap; \/* 4096-bit bitmap of in-use VLANs. *\/$/;"	m	struct:ofproto
vlan_bitmap_clone	.\lib\vlan-bitmap.h	/^vlan_bitmap_clone(const unsigned long *vlans)$/;"	f
vlan_bitmap_equal	.\lib\vlan-bitmap.c	/^vlan_bitmap_equal(const unsigned long *a, const unsigned long *b)$/;"	f
vlan_bitmap_from_array	.\lib\vlan-bitmap.c	/^vlan_bitmap_from_array(const int64_t *vlans, size_t n_vlans)$/;"	f
vlan_bitmap_from_array__	.\lib\vlan-bitmap.c	/^vlan_bitmap_from_array__(const int64_t *vlans, size_t n_vlans,$/;"	f
vlan_cache_cb	.\lib\vlandev.c	/^vlan_cache_cb(const struct rtnetlink_link_change *change OVS_UNUSED,$/;"	f	file:
vlan_cache_notifier	.\lib\vlandev.c	/^static struct nln_notifier *vlan_cache_notifier;$/;"	v	typeref:struct:nln_notifier	file:
vlan_dev	.\lib\vlandev.h	/^struct vlan_dev {$/;"	s
vlan_devs	.\lib\vlandev.c	/^static struct shash vlan_devs = SHASH_INITIALIZER(&vlan_devs);$/;"	v	typeref:struct:shash	file:
vlan_devs	.\lib\vlandev.h	/^    struct hmap vlan_devs;      \/* All child VLAN devices, hashed by VID. *\/$/;"	m	struct:vlan_real_dev	typeref:struct:vlan_real_dev::hmap
vlan_get_tci	.\datapath\vlan.h	/^static inline u16 vlan_get_tci(struct sk_buff *skb)$/;"	f
vlan_header	.\lib\packets.h	/^struct vlan_header {$/;"	s
vlan_id	.\lib\sflow.h	/^    u_int32_t vlan_id;$/;"	m	struct:_SFLVlan_counters
vlan_mode	.\lib\vswitch-idl.h	/^	char *vlan_mode;$/;"	m	struct:ovsrec_port
vlan_mode	.\ofproto\ofproto-dpif-xlate.c	/^    enum port_vlan_mode vlan_mode; \/* VLAN mode. *\/$/;"	m	struct:xbundle	typeref:enum:xbundle::port_vlan_mode	file:
vlan_mode	.\ofproto\ofproto-dpif.c	/^    enum port_vlan_mode vlan_mode; \/* VLAN mode *\/$/;"	m	struct:ofbundle	typeref:enum:ofbundle::port_vlan_mode	file:
vlan_mode	.\ofproto\ofproto.h	/^    enum port_vlan_mode vlan_mode; \/* Selects mode for vlan and trunks *\/$/;"	m	struct:ofproto_bundle_settings	typeref:enum:ofproto_bundle_settings::port_vlan_mode
vlan_next_type	.\lib\packets.h	/^    ovs_be16 vlan_next_type;$/;"	m	struct:vlan_header
vlan_pcp	.\include\openflow\openflow-common.h	/^    uint8_t vlan_pcp;               \/* VLAN priority. *\/$/;"	m	struct:ofp_action_vlan_pcp
vlan_pcp	.\lib\ofp-actions.c	/^    struct ofp_action_vlan_pcp vlan_pcp;$/;"	m	union:ofp_action	typeref:struct:ofp_action::ofp_action_vlan_pcp	file:
vlan_pcp	.\lib\ofp-actions.h	/^    uint8_t vlan_pcp;           \/* VLAN PCP in low 3 bits, 0 in other bits. *\/$/;"	m	struct:ofpact_vlan_pcp
vlan_real_dev	.\lib\vlandev.h	/^struct vlan_real_dev {$/;"	s
vlan_real_devs	.\lib\vlandev.c	/^static struct shash vlan_real_devs = SHASH_INITIALIZER(&vlan_real_devs);$/;"	v	typeref:struct:shash	file:
vlan_set_encap_proto	.\datapath\linux\compat\include\linux\if_vlan.h	/^static inline void vlan_set_encap_proto(struct sk_buff *skb, struct vlan_hdr *vhdr)$/;"	f
vlan_set_tci	.\datapath\vlan.h	/^static inline void vlan_set_tci(struct sk_buff *skb, u16 vlan_tci)$/;"	f
vlan_splinter	.\ofproto\ofproto-dpif.c	/^struct vlan_splinter {$/;"	s	file:
vlan_splinters_enabled_anywhere	.\vswitchd\bridge.c	/^static bool vlan_splinters_enabled_anywhere;$/;"	v	file:
vlan_splinters_is_enabled	.\vswitchd\bridge.c	/^vlan_splinters_is_enabled(const struct ovsrec_interface *iface_cfg)$/;"	f	file:
vlan_tag	.\python\ovstest\args.py	/^def vlan_tag(string):$/;"	f
vlan_tci	.\include\linux\openvswitch.h	/^	__be16 vlan_tci;	\/* 802.1Q TCI (VLAN ID and priority). *\/$/;"	m	struct:ovs_action_push_vlan
vlan_tci	.\lib\flow.h	/^    ovs_be16 vlan_tci;          \/* If 802.1Q, TCI | VLAN_CFI; otherwise 0. *\/$/;"	m	struct:flow
vlan_tci	.\lib\odp-util.h	/^        ovs_be16 vlan_tci;      \/* Destination VLAN TCI. *\/$/;"	m	struct:user_action_cookie::__anon69
vlan_tci	.\lib\packets.h	/^    ovs_be16 vlan_tci;          \/* Lowest 12 bits are VLAN ID. *\/$/;"	m	struct:vlan_header
vlan_tci_to_cfi	.\lib\packets.h	/^vlan_tci_to_cfi(ovs_be16 vlan_tci)$/;"	f
vlan_tci_to_pcp	.\lib\packets.h	/^vlan_tci_to_pcp(ovs_be16 vlan_tci)$/;"	f
vlan_tci_to_vid	.\lib\packets.h	/^vlan_tci_to_vid(ovs_be16 vlan_tci)$/;"	f
vlan_tci_values	.\tests\test-classifier.c	/^static ovs_be16 vlan_tci_values[] = { CONSTANT_HTONS(101), CONSTANT_HTONS(0) };$/;"	v	file:
vlan_tpid	.\include\linux\openvswitch.h	/^	__be16 vlan_tpid;	\/* 802.1Q TPID. *\/$/;"	m	struct:ovs_action_push_vlan
vlan_tso	.\datapath\linux\compat\gso.c	50;"	d	file:
vlan_tunnel	.\lib\sflow.h	/^    SFLExtended_vlan_tunnel vlan_tunnel;$/;"	m	union:_SFLFlow_type
vlan_vid	.\include\openflow\openflow-common.h	/^    ovs_be16 vlan_vid;              \/* VLAN id. *\/$/;"	m	struct:ofp_action_vlan_vid
vlan_vid	.\lib\ofp-actions.c	/^    struct ofp_action_vlan_vid vlan_vid;$/;"	m	union:ofp_action	typeref:struct:ofp_action::ofp_action_vlan_vid	file:
vlan_vid	.\lib\ofp-actions.h	/^    uint16_t vlan_vid;          \/* VLAN VID in low 12 bits, 0 in other bits. *\/$/;"	m	struct:ofpact_vlan_vid
vlandev	.\lib\vlandev.c	/^VLOG_DEFINE_THIS_MODULE(vlandev);$/;"	v
vlandev_add	.\lib\vlandev.c	/^vlandev_add(const char *real_dev, int vid)$/;"	f
vlandev_add__	.\lib\vlandev.c	/^vlandev_add__(const char *vlan_dev, const char *real_dev, int vid)$/;"	f	file:
vlandev_class	.\lib\vlandev.c	/^struct vlandev_class {$/;"	s	file:
vlandev_clear__	.\lib\vlandev.c	/^vlandev_clear__(void)$/;"	f	file:
vlandev_del	.\lib\vlandev.c	/^vlandev_del(const char *vlan_dev)$/;"	f
vlandev_del__	.\lib\vlandev.c	/^vlandev_del__(const char *vlan_dev)$/;"	f	file:
vlandev_dummy_add	.\lib\vlandev.c	/^vlandev_dummy_add(const char *real_dev, int vid)$/;"	f	file:
vlandev_dummy_class	.\lib\vlandev.c	/^static const struct vlandev_class vlandev_dummy_class = {$/;"	v	typeref:struct:vlandev_class	file:
vlandev_dummy_class	.\lib\vlandev.c	/^static const struct vlandev_class vlandev_dummy_class;$/;"	v	typeref:struct:vlandev_class	file:
vlandev_dummy_del	.\lib\vlandev.c	/^vlandev_dummy_del(const char *vlan_dev)$/;"	f	file:
vlandev_dummy_enable	.\lib\vlandev.c	/^vlandev_dummy_enable(void)$/;"	f
vlandev_find	.\ofproto\ofproto-dpif.c	/^vlandev_find(const struct ofproto_dpif *ofproto, ofp_port_t vlandev_ofp_port)$/;"	f	file:
vlandev_get_class	.\lib\vlandev.c	/^vlandev_get_class(void)$/;"	f	file:
vlandev_get_name	.\lib\vlandev.c	/^vlandev_get_name(const char *real_dev_name, int vid)$/;"	f
vlandev_get_real_devs	.\lib\vlandev.c	/^vlandev_get_real_devs(void)$/;"	f
vlandev_linux_add	.\lib\vlandev.c	/^vlandev_linux_add(const char *real_dev, int vid)$/;"	f	file:
vlandev_linux_class	.\lib\vlandev.c	/^static const struct vlandev_class vlandev_linux_class = {$/;"	v	typeref:struct:vlandev_class	file:
vlandev_linux_class	.\lib\vlandev.c	/^static const struct vlandev_class vlandev_linux_class;$/;"	v	typeref:struct:vlandev_class	file:
vlandev_linux_del	.\lib\vlandev.c	/^vlandev_linux_del(const char *vlan_dev)$/;"	f	file:
vlandev_linux_refresh	.\lib\vlandev.c	/^vlandev_linux_refresh(void)$/;"	f	file:
vlandev_node	.\ofproto\ofproto-dpif.c	/^    struct hmap_node vlandev_node;$/;"	m	struct:vlan_splinter	typeref:struct:vlan_splinter::hmap_node	file:
vlandev_ofp_port	.\ofproto\ofproto-dpif.c	/^    ofp_port_t vlandev_ofp_port;$/;"	m	struct:vlan_splinter	file:
vlandev_refresh	.\lib\vlandev.c	/^vlandev_refresh(void)$/;"	f
vlandev_stub_add	.\lib\vlandev.c	/^vlandev_stub_add(const char *real_dev OVS_UNUSED, int vid OVS_UNUSED)$/;"	f	file:
vlandev_stub_class	.\lib\vlandev.c	/^static const struct vlandev_class OVS_UNUSED vlandev_stub_class = {$/;"	v	typeref:struct:OVS_UNUSED	file:
vlandev_stub_class	.\lib\vlandev.c	/^static const struct vlandev_class vlandev_stub_class;$/;"	v	typeref:struct:vlandev_class	file:
vlandev_stub_del	.\lib\vlandev.c	/^vlandev_stub_del(const char *vlan_dev OVS_UNUSED)$/;"	f	file:
vlandev_vid	.\ofproto\ofproto-dpif.c	/^    int vlandev_vid;$/;"	m	struct:ofport_dpif	file:
vlans	.\ofproto\ofproto-dpif-mirror.c	/^    unsigned long *vlans;       \/* Bitmap of chosen VLANs, NULL selects all. *\/$/;"	m	struct:mirror	file:
vlans_changed	.\ofproto\ofproto-provider.h	/^    bool vlans_changed;             \/* True if new VLANs are in use. *\/$/;"	m	struct:ofproto
vll_vc_id	.\lib\sflow.h	/^    u_int32_t vll_vc_id;        \/* VLL\/VC instance ID *\/$/;"	m	struct:_SFLExtended_mpls_vc
vlog	.\lib\vlog.c	/^VLOG_DEFINE_THIS_MODULE(vlog);$/;"	v
vlog	.\lib\vlog.c	/^vlog(const struct vlog_module *module, enum vlog_level level,$/;"	f
vlog	.\python\ovs\daemon.py	/^import ovs.vlog$/;"	i
vlog	.\python\ovs\daemon.py	/^vlog = ovs.vlog.Vlog("daemon")$/;"	v
vlog	.\python\ovs\db\idl.py	/^import ovs.vlog$/;"	i
vlog	.\python\ovs\db\idl.py	/^vlog = ovs.vlog.Vlog("idl")$/;"	v
vlog	.\python\ovs\fatal_signal.py	/^import ovs.vlog$/;"	i
vlog	.\python\ovs\fatal_signal.py	/^vlog = ovs.vlog.Vlog("fatal-signal")$/;"	v
vlog	.\python\ovs\jsonrpc.py	/^import ovs.vlog$/;"	i
vlog	.\python\ovs\jsonrpc.py	/^vlog = ovs.vlog.Vlog("jsonrpc")$/;"	v
vlog	.\python\ovs\poller.py	/^import ovs.vlog$/;"	i
vlog	.\python\ovs\poller.py	/^vlog = ovs.vlog.Vlog("poller")$/;"	v
vlog	.\python\ovs\reconnect.py	/^import ovs.vlog$/;"	i
vlog	.\python\ovs\reconnect.py	/^vlog = ovs.vlog.Vlog("reconnect")$/;"	v
vlog	.\python\ovs\socket_util.py	/^import ovs.vlog$/;"	i
vlog	.\python\ovs\socket_util.py	/^vlog = ovs.vlog.Vlog("socket_util")$/;"	v
vlog	.\python\ovs\stream.py	/^import ovs.vlog$/;"	i
vlog	.\python\ovs\stream.py	/^vlog = ovs.vlog.Vlog("stream")$/;"	v
vlog	.\python\ovs\unixctl\client.py	/^vlog = ovs.vlog.Vlog("unixctl_client")$/;"	v
vlog	.\python\ovs\unixctl\server.py	/^import ovs.vlog$/;"	i
vlog	.\python\ovs\unixctl\server.py	/^vlog = ovs.vlog.Vlog("unixctl_server")$/;"	v
vlog	.\tests\appctl.py	/^import ovs.vlog$/;"	i
vlog	.\tests\test-unixctl.py	/^vlog = ovs.vlog.Vlog("test-unixctl")$/;"	v
vlog	.\tests\test-vlog.py	/^import ovs.vlog$/;"	i
vlog_abort	.\lib\vlog.c	/^vlog_abort(const struct vlog_module *module, const char *message, ...)$/;"	f
vlog_abort_valist	.\lib\vlog.c	/^vlog_abort_valist(const struct vlog_module *module_,$/;"	f
vlog_disable_rate_limit	.\lib\vlog.c	/^vlog_disable_rate_limit(struct unixctl_conn *conn, int argc,$/;"	f	file:
vlog_enable_async	.\lib\vlog.c	/^vlog_enable_async(void)$/;"	f
vlog_enable_rate_limit	.\lib\vlog.c	/^vlog_enable_rate_limit(struct unixctl_conn *conn, int argc,$/;"	f	file:
vlog_facility	.\lib\vlog.h	/^enum vlog_facility {$/;"	g
vlog_fatal	.\lib\vlog.c	/^vlog_fatal(const struct vlog_module *module, const char *message, ...)$/;"	f
vlog_fatal_valist	.\lib\vlog.c	/^vlog_fatal_valist(const struct vlog_module *module_,$/;"	f
vlog_get_facility_name	.\lib\vlog.c	/^vlog_get_facility_name(enum vlog_facility facility)$/;"	f
vlog_get_facility_val	.\lib\vlog.c	/^vlog_get_facility_val(const char *name)$/;"	f
vlog_get_level	.\lib\vlog.c	/^vlog_get_level(const struct vlog_module *module, enum vlog_facility facility)$/;"	f
vlog_get_level_name	.\lib\vlog.c	/^vlog_get_level_name(enum vlog_level level)$/;"	f
vlog_get_level_val	.\lib\vlog.c	/^vlog_get_level_val(const char *name)$/;"	f
vlog_get_levels	.\lib\vlog.c	/^vlog_get_levels(void)$/;"	f
vlog_get_module_name	.\lib\vlog.c	/^vlog_get_module_name(const struct vlog_module *module)$/;"	f
vlog_init	.\lib\vlog.c	/^vlog_init(void)$/;"	f
vlog_is_enabled	.\lib\vlog.c	/^vlog_is_enabled(const struct vlog_module *module, enum vlog_level level)$/;"	f
vlog_level	.\lib\vlog.h	/^enum vlog_level {$/;"	g
vlog_module	.\lib\vlog.h	/^struct vlog_module {$/;"	s
vlog_module_from_name	.\lib\vlog.c	/^vlog_module_from_name(const char *name)$/;"	f
vlog_modules	.\lib\vlog.c	/^struct list vlog_modules = LIST_INITIALIZER(&vlog_modules);$/;"	v	typeref:struct:list
vlog_rate_limit	.\lib\vlog.c	/^vlog_rate_limit(const struct vlog_module *module, enum vlog_level level,$/;"	f
vlog_rate_limit	.\lib\vlog.h	/^struct vlog_rate_limit {$/;"	s
vlog_reopen_log_file	.\lib\vlog.c	/^vlog_reopen_log_file(void)$/;"	f
vlog_set_levels	.\lib\vlog.c	/^vlog_set_levels(struct vlog_module *module, enum vlog_facility facility,$/;"	f
vlog_set_levels_from_string	.\lib\vlog.c	/^vlog_set_levels_from_string(const char *s_)$/;"	f
vlog_set_levels_from_string_assert	.\lib\vlog.c	/^vlog_set_levels_from_string_assert(const char *s)$/;"	f
vlog_set_log_file	.\lib\vlog.c	/^vlog_set_log_file(const char *file_name)$/;"	f
vlog_set_pattern	.\lib\vlog.c	/^vlog_set_pattern(enum vlog_facility facility, const char *pattern)$/;"	f
vlog_set_syslog_target	.\lib\vlog.c	/^vlog_set_syslog_target(const char *target)$/;"	f
vlog_set_verbosity	.\lib\vlog.c	/^vlog_set_verbosity(const char *arg)$/;"	f
vlog_should_drop	.\lib\vlog.c	/^vlog_should_drop(const struct vlog_module *module, enum vlog_level level,$/;"	f
vlog_unixctl_list	.\lib\vlog.c	/^vlog_unixctl_list(struct unixctl_conn *conn, int argc OVS_UNUSED,$/;"	f	file:
vlog_unixctl_reopen	.\lib\vlog.c	/^vlog_unixctl_reopen(struct unixctl_conn *conn, int argc OVS_UNUSED,$/;"	f	file:
vlog_unixctl_set	.\lib\vlog.c	/^vlog_unixctl_set(struct unixctl_conn *conn, int argc, const char *argv[],$/;"	f	file:
vlog_usage	.\lib\vlog.c	/^vlog_usage(void)$/;"	f
vlog_valist	.\lib\vlog.c	/^vlog_valist(const struct vlog_module *module, enum vlog_level level,$/;"	f
vport	.\datapath\vport-internal_dev.c	/^	struct vport *vport;$/;"	m	struct:internal_dev	typeref:struct:internal_dev::vport	file:
vport	.\datapath\vport.h	/^struct vport {$/;"	s
vport_add_channels	.\lib\dpif-linux.c	/^vport_add_channels(struct dpif_linux *dpif, odp_port_t port_no,$/;"	f	file:
vport_class	.\lib\netdev-vport.c	/^struct vport_class {$/;"	s	file:
vport_class_cast	.\lib\netdev-vport.c	/^vport_class_cast(const struct netdev_class *class)$/;"	f	file:
vport_create_socksp	.\lib\dpif-linux.c	/^vport_create_socksp(uint32_t n_socks, int *error)$/;"	f	file:
vport_del_channels	.\lib\dpif-linux.c	/^vport_del_channels(struct dpif_linux *dpif, odp_port_t port_no)$/;"	f	file:
vport_del_socksp	.\lib\dpif-linux.c	/^vport_del_socksp(struct nl_sock **socksp, uint32_t n_socks)$/;"	f	file:
vport_err_stats	.\datapath\vport.h	/^struct vport_err_stats {$/;"	s
vport_err_type	.\datapath\vport.h	/^enum vport_err_type {$/;"	g
vport_from_priv	.\datapath\vport.h	/^static inline struct vport *vport_from_priv(void *priv)$/;"	f
vport_get_pids	.\lib\dpif-linux.c	/^vport_get_pids(struct dpif_linux *dpif, uint32_t port_idx,$/;"	f	file:
vport_hash_bucket	.\datapath\datapath.c	/^static struct hlist_head *vport_hash_bucket(const struct datapath *dp,$/;"	f	file:
vport_net	.\datapath\datapath.h	/^	struct vport_net vport_net;$/;"	m	struct:ovs_net	typeref:struct:ovs_net::vport_net
vport_net	.\datapath\vport.h	/^struct vport_net {$/;"	s
vport_ops	.\datapath\vport.h	/^struct vport_ops {$/;"	s
vport_ops_list	.\datapath\vport.c	/^static const struct vport_ops *vport_ops_list[] = {$/;"	v	typeref:struct:vport_ops	file:
vport_parms	.\datapath\vport.h	/^struct vport_parms {$/;"	s
vport_policy	.\datapath\datapath.c	/^static const struct nla_policy vport_policy[OVS_VPORT_ATTR_MAX + 1] = {$/;"	v	typeref:struct:nla_policy	file:
vport_portids	.\datapath\vport.h	/^struct vport_portids {$/;"	s
vport_portids_destroy_rcu_cb	.\datapath\vport.c	/^static void vport_portids_destroy_rcu_cb(struct rcu_head *rcu)$/;"	f	file:
vport_priv	.\datapath\vport.h	/^static inline void *vport_priv(const struct vport *vport)$/;"	f
vport_socksp_to_pids	.\lib\dpif-linux.c	/^vport_socksp_to_pids(struct nl_sock **socksp, uint32_t n_socks)$/;"	f	file:
vport_stats_error	.\lib\netdev-linux.c	/^    int vport_stats_error;      \/* Cached error code from vport_get_stats().$/;"	m	struct:netdev_linux	file:
vs	.\datapath\vport-vxlan.c	/^	struct vxlan_sock *vs;$/;"	m	struct:vxlan_port	typeref:struct:vxlan_port::vxlan_sock	file:
vsctl	.\utilities\ovs-vsctl.c	/^VLOG_DEFINE_THIS_MODULE(vsctl);$/;"	v
vsctl	.\xenserver\usr_lib_xsconsole_plugins-base_XSFeatureVSwitch.py	/^vsctl="\/usr\/bin\/ovs-vsctl"$/;"	v
vsctl_bridge	.\utilities\ovs-vsctl.c	/^struct vsctl_bridge {$/;"	s	file:
vsctl_command	.\utilities\ovs-vsctl.c	/^struct vsctl_command {$/;"	s	file:
vsctl_command_syntax	.\utilities\ovs-vsctl.c	/^struct vsctl_command_syntax {$/;"	s	file:
vsctl_context	.\utilities\ovs-vsctl.c	/^struct vsctl_context {$/;"	s	file:
vsctl_context_done	.\utilities\ovs-vsctl.c	/^vsctl_context_done(struct vsctl_context *ctx, struct vsctl_command *command)$/;"	f	file:
vsctl_context_done_command	.\utilities\ovs-vsctl.c	/^vsctl_context_done_command(struct vsctl_context *ctx,$/;"	f	file:
vsctl_context_init	.\utilities\ovs-vsctl.c	/^vsctl_context_init(struct vsctl_context *ctx, struct vsctl_command *command,$/;"	f	file:
vsctl_context_init_command	.\utilities\ovs-vsctl.c	/^vsctl_context_init_command(struct vsctl_context *ctx,$/;"	f	file:
vsctl_context_invalidate_cache	.\utilities\ovs-vsctl.c	/^vsctl_context_invalidate_cache(struct vsctl_context *ctx)$/;"	f	file:
vsctl_context_populate_cache	.\utilities\ovs-vsctl.c	/^vsctl_context_populate_cache(struct vsctl_context *ctx)$/;"	f	file:
vsctl_context_to_string	.\utilities\ovs-vsctl.c	/^vsctl_context_to_string(const struct vsctl_context *ctx)$/;"	f	file:
vsctl_escape	.\xenserver\opt_xensource_libexec_InterfaceReconfigureVswitch.py	/^def vsctl_escape(s):$/;"	f
vsctl_exit	.\utilities\ovs-vsctl.c	/^vsctl_exit(int status)$/;"	f	file:
vsctl_fatal	.\utilities\ovs-vsctl.c	/^vsctl_fatal(const char *format, ...)$/;"	f	file:
vsctl_iface	.\utilities\ovs-vsctl.c	/^struct vsctl_iface {$/;"	s	file:
vsctl_port	.\utilities\ovs-vsctl.c	/^struct vsctl_port {$/;"	s	file:
vsctl_row_id	.\utilities\ovs-vsctl.c	/^struct vsctl_row_id {$/;"	s	file:
vsctl_table_class	.\utilities\ovs-vsctl.c	/^struct vsctl_table_class {$/;"	s	file:
vsm	.\include\openflow\nicira-ext.h	/^    struct ofp10_vendor_stats_msg vsm; \/* Vendor NX_VENDOR_ID. *\/$/;"	m	struct:nicira10_stats_msg	typeref:struct:nicira10_stats_msg::ofp10_vendor_stats_msg
vsm	.\include\openflow\nicira-ext.h	/^    struct ofp11_vendor_stats_msg vsm; \/* Vendor NX_VENDOR_ID. *\/$/;"	m	struct:nicira11_stats_msg	typeref:struct:nicira11_stats_msg::ofp11_vendor_stats_msg
vsnprintf	.\lib\stdio.c	24;"	d	file:
vsp_add	.\ofproto\ofproto-dpif.c	/^vsp_add(struct ofport_dpif *port, ofp_port_t realdev_ofp_port, int vid)$/;"	f	file:
vsp_mutex	.\ofproto\ofproto-dpif.c	/^    struct ovs_mutex vsp_mutex;$/;"	m	struct:ofproto_dpif	typeref:struct:ofproto_dpif::ovs_mutex	file:
vsp_remove	.\ofproto\ofproto-dpif.c	/^vsp_remove(struct ofport_dpif *port)$/;"	f	file:
vswitch	.\python\ovstest\rpcserver.py	/^import vswitch$/;"	i
vswitchCfgQuery	.\xenserver\opt_xensource_libexec_InterfaceReconfigureVswitch.py	/^def vswitchCfgQuery(action_args):$/;"	f
vswitchd	.\vswitchd\ovs-vswitchd.c	/^VLOG_DEFINE_THIS_MODULE(vswitchd);$/;"	v
vswitchd_ovs_vswitchd_LDADD	.\vswitchd\automake.mk	/^vswitchd_ovs_vswitchd_LDADD = \\$/;"	m
vswitchd_ovs_vswitchd_SOURCES	.\vswitchd\automake.mk	/^vswitchd_ovs_vswitchd_SOURCES = \\$/;"	m
vsz	.\vswitchd\system-stats.c	/^    unsigned long int vsz;      \/* Virtual size, in kB. *\/$/;"	m	struct:process_info	file:
vsz	.\vswitchd\system-stats.c	/^    unsigned long int vsz;      \/* Virtual size, in kB. *\/$/;"	m	struct:raw_process_info	file:
vtep_ctl	.\vtep\vtep-ctl.c	/^VLOG_DEFINE_THIS_MODULE(vtep_ctl);$/;"	v
vtep_ctl_command	.\vtep\vtep-ctl.c	/^struct vtep_ctl_command {$/;"	s	file:
vtep_ctl_command_syntax	.\vtep\vtep-ctl.c	/^struct vtep_ctl_command_syntax {$/;"	s	file:
vtep_ctl_context	.\vtep\vtep-ctl.c	/^struct vtep_ctl_context {$/;"	s	file:
vtep_ctl_context_done	.\vtep\vtep-ctl.c	/^vtep_ctl_context_done(struct vtep_ctl_context *ctx, struct vtep_ctl_command *command)$/;"	f	file:
vtep_ctl_context_done_command	.\vtep\vtep-ctl.c	/^vtep_ctl_context_done_command(struct vtep_ctl_context *ctx,$/;"	f	file:
vtep_ctl_context_init	.\vtep\vtep-ctl.c	/^vtep_ctl_context_init(struct vtep_ctl_context *ctx,$/;"	f	file:
vtep_ctl_context_init_command	.\vtep\vtep-ctl.c	/^vtep_ctl_context_init_command(struct vtep_ctl_context *ctx,$/;"	f	file:
vtep_ctl_context_invalidate_cache	.\vtep\vtep-ctl.c	/^vtep_ctl_context_invalidate_cache(struct vtep_ctl_context *ctx)$/;"	f	file:
vtep_ctl_context_populate_cache	.\vtep\vtep-ctl.c	/^vtep_ctl_context_populate_cache(struct vtep_ctl_context *ctx)$/;"	f	file:
vtep_ctl_exit	.\vtep\vtep-ctl.c	/^vtep_ctl_exit(int status)$/;"	f	file:
vtep_ctl_fatal	.\vtep\vtep-ctl.c	/^vtep_ctl_fatal(const char *format, ...)$/;"	f	file:
vtep_ctl_lswitch	.\vtep\vtep-ctl.c	/^struct vtep_ctl_lswitch {$/;"	s	file:
vtep_ctl_mcast_mac	.\vtep\vtep-ctl.c	/^struct vtep_ctl_mcast_mac {$/;"	s	file:
vtep_ctl_ploc	.\vtep\vtep-ctl.c	/^struct vtep_ctl_ploc {$/;"	s	file:
vtep_ctl_port	.\vtep\vtep-ctl.c	/^struct vtep_ctl_port {$/;"	s	file:
vtep_ctl_pswitch	.\vtep\vtep-ctl.c	/^struct vtep_ctl_pswitch {$/;"	s	file:
vtep_ctl_row_id	.\vtep\vtep-ctl.c	/^struct vtep_ctl_row_id {$/;"	s	file:
vtep_ctl_table_class	.\vtep\vtep-ctl.c	/^struct vtep_ctl_table_class {$/;"	s	file:
vtep_delete_pswitch	.\vtep\vtep-ctl.c	/^vtep_delete_pswitch(const struct vteprec_global *vtep_global,$/;"	f	file:
vtep_global	.\vtep\vtep-ctl.c	/^    const struct vteprec_global *vtep_global;$/;"	m	struct:vtep_ctl_context	typeref:struct:vtep_ctl_context::vteprec_global	file:
vtep_insert_pswitch	.\vtep\vtep-ctl.c	/^vtep_insert_pswitch(const struct vteprec_global *vtep_global,$/;"	f	file:
vtep_vtep_ctl_LDADD	.\vtep\automake.mk	/^vtep_vtep_ctl_LDADD = lib\/libopenvswitch.la$/;"	m
vtep_vtep_ctl_SOURCES	.\vtep\automake.mk	/^vtep_vtep_ctl_SOURCES = vtep\/vtep-ctl.c$/;"	m
vteprec_arp_sources_local	.\lib\vtep-idl.h	/^struct vteprec_arp_sources_local {$/;"	s
vteprec_arp_sources_local_cast	.\lib\vtep-idl.c	/^vteprec_arp_sources_local_cast(const struct ovsdb_idl_row *row)$/;"	f	file:
vteprec_arp_sources_local_col_locator	.\lib\vtep-idl.h	31;"	d
vteprec_arp_sources_local_col_src_mac	.\lib\vtep-idl.h	32;"	d
vteprec_arp_sources_local_columns	.\lib\vtep-idl.c	/^struct ovsdb_idl_column vteprec_arp_sources_local_columns[VTEPREC_ARP_SOURCES_LOCAL_N_COLUMNS];$/;"	v	typeref:struct:ovsdb_idl_column
vteprec_arp_sources_local_columns_init	.\lib\vtep-idl.c	/^vteprec_arp_sources_local_columns_init(void)$/;"	f	file:
vteprec_arp_sources_local_delete	.\lib\vtep-idl.c	/^vteprec_arp_sources_local_delete(const struct vteprec_arp_sources_local *row)$/;"	f
vteprec_arp_sources_local_first	.\lib\vtep-idl.c	/^vteprec_arp_sources_local_first(const struct ovsdb_idl *idl)$/;"	f
vteprec_arp_sources_local_get_for_uuid	.\lib\vtep-idl.c	/^vteprec_arp_sources_local_get_for_uuid(const struct ovsdb_idl *idl, const struct uuid *uuid)$/;"	f
vteprec_arp_sources_local_get_locator	.\lib\vtep-idl.c	/^vteprec_arp_sources_local_get_locator(const struct vteprec_arp_sources_local *row,$/;"	f
vteprec_arp_sources_local_get_src_mac	.\lib\vtep-idl.c	/^vteprec_arp_sources_local_get_src_mac(const struct vteprec_arp_sources_local *row,$/;"	f
vteprec_arp_sources_local_init	.\lib\vtep-idl.c	/^vteprec_arp_sources_local_init(struct vteprec_arp_sources_local *row)$/;"	f
vteprec_arp_sources_local_init__	.\lib\vtep-idl.c	/^vteprec_arp_sources_local_init__(struct ovsdb_idl_row *row)$/;"	f	file:
vteprec_arp_sources_local_insert	.\lib\vtep-idl.c	/^vteprec_arp_sources_local_insert(struct ovsdb_idl_txn *txn)$/;"	f
vteprec_arp_sources_local_next	.\lib\vtep-idl.c	/^vteprec_arp_sources_local_next(const struct vteprec_arp_sources_local *row)$/;"	f
vteprec_arp_sources_local_parse_locator	.\lib\vtep-idl.c	/^vteprec_arp_sources_local_parse_locator(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
vteprec_arp_sources_local_parse_src_mac	.\lib\vtep-idl.c	/^vteprec_arp_sources_local_parse_src_mac(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
vteprec_arp_sources_local_set_locator	.\lib\vtep-idl.c	/^vteprec_arp_sources_local_set_locator(const struct vteprec_arp_sources_local *row, const struct vteprec_physical_locator *locator)$/;"	f
vteprec_arp_sources_local_set_src_mac	.\lib\vtep-idl.c	/^vteprec_arp_sources_local_set_src_mac(const struct vteprec_arp_sources_local *row, const char *src_mac)$/;"	f
vteprec_arp_sources_local_unparse_locator	.\lib\vtep-idl.c	/^vteprec_arp_sources_local_unparse_locator(struct ovsdb_idl_row *row OVS_UNUSED)$/;"	f	file:
vteprec_arp_sources_local_unparse_src_mac	.\lib\vtep-idl.c	/^vteprec_arp_sources_local_unparse_src_mac(struct ovsdb_idl_row *row OVS_UNUSED)$/;"	f	file:
vteprec_arp_sources_local_verify_locator	.\lib\vtep-idl.c	/^vteprec_arp_sources_local_verify_locator(const struct vteprec_arp_sources_local *row)$/;"	f
vteprec_arp_sources_local_verify_src_mac	.\lib\vtep-idl.c	/^vteprec_arp_sources_local_verify_src_mac(const struct vteprec_arp_sources_local *row)$/;"	f
vteprec_arp_sources_remote	.\lib\vtep-idl.h	/^struct vteprec_arp_sources_remote {$/;"	s
vteprec_arp_sources_remote_cast	.\lib\vtep-idl.c	/^vteprec_arp_sources_remote_cast(const struct ovsdb_idl_row *row)$/;"	f	file:
vteprec_arp_sources_remote_col_locator	.\lib\vtep-idl.h	82;"	d
vteprec_arp_sources_remote_col_src_mac	.\lib\vtep-idl.h	83;"	d
vteprec_arp_sources_remote_columns	.\lib\vtep-idl.c	/^struct ovsdb_idl_column vteprec_arp_sources_remote_columns[VTEPREC_ARP_SOURCES_REMOTE_N_COLUMNS];$/;"	v	typeref:struct:ovsdb_idl_column
vteprec_arp_sources_remote_columns_init	.\lib\vtep-idl.c	/^vteprec_arp_sources_remote_columns_init(void)$/;"	f	file:
vteprec_arp_sources_remote_delete	.\lib\vtep-idl.c	/^vteprec_arp_sources_remote_delete(const struct vteprec_arp_sources_remote *row)$/;"	f
vteprec_arp_sources_remote_first	.\lib\vtep-idl.c	/^vteprec_arp_sources_remote_first(const struct ovsdb_idl *idl)$/;"	f
vteprec_arp_sources_remote_get_for_uuid	.\lib\vtep-idl.c	/^vteprec_arp_sources_remote_get_for_uuid(const struct ovsdb_idl *idl, const struct uuid *uuid)$/;"	f
vteprec_arp_sources_remote_get_locator	.\lib\vtep-idl.c	/^vteprec_arp_sources_remote_get_locator(const struct vteprec_arp_sources_remote *row,$/;"	f
vteprec_arp_sources_remote_get_src_mac	.\lib\vtep-idl.c	/^vteprec_arp_sources_remote_get_src_mac(const struct vteprec_arp_sources_remote *row,$/;"	f
vteprec_arp_sources_remote_init	.\lib\vtep-idl.c	/^vteprec_arp_sources_remote_init(struct vteprec_arp_sources_remote *row)$/;"	f
vteprec_arp_sources_remote_init__	.\lib\vtep-idl.c	/^vteprec_arp_sources_remote_init__(struct ovsdb_idl_row *row)$/;"	f	file:
vteprec_arp_sources_remote_insert	.\lib\vtep-idl.c	/^vteprec_arp_sources_remote_insert(struct ovsdb_idl_txn *txn)$/;"	f
vteprec_arp_sources_remote_next	.\lib\vtep-idl.c	/^vteprec_arp_sources_remote_next(const struct vteprec_arp_sources_remote *row)$/;"	f
vteprec_arp_sources_remote_parse_locator	.\lib\vtep-idl.c	/^vteprec_arp_sources_remote_parse_locator(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
vteprec_arp_sources_remote_parse_src_mac	.\lib\vtep-idl.c	/^vteprec_arp_sources_remote_parse_src_mac(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
vteprec_arp_sources_remote_set_locator	.\lib\vtep-idl.c	/^vteprec_arp_sources_remote_set_locator(const struct vteprec_arp_sources_remote *row, const struct vteprec_physical_locator *locator)$/;"	f
vteprec_arp_sources_remote_set_src_mac	.\lib\vtep-idl.c	/^vteprec_arp_sources_remote_set_src_mac(const struct vteprec_arp_sources_remote *row, const char *src_mac)$/;"	f
vteprec_arp_sources_remote_unparse_locator	.\lib\vtep-idl.c	/^vteprec_arp_sources_remote_unparse_locator(struct ovsdb_idl_row *row OVS_UNUSED)$/;"	f	file:
vteprec_arp_sources_remote_unparse_src_mac	.\lib\vtep-idl.c	/^vteprec_arp_sources_remote_unparse_src_mac(struct ovsdb_idl_row *row OVS_UNUSED)$/;"	f	file:
vteprec_arp_sources_remote_verify_locator	.\lib\vtep-idl.c	/^vteprec_arp_sources_remote_verify_locator(const struct vteprec_arp_sources_remote *row)$/;"	f
vteprec_arp_sources_remote_verify_src_mac	.\lib\vtep-idl.c	/^vteprec_arp_sources_remote_verify_src_mac(const struct vteprec_arp_sources_remote *row)$/;"	f
vteprec_get_db_version	.\lib\vtep-idl.c	/^vteprec_get_db_version(void)$/;"	f
vteprec_global	.\lib\vtep-idl.h	/^struct vteprec_global {$/;"	s
vteprec_global_cast	.\lib\vtep-idl.c	/^vteprec_global_cast(const struct ovsdb_idl_row *row)$/;"	f	file:
vteprec_global_col_managers	.\lib\vtep-idl.h	136;"	d
vteprec_global_col_switches	.\lib\vtep-idl.h	135;"	d
vteprec_global_columns	.\lib\vtep-idl.c	/^struct ovsdb_idl_column vteprec_global_columns[VTEPREC_GLOBAL_N_COLUMNS];$/;"	v	typeref:struct:ovsdb_idl_column
vteprec_global_columns_init	.\lib\vtep-idl.c	/^vteprec_global_columns_init(void)$/;"	f	file:
vteprec_global_delete	.\lib\vtep-idl.c	/^vteprec_global_delete(const struct vteprec_global *row)$/;"	f
vteprec_global_first	.\lib\vtep-idl.c	/^vteprec_global_first(const struct ovsdb_idl *idl)$/;"	f
vteprec_global_get_for_uuid	.\lib\vtep-idl.c	/^vteprec_global_get_for_uuid(const struct ovsdb_idl *idl, const struct uuid *uuid)$/;"	f
vteprec_global_get_managers	.\lib\vtep-idl.c	/^vteprec_global_get_managers(const struct vteprec_global *row,$/;"	f
vteprec_global_get_switches	.\lib\vtep-idl.c	/^vteprec_global_get_switches(const struct vteprec_global *row,$/;"	f
vteprec_global_init	.\lib\vtep-idl.c	/^vteprec_global_init(struct vteprec_global *row)$/;"	f
vteprec_global_init__	.\lib\vtep-idl.c	/^vteprec_global_init__(struct ovsdb_idl_row *row)$/;"	f	file:
vteprec_global_insert	.\lib\vtep-idl.c	/^vteprec_global_insert(struct ovsdb_idl_txn *txn)$/;"	f
vteprec_global_next	.\lib\vtep-idl.c	/^vteprec_global_next(const struct vteprec_global *row)$/;"	f
vteprec_global_parse_managers	.\lib\vtep-idl.c	/^vteprec_global_parse_managers(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
vteprec_global_parse_switches	.\lib\vtep-idl.c	/^vteprec_global_parse_switches(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
vteprec_global_set_managers	.\lib\vtep-idl.c	/^vteprec_global_set_managers(const struct vteprec_global *row, struct vteprec_manager **managers, size_t n_managers)$/;"	f
vteprec_global_set_switches	.\lib\vtep-idl.c	/^vteprec_global_set_switches(const struct vteprec_global *row, struct vteprec_physical_switch **switches, size_t n_switches)$/;"	f
vteprec_global_unparse_managers	.\lib\vtep-idl.c	/^vteprec_global_unparse_managers(struct ovsdb_idl_row *row_)$/;"	f	file:
vteprec_global_unparse_switches	.\lib\vtep-idl.c	/^vteprec_global_unparse_switches(struct ovsdb_idl_row *row_)$/;"	f	file:
vteprec_global_verify_managers	.\lib\vtep-idl.c	/^vteprec_global_verify_managers(const struct vteprec_global *row)$/;"	f
vteprec_global_verify_switches	.\lib\vtep-idl.c	/^vteprec_global_verify_switches(const struct vteprec_global *row)$/;"	f
vteprec_idl_class	.\lib\vtep-idl.c	/^struct ovsdb_idl_class vteprec_idl_class = {$/;"	v	typeref:struct:ovsdb_idl_class
vteprec_init	.\lib\vtep-idl.c	/^vteprec_init(void)$/;"	f
vteprec_logical_binding_stats	.\lib\vtep-idl.h	/^struct vteprec_logical_binding_stats {$/;"	s
vteprec_logical_binding_stats_cast	.\lib\vtep-idl.c	/^vteprec_logical_binding_stats_cast(const struct ovsdb_idl_row *row)$/;"	f	file:
vteprec_logical_binding_stats_col_bytes_from_local	.\lib\vtep-idl.h	195;"	d
vteprec_logical_binding_stats_col_bytes_to_local	.\lib\vtep-idl.h	194;"	d
vteprec_logical_binding_stats_col_packets_from_local	.\lib\vtep-idl.h	196;"	d
vteprec_logical_binding_stats_col_packets_to_local	.\lib\vtep-idl.h	197;"	d
vteprec_logical_binding_stats_columns	.\lib\vtep-idl.c	/^struct ovsdb_idl_column vteprec_logical_binding_stats_columns[VTEPREC_LOGICAL_BINDING_STATS_N_COLUMNS];$/;"	v	typeref:struct:ovsdb_idl_column
vteprec_logical_binding_stats_columns_init	.\lib\vtep-idl.c	/^vteprec_logical_binding_stats_columns_init(void)$/;"	f	file:
vteprec_logical_binding_stats_delete	.\lib\vtep-idl.c	/^vteprec_logical_binding_stats_delete(const struct vteprec_logical_binding_stats *row)$/;"	f
vteprec_logical_binding_stats_first	.\lib\vtep-idl.c	/^vteprec_logical_binding_stats_first(const struct ovsdb_idl *idl)$/;"	f
vteprec_logical_binding_stats_get_bytes_from_local	.\lib\vtep-idl.c	/^vteprec_logical_binding_stats_get_bytes_from_local(const struct vteprec_logical_binding_stats *row,$/;"	f
vteprec_logical_binding_stats_get_bytes_to_local	.\lib\vtep-idl.c	/^vteprec_logical_binding_stats_get_bytes_to_local(const struct vteprec_logical_binding_stats *row,$/;"	f
vteprec_logical_binding_stats_get_for_uuid	.\lib\vtep-idl.c	/^vteprec_logical_binding_stats_get_for_uuid(const struct ovsdb_idl *idl, const struct uuid *uuid)$/;"	f
vteprec_logical_binding_stats_get_packets_from_local	.\lib\vtep-idl.c	/^vteprec_logical_binding_stats_get_packets_from_local(const struct vteprec_logical_binding_stats *row,$/;"	f
vteprec_logical_binding_stats_get_packets_to_local	.\lib\vtep-idl.c	/^vteprec_logical_binding_stats_get_packets_to_local(const struct vteprec_logical_binding_stats *row,$/;"	f
vteprec_logical_binding_stats_init	.\lib\vtep-idl.c	/^vteprec_logical_binding_stats_init(struct vteprec_logical_binding_stats *row)$/;"	f
vteprec_logical_binding_stats_init__	.\lib\vtep-idl.c	/^vteprec_logical_binding_stats_init__(struct ovsdb_idl_row *row)$/;"	f	file:
vteprec_logical_binding_stats_insert	.\lib\vtep-idl.c	/^vteprec_logical_binding_stats_insert(struct ovsdb_idl_txn *txn)$/;"	f
vteprec_logical_binding_stats_next	.\lib\vtep-idl.c	/^vteprec_logical_binding_stats_next(const struct vteprec_logical_binding_stats *row)$/;"	f
vteprec_logical_binding_stats_parse_bytes_from_local	.\lib\vtep-idl.c	/^vteprec_logical_binding_stats_parse_bytes_from_local(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
vteprec_logical_binding_stats_parse_bytes_to_local	.\lib\vtep-idl.c	/^vteprec_logical_binding_stats_parse_bytes_to_local(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
vteprec_logical_binding_stats_parse_packets_from_local	.\lib\vtep-idl.c	/^vteprec_logical_binding_stats_parse_packets_from_local(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
vteprec_logical_binding_stats_parse_packets_to_local	.\lib\vtep-idl.c	/^vteprec_logical_binding_stats_parse_packets_to_local(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
vteprec_logical_binding_stats_set_bytes_from_local	.\lib\vtep-idl.c	/^vteprec_logical_binding_stats_set_bytes_from_local(const struct vteprec_logical_binding_stats *row, int64_t bytes_from_local)$/;"	f
vteprec_logical_binding_stats_set_bytes_to_local	.\lib\vtep-idl.c	/^vteprec_logical_binding_stats_set_bytes_to_local(const struct vteprec_logical_binding_stats *row, int64_t bytes_to_local)$/;"	f
vteprec_logical_binding_stats_set_packets_from_local	.\lib\vtep-idl.c	/^vteprec_logical_binding_stats_set_packets_from_local(const struct vteprec_logical_binding_stats *row, int64_t packets_from_local)$/;"	f
vteprec_logical_binding_stats_set_packets_to_local	.\lib\vtep-idl.c	/^vteprec_logical_binding_stats_set_packets_to_local(const struct vteprec_logical_binding_stats *row, int64_t packets_to_local)$/;"	f
vteprec_logical_binding_stats_unparse_bytes_from_local	.\lib\vtep-idl.c	/^vteprec_logical_binding_stats_unparse_bytes_from_local(struct ovsdb_idl_row *row OVS_UNUSED)$/;"	f	file:
vteprec_logical_binding_stats_unparse_bytes_to_local	.\lib\vtep-idl.c	/^vteprec_logical_binding_stats_unparse_bytes_to_local(struct ovsdb_idl_row *row OVS_UNUSED)$/;"	f	file:
vteprec_logical_binding_stats_unparse_packets_from_local	.\lib\vtep-idl.c	/^vteprec_logical_binding_stats_unparse_packets_from_local(struct ovsdb_idl_row *row OVS_UNUSED)$/;"	f	file:
vteprec_logical_binding_stats_unparse_packets_to_local	.\lib\vtep-idl.c	/^vteprec_logical_binding_stats_unparse_packets_to_local(struct ovsdb_idl_row *row OVS_UNUSED)$/;"	f	file:
vteprec_logical_binding_stats_verify_bytes_from_local	.\lib\vtep-idl.c	/^vteprec_logical_binding_stats_verify_bytes_from_local(const struct vteprec_logical_binding_stats *row)$/;"	f
vteprec_logical_binding_stats_verify_bytes_to_local	.\lib\vtep-idl.c	/^vteprec_logical_binding_stats_verify_bytes_to_local(const struct vteprec_logical_binding_stats *row)$/;"	f
vteprec_logical_binding_stats_verify_packets_from_local	.\lib\vtep-idl.c	/^vteprec_logical_binding_stats_verify_packets_from_local(const struct vteprec_logical_binding_stats *row)$/;"	f
vteprec_logical_binding_stats_verify_packets_to_local	.\lib\vtep-idl.c	/^vteprec_logical_binding_stats_verify_packets_to_local(const struct vteprec_logical_binding_stats *row)$/;"	f
vteprec_logical_router	.\lib\vtep-idl.h	/^struct vteprec_logical_router {$/;"	s
vteprec_logical_router_cast	.\lib\vtep-idl.c	/^vteprec_logical_router_cast(const struct ovsdb_idl_row *row)$/;"	f	file:
vteprec_logical_router_col_description	.\lib\vtep-idl.h	264;"	d
vteprec_logical_router_col_name	.\lib\vtep-idl.h	266;"	d
vteprec_logical_router_col_static_routes	.\lib\vtep-idl.h	265;"	d
vteprec_logical_router_col_switch_binding	.\lib\vtep-idl.h	263;"	d
vteprec_logical_router_columns	.\lib\vtep-idl.c	/^struct ovsdb_idl_column vteprec_logical_router_columns[VTEPREC_LOGICAL_ROUTER_N_COLUMNS];$/;"	v	typeref:struct:ovsdb_idl_column
vteprec_logical_router_columns_init	.\lib\vtep-idl.c	/^vteprec_logical_router_columns_init(void)$/;"	f	file:
vteprec_logical_router_delete	.\lib\vtep-idl.c	/^vteprec_logical_router_delete(const struct vteprec_logical_router *row)$/;"	f
vteprec_logical_router_first	.\lib\vtep-idl.c	/^vteprec_logical_router_first(const struct ovsdb_idl *idl)$/;"	f
vteprec_logical_router_get_description	.\lib\vtep-idl.c	/^vteprec_logical_router_get_description(const struct vteprec_logical_router *row,$/;"	f
vteprec_logical_router_get_for_uuid	.\lib\vtep-idl.c	/^vteprec_logical_router_get_for_uuid(const struct ovsdb_idl *idl, const struct uuid *uuid)$/;"	f
vteprec_logical_router_get_name	.\lib\vtep-idl.c	/^vteprec_logical_router_get_name(const struct vteprec_logical_router *row,$/;"	f
vteprec_logical_router_get_static_routes	.\lib\vtep-idl.c	/^vteprec_logical_router_get_static_routes(const struct vteprec_logical_router *row,$/;"	f
vteprec_logical_router_get_switch_binding	.\lib\vtep-idl.c	/^vteprec_logical_router_get_switch_binding(const struct vteprec_logical_router *row,$/;"	f
vteprec_logical_router_init	.\lib\vtep-idl.c	/^vteprec_logical_router_init(struct vteprec_logical_router *row)$/;"	f
vteprec_logical_router_init__	.\lib\vtep-idl.c	/^vteprec_logical_router_init__(struct ovsdb_idl_row *row)$/;"	f	file:
vteprec_logical_router_insert	.\lib\vtep-idl.c	/^vteprec_logical_router_insert(struct ovsdb_idl_txn *txn)$/;"	f
vteprec_logical_router_next	.\lib\vtep-idl.c	/^vteprec_logical_router_next(const struct vteprec_logical_router *row)$/;"	f
vteprec_logical_router_parse_description	.\lib\vtep-idl.c	/^vteprec_logical_router_parse_description(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
vteprec_logical_router_parse_name	.\lib\vtep-idl.c	/^vteprec_logical_router_parse_name(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
vteprec_logical_router_parse_static_routes	.\lib\vtep-idl.c	/^vteprec_logical_router_parse_static_routes(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
vteprec_logical_router_parse_switch_binding	.\lib\vtep-idl.c	/^vteprec_logical_router_parse_switch_binding(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
vteprec_logical_router_set_description	.\lib\vtep-idl.c	/^vteprec_logical_router_set_description(const struct vteprec_logical_router *row, const char *description)$/;"	f
vteprec_logical_router_set_name	.\lib\vtep-idl.c	/^vteprec_logical_router_set_name(const struct vteprec_logical_router *row, const char *name)$/;"	f
vteprec_logical_router_set_static_routes	.\lib\vtep-idl.c	/^vteprec_logical_router_set_static_routes(const struct vteprec_logical_router *row, const struct smap *smap)$/;"	f
vteprec_logical_router_set_switch_binding	.\lib\vtep-idl.c	/^vteprec_logical_router_set_switch_binding(const struct vteprec_logical_router *row, char **key_switch_binding, struct vteprec_logical_switch **value_switch_binding, size_t n_switch_binding)$/;"	f
vteprec_logical_router_unparse_description	.\lib\vtep-idl.c	/^vteprec_logical_router_unparse_description(struct ovsdb_idl_row *row OVS_UNUSED)$/;"	f	file:
vteprec_logical_router_unparse_name	.\lib\vtep-idl.c	/^vteprec_logical_router_unparse_name(struct ovsdb_idl_row *row OVS_UNUSED)$/;"	f	file:
vteprec_logical_router_unparse_static_routes	.\lib\vtep-idl.c	/^vteprec_logical_router_unparse_static_routes(struct ovsdb_idl_row *row_)$/;"	f	file:
vteprec_logical_router_unparse_switch_binding	.\lib\vtep-idl.c	/^vteprec_logical_router_unparse_switch_binding(struct ovsdb_idl_row *row_)$/;"	f	file:
vteprec_logical_router_verify_description	.\lib\vtep-idl.c	/^vteprec_logical_router_verify_description(const struct vteprec_logical_router *row)$/;"	f
vteprec_logical_router_verify_name	.\lib\vtep-idl.c	/^vteprec_logical_router_verify_name(const struct vteprec_logical_router *row)$/;"	f
vteprec_logical_router_verify_static_routes	.\lib\vtep-idl.c	/^vteprec_logical_router_verify_static_routes(const struct vteprec_logical_router *row)$/;"	f
vteprec_logical_router_verify_switch_binding	.\lib\vtep-idl.c	/^vteprec_logical_router_verify_switch_binding(const struct vteprec_logical_router *row)$/;"	f
vteprec_logical_switch	.\lib\vtep-idl.h	/^struct vteprec_logical_switch {$/;"	s
vteprec_logical_switch_cast	.\lib\vtep-idl.c	/^vteprec_logical_switch_cast(const struct ovsdb_idl_row *row)$/;"	f	file:
vteprec_logical_switch_col_description	.\lib\vtep-idl.h	328;"	d
vteprec_logical_switch_col_name	.\lib\vtep-idl.h	329;"	d
vteprec_logical_switch_col_tunnel_key	.\lib\vtep-idl.h	327;"	d
vteprec_logical_switch_columns	.\lib\vtep-idl.c	/^struct ovsdb_idl_column vteprec_logical_switch_columns[VTEPREC_LOGICAL_SWITCH_N_COLUMNS];$/;"	v	typeref:struct:ovsdb_idl_column
vteprec_logical_switch_columns_init	.\lib\vtep-idl.c	/^vteprec_logical_switch_columns_init(void)$/;"	f	file:
vteprec_logical_switch_delete	.\lib\vtep-idl.c	/^vteprec_logical_switch_delete(const struct vteprec_logical_switch *row)$/;"	f
vteprec_logical_switch_first	.\lib\vtep-idl.c	/^vteprec_logical_switch_first(const struct ovsdb_idl *idl)$/;"	f
vteprec_logical_switch_get_description	.\lib\vtep-idl.c	/^vteprec_logical_switch_get_description(const struct vteprec_logical_switch *row,$/;"	f
vteprec_logical_switch_get_for_uuid	.\lib\vtep-idl.c	/^vteprec_logical_switch_get_for_uuid(const struct ovsdb_idl *idl, const struct uuid *uuid)$/;"	f
vteprec_logical_switch_get_name	.\lib\vtep-idl.c	/^vteprec_logical_switch_get_name(const struct vteprec_logical_switch *row,$/;"	f
vteprec_logical_switch_get_tunnel_key	.\lib\vtep-idl.c	/^vteprec_logical_switch_get_tunnel_key(const struct vteprec_logical_switch *row,$/;"	f
vteprec_logical_switch_init	.\lib\vtep-idl.c	/^vteprec_logical_switch_init(struct vteprec_logical_switch *row)$/;"	f
vteprec_logical_switch_init__	.\lib\vtep-idl.c	/^vteprec_logical_switch_init__(struct ovsdb_idl_row *row)$/;"	f	file:
vteprec_logical_switch_insert	.\lib\vtep-idl.c	/^vteprec_logical_switch_insert(struct ovsdb_idl_txn *txn)$/;"	f
vteprec_logical_switch_next	.\lib\vtep-idl.c	/^vteprec_logical_switch_next(const struct vteprec_logical_switch *row)$/;"	f
vteprec_logical_switch_parse_description	.\lib\vtep-idl.c	/^vteprec_logical_switch_parse_description(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
vteprec_logical_switch_parse_name	.\lib\vtep-idl.c	/^vteprec_logical_switch_parse_name(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
vteprec_logical_switch_parse_tunnel_key	.\lib\vtep-idl.c	/^vteprec_logical_switch_parse_tunnel_key(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
vteprec_logical_switch_set_description	.\lib\vtep-idl.c	/^vteprec_logical_switch_set_description(const struct vteprec_logical_switch *row, const char *description)$/;"	f
vteprec_logical_switch_set_name	.\lib\vtep-idl.c	/^vteprec_logical_switch_set_name(const struct vteprec_logical_switch *row, const char *name)$/;"	f
vteprec_logical_switch_set_tunnel_key	.\lib\vtep-idl.c	/^vteprec_logical_switch_set_tunnel_key(const struct vteprec_logical_switch *row, const int64_t *tunnel_key, size_t n_tunnel_key)$/;"	f
vteprec_logical_switch_unparse_description	.\lib\vtep-idl.c	/^vteprec_logical_switch_unparse_description(struct ovsdb_idl_row *row OVS_UNUSED)$/;"	f	file:
vteprec_logical_switch_unparse_name	.\lib\vtep-idl.c	/^vteprec_logical_switch_unparse_name(struct ovsdb_idl_row *row OVS_UNUSED)$/;"	f	file:
vteprec_logical_switch_unparse_tunnel_key	.\lib\vtep-idl.c	/^vteprec_logical_switch_unparse_tunnel_key(struct ovsdb_idl_row *row_)$/;"	f	file:
vteprec_logical_switch_verify_description	.\lib\vtep-idl.c	/^vteprec_logical_switch_verify_description(const struct vteprec_logical_switch *row)$/;"	f
vteprec_logical_switch_verify_name	.\lib\vtep-idl.c	/^vteprec_logical_switch_verify_name(const struct vteprec_logical_switch *row)$/;"	f
vteprec_logical_switch_verify_tunnel_key	.\lib\vtep-idl.c	/^vteprec_logical_switch_verify_tunnel_key(const struct vteprec_logical_switch *row)$/;"	f
vteprec_manager	.\lib\vtep-idl.h	/^struct vteprec_manager {$/;"	s
vteprec_manager_cast	.\lib\vtep-idl.c	/^vteprec_manager_cast(const struct ovsdb_idl_row *row)$/;"	f	file:
vteprec_manager_col_inactivity_probe	.\lib\vtep-idl.h	404;"	d
vteprec_manager_col_is_connected	.\lib\vtep-idl.h	405;"	d
vteprec_manager_col_max_backoff	.\lib\vtep-idl.h	400;"	d
vteprec_manager_col_other_config	.\lib\vtep-idl.h	403;"	d
vteprec_manager_col_status	.\lib\vtep-idl.h	401;"	d
vteprec_manager_col_target	.\lib\vtep-idl.h	402;"	d
vteprec_manager_columns	.\lib\vtep-idl.c	/^struct ovsdb_idl_column vteprec_manager_columns[VTEPREC_MANAGER_N_COLUMNS];$/;"	v	typeref:struct:ovsdb_idl_column
vteprec_manager_columns_init	.\lib\vtep-idl.c	/^vteprec_manager_columns_init(void)$/;"	f	file:
vteprec_manager_delete	.\lib\vtep-idl.c	/^vteprec_manager_delete(const struct vteprec_manager *row)$/;"	f
vteprec_manager_first	.\lib\vtep-idl.c	/^vteprec_manager_first(const struct ovsdb_idl *idl)$/;"	f
vteprec_manager_get_for_uuid	.\lib\vtep-idl.c	/^vteprec_manager_get_for_uuid(const struct ovsdb_idl *idl, const struct uuid *uuid)$/;"	f
vteprec_manager_get_inactivity_probe	.\lib\vtep-idl.c	/^vteprec_manager_get_inactivity_probe(const struct vteprec_manager *row,$/;"	f
vteprec_manager_get_is_connected	.\lib\vtep-idl.c	/^vteprec_manager_get_is_connected(const struct vteprec_manager *row,$/;"	f
vteprec_manager_get_max_backoff	.\lib\vtep-idl.c	/^vteprec_manager_get_max_backoff(const struct vteprec_manager *row,$/;"	f
vteprec_manager_get_other_config	.\lib\vtep-idl.c	/^vteprec_manager_get_other_config(const struct vteprec_manager *row,$/;"	f
vteprec_manager_get_status	.\lib\vtep-idl.c	/^vteprec_manager_get_status(const struct vteprec_manager *row,$/;"	f
vteprec_manager_get_target	.\lib\vtep-idl.c	/^vteprec_manager_get_target(const struct vteprec_manager *row,$/;"	f
vteprec_manager_init	.\lib\vtep-idl.c	/^vteprec_manager_init(struct vteprec_manager *row)$/;"	f
vteprec_manager_init__	.\lib\vtep-idl.c	/^vteprec_manager_init__(struct ovsdb_idl_row *row)$/;"	f	file:
vteprec_manager_insert	.\lib\vtep-idl.c	/^vteprec_manager_insert(struct ovsdb_idl_txn *txn)$/;"	f
vteprec_manager_next	.\lib\vtep-idl.c	/^vteprec_manager_next(const struct vteprec_manager *row)$/;"	f
vteprec_manager_parse_inactivity_probe	.\lib\vtep-idl.c	/^vteprec_manager_parse_inactivity_probe(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
vteprec_manager_parse_is_connected	.\lib\vtep-idl.c	/^vteprec_manager_parse_is_connected(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
vteprec_manager_parse_max_backoff	.\lib\vtep-idl.c	/^vteprec_manager_parse_max_backoff(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
vteprec_manager_parse_other_config	.\lib\vtep-idl.c	/^vteprec_manager_parse_other_config(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
vteprec_manager_parse_status	.\lib\vtep-idl.c	/^vteprec_manager_parse_status(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
vteprec_manager_parse_target	.\lib\vtep-idl.c	/^vteprec_manager_parse_target(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
vteprec_manager_set_inactivity_probe	.\lib\vtep-idl.c	/^vteprec_manager_set_inactivity_probe(const struct vteprec_manager *row, const int64_t *inactivity_probe, size_t n_inactivity_probe)$/;"	f
vteprec_manager_set_is_connected	.\lib\vtep-idl.c	/^vteprec_manager_set_is_connected(const struct vteprec_manager *row, bool is_connected)$/;"	f
vteprec_manager_set_max_backoff	.\lib\vtep-idl.c	/^vteprec_manager_set_max_backoff(const struct vteprec_manager *row, const int64_t *max_backoff, size_t n_max_backoff)$/;"	f
vteprec_manager_set_other_config	.\lib\vtep-idl.c	/^vteprec_manager_set_other_config(const struct vteprec_manager *row, const struct smap *smap)$/;"	f
vteprec_manager_set_status	.\lib\vtep-idl.c	/^vteprec_manager_set_status(const struct vteprec_manager *row, const struct smap *smap)$/;"	f
vteprec_manager_set_target	.\lib\vtep-idl.c	/^vteprec_manager_set_target(const struct vteprec_manager *row, const char *target)$/;"	f
vteprec_manager_unparse_inactivity_probe	.\lib\vtep-idl.c	/^vteprec_manager_unparse_inactivity_probe(struct ovsdb_idl_row *row_)$/;"	f	file:
vteprec_manager_unparse_is_connected	.\lib\vtep-idl.c	/^vteprec_manager_unparse_is_connected(struct ovsdb_idl_row *row OVS_UNUSED)$/;"	f	file:
vteprec_manager_unparse_max_backoff	.\lib\vtep-idl.c	/^vteprec_manager_unparse_max_backoff(struct ovsdb_idl_row *row_)$/;"	f	file:
vteprec_manager_unparse_other_config	.\lib\vtep-idl.c	/^vteprec_manager_unparse_other_config(struct ovsdb_idl_row *row_)$/;"	f	file:
vteprec_manager_unparse_status	.\lib\vtep-idl.c	/^vteprec_manager_unparse_status(struct ovsdb_idl_row *row_)$/;"	f	file:
vteprec_manager_unparse_target	.\lib\vtep-idl.c	/^vteprec_manager_unparse_target(struct ovsdb_idl_row *row OVS_UNUSED)$/;"	f	file:
vteprec_manager_verify_inactivity_probe	.\lib\vtep-idl.c	/^vteprec_manager_verify_inactivity_probe(const struct vteprec_manager *row)$/;"	f
vteprec_manager_verify_is_connected	.\lib\vtep-idl.c	/^vteprec_manager_verify_is_connected(const struct vteprec_manager *row)$/;"	f
vteprec_manager_verify_max_backoff	.\lib\vtep-idl.c	/^vteprec_manager_verify_max_backoff(const struct vteprec_manager *row)$/;"	f
vteprec_manager_verify_other_config	.\lib\vtep-idl.c	/^vteprec_manager_verify_other_config(const struct vteprec_manager *row)$/;"	f
vteprec_manager_verify_status	.\lib\vtep-idl.c	/^vteprec_manager_verify_status(const struct vteprec_manager *row)$/;"	f
vteprec_manager_verify_target	.\lib\vtep-idl.c	/^vteprec_manager_verify_target(const struct vteprec_manager *row)$/;"	f
vteprec_mcast_macs_local	.\lib\vtep-idl.h	/^struct vteprec_mcast_macs_local {$/;"	s
vteprec_mcast_macs_local_cast	.\lib\vtep-idl.c	/^vteprec_mcast_macs_local_cast(const struct ovsdb_idl_row *row)$/;"	f	file:
vteprec_mcast_macs_local_col_MAC	.\lib\vtep-idl.h	476;"	d
vteprec_mcast_macs_local_col_ipaddr	.\lib\vtep-idl.h	475;"	d
vteprec_mcast_macs_local_col_locator_set	.\lib\vtep-idl.h	477;"	d
vteprec_mcast_macs_local_col_logical_switch	.\lib\vtep-idl.h	478;"	d
vteprec_mcast_macs_local_columns	.\lib\vtep-idl.c	/^struct ovsdb_idl_column vteprec_mcast_macs_local_columns[VTEPREC_MCAST_MACS_LOCAL_N_COLUMNS];$/;"	v	typeref:struct:ovsdb_idl_column
vteprec_mcast_macs_local_columns_init	.\lib\vtep-idl.c	/^vteprec_mcast_macs_local_columns_init(void)$/;"	f	file:
vteprec_mcast_macs_local_delete	.\lib\vtep-idl.c	/^vteprec_mcast_macs_local_delete(const struct vteprec_mcast_macs_local *row)$/;"	f
vteprec_mcast_macs_local_first	.\lib\vtep-idl.c	/^vteprec_mcast_macs_local_first(const struct ovsdb_idl *idl)$/;"	f
vteprec_mcast_macs_local_get_MAC	.\lib\vtep-idl.c	/^vteprec_mcast_macs_local_get_MAC(const struct vteprec_mcast_macs_local *row,$/;"	f
vteprec_mcast_macs_local_get_for_uuid	.\lib\vtep-idl.c	/^vteprec_mcast_macs_local_get_for_uuid(const struct ovsdb_idl *idl, const struct uuid *uuid)$/;"	f
vteprec_mcast_macs_local_get_ipaddr	.\lib\vtep-idl.c	/^vteprec_mcast_macs_local_get_ipaddr(const struct vteprec_mcast_macs_local *row,$/;"	f
vteprec_mcast_macs_local_get_locator_set	.\lib\vtep-idl.c	/^vteprec_mcast_macs_local_get_locator_set(const struct vteprec_mcast_macs_local *row,$/;"	f
vteprec_mcast_macs_local_get_logical_switch	.\lib\vtep-idl.c	/^vteprec_mcast_macs_local_get_logical_switch(const struct vteprec_mcast_macs_local *row,$/;"	f
vteprec_mcast_macs_local_init	.\lib\vtep-idl.c	/^vteprec_mcast_macs_local_init(struct vteprec_mcast_macs_local *row)$/;"	f
vteprec_mcast_macs_local_init__	.\lib\vtep-idl.c	/^vteprec_mcast_macs_local_init__(struct ovsdb_idl_row *row)$/;"	f	file:
vteprec_mcast_macs_local_insert	.\lib\vtep-idl.c	/^vteprec_mcast_macs_local_insert(struct ovsdb_idl_txn *txn)$/;"	f
vteprec_mcast_macs_local_next	.\lib\vtep-idl.c	/^vteprec_mcast_macs_local_next(const struct vteprec_mcast_macs_local *row)$/;"	f
vteprec_mcast_macs_local_parse_MAC	.\lib\vtep-idl.c	/^vteprec_mcast_macs_local_parse_MAC(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
vteprec_mcast_macs_local_parse_ipaddr	.\lib\vtep-idl.c	/^vteprec_mcast_macs_local_parse_ipaddr(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
vteprec_mcast_macs_local_parse_locator_set	.\lib\vtep-idl.c	/^vteprec_mcast_macs_local_parse_locator_set(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
vteprec_mcast_macs_local_parse_logical_switch	.\lib\vtep-idl.c	/^vteprec_mcast_macs_local_parse_logical_switch(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
vteprec_mcast_macs_local_set_MAC	.\lib\vtep-idl.c	/^vteprec_mcast_macs_local_set_MAC(const struct vteprec_mcast_macs_local *row, const char *MAC)$/;"	f
vteprec_mcast_macs_local_set_ipaddr	.\lib\vtep-idl.c	/^vteprec_mcast_macs_local_set_ipaddr(const struct vteprec_mcast_macs_local *row, const char *ipaddr)$/;"	f
vteprec_mcast_macs_local_set_locator_set	.\lib\vtep-idl.c	/^vteprec_mcast_macs_local_set_locator_set(const struct vteprec_mcast_macs_local *row, const struct vteprec_physical_locator_set *locator_set)$/;"	f
vteprec_mcast_macs_local_set_logical_switch	.\lib\vtep-idl.c	/^vteprec_mcast_macs_local_set_logical_switch(const struct vteprec_mcast_macs_local *row, const struct vteprec_logical_switch *logical_switch)$/;"	f
vteprec_mcast_macs_local_unparse_MAC	.\lib\vtep-idl.c	/^vteprec_mcast_macs_local_unparse_MAC(struct ovsdb_idl_row *row OVS_UNUSED)$/;"	f	file:
vteprec_mcast_macs_local_unparse_ipaddr	.\lib\vtep-idl.c	/^vteprec_mcast_macs_local_unparse_ipaddr(struct ovsdb_idl_row *row OVS_UNUSED)$/;"	f	file:
vteprec_mcast_macs_local_unparse_locator_set	.\lib\vtep-idl.c	/^vteprec_mcast_macs_local_unparse_locator_set(struct ovsdb_idl_row *row OVS_UNUSED)$/;"	f	file:
vteprec_mcast_macs_local_unparse_logical_switch	.\lib\vtep-idl.c	/^vteprec_mcast_macs_local_unparse_logical_switch(struct ovsdb_idl_row *row OVS_UNUSED)$/;"	f	file:
vteprec_mcast_macs_local_verify_MAC	.\lib\vtep-idl.c	/^vteprec_mcast_macs_local_verify_MAC(const struct vteprec_mcast_macs_local *row)$/;"	f
vteprec_mcast_macs_local_verify_ipaddr	.\lib\vtep-idl.c	/^vteprec_mcast_macs_local_verify_ipaddr(const struct vteprec_mcast_macs_local *row)$/;"	f
vteprec_mcast_macs_local_verify_locator_set	.\lib\vtep-idl.c	/^vteprec_mcast_macs_local_verify_locator_set(const struct vteprec_mcast_macs_local *row)$/;"	f
vteprec_mcast_macs_local_verify_logical_switch	.\lib\vtep-idl.c	/^vteprec_mcast_macs_local_verify_logical_switch(const struct vteprec_mcast_macs_local *row)$/;"	f
vteprec_mcast_macs_remote	.\lib\vtep-idl.h	/^struct vteprec_mcast_macs_remote {$/;"	s
vteprec_mcast_macs_remote_cast	.\lib\vtep-idl.c	/^vteprec_mcast_macs_remote_cast(const struct ovsdb_idl_row *row)$/;"	f	file:
vteprec_mcast_macs_remote_col_MAC	.\lib\vtep-idl.h	543;"	d
vteprec_mcast_macs_remote_col_ipaddr	.\lib\vtep-idl.h	542;"	d
vteprec_mcast_macs_remote_col_locator_set	.\lib\vtep-idl.h	544;"	d
vteprec_mcast_macs_remote_col_logical_switch	.\lib\vtep-idl.h	545;"	d
vteprec_mcast_macs_remote_columns	.\lib\vtep-idl.c	/^struct ovsdb_idl_column vteprec_mcast_macs_remote_columns[VTEPREC_MCAST_MACS_REMOTE_N_COLUMNS];$/;"	v	typeref:struct:ovsdb_idl_column
vteprec_mcast_macs_remote_columns_init	.\lib\vtep-idl.c	/^vteprec_mcast_macs_remote_columns_init(void)$/;"	f	file:
vteprec_mcast_macs_remote_delete	.\lib\vtep-idl.c	/^vteprec_mcast_macs_remote_delete(const struct vteprec_mcast_macs_remote *row)$/;"	f
vteprec_mcast_macs_remote_first	.\lib\vtep-idl.c	/^vteprec_mcast_macs_remote_first(const struct ovsdb_idl *idl)$/;"	f
vteprec_mcast_macs_remote_get_MAC	.\lib\vtep-idl.c	/^vteprec_mcast_macs_remote_get_MAC(const struct vteprec_mcast_macs_remote *row,$/;"	f
vteprec_mcast_macs_remote_get_for_uuid	.\lib\vtep-idl.c	/^vteprec_mcast_macs_remote_get_for_uuid(const struct ovsdb_idl *idl, const struct uuid *uuid)$/;"	f
vteprec_mcast_macs_remote_get_ipaddr	.\lib\vtep-idl.c	/^vteprec_mcast_macs_remote_get_ipaddr(const struct vteprec_mcast_macs_remote *row,$/;"	f
vteprec_mcast_macs_remote_get_locator_set	.\lib\vtep-idl.c	/^vteprec_mcast_macs_remote_get_locator_set(const struct vteprec_mcast_macs_remote *row,$/;"	f
vteprec_mcast_macs_remote_get_logical_switch	.\lib\vtep-idl.c	/^vteprec_mcast_macs_remote_get_logical_switch(const struct vteprec_mcast_macs_remote *row,$/;"	f
vteprec_mcast_macs_remote_init	.\lib\vtep-idl.c	/^vteprec_mcast_macs_remote_init(struct vteprec_mcast_macs_remote *row)$/;"	f
vteprec_mcast_macs_remote_init__	.\lib\vtep-idl.c	/^vteprec_mcast_macs_remote_init__(struct ovsdb_idl_row *row)$/;"	f	file:
vteprec_mcast_macs_remote_insert	.\lib\vtep-idl.c	/^vteprec_mcast_macs_remote_insert(struct ovsdb_idl_txn *txn)$/;"	f
vteprec_mcast_macs_remote_next	.\lib\vtep-idl.c	/^vteprec_mcast_macs_remote_next(const struct vteprec_mcast_macs_remote *row)$/;"	f
vteprec_mcast_macs_remote_parse_MAC	.\lib\vtep-idl.c	/^vteprec_mcast_macs_remote_parse_MAC(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
vteprec_mcast_macs_remote_parse_ipaddr	.\lib\vtep-idl.c	/^vteprec_mcast_macs_remote_parse_ipaddr(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
vteprec_mcast_macs_remote_parse_locator_set	.\lib\vtep-idl.c	/^vteprec_mcast_macs_remote_parse_locator_set(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
vteprec_mcast_macs_remote_parse_logical_switch	.\lib\vtep-idl.c	/^vteprec_mcast_macs_remote_parse_logical_switch(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
vteprec_mcast_macs_remote_set_MAC	.\lib\vtep-idl.c	/^vteprec_mcast_macs_remote_set_MAC(const struct vteprec_mcast_macs_remote *row, const char *MAC)$/;"	f
vteprec_mcast_macs_remote_set_ipaddr	.\lib\vtep-idl.c	/^vteprec_mcast_macs_remote_set_ipaddr(const struct vteprec_mcast_macs_remote *row, const char *ipaddr)$/;"	f
vteprec_mcast_macs_remote_set_locator_set	.\lib\vtep-idl.c	/^vteprec_mcast_macs_remote_set_locator_set(const struct vteprec_mcast_macs_remote *row, const struct vteprec_physical_locator_set *locator_set)$/;"	f
vteprec_mcast_macs_remote_set_logical_switch	.\lib\vtep-idl.c	/^vteprec_mcast_macs_remote_set_logical_switch(const struct vteprec_mcast_macs_remote *row, const struct vteprec_logical_switch *logical_switch)$/;"	f
vteprec_mcast_macs_remote_unparse_MAC	.\lib\vtep-idl.c	/^vteprec_mcast_macs_remote_unparse_MAC(struct ovsdb_idl_row *row OVS_UNUSED)$/;"	f	file:
vteprec_mcast_macs_remote_unparse_ipaddr	.\lib\vtep-idl.c	/^vteprec_mcast_macs_remote_unparse_ipaddr(struct ovsdb_idl_row *row OVS_UNUSED)$/;"	f	file:
vteprec_mcast_macs_remote_unparse_locator_set	.\lib\vtep-idl.c	/^vteprec_mcast_macs_remote_unparse_locator_set(struct ovsdb_idl_row *row OVS_UNUSED)$/;"	f	file:
vteprec_mcast_macs_remote_unparse_logical_switch	.\lib\vtep-idl.c	/^vteprec_mcast_macs_remote_unparse_logical_switch(struct ovsdb_idl_row *row OVS_UNUSED)$/;"	f	file:
vteprec_mcast_macs_remote_verify_MAC	.\lib\vtep-idl.c	/^vteprec_mcast_macs_remote_verify_MAC(const struct vteprec_mcast_macs_remote *row)$/;"	f
vteprec_mcast_macs_remote_verify_ipaddr	.\lib\vtep-idl.c	/^vteprec_mcast_macs_remote_verify_ipaddr(const struct vteprec_mcast_macs_remote *row)$/;"	f
vteprec_mcast_macs_remote_verify_locator_set	.\lib\vtep-idl.c	/^vteprec_mcast_macs_remote_verify_locator_set(const struct vteprec_mcast_macs_remote *row)$/;"	f
vteprec_mcast_macs_remote_verify_logical_switch	.\lib\vtep-idl.c	/^vteprec_mcast_macs_remote_verify_logical_switch(const struct vteprec_mcast_macs_remote *row)$/;"	f
vteprec_physical_locator	.\lib\vtep-idl.h	/^struct vteprec_physical_locator {$/;"	s
vteprec_physical_locator_cast	.\lib\vtep-idl.c	/^vteprec_physical_locator_cast(const struct ovsdb_idl_row *row)$/;"	f	file:
vteprec_physical_locator_col_dst_ip	.\lib\vtep-idl.h	601;"	d
vteprec_physical_locator_col_encapsulation_type	.\lib\vtep-idl.h	602;"	d
vteprec_physical_locator_columns	.\lib\vtep-idl.c	/^struct ovsdb_idl_column vteprec_physical_locator_columns[VTEPREC_PHYSICAL_LOCATOR_N_COLUMNS];$/;"	v	typeref:struct:ovsdb_idl_column
vteprec_physical_locator_columns_init	.\lib\vtep-idl.c	/^vteprec_physical_locator_columns_init(void)$/;"	f	file:
vteprec_physical_locator_delete	.\lib\vtep-idl.c	/^vteprec_physical_locator_delete(const struct vteprec_physical_locator *row)$/;"	f
vteprec_physical_locator_first	.\lib\vtep-idl.c	/^vteprec_physical_locator_first(const struct ovsdb_idl *idl)$/;"	f
vteprec_physical_locator_get_dst_ip	.\lib\vtep-idl.c	/^vteprec_physical_locator_get_dst_ip(const struct vteprec_physical_locator *row,$/;"	f
vteprec_physical_locator_get_encapsulation_type	.\lib\vtep-idl.c	/^vteprec_physical_locator_get_encapsulation_type(const struct vteprec_physical_locator *row,$/;"	f
vteprec_physical_locator_get_for_uuid	.\lib\vtep-idl.c	/^vteprec_physical_locator_get_for_uuid(const struct ovsdb_idl *idl, const struct uuid *uuid)$/;"	f
vteprec_physical_locator_init	.\lib\vtep-idl.c	/^vteprec_physical_locator_init(struct vteprec_physical_locator *row)$/;"	f
vteprec_physical_locator_init__	.\lib\vtep-idl.c	/^vteprec_physical_locator_init__(struct ovsdb_idl_row *row)$/;"	f	file:
vteprec_physical_locator_insert	.\lib\vtep-idl.c	/^vteprec_physical_locator_insert(struct ovsdb_idl_txn *txn)$/;"	f
vteprec_physical_locator_next	.\lib\vtep-idl.c	/^vteprec_physical_locator_next(const struct vteprec_physical_locator *row)$/;"	f
vteprec_physical_locator_parse_dst_ip	.\lib\vtep-idl.c	/^vteprec_physical_locator_parse_dst_ip(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
vteprec_physical_locator_parse_encapsulation_type	.\lib\vtep-idl.c	/^vteprec_physical_locator_parse_encapsulation_type(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
vteprec_physical_locator_set	.\lib\vtep-idl.h	/^struct vteprec_physical_locator_set {$/;"	s
vteprec_physical_locator_set_cast	.\lib\vtep-idl.c	/^vteprec_physical_locator_set_cast(const struct ovsdb_idl_row *row)$/;"	f	file:
vteprec_physical_locator_set_col_locators	.\lib\vtep-idl.h	649;"	d
vteprec_physical_locator_set_columns	.\lib\vtep-idl.c	/^struct ovsdb_idl_column vteprec_physical_locator_set_columns[VTEPREC_PHYSICAL_LOCATOR_SET_N_COLUMNS];$/;"	v	typeref:struct:ovsdb_idl_column
vteprec_physical_locator_set_columns_init	.\lib\vtep-idl.c	/^vteprec_physical_locator_set_columns_init(void)$/;"	f	file:
vteprec_physical_locator_set_delete	.\lib\vtep-idl.c	/^vteprec_physical_locator_set_delete(const struct vteprec_physical_locator_set *row)$/;"	f
vteprec_physical_locator_set_dst_ip	.\lib\vtep-idl.c	/^vteprec_physical_locator_set_dst_ip(const struct vteprec_physical_locator *row, const char *dst_ip)$/;"	f
vteprec_physical_locator_set_encapsulation_type	.\lib\vtep-idl.c	/^vteprec_physical_locator_set_encapsulation_type(const struct vteprec_physical_locator *row, const char *encapsulation_type)$/;"	f
vteprec_physical_locator_set_first	.\lib\vtep-idl.c	/^vteprec_physical_locator_set_first(const struct ovsdb_idl *idl)$/;"	f
vteprec_physical_locator_set_get_for_uuid	.\lib\vtep-idl.c	/^vteprec_physical_locator_set_get_for_uuid(const struct ovsdb_idl *idl, const struct uuid *uuid)$/;"	f
vteprec_physical_locator_set_get_locators	.\lib\vtep-idl.c	/^vteprec_physical_locator_set_get_locators(const struct vteprec_physical_locator_set *row,$/;"	f
vteprec_physical_locator_set_init	.\lib\vtep-idl.c	/^vteprec_physical_locator_set_init(struct vteprec_physical_locator_set *row)$/;"	f
vteprec_physical_locator_set_init__	.\lib\vtep-idl.c	/^vteprec_physical_locator_set_init__(struct ovsdb_idl_row *row)$/;"	f	file:
vteprec_physical_locator_set_insert	.\lib\vtep-idl.c	/^vteprec_physical_locator_set_insert(struct ovsdb_idl_txn *txn)$/;"	f
vteprec_physical_locator_set_next	.\lib\vtep-idl.c	/^vteprec_physical_locator_set_next(const struct vteprec_physical_locator_set *row)$/;"	f
vteprec_physical_locator_set_parse_locators	.\lib\vtep-idl.c	/^vteprec_physical_locator_set_parse_locators(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
vteprec_physical_locator_set_set_locators	.\lib\vtep-idl.c	/^vteprec_physical_locator_set_set_locators(const struct vteprec_physical_locator_set *row, struct vteprec_physical_locator **locators, size_t n_locators)$/;"	f
vteprec_physical_locator_set_unparse_locators	.\lib\vtep-idl.c	/^vteprec_physical_locator_set_unparse_locators(struct ovsdb_idl_row *row_)$/;"	f	file:
vteprec_physical_locator_set_verify_locators	.\lib\vtep-idl.c	/^vteprec_physical_locator_set_verify_locators(const struct vteprec_physical_locator_set *row)$/;"	f
vteprec_physical_locator_unparse_dst_ip	.\lib\vtep-idl.c	/^vteprec_physical_locator_unparse_dst_ip(struct ovsdb_idl_row *row OVS_UNUSED)$/;"	f	file:
vteprec_physical_locator_unparse_encapsulation_type	.\lib\vtep-idl.c	/^vteprec_physical_locator_unparse_encapsulation_type(struct ovsdb_idl_row *row OVS_UNUSED)$/;"	f	file:
vteprec_physical_locator_verify_dst_ip	.\lib\vtep-idl.c	/^vteprec_physical_locator_verify_dst_ip(const struct vteprec_physical_locator *row)$/;"	f
vteprec_physical_locator_verify_encapsulation_type	.\lib\vtep-idl.c	/^vteprec_physical_locator_verify_encapsulation_type(const struct vteprec_physical_locator *row)$/;"	f
vteprec_physical_port	.\lib\vtep-idl.h	/^struct vteprec_physical_port {$/;"	s
vteprec_physical_port_cast	.\lib\vtep-idl.c	/^vteprec_physical_port_cast(const struct ovsdb_idl_row *row)$/;"	f	file:
vteprec_physical_port_col_description	.\lib\vtep-idl.h	717;"	d
vteprec_physical_port_col_name	.\lib\vtep-idl.h	713;"	d
vteprec_physical_port_col_port_fault_status	.\lib\vtep-idl.h	714;"	d
vteprec_physical_port_col_vlan_bindings	.\lib\vtep-idl.h	715;"	d
vteprec_physical_port_col_vlan_stats	.\lib\vtep-idl.h	716;"	d
vteprec_physical_port_columns	.\lib\vtep-idl.c	/^struct ovsdb_idl_column vteprec_physical_port_columns[VTEPREC_PHYSICAL_PORT_N_COLUMNS];$/;"	v	typeref:struct:ovsdb_idl_column
vteprec_physical_port_columns_init	.\lib\vtep-idl.c	/^vteprec_physical_port_columns_init(void)$/;"	f	file:
vteprec_physical_port_delete	.\lib\vtep-idl.c	/^vteprec_physical_port_delete(const struct vteprec_physical_port *row)$/;"	f
vteprec_physical_port_first	.\lib\vtep-idl.c	/^vteprec_physical_port_first(const struct ovsdb_idl *idl)$/;"	f
vteprec_physical_port_get_description	.\lib\vtep-idl.c	/^vteprec_physical_port_get_description(const struct vteprec_physical_port *row,$/;"	f
vteprec_physical_port_get_for_uuid	.\lib\vtep-idl.c	/^vteprec_physical_port_get_for_uuid(const struct ovsdb_idl *idl, const struct uuid *uuid)$/;"	f
vteprec_physical_port_get_name	.\lib\vtep-idl.c	/^vteprec_physical_port_get_name(const struct vteprec_physical_port *row,$/;"	f
vteprec_physical_port_get_port_fault_status	.\lib\vtep-idl.c	/^vteprec_physical_port_get_port_fault_status(const struct vteprec_physical_port *row,$/;"	f
vteprec_physical_port_get_vlan_bindings	.\lib\vtep-idl.c	/^vteprec_physical_port_get_vlan_bindings(const struct vteprec_physical_port *row,$/;"	f
vteprec_physical_port_get_vlan_stats	.\lib\vtep-idl.c	/^vteprec_physical_port_get_vlan_stats(const struct vteprec_physical_port *row,$/;"	f
vteprec_physical_port_init	.\lib\vtep-idl.c	/^vteprec_physical_port_init(struct vteprec_physical_port *row)$/;"	f
vteprec_physical_port_init__	.\lib\vtep-idl.c	/^vteprec_physical_port_init__(struct ovsdb_idl_row *row)$/;"	f	file:
vteprec_physical_port_insert	.\lib\vtep-idl.c	/^vteprec_physical_port_insert(struct ovsdb_idl_txn *txn)$/;"	f
vteprec_physical_port_next	.\lib\vtep-idl.c	/^vteprec_physical_port_next(const struct vteprec_physical_port *row)$/;"	f
vteprec_physical_port_parse_description	.\lib\vtep-idl.c	/^vteprec_physical_port_parse_description(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
vteprec_physical_port_parse_name	.\lib\vtep-idl.c	/^vteprec_physical_port_parse_name(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
vteprec_physical_port_parse_port_fault_status	.\lib\vtep-idl.c	/^vteprec_physical_port_parse_port_fault_status(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
vteprec_physical_port_parse_vlan_bindings	.\lib\vtep-idl.c	/^vteprec_physical_port_parse_vlan_bindings(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
vteprec_physical_port_parse_vlan_stats	.\lib\vtep-idl.c	/^vteprec_physical_port_parse_vlan_stats(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
vteprec_physical_port_set_description	.\lib\vtep-idl.c	/^vteprec_physical_port_set_description(const struct vteprec_physical_port *row, const char *description)$/;"	f
vteprec_physical_port_set_name	.\lib\vtep-idl.c	/^vteprec_physical_port_set_name(const struct vteprec_physical_port *row, const char *name)$/;"	f
vteprec_physical_port_set_port_fault_status	.\lib\vtep-idl.c	/^vteprec_physical_port_set_port_fault_status(const struct vteprec_physical_port *row, char **port_fault_status, size_t n_port_fault_status)$/;"	f
vteprec_physical_port_set_vlan_bindings	.\lib\vtep-idl.c	/^vteprec_physical_port_set_vlan_bindings(const struct vteprec_physical_port *row, const int64_t *key_vlan_bindings, struct vteprec_logical_switch **value_vlan_bindings, size_t n_vlan_bindings)$/;"	f
vteprec_physical_port_set_vlan_stats	.\lib\vtep-idl.c	/^vteprec_physical_port_set_vlan_stats(const struct vteprec_physical_port *row, const int64_t *key_vlan_stats, struct vteprec_logical_binding_stats **value_vlan_stats, size_t n_vlan_stats)$/;"	f
vteprec_physical_port_unparse_description	.\lib\vtep-idl.c	/^vteprec_physical_port_unparse_description(struct ovsdb_idl_row *row OVS_UNUSED)$/;"	f	file:
vteprec_physical_port_unparse_name	.\lib\vtep-idl.c	/^vteprec_physical_port_unparse_name(struct ovsdb_idl_row *row OVS_UNUSED)$/;"	f	file:
vteprec_physical_port_unparse_port_fault_status	.\lib\vtep-idl.c	/^vteprec_physical_port_unparse_port_fault_status(struct ovsdb_idl_row *row_)$/;"	f	file:
vteprec_physical_port_unparse_vlan_bindings	.\lib\vtep-idl.c	/^vteprec_physical_port_unparse_vlan_bindings(struct ovsdb_idl_row *row_)$/;"	f	file:
vteprec_physical_port_unparse_vlan_stats	.\lib\vtep-idl.c	/^vteprec_physical_port_unparse_vlan_stats(struct ovsdb_idl_row *row_)$/;"	f	file:
vteprec_physical_port_verify_description	.\lib\vtep-idl.c	/^vteprec_physical_port_verify_description(const struct vteprec_physical_port *row)$/;"	f
vteprec_physical_port_verify_name	.\lib\vtep-idl.c	/^vteprec_physical_port_verify_name(const struct vteprec_physical_port *row)$/;"	f
vteprec_physical_port_verify_port_fault_status	.\lib\vtep-idl.c	/^vteprec_physical_port_verify_port_fault_status(const struct vteprec_physical_port *row)$/;"	f
vteprec_physical_port_verify_vlan_bindings	.\lib\vtep-idl.c	/^vteprec_physical_port_verify_vlan_bindings(const struct vteprec_physical_port *row)$/;"	f
vteprec_physical_port_verify_vlan_stats	.\lib\vtep-idl.c	/^vteprec_physical_port_verify_vlan_stats(const struct vteprec_physical_port *row)$/;"	f
vteprec_physical_switch	.\lib\vtep-idl.h	/^struct vteprec_physical_switch {$/;"	s
vteprec_physical_switch_cast	.\lib\vtep-idl.c	/^vteprec_physical_switch_cast(const struct ovsdb_idl_row *row)$/;"	f	file:
vteprec_physical_switch_col_description	.\lib\vtep-idl.h	802;"	d
vteprec_physical_switch_col_management_ips	.\lib\vtep-idl.h	801;"	d
vteprec_physical_switch_col_name	.\lib\vtep-idl.h	807;"	d
vteprec_physical_switch_col_ports	.\lib\vtep-idl.h	805;"	d
vteprec_physical_switch_col_switch_fault_status	.\lib\vtep-idl.h	804;"	d
vteprec_physical_switch_col_tunnel_ips	.\lib\vtep-idl.h	803;"	d
vteprec_physical_switch_col_tunnels	.\lib\vtep-idl.h	806;"	d
vteprec_physical_switch_columns	.\lib\vtep-idl.c	/^struct ovsdb_idl_column vteprec_physical_switch_columns[VTEPREC_PHYSICAL_SWITCH_N_COLUMNS];$/;"	v	typeref:struct:ovsdb_idl_column
vteprec_physical_switch_columns_init	.\lib\vtep-idl.c	/^vteprec_physical_switch_columns_init(void)$/;"	f	file:
vteprec_physical_switch_delete	.\lib\vtep-idl.c	/^vteprec_physical_switch_delete(const struct vteprec_physical_switch *row)$/;"	f
vteprec_physical_switch_first	.\lib\vtep-idl.c	/^vteprec_physical_switch_first(const struct ovsdb_idl *idl)$/;"	f
vteprec_physical_switch_get_description	.\lib\vtep-idl.c	/^vteprec_physical_switch_get_description(const struct vteprec_physical_switch *row,$/;"	f
vteprec_physical_switch_get_for_uuid	.\lib\vtep-idl.c	/^vteprec_physical_switch_get_for_uuid(const struct ovsdb_idl *idl, const struct uuid *uuid)$/;"	f
vteprec_physical_switch_get_management_ips	.\lib\vtep-idl.c	/^vteprec_physical_switch_get_management_ips(const struct vteprec_physical_switch *row,$/;"	f
vteprec_physical_switch_get_name	.\lib\vtep-idl.c	/^vteprec_physical_switch_get_name(const struct vteprec_physical_switch *row,$/;"	f
vteprec_physical_switch_get_ports	.\lib\vtep-idl.c	/^vteprec_physical_switch_get_ports(const struct vteprec_physical_switch *row,$/;"	f
vteprec_physical_switch_get_switch_fault_status	.\lib\vtep-idl.c	/^vteprec_physical_switch_get_switch_fault_status(const struct vteprec_physical_switch *row,$/;"	f
vteprec_physical_switch_get_tunnel_ips	.\lib\vtep-idl.c	/^vteprec_physical_switch_get_tunnel_ips(const struct vteprec_physical_switch *row,$/;"	f
vteprec_physical_switch_get_tunnels	.\lib\vtep-idl.c	/^vteprec_physical_switch_get_tunnels(const struct vteprec_physical_switch *row,$/;"	f
vteprec_physical_switch_init	.\lib\vtep-idl.c	/^vteprec_physical_switch_init(struct vteprec_physical_switch *row)$/;"	f
vteprec_physical_switch_init__	.\lib\vtep-idl.c	/^vteprec_physical_switch_init__(struct ovsdb_idl_row *row)$/;"	f	file:
vteprec_physical_switch_insert	.\lib\vtep-idl.c	/^vteprec_physical_switch_insert(struct ovsdb_idl_txn *txn)$/;"	f
vteprec_physical_switch_next	.\lib\vtep-idl.c	/^vteprec_physical_switch_next(const struct vteprec_physical_switch *row)$/;"	f
vteprec_physical_switch_parse_description	.\lib\vtep-idl.c	/^vteprec_physical_switch_parse_description(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
vteprec_physical_switch_parse_management_ips	.\lib\vtep-idl.c	/^vteprec_physical_switch_parse_management_ips(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
vteprec_physical_switch_parse_name	.\lib\vtep-idl.c	/^vteprec_physical_switch_parse_name(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
vteprec_physical_switch_parse_ports	.\lib\vtep-idl.c	/^vteprec_physical_switch_parse_ports(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
vteprec_physical_switch_parse_switch_fault_status	.\lib\vtep-idl.c	/^vteprec_physical_switch_parse_switch_fault_status(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
vteprec_physical_switch_parse_tunnel_ips	.\lib\vtep-idl.c	/^vteprec_physical_switch_parse_tunnel_ips(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
vteprec_physical_switch_parse_tunnels	.\lib\vtep-idl.c	/^vteprec_physical_switch_parse_tunnels(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
vteprec_physical_switch_set_description	.\lib\vtep-idl.c	/^vteprec_physical_switch_set_description(const struct vteprec_physical_switch *row, const char *description)$/;"	f
vteprec_physical_switch_set_management_ips	.\lib\vtep-idl.c	/^vteprec_physical_switch_set_management_ips(const struct vteprec_physical_switch *row, char **management_ips, size_t n_management_ips)$/;"	f
vteprec_physical_switch_set_name	.\lib\vtep-idl.c	/^vteprec_physical_switch_set_name(const struct vteprec_physical_switch *row, const char *name)$/;"	f
vteprec_physical_switch_set_ports	.\lib\vtep-idl.c	/^vteprec_physical_switch_set_ports(const struct vteprec_physical_switch *row, struct vteprec_physical_port **ports, size_t n_ports)$/;"	f
vteprec_physical_switch_set_switch_fault_status	.\lib\vtep-idl.c	/^vteprec_physical_switch_set_switch_fault_status(const struct vteprec_physical_switch *row, char **switch_fault_status, size_t n_switch_fault_status)$/;"	f
vteprec_physical_switch_set_tunnel_ips	.\lib\vtep-idl.c	/^vteprec_physical_switch_set_tunnel_ips(const struct vteprec_physical_switch *row, char **tunnel_ips, size_t n_tunnel_ips)$/;"	f
vteprec_physical_switch_set_tunnels	.\lib\vtep-idl.c	/^vteprec_physical_switch_set_tunnels(const struct vteprec_physical_switch *row, struct vteprec_tunnel **tunnels, size_t n_tunnels)$/;"	f
vteprec_physical_switch_unparse_description	.\lib\vtep-idl.c	/^vteprec_physical_switch_unparse_description(struct ovsdb_idl_row *row OVS_UNUSED)$/;"	f	file:
vteprec_physical_switch_unparse_management_ips	.\lib\vtep-idl.c	/^vteprec_physical_switch_unparse_management_ips(struct ovsdb_idl_row *row_)$/;"	f	file:
vteprec_physical_switch_unparse_name	.\lib\vtep-idl.c	/^vteprec_physical_switch_unparse_name(struct ovsdb_idl_row *row OVS_UNUSED)$/;"	f	file:
vteprec_physical_switch_unparse_ports	.\lib\vtep-idl.c	/^vteprec_physical_switch_unparse_ports(struct ovsdb_idl_row *row_)$/;"	f	file:
vteprec_physical_switch_unparse_switch_fault_status	.\lib\vtep-idl.c	/^vteprec_physical_switch_unparse_switch_fault_status(struct ovsdb_idl_row *row_)$/;"	f	file:
vteprec_physical_switch_unparse_tunnel_ips	.\lib\vtep-idl.c	/^vteprec_physical_switch_unparse_tunnel_ips(struct ovsdb_idl_row *row_)$/;"	f	file:
vteprec_physical_switch_unparse_tunnels	.\lib\vtep-idl.c	/^vteprec_physical_switch_unparse_tunnels(struct ovsdb_idl_row *row_)$/;"	f	file:
vteprec_physical_switch_verify_description	.\lib\vtep-idl.c	/^vteprec_physical_switch_verify_description(const struct vteprec_physical_switch *row)$/;"	f
vteprec_physical_switch_verify_management_ips	.\lib\vtep-idl.c	/^vteprec_physical_switch_verify_management_ips(const struct vteprec_physical_switch *row)$/;"	f
vteprec_physical_switch_verify_name	.\lib\vtep-idl.c	/^vteprec_physical_switch_verify_name(const struct vteprec_physical_switch *row)$/;"	f
vteprec_physical_switch_verify_ports	.\lib\vtep-idl.c	/^vteprec_physical_switch_verify_ports(const struct vteprec_physical_switch *row)$/;"	f
vteprec_physical_switch_verify_switch_fault_status	.\lib\vtep-idl.c	/^vteprec_physical_switch_verify_switch_fault_status(const struct vteprec_physical_switch *row)$/;"	f
vteprec_physical_switch_verify_tunnel_ips	.\lib\vtep-idl.c	/^vteprec_physical_switch_verify_tunnel_ips(const struct vteprec_physical_switch *row)$/;"	f
vteprec_physical_switch_verify_tunnels	.\lib\vtep-idl.c	/^vteprec_physical_switch_verify_tunnels(const struct vteprec_physical_switch *row)$/;"	f
vteprec_table_arp_sources_local	.\lib\vtep-idl.h	1105;"	d
vteprec_table_arp_sources_remote	.\lib\vtep-idl.h	1104;"	d
vteprec_table_classes	.\lib\vtep-idl.c	/^struct ovsdb_idl_table_class vteprec_table_classes[VTEPREC_N_TABLES] = {$/;"	v	typeref:struct:ovsdb_idl_table_class
vteprec_table_global	.\lib\vtep-idl.h	1093;"	d
vteprec_table_logical_binding_stats	.\lib\vtep-idl.h	1107;"	d
vteprec_table_logical_router	.\lib\vtep-idl.h	1099;"	d
vteprec_table_logical_switch	.\lib\vtep-idl.h	1102;"	d
vteprec_table_manager	.\lib\vtep-idl.h	1100;"	d
vteprec_table_mcast_macs_local	.\lib\vtep-idl.h	1097;"	d
vteprec_table_mcast_macs_remote	.\lib\vtep-idl.h	1092;"	d
vteprec_table_physical_locator	.\lib\vtep-idl.h	1094;"	d
vteprec_table_physical_locator_set	.\lib\vtep-idl.h	1095;"	d
vteprec_table_physical_port	.\lib\vtep-idl.h	1106;"	d
vteprec_table_physical_switch	.\lib\vtep-idl.h	1098;"	d
vteprec_table_tunnel	.\lib\vtep-idl.h	1096;"	d
vteprec_table_ucast_macs_local	.\lib\vtep-idl.h	1101;"	d
vteprec_table_ucast_macs_remote	.\lib\vtep-idl.h	1103;"	d
vteprec_tunnel	.\lib\vtep-idl.h	/^struct vteprec_tunnel {$/;"	s
vteprec_tunnel_cast	.\lib\vtep-idl.c	/^vteprec_tunnel_cast(const struct ovsdb_idl_row *row)$/;"	f	file:
vteprec_tunnel_col_bfd_config_local	.\lib\vtep-idl.h	889;"	d
vteprec_tunnel_col_bfd_config_remote	.\lib\vtep-idl.h	893;"	d
vteprec_tunnel_col_bfd_params	.\lib\vtep-idl.h	890;"	d
vteprec_tunnel_col_bfd_status	.\lib\vtep-idl.h	891;"	d
vteprec_tunnel_col_local	.\lib\vtep-idl.h	892;"	d
vteprec_tunnel_col_remote	.\lib\vtep-idl.h	888;"	d
vteprec_tunnel_columns	.\lib\vtep-idl.c	/^struct ovsdb_idl_column vteprec_tunnel_columns[VTEPREC_TUNNEL_N_COLUMNS];$/;"	v	typeref:struct:ovsdb_idl_column
vteprec_tunnel_columns_init	.\lib\vtep-idl.c	/^vteprec_tunnel_columns_init(void)$/;"	f	file:
vteprec_tunnel_delete	.\lib\vtep-idl.c	/^vteprec_tunnel_delete(const struct vteprec_tunnel *row)$/;"	f
vteprec_tunnel_first	.\lib\vtep-idl.c	/^vteprec_tunnel_first(const struct ovsdb_idl *idl)$/;"	f
vteprec_tunnel_get_bfd_config_local	.\lib\vtep-idl.c	/^vteprec_tunnel_get_bfd_config_local(const struct vteprec_tunnel *row,$/;"	f
vteprec_tunnel_get_bfd_config_remote	.\lib\vtep-idl.c	/^vteprec_tunnel_get_bfd_config_remote(const struct vteprec_tunnel *row,$/;"	f
vteprec_tunnel_get_bfd_params	.\lib\vtep-idl.c	/^vteprec_tunnel_get_bfd_params(const struct vteprec_tunnel *row,$/;"	f
vteprec_tunnel_get_bfd_status	.\lib\vtep-idl.c	/^vteprec_tunnel_get_bfd_status(const struct vteprec_tunnel *row,$/;"	f
vteprec_tunnel_get_for_uuid	.\lib\vtep-idl.c	/^vteprec_tunnel_get_for_uuid(const struct ovsdb_idl *idl, const struct uuid *uuid)$/;"	f
vteprec_tunnel_get_local	.\lib\vtep-idl.c	/^vteprec_tunnel_get_local(const struct vteprec_tunnel *row,$/;"	f
vteprec_tunnel_get_remote	.\lib\vtep-idl.c	/^vteprec_tunnel_get_remote(const struct vteprec_tunnel *row,$/;"	f
vteprec_tunnel_init	.\lib\vtep-idl.c	/^vteprec_tunnel_init(struct vteprec_tunnel *row)$/;"	f
vteprec_tunnel_init__	.\lib\vtep-idl.c	/^vteprec_tunnel_init__(struct ovsdb_idl_row *row)$/;"	f	file:
vteprec_tunnel_insert	.\lib\vtep-idl.c	/^vteprec_tunnel_insert(struct ovsdb_idl_txn *txn)$/;"	f
vteprec_tunnel_next	.\lib\vtep-idl.c	/^vteprec_tunnel_next(const struct vteprec_tunnel *row)$/;"	f
vteprec_tunnel_parse_bfd_config_local	.\lib\vtep-idl.c	/^vteprec_tunnel_parse_bfd_config_local(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
vteprec_tunnel_parse_bfd_config_remote	.\lib\vtep-idl.c	/^vteprec_tunnel_parse_bfd_config_remote(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
vteprec_tunnel_parse_bfd_params	.\lib\vtep-idl.c	/^vteprec_tunnel_parse_bfd_params(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
vteprec_tunnel_parse_bfd_status	.\lib\vtep-idl.c	/^vteprec_tunnel_parse_bfd_status(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
vteprec_tunnel_parse_local	.\lib\vtep-idl.c	/^vteprec_tunnel_parse_local(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
vteprec_tunnel_parse_remote	.\lib\vtep-idl.c	/^vteprec_tunnel_parse_remote(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
vteprec_tunnel_set_bfd_config_local	.\lib\vtep-idl.c	/^vteprec_tunnel_set_bfd_config_local(const struct vteprec_tunnel *row, const struct smap *smap)$/;"	f
vteprec_tunnel_set_bfd_config_remote	.\lib\vtep-idl.c	/^vteprec_tunnel_set_bfd_config_remote(const struct vteprec_tunnel *row, const struct smap *smap)$/;"	f
vteprec_tunnel_set_bfd_params	.\lib\vtep-idl.c	/^vteprec_tunnel_set_bfd_params(const struct vteprec_tunnel *row, const struct smap *smap)$/;"	f
vteprec_tunnel_set_bfd_status	.\lib\vtep-idl.c	/^vteprec_tunnel_set_bfd_status(const struct vteprec_tunnel *row, const struct smap *smap)$/;"	f
vteprec_tunnel_set_local	.\lib\vtep-idl.c	/^vteprec_tunnel_set_local(const struct vteprec_tunnel *row, const struct vteprec_physical_locator *local)$/;"	f
vteprec_tunnel_set_remote	.\lib\vtep-idl.c	/^vteprec_tunnel_set_remote(const struct vteprec_tunnel *row, const struct vteprec_physical_locator *remote)$/;"	f
vteprec_tunnel_unparse_bfd_config_local	.\lib\vtep-idl.c	/^vteprec_tunnel_unparse_bfd_config_local(struct ovsdb_idl_row *row_)$/;"	f	file:
vteprec_tunnel_unparse_bfd_config_remote	.\lib\vtep-idl.c	/^vteprec_tunnel_unparse_bfd_config_remote(struct ovsdb_idl_row *row_)$/;"	f	file:
vteprec_tunnel_unparse_bfd_params	.\lib\vtep-idl.c	/^vteprec_tunnel_unparse_bfd_params(struct ovsdb_idl_row *row_)$/;"	f	file:
vteprec_tunnel_unparse_bfd_status	.\lib\vtep-idl.c	/^vteprec_tunnel_unparse_bfd_status(struct ovsdb_idl_row *row_)$/;"	f	file:
vteprec_tunnel_unparse_local	.\lib\vtep-idl.c	/^vteprec_tunnel_unparse_local(struct ovsdb_idl_row *row OVS_UNUSED)$/;"	f	file:
vteprec_tunnel_unparse_remote	.\lib\vtep-idl.c	/^vteprec_tunnel_unparse_remote(struct ovsdb_idl_row *row OVS_UNUSED)$/;"	f	file:
vteprec_tunnel_verify_bfd_config_local	.\lib\vtep-idl.c	/^vteprec_tunnel_verify_bfd_config_local(const struct vteprec_tunnel *row)$/;"	f
vteprec_tunnel_verify_bfd_config_remote	.\lib\vtep-idl.c	/^vteprec_tunnel_verify_bfd_config_remote(const struct vteprec_tunnel *row)$/;"	f
vteprec_tunnel_verify_bfd_params	.\lib\vtep-idl.c	/^vteprec_tunnel_verify_bfd_params(const struct vteprec_tunnel *row)$/;"	f
vteprec_tunnel_verify_bfd_status	.\lib\vtep-idl.c	/^vteprec_tunnel_verify_bfd_status(const struct vteprec_tunnel *row)$/;"	f
vteprec_tunnel_verify_local	.\lib\vtep-idl.c	/^vteprec_tunnel_verify_local(const struct vteprec_tunnel *row)$/;"	f
vteprec_tunnel_verify_remote	.\lib\vtep-idl.c	/^vteprec_tunnel_verify_remote(const struct vteprec_tunnel *row)$/;"	f
vteprec_ucast_macs_local	.\lib\vtep-idl.h	/^struct vteprec_ucast_macs_local {$/;"	s
vteprec_ucast_macs_local_cast	.\lib\vtep-idl.c	/^vteprec_ucast_macs_local_cast(const struct ovsdb_idl_row *row)$/;"	f	file:
vteprec_ucast_macs_local_col_MAC	.\lib\vtep-idl.h	964;"	d
vteprec_ucast_macs_local_col_ipaddr	.\lib\vtep-idl.h	965;"	d
vteprec_ucast_macs_local_col_locator	.\lib\vtep-idl.h	963;"	d
vteprec_ucast_macs_local_col_logical_switch	.\lib\vtep-idl.h	966;"	d
vteprec_ucast_macs_local_columns	.\lib\vtep-idl.c	/^struct ovsdb_idl_column vteprec_ucast_macs_local_columns[VTEPREC_UCAST_MACS_LOCAL_N_COLUMNS];$/;"	v	typeref:struct:ovsdb_idl_column
vteprec_ucast_macs_local_columns_init	.\lib\vtep-idl.c	/^vteprec_ucast_macs_local_columns_init(void)$/;"	f	file:
vteprec_ucast_macs_local_delete	.\lib\vtep-idl.c	/^vteprec_ucast_macs_local_delete(const struct vteprec_ucast_macs_local *row)$/;"	f
vteprec_ucast_macs_local_first	.\lib\vtep-idl.c	/^vteprec_ucast_macs_local_first(const struct ovsdb_idl *idl)$/;"	f
vteprec_ucast_macs_local_get_MAC	.\lib\vtep-idl.c	/^vteprec_ucast_macs_local_get_MAC(const struct vteprec_ucast_macs_local *row,$/;"	f
vteprec_ucast_macs_local_get_for_uuid	.\lib\vtep-idl.c	/^vteprec_ucast_macs_local_get_for_uuid(const struct ovsdb_idl *idl, const struct uuid *uuid)$/;"	f
vteprec_ucast_macs_local_get_ipaddr	.\lib\vtep-idl.c	/^vteprec_ucast_macs_local_get_ipaddr(const struct vteprec_ucast_macs_local *row,$/;"	f
vteprec_ucast_macs_local_get_locator	.\lib\vtep-idl.c	/^vteprec_ucast_macs_local_get_locator(const struct vteprec_ucast_macs_local *row,$/;"	f
vteprec_ucast_macs_local_get_logical_switch	.\lib\vtep-idl.c	/^vteprec_ucast_macs_local_get_logical_switch(const struct vteprec_ucast_macs_local *row,$/;"	f
vteprec_ucast_macs_local_init	.\lib\vtep-idl.c	/^vteprec_ucast_macs_local_init(struct vteprec_ucast_macs_local *row)$/;"	f
vteprec_ucast_macs_local_init__	.\lib\vtep-idl.c	/^vteprec_ucast_macs_local_init__(struct ovsdb_idl_row *row)$/;"	f	file:
vteprec_ucast_macs_local_insert	.\lib\vtep-idl.c	/^vteprec_ucast_macs_local_insert(struct ovsdb_idl_txn *txn)$/;"	f
vteprec_ucast_macs_local_next	.\lib\vtep-idl.c	/^vteprec_ucast_macs_local_next(const struct vteprec_ucast_macs_local *row)$/;"	f
vteprec_ucast_macs_local_parse_MAC	.\lib\vtep-idl.c	/^vteprec_ucast_macs_local_parse_MAC(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
vteprec_ucast_macs_local_parse_ipaddr	.\lib\vtep-idl.c	/^vteprec_ucast_macs_local_parse_ipaddr(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
vteprec_ucast_macs_local_parse_locator	.\lib\vtep-idl.c	/^vteprec_ucast_macs_local_parse_locator(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
vteprec_ucast_macs_local_parse_logical_switch	.\lib\vtep-idl.c	/^vteprec_ucast_macs_local_parse_logical_switch(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
vteprec_ucast_macs_local_set_MAC	.\lib\vtep-idl.c	/^vteprec_ucast_macs_local_set_MAC(const struct vteprec_ucast_macs_local *row, const char *MAC)$/;"	f
vteprec_ucast_macs_local_set_ipaddr	.\lib\vtep-idl.c	/^vteprec_ucast_macs_local_set_ipaddr(const struct vteprec_ucast_macs_local *row, const char *ipaddr)$/;"	f
vteprec_ucast_macs_local_set_locator	.\lib\vtep-idl.c	/^vteprec_ucast_macs_local_set_locator(const struct vteprec_ucast_macs_local *row, const struct vteprec_physical_locator *locator)$/;"	f
vteprec_ucast_macs_local_set_logical_switch	.\lib\vtep-idl.c	/^vteprec_ucast_macs_local_set_logical_switch(const struct vteprec_ucast_macs_local *row, const struct vteprec_logical_switch *logical_switch)$/;"	f
vteprec_ucast_macs_local_unparse_MAC	.\lib\vtep-idl.c	/^vteprec_ucast_macs_local_unparse_MAC(struct ovsdb_idl_row *row OVS_UNUSED)$/;"	f	file:
vteprec_ucast_macs_local_unparse_ipaddr	.\lib\vtep-idl.c	/^vteprec_ucast_macs_local_unparse_ipaddr(struct ovsdb_idl_row *row OVS_UNUSED)$/;"	f	file:
vteprec_ucast_macs_local_unparse_locator	.\lib\vtep-idl.c	/^vteprec_ucast_macs_local_unparse_locator(struct ovsdb_idl_row *row OVS_UNUSED)$/;"	f	file:
vteprec_ucast_macs_local_unparse_logical_switch	.\lib\vtep-idl.c	/^vteprec_ucast_macs_local_unparse_logical_switch(struct ovsdb_idl_row *row OVS_UNUSED)$/;"	f	file:
vteprec_ucast_macs_local_verify_MAC	.\lib\vtep-idl.c	/^vteprec_ucast_macs_local_verify_MAC(const struct vteprec_ucast_macs_local *row)$/;"	f
vteprec_ucast_macs_local_verify_ipaddr	.\lib\vtep-idl.c	/^vteprec_ucast_macs_local_verify_ipaddr(const struct vteprec_ucast_macs_local *row)$/;"	f
vteprec_ucast_macs_local_verify_locator	.\lib\vtep-idl.c	/^vteprec_ucast_macs_local_verify_locator(const struct vteprec_ucast_macs_local *row)$/;"	f
vteprec_ucast_macs_local_verify_logical_switch	.\lib\vtep-idl.c	/^vteprec_ucast_macs_local_verify_logical_switch(const struct vteprec_ucast_macs_local *row)$/;"	f
vteprec_ucast_macs_remote	.\lib\vtep-idl.h	/^struct vteprec_ucast_macs_remote {$/;"	s
vteprec_ucast_macs_remote_cast	.\lib\vtep-idl.c	/^vteprec_ucast_macs_remote_cast(const struct ovsdb_idl_row *row)$/;"	f	file:
vteprec_ucast_macs_remote_col_MAC	.\lib\vtep-idl.h	1031;"	d
vteprec_ucast_macs_remote_col_ipaddr	.\lib\vtep-idl.h	1032;"	d
vteprec_ucast_macs_remote_col_locator	.\lib\vtep-idl.h	1030;"	d
vteprec_ucast_macs_remote_col_logical_switch	.\lib\vtep-idl.h	1033;"	d
vteprec_ucast_macs_remote_columns	.\lib\vtep-idl.c	/^struct ovsdb_idl_column vteprec_ucast_macs_remote_columns[VTEPREC_UCAST_MACS_REMOTE_N_COLUMNS];$/;"	v	typeref:struct:ovsdb_idl_column
vteprec_ucast_macs_remote_columns_init	.\lib\vtep-idl.c	/^vteprec_ucast_macs_remote_columns_init(void)$/;"	f	file:
vteprec_ucast_macs_remote_delete	.\lib\vtep-idl.c	/^vteprec_ucast_macs_remote_delete(const struct vteprec_ucast_macs_remote *row)$/;"	f
vteprec_ucast_macs_remote_first	.\lib\vtep-idl.c	/^vteprec_ucast_macs_remote_first(const struct ovsdb_idl *idl)$/;"	f
vteprec_ucast_macs_remote_get_MAC	.\lib\vtep-idl.c	/^vteprec_ucast_macs_remote_get_MAC(const struct vteprec_ucast_macs_remote *row,$/;"	f
vteprec_ucast_macs_remote_get_for_uuid	.\lib\vtep-idl.c	/^vteprec_ucast_macs_remote_get_for_uuid(const struct ovsdb_idl *idl, const struct uuid *uuid)$/;"	f
vteprec_ucast_macs_remote_get_ipaddr	.\lib\vtep-idl.c	/^vteprec_ucast_macs_remote_get_ipaddr(const struct vteprec_ucast_macs_remote *row,$/;"	f
vteprec_ucast_macs_remote_get_locator	.\lib\vtep-idl.c	/^vteprec_ucast_macs_remote_get_locator(const struct vteprec_ucast_macs_remote *row,$/;"	f
vteprec_ucast_macs_remote_get_logical_switch	.\lib\vtep-idl.c	/^vteprec_ucast_macs_remote_get_logical_switch(const struct vteprec_ucast_macs_remote *row,$/;"	f
vteprec_ucast_macs_remote_init	.\lib\vtep-idl.c	/^vteprec_ucast_macs_remote_init(struct vteprec_ucast_macs_remote *row)$/;"	f
vteprec_ucast_macs_remote_init__	.\lib\vtep-idl.c	/^vteprec_ucast_macs_remote_init__(struct ovsdb_idl_row *row)$/;"	f	file:
vteprec_ucast_macs_remote_insert	.\lib\vtep-idl.c	/^vteprec_ucast_macs_remote_insert(struct ovsdb_idl_txn *txn)$/;"	f
vteprec_ucast_macs_remote_next	.\lib\vtep-idl.c	/^vteprec_ucast_macs_remote_next(const struct vteprec_ucast_macs_remote *row)$/;"	f
vteprec_ucast_macs_remote_parse_MAC	.\lib\vtep-idl.c	/^vteprec_ucast_macs_remote_parse_MAC(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
vteprec_ucast_macs_remote_parse_ipaddr	.\lib\vtep-idl.c	/^vteprec_ucast_macs_remote_parse_ipaddr(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
vteprec_ucast_macs_remote_parse_locator	.\lib\vtep-idl.c	/^vteprec_ucast_macs_remote_parse_locator(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
vteprec_ucast_macs_remote_parse_logical_switch	.\lib\vtep-idl.c	/^vteprec_ucast_macs_remote_parse_logical_switch(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)$/;"	f	file:
vteprec_ucast_macs_remote_set_MAC	.\lib\vtep-idl.c	/^vteprec_ucast_macs_remote_set_MAC(const struct vteprec_ucast_macs_remote *row, const char *MAC)$/;"	f
vteprec_ucast_macs_remote_set_ipaddr	.\lib\vtep-idl.c	/^vteprec_ucast_macs_remote_set_ipaddr(const struct vteprec_ucast_macs_remote *row, const char *ipaddr)$/;"	f
vteprec_ucast_macs_remote_set_locator	.\lib\vtep-idl.c	/^vteprec_ucast_macs_remote_set_locator(const struct vteprec_ucast_macs_remote *row, const struct vteprec_physical_locator *locator)$/;"	f
vteprec_ucast_macs_remote_set_logical_switch	.\lib\vtep-idl.c	/^vteprec_ucast_macs_remote_set_logical_switch(const struct vteprec_ucast_macs_remote *row, const struct vteprec_logical_switch *logical_switch)$/;"	f
vteprec_ucast_macs_remote_unparse_MAC	.\lib\vtep-idl.c	/^vteprec_ucast_macs_remote_unparse_MAC(struct ovsdb_idl_row *row OVS_UNUSED)$/;"	f	file:
vteprec_ucast_macs_remote_unparse_ipaddr	.\lib\vtep-idl.c	/^vteprec_ucast_macs_remote_unparse_ipaddr(struct ovsdb_idl_row *row OVS_UNUSED)$/;"	f	file:
vteprec_ucast_macs_remote_unparse_locator	.\lib\vtep-idl.c	/^vteprec_ucast_macs_remote_unparse_locator(struct ovsdb_idl_row *row OVS_UNUSED)$/;"	f	file:
vteprec_ucast_macs_remote_unparse_logical_switch	.\lib\vtep-idl.c	/^vteprec_ucast_macs_remote_unparse_logical_switch(struct ovsdb_idl_row *row OVS_UNUSED)$/;"	f	file:
vteprec_ucast_macs_remote_verify_MAC	.\lib\vtep-idl.c	/^vteprec_ucast_macs_remote_verify_MAC(const struct vteprec_ucast_macs_remote *row)$/;"	f
vteprec_ucast_macs_remote_verify_ipaddr	.\lib\vtep-idl.c	/^vteprec_ucast_macs_remote_verify_ipaddr(const struct vteprec_ucast_macs_remote *row)$/;"	f
vteprec_ucast_macs_remote_verify_locator	.\lib\vtep-idl.c	/^vteprec_ucast_macs_remote_verify_locator(const struct vteprec_ucast_macs_remote *row)$/;"	f
vteprec_ucast_macs_remote_verify_logical_switch	.\lib\vtep-idl.c	/^vteprec_ucast_macs_remote_verify_logical_switch(const struct vteprec_ucast_macs_remote *row)$/;"	f
vx_flags	.\datapath\linux\compat\vxlan.c	/^	__be32 vx_flags;$/;"	m	struct:vxlanhdr	file:
vx_vni	.\datapath\linux\compat\vxlan.c	/^	__be32 vx_vni;$/;"	m	struct:vxlanhdr	file:
vxlan_del_work	.\datapath\linux\compat\vxlan.c	/^static void vxlan_del_work(struct work_struct *work)$/;"	f	file:
vxlan_get_name	.\datapath\vport-vxlan.c	/^static const char *vxlan_get_name(const struct vport *vport)$/;"	f	file:
vxlan_get_options	.\datapath\vport-vxlan.c	/^static int vxlan_get_options(const struct vport *vport, struct sk_buff *skb)$/;"	f	file:
vxlan_gso	.\datapath\linux\compat\vxlan.c	/^static void vxlan_gso(struct sk_buff *skb)$/;"	f	file:
vxlan_port	.\datapath\vport-vxlan.c	/^struct vxlan_port {$/;"	s	file:
vxlan_rcv	.\datapath\vport-vxlan.c	/^static void vxlan_rcv(struct vxlan_sock *vs, struct sk_buff *skb, __be32 vx_vni)$/;"	f	file:
vxlan_rcv_t	.\datapath\linux\compat\include\net\vxlan.h	/^typedef void (vxlan_rcv_t)(struct vxlan_sock *vs, struct sk_buff *skb, __be32 key);$/;"	t
vxlan_set_owner	.\datapath\linux\compat\vxlan.c	/^static void vxlan_set_owner(struct sock *sk, struct sk_buff *skb)$/;"	f	file:
vxlan_sock	.\datapath\linux\compat\include\net\vxlan.h	/^struct vxlan_sock {$/;"	s
vxlan_sock_add	.\datapath\linux\compat\vxlan.c	/^struct vxlan_sock *vxlan_sock_add(struct net *net, __be16 port,$/;"	f
vxlan_sock_put	.\datapath\linux\compat\vxlan.c	/^static void vxlan_sock_put(struct sk_buff *skb)$/;"	f	file:
vxlan_sock_release	.\datapath\linux\compat\vxlan.c	/^void vxlan_sock_release(struct vxlan_sock *vs)$/;"	f
vxlan_socket_create	.\datapath\linux\compat\vxlan.c	/^static struct vxlan_sock *vxlan_socket_create(struct net *net, __be16 port,$/;"	f	file:
vxlan_src_port	.\datapath\linux\compat\vxlan.c	/^__be16 vxlan_src_port(__u16 port_min, __u16 port_max, struct sk_buff *skb)$/;"	f
vxlan_tnl_create	.\datapath\vport-vxlan.c	/^static struct vport *vxlan_tnl_create(const struct vport_parms *parms)$/;"	f	file:
vxlan_tnl_destroy	.\datapath\vport-vxlan.c	/^static void vxlan_tnl_destroy(struct vport *vport)$/;"	f	file:
vxlan_tnl_send	.\datapath\vport-vxlan.c	/^static int vxlan_tnl_send(struct vport *vport, struct sk_buff *skb)$/;"	f	file:
vxlan_udp_encap_recv	.\datapath\linux\compat\vxlan.c	/^static int vxlan_udp_encap_recv(struct sock *sk, struct sk_buff *skb)$/;"	f	file:
vxlan_vport	.\datapath\vport-vxlan.c	/^static inline struct vxlan_port *vxlan_vport(const struct vport *vport)$/;"	f	file:
vxlan_xmit_skb	.\datapath\linux\compat\include\net\vxlan.h	30;"	d
vxlan_xmit_skb	.\datapath\linux\compat\vxlan.c	/^int vxlan_xmit_skb(struct vxlan_sock *vs,$/;"	f
vxlanhdr	.\datapath\linux\compat\vxlan.c	/^struct vxlanhdr {$/;"	s	file:
wait	.\include\sparse\sys\wait.h	26;"	d
wait	.\include\sparse\sys\wait.h	27;"	d
wait	.\lib\dpif-provider.h	/^    void (*wait)(struct dpif *dpif);$/;"	m	struct:dpif_class
wait	.\lib\netdev-provider.h	/^    void (*wait)(void);$/;"	m	struct:netdev_class
wait	.\lib\stream-provider.h	/^    void (*wait)(struct pstream *pstream);$/;"	m	struct:pstream_class
wait	.\lib\stream-provider.h	/^    void (*wait)(struct stream *stream, enum stream_wait_type type);$/;"	m	struct:stream_class
wait	.\lib\vconn-provider.h	/^    void (*wait)(struct pvconn *pvconn);$/;"	m	struct:pvconn_class
wait	.\lib\vconn-provider.h	/^    void (*wait)(struct vconn *vconn, enum vconn_wait_type type);$/;"	m	struct:vconn_class
wait	.\ofproto\ofproto-dpif.c	/^wait(struct ofproto *ofproto_)$/;"	f	file:
wait	.\ofproto\ofproto-provider.h	/^    void (*wait)(struct ofproto *ofproto);$/;"	m	struct:ofproto_class
wait	.\python\ovs\db\idl.py	/^    def wait(self, poller):$/;"	m	class:Idl
wait	.\python\ovs\db\idl.py	/^    def wait(self, poller):$/;"	m	class:Transaction
wait	.\python\ovs\jsonrpc.py	/^    def wait(self, poller):$/;"	m	class:Connection
wait	.\python\ovs\jsonrpc.py	/^    def wait(self, poller):$/;"	m	class:Session
wait	.\python\ovs\reconnect.py	/^    def wait(self, poller, now):$/;"	m	class:Reconnect
wait	.\python\ovs\stream.py	/^    def wait(self, poller):$/;"	m	class:PassiveStream
wait	.\python\ovs\stream.py	/^    def wait(self, poller, wait):$/;"	m	class:Stream
wait	.\python\ovs\unixctl\server.py	/^    def wait(self, poller):$/;"	m	class:UnixctlServer
wait_auxdata	.\ovsdb\execution.c	/^struct wait_auxdata {$/;"	s	file:
wait_for_reload	.\utilities\ovs-vsctl.c	/^static bool wait_for_reload = true;$/;"	v	file:
waiters	.\ovsdb\server.h	/^    struct hmap waiters;        \/* "ovsdb_lock_waiter *"s by lock name. *\/$/;"	m	struct:ovsdb_session	typeref:struct:ovsdb_session::hmap
waiters	.\ovsdb\server.h	/^    struct list waiters;         \/* Contains "struct ovsdb_lock_waiter"s. *\/$/;"	m	struct:ovsdb_lock	typeref:struct:ovsdb_lock::list
waitpid	.\include\sparse\sys\wait.h	30;"	d
waitpid	.\include\sparse\sys\wait.h	31;"	d
wall_clock	.\lib\timeval.c	/^static struct clock wall_clock;      \/* CLOCK_REALTIME. *\/$/;"	v	typeref:struct:clock	file:
want_mlockall	.\vswitchd\ovs-vswitchd.c	/^static bool want_mlockall;$/;"	v	file:
want_report	.\lib\memory.c	/^static bool want_report;$/;"	v	file:
want_to_poll_events	.\lib\stream-ssl.c	/^want_to_poll_events(int want)$/;"	f	file:
wanted_ports	.\vswitchd\bridge.c	/^    struct shash wanted_ports;$/;"	m	struct:bridge	typeref:struct:bridge::shash	file:
warn	.\python\ovs\vlog.py	/^    def warn(self, message, **kwargs):$/;"	m	class:Vlog
warn	.\tests\test-stp.c	/^warn(const char *message, ...)$/;"	f	file:
warn_is_enabled	.\python\ovs\vlog.py	/^    def warn_is_enabled(self):$/;"	m	class:Vlog
warnings	.\python\compat\argparse.py	/^            import warnings$/;"	i
warnings	.\python\compat\argparse.py	/^        import warnings$/;"	i
warnx	.\lib\getopt_long.c	65;"	d	file:
watch_group	.\include\openflow\openflow-1.1.h	/^    ovs_be32 watch_group;            \/* Group whose state affects whether this$/;"	m	struct:ofp11_bucket
watch_group	.\lib\ofp-util.h	/^    uint32_t watch_group;       \/* Group whose state affects whether this$/;"	m	struct:ofputil_bucket
watch_port	.\include\openflow\openflow-1.1.h	/^    ovs_be32 watch_port;             \/* Port whose state affects whether this$/;"	m	struct:ofp11_bucket
watch_port	.\lib\ofp-util.h	/^    ofp_port_t watch_port;      \/* Port whose state affects whether this bucket$/;"	m	struct:ofputil_bucket
watchdp	.\xenserver\etc_profile.d_openvswitch.sh	/^function watchdp {$/;"	f
watchdpflows	.\xenserver\etc_profile.d_openvswitch.sh	/^function watchdpflows {$/;"	f
watchflows	.\xenserver\etc_profile.d_openvswitch.sh	/^function watchflows {$/;"	f
wc	.\lib\learning-switch.c	/^    struct flow_wildcards wc;   \/* Wildcards to apply to flows. *\/$/;"	m	struct:lswitch	typeref:struct:lswitch::flow_wildcards	file:
wc	.\lib\match.h	/^    struct flow_wildcards wc;$/;"	m	struct:match	typeref:struct:match::flow_wildcards
wc	.\ofproto\ofproto-dpif-xlate.h	/^    struct flow_wildcards wc;$/;"	m	struct:xlate_out	typeref:struct:xlate_out::flow_wildcards
wc	.\ofproto\ofproto-dpif.c	/^    struct flow_wildcards wc;$/;"	m	struct:trace_ctx	typeref:struct:trace_ctx::flow_wildcards	file:
weak_ref	.\lib\ovsdb-data.h	/^    bool weak_ref;              \/* Parsed a weak reference to this row? *\/$/;"	m	struct:ovsdb_symbol
weight	.\include\openflow\openflow-1.1.h	/^    ovs_be16 weight;                 \/* Relative weight of bucket. Only$/;"	m	struct:ofp11_bucket
weight	.\lib\ofp-util.h	/^    uint16_t weight;            \/* Relative weight, for "select" groups. *\/$/;"	m	struct:ofputil_bucket
wevent	.\lib\daemon-windows.c	/^static HANDLE wevent;$/;"	v	file:
wevent	.\lib\fatal-signal.c	/^static HANDLE wevent;$/;"	v	file:
wevent	.\lib\poll-loop.c	/^    HANDLE wevent;              \/* Events for WaitForMultipleObjects(). *\/$/;"	m	struct:poll_node	file:
wevent	.\lib\stream-fd-windows.c	/^    HANDLE wevent;$/;"	m	struct:fd_pstream	file:
wevent	.\lib\stream-fd-windows.c	/^    HANDLE wevent;$/;"	m	struct:stream_fd	file:
wevent	.\lib\stream-ssl.c	/^    HANDLE wevent;$/;"	m	struct:pssl_pstream	file:
wevent	.\lib\stream-ssl.c	/^    HANDLE wevent;$/;"	m	struct:ssl_stream	file:
when	.\lib\timeval.c	/^    long long int when;         \/* Time that this sample was taken. *\/$/;"	m	struct:cpu_usage	file:
where	.\lib\ovs-thread.h	/^    const char *where;          \/* NULL if and only if uninitialized. *\/$/;"	m	struct:ovs_mutex
where	.\lib\ovs-thread.h	/^    const char *where;          \/* NULL if and only if uninitialized. *\/$/;"	m	struct:ovs_rwlock
where	.\lib\poll-loop.c	/^    const char *where;          \/* Where poll_node was created. *\/$/;"	m	struct:poll_node	file:
where_uuid_equals	.\lib\ovsdb-idl.c	/^where_uuid_equals(const struct uuid *uuid)$/;"	f	file:
width	.\lib\util.c	/^    unsigned int width;$/;"	m	struct:scan_spec	file:
wildcard	.\lib\ofp-util.h	/^    uint64_t wildcard;          \/* Subset of 'match' that may be wildcarded. *\/$/;"	m	struct:ofputil_table_features
wildcard_extra_bits	.\tests\test-classifier.c	/^wildcard_extra_bits(struct flow_wildcards *mask)$/;"	f	file:
wildcards	.\include\openflow\openflow-1.0.h	/^    ovs_be32 wildcards;        \/* Wildcard fields. *\/$/;"	m	struct:ofp10_match
wildcards	.\include\openflow\openflow-1.0.h	/^    ovs_be32 wildcards;      \/* Bitmap of OFPFW10_* wildcards that are$/;"	m	struct:ofp10_table_stats
wildcards	.\include\openflow\openflow-1.1.h	/^    ovs_be32 wildcards;        \/* Wildcard fields. *\/$/;"	m	struct:ofp11_match
wildcards	.\include\openflow\openflow-1.1.h	/^    ovs_be32 wildcards;      \/* Bitmap of OFPFMF_* wildcards that are$/;"	m	struct:ofp11_table_stats
wildcards	.\include\openflow\openflow-1.2.h	/^    ovs_be64 wildcards;      \/* Bitmap of (1 << OFPXMT_*) wildcards that are$/;"	m	struct:ofp12_table_stats
wildcards	.\lib\learning-switch.h	/^    uint32_t wildcards;$/;"	m	struct:lswitch_config
wildcards	.\tests\test-controller.c	/^static uint32_t wildcards = 0;$/;"	v	file:
win32wnet	.\python\compat\uuid.py	/^    import win32wnet, netbios$/;"	i
windows_open	.\lib\stream-tcp.c	/^windows_open(const char *name, char *suffix, struct stream **streamp,$/;"	f	file:
windows_stream_class	.\lib\stream-tcp.c	/^const struct stream_class windows_stream_class = {$/;"	v	typeref:struct:stream_class
winsock_start	.\lib\stream.c	/^winsock_start(void)$/;"	f	file:
wire_reason	.\ofproto\connmgr.c	/^wire_reason(struct ofconn *ofconn, const struct ofproto_packet_in *pin)$/;"	f	file:
without_constraints	.\python\ovs\db\types.py	/^    def without_constraints(self):$/;"	m	class:BaseType
word2	.\datapath\vport-lisp.c	/^		} word2;$/;"	m	union:lisphdr::__anon18	typeref:struct:lisphdr::__anon18::__anon19	file:
wrap_json	.\lib\ovsdb-data.c	/^wrap_json(const char *name, struct json *wrapped)$/;"	f	file:
writable	.\lib\meta-flow.h	/^    bool writable;              \/* May be written by actions? *\/$/;"	m	struct:mf_field
write	.\lib\ofp-util.h	/^        } write, apply;$/;"	m	struct:ofputil_table_features::ofputil_table_instruction_features	typeref:struct:ofputil_table_features::ofputil_table_instruction_features::ofputil_table_action_features
write	.\xenserver\opt_xensource_libexec_InterfaceReconfigure.py	/^    def write(self, args):$/;"	m	class:ConfigurationFile
write_actions	.\include\openflow\openflow-1.1.h	/^    ovs_be32 write_actions;  \/* Bitmap of OFPAT_* that are supported$/;"	m	struct:ofp11_table_stats
write_actions	.\include\openflow\openflow-1.2.h	/^    ovs_be32 write_actions;  \/* Bitmap of OFPAT_* that are supported$/;"	m	struct:ofp12_table_stats
write_bool_column	.\ovsdb\ovsdb-server.c	/^write_bool_column(struct ovsdb_row *row, const char *column_name, bool value)$/;"	f	file:
write_error	.\ovsdb\log.c	/^    bool write_error;$/;"	m	struct:ovsdb_log	file:
write_fully	.\lib\socket-util.c	/^write_fully(int fd, const void *p_, size_t size, size_t *bytes_written)$/;"	f
write_fully	.\python\ovs\socket_util.py	/^def write_fully(fd, buf):$/;"	f
write_handle	.\lib\daemon-windows.c	/^static HANDLE write_handle;  \/* End of pipe to write to parent. *\/$/;"	v	file:
write_metadata	.\lib\ofp-actions.c	/^    struct nx_action_write_metadata write_metadata;$/;"	m	union:ofp_action	typeref:struct:ofp_action::nx_action_write_metadata	file:
write_setfields	.\include\openflow\openflow-1.2.h	/^    ovs_be64 write_setfields;\/* Bitmap of (1 << OFPXMT_*) header fields that$/;"	m	struct:ofp12_table_stats
write_string_string_column	.\ovsdb\ovsdb-server.c	/^write_string_string_column(struct ovsdb_row *row, const char *column_name,$/;"	f	file:
written	.\lib\ovsdb-idl-provider.h	/^    unsigned long int *written; \/* Bitmap of columns from "new" to write. *\/$/;"	m	struct:ovsdb_idl_row
x2nrealloc	.\lib\util.c	/^x2nrealloc(void *p, size_t *n, size_t s)$/;"	f
xapi_local	.\tests\MockXenAPI.py	/^def xapi_local():$/;"	f
xasprintf	.\lib\util.c	/^xasprintf(const char *format, ...)$/;"	f
xastrftime_msec	.\lib\dynamic-string.c	/^xastrftime_msec(const char *template, long long int when, bool utc)$/;"	f
xbridge	.\ofproto\ofproto-dpif-xlate.c	/^    const struct xbridge *xbridge;$/;"	m	struct:xlate_ctx	typeref:struct:xlate_ctx::xbridge	file:
xbridge	.\ofproto\ofproto-dpif-xlate.c	/^    struct xbridge *xbridge;         \/* Parent bridge. *\/$/;"	m	struct:xport	typeref:struct:xport::xbridge	file:
xbridge	.\ofproto\ofproto-dpif-xlate.c	/^    struct xbridge *xbridge;       \/* Parent xbridge. *\/$/;"	m	struct:xbundle	typeref:struct:xbundle::xbridge	file:
xbridge	.\ofproto\ofproto-dpif-xlate.c	/^struct xbridge {$/;"	s	file:
xbridge_lookup	.\ofproto\ofproto-dpif-xlate.c	/^xbridge_lookup(const struct ofproto_dpif *ofproto)$/;"	f	file:
xbridges	.\ofproto\ofproto-dpif-xlate.c	/^static struct hmap xbridges = HMAP_INITIALIZER(&xbridges);$/;"	v	typeref:struct:hmap	file:
xbundle	.\ofproto\ofproto-dpif-xlate.c	/^    struct xbundle *xbundle;         \/* Parent xbundle or null. *\/$/;"	m	struct:xport	typeref:struct:xport::xbundle	file:
xbundle	.\ofproto\ofproto-dpif-xlate.c	/^struct xbundle {$/;"	s	file:
xbundle_includes_vlan	.\ofproto\ofproto-dpif-xlate.c	/^xbundle_includes_vlan(const struct xbundle *xbundle, uint16_t vlan)$/;"	f	file:
xbundle_lookup	.\ofproto\ofproto-dpif-xlate.c	/^xbundle_lookup(const struct ofbundle *ofbundle)$/;"	f	file:
xbundle_mirror_dst	.\ofproto\ofproto-dpif-xlate.c	/^xbundle_mirror_dst(const struct xbridge *xbridge, struct xbundle *xbundle)$/;"	f	file:
xbundle_mirror_out	.\ofproto\ofproto-dpif-xlate.c	/^xbundle_mirror_out(const struct xbridge *xbridge, struct xbundle *xbundle)$/;"	f	file:
xbundle_mirror_src	.\ofproto\ofproto-dpif-xlate.c	/^xbundle_mirror_src(const struct xbridge *xbridge, struct xbundle *xbundle)$/;"	f	file:
xbundle_trunks_vlan	.\ofproto\ofproto-dpif-xlate.c	/^xbundle_trunks_vlan(const struct xbundle *bundle, uint16_t vlan)$/;"	f	file:
xbundles	.\ofproto\ofproto-dpif-xlate.c	/^    struct list xbundles;         \/* Owned xbundles. *\/$/;"	m	struct:xbridge	typeref:struct:xbridge::list	file:
xbundles	.\ofproto\ofproto-dpif-xlate.c	/^static struct hmap xbundles = HMAP_INITIALIZER(&xbundles);$/;"	v	typeref:struct:hmap	file:
xc_entry	.\ofproto\ofproto-dpif-xlate.c	/^struct xc_entry {$/;"	s	file:
xc_type	.\ofproto\ofproto-dpif-xlate.c	/^enum xc_type {$/;"	g	file:
xcache	.\ofproto\ofproto-dpif-xlate.h	/^    struct xlate_cache *xcache;$/;"	m	struct:xlate_in	typeref:struct:xlate_in::xlate_cache
xcalloc	.\lib\util.c	/^xcalloc(size_t count, size_t size)$/;"	f
xclock_gettime	.\lib\timeval.c	/^xclock_gettime(clock_t id, struct timespec *ts)$/;"	f
xenserver	.\vswitchd\xenserver.c	/^VLOG_DEFINE_THIS_MODULE(xenserver);$/;"	v
xenserver_get_host_uuid	.\vswitchd\xenserver.c	/^xenserver_get_host_uuid(void)$/;"	f
xfork	.\lib\ovs-thread.h	629;"	d
xfork_at	.\lib\ovs-thread.c	/^xfork_at(const char *where)$/;"	f
xgetfiletime	.\lib\timeval.c	/^xgetfiletime(void)$/;"	f	file:
xgettimeofday	.\lib\timeval.c	/^xgettimeofday(struct timeval *tv)$/;"	f
xid	.\include\openflow\nicira-ext.h	/^    ovs_be32 xid;               \/* Controller-specified xid from flow_mod. *\/$/;"	m	struct:nx_flow_update_abbrev
xid	.\include\openflow\openflow-common.h	/^    ovs_be32 xid;       \/* Transaction id associated with this packet.$/;"	m	struct:ofp_header
xid	.\lib\dhcp.h	/^    ovs_be32 xid;               \/* Transaction ID. *\/$/;"	m	struct:dhcp_header
xid	.\lib\ofp-util.h	/^    ovs_be32 xid;$/;"	m	struct:ofputil_flow_update
xin	.\ofproto\ofproto-dpif-xlate.c	/^    struct xlate_in *xin;$/;"	m	struct:xlate_ctx	typeref:struct:xlate_ctx::xlate_in	file:
xin	.\ofproto\ofproto-dpif.c	/^    struct xlate_in xin;$/;"	m	struct:trace_ctx	typeref:struct:trace_ctx::xlate_in	file:
xlate_action_set	.\ofproto\ofproto-dpif-xlate.c	/^xlate_action_set(struct xlate_ctx *ctx)$/;"	f	file:
xlate_actions	.\ofproto\ofproto-dpif-xlate.c	/^COVERAGE_DEFINE(xlate_actions);$/;"	v
xlate_actions_for_side_effects	.\ofproto\ofproto-dpif-xlate.c	/^xlate_actions_for_side_effects(struct xlate_in *xin)$/;"	f
xlate_actions_mpls_overflow	.\ofproto\ofproto-dpif-xlate.c	/^COVERAGE_DEFINE(xlate_actions_mpls_overflow);$/;"	v
xlate_actions_oversize	.\ofproto\ofproto-dpif-xlate.c	/^COVERAGE_DEFINE(xlate_actions_oversize);$/;"	v
xlate_actions_too_many_output	.\ofproto\ofproto-dpif-xlate.c	/^COVERAGE_DEFINE(xlate_actions_too_many_output);$/;"	v
xlate_all_group	.\ofproto\ofproto-dpif-xlate.c	/^xlate_all_group(struct xlate_ctx *ctx, struct group_dpif *group)$/;"	f	file:
xlate_bundle_action	.\ofproto\ofproto-dpif-xlate.c	/^xlate_bundle_action(struct xlate_ctx *ctx,$/;"	f	file:
xlate_bundle_remove	.\ofproto\ofproto-dpif-xlate.c	/^xlate_bundle_remove(struct ofbundle *ofbundle)$/;"	f
xlate_bundle_set	.\ofproto\ofproto-dpif-xlate.c	/^xlate_bundle_set(struct ofproto_dpif *ofproto, struct ofbundle *ofbundle,$/;"	f
xlate_cache	.\ofproto\ofproto-dpif-xlate.c	/^struct xlate_cache {$/;"	s	file:
xlate_cache_add_entry	.\ofproto\ofproto-dpif-xlate.c	/^xlate_cache_add_entry(struct xlate_cache *xcache, enum xc_type type)$/;"	f	file:
xlate_cache_clear	.\ofproto\ofproto-dpif-xlate.c	/^xlate_cache_clear(struct xlate_cache *xcache)$/;"	f
xlate_cache_clear_netflow	.\ofproto\ofproto-dpif-xlate.c	/^xlate_cache_clear_netflow(struct netflow *netflow, struct flow *flow)$/;"	f	file:
xlate_cache_delete	.\ofproto\ofproto-dpif-xlate.c	/^xlate_cache_delete(struct xlate_cache *xcache)$/;"	f
xlate_cache_netdev	.\ofproto\ofproto-dpif-xlate.c	/^xlate_cache_netdev(struct xc_entry *entry, const struct dpif_flow_stats *stats)$/;"	f	file:
xlate_cache_new	.\ofproto\ofproto-dpif-xlate.c	/^xlate_cache_new(void)$/;"	f
xlate_cache_normal	.\ofproto\ofproto-dpif-xlate.c	/^xlate_cache_normal(struct ofproto_dpif *ofproto, struct flow *flow, int vlan)$/;"	f	file:
xlate_ctx	.\ofproto\ofproto-dpif-xlate.c	/^struct xlate_ctx {$/;"	s	file:
xlate_dev_unref	.\ofproto\ofproto-dpif-xlate.c	/^xlate_dev_unref(struct xc_entry *entry)$/;"	f	file:
xlate_enqueue_action	.\ofproto\ofproto-dpif-xlate.c	/^xlate_enqueue_action(struct xlate_ctx *ctx,$/;"	f	file:
xlate_ff_group	.\ofproto\ofproto-dpif-xlate.c	/^xlate_ff_group(struct xlate_ctx *ctx, struct group_dpif *group)$/;"	f	file:
xlate_fin_timeout	.\ofproto\ofproto-dpif-xlate.c	/^xlate_fin_timeout(struct xlate_ctx *ctx,$/;"	f	file:
xlate_fin_timeout__	.\ofproto\ofproto-dpif-xlate.c	/^xlate_fin_timeout__(struct rule_dpif *rule, uint16_t tcp_flags,$/;"	f	file:
xlate_group_action	.\ofproto\ofproto-dpif-xlate.c	/^xlate_group_action(struct xlate_ctx *ctx, uint32_t group_id)$/;"	f	file:
xlate_group_action__	.\ofproto\ofproto-dpif-xlate.c	/^xlate_group_action__(struct xlate_ctx *ctx, struct group_dpif *group)$/;"	f	file:
xlate_group_bucket	.\ofproto\ofproto-dpif-xlate.c	/^xlate_group_bucket(struct xlate_ctx *ctx, const struct ofputil_bucket *bucket)$/;"	f	file:
xlate_group_resource_check	.\ofproto\ofproto-dpif-xlate.c	/^xlate_group_resource_check(struct xlate_ctx *ctx)$/;"	f	file:
xlate_in	.\ofproto\ofproto-dpif-xlate.h	/^struct xlate_in {$/;"	s
xlate_in_init	.\ofproto\ofproto-dpif-xlate.c	/^xlate_in_init(struct xlate_in *xin, struct ofproto_dpif *ofproto,$/;"	f
xlate_learn_action	.\ofproto\ofproto-dpif-xlate.c	/^xlate_learn_action(struct xlate_ctx *ctx, const struct ofpact_learn *learn)$/;"	f	file:
xlate_learn_action__	.\ofproto\ofproto-dpif-xlate.c	/^xlate_learn_action__(struct xlate_ctx *ctx, const struct ofpact_learn *learn,$/;"	f	file:
xlate_normal	.\ofproto\ofproto-dpif-xlate.c	/^xlate_normal(struct xlate_ctx *ctx)$/;"	f	file:
xlate_ofpact_resubmit	.\ofproto\ofproto-dpif-xlate.c	/^xlate_ofpact_resubmit(struct xlate_ctx *ctx,$/;"	f	file:
xlate_ofport_remove	.\ofproto\ofproto-dpif-xlate.c	/^xlate_ofport_remove(struct ofport_dpif *ofport)$/;"	f
xlate_ofport_set	.\ofproto\ofproto-dpif-xlate.c	/^xlate_ofport_set(struct ofproto_dpif *ofproto, struct ofbundle *ofbundle,$/;"	f
xlate_ofproto_set	.\ofproto\ofproto-dpif-xlate.c	/^xlate_ofproto_set(struct ofproto_dpif *ofproto, const char *name,$/;"	f
xlate_out	.\ofproto\ofproto-dpif-xlate.h	/^struct xlate_out {$/;"	s
xlate_out_copy	.\ofproto\ofproto-dpif-xlate.c	/^xlate_out_copy(struct xlate_out *dst, const struct xlate_out *src)$/;"	f
xlate_out_uninit	.\ofproto\ofproto-dpif-xlate.c	/^xlate_out_uninit(struct xlate_out *xout)$/;"	f
xlate_output_action	.\ofproto\ofproto-dpif-xlate.c	/^xlate_output_action(struct xlate_ctx *ctx,$/;"	f	file:
xlate_output_reg_action	.\ofproto\ofproto-dpif-xlate.c	/^xlate_output_reg_action(struct xlate_ctx *ctx,$/;"	f	file:
xlate_push_stats	.\ofproto\ofproto-dpif-xlate.c	/^xlate_push_stats(struct xlate_cache *xcache, bool may_learn,$/;"	f
xlate_receive	.\ofproto\ofproto-dpif-xlate.c	/^xlate_receive(const struct dpif_backer *backer, struct ofpbuf *packet,$/;"	f
xlate_recirc	.\ofproto\ofproto-dpif-xlate.h	/^struct xlate_recirc {$/;"	s
xlate_recursively	.\ofproto\ofproto-dpif-xlate.c	/^xlate_recursively(struct xlate_ctx *ctx, struct rule_dpif *rule)$/;"	f	file:
xlate_remove_ofproto	.\ofproto\ofproto-dpif-xlate.c	/^xlate_remove_ofproto(struct ofproto_dpif *ofproto)$/;"	f
xlate_report	.\ofproto\ofproto-dpif-xlate.c	/^xlate_report(struct xlate_ctx *ctx, const char *s)$/;"	f	file:
xlate_resubmit_resource_check	.\ofproto\ofproto-dpif-xlate.c	/^xlate_resubmit_resource_check(struct xlate_ctx *ctx)$/;"	f	file:
xlate_rwlock	.\ofproto\ofproto-dpif-xlate.c	/^    OVS_REQ_RDLOCK(xlate_rwlock);$/;"	v
xlate_rwlock	.\ofproto\ofproto-dpif-xlate.c	/^struct ovs_rwlock xlate_rwlock = OVS_RWLOCK_INITIALIZER;$/;"	v	typeref:struct:ovs_rwlock
xlate_rwlock	.\ofproto\ofproto-dpif-xlate.h	/^                      bool floodable) OVS_REQ_WRLOCK(xlate_rwlock);$/;"	v
xlate_rwlock	.\ofproto\ofproto-dpif-xlate.h	/^                      bool may_enable) OVS_REQ_WRLOCK(xlate_rwlock);$/;"	v
xlate_rwlock	.\ofproto\ofproto-dpif-xlate.h	/^    OVS_EXCLUDED(xlate_rwlock);$/;"	v
xlate_rwlock	.\ofproto\ofproto-dpif-xlate.h	/^    OVS_REQ_WRLOCK(xlate_rwlock);$/;"	v
xlate_rwlock	.\ofproto\ofproto-dpif-xlate.h	/^void xlate_bundle_remove(struct ofbundle *) OVS_REQ_WRLOCK(xlate_rwlock);$/;"	v
xlate_rwlock	.\ofproto\ofproto-dpif-xlate.h	/^void xlate_ofport_remove(struct ofport_dpif *) OVS_REQ_WRLOCK(xlate_rwlock);$/;"	v
xlate_rwlock	.\ofproto\ofproto-dpif-xlate.h	/^void xlate_remove_ofproto(struct ofproto_dpif *) OVS_REQ_WRLOCK(xlate_rwlock);$/;"	v
xlate_rwlock	.\ofproto\ofproto-dpif.h	/^    OVS_EXCLUDED(xlate_rwlock);$/;"	v
xlate_sample_action	.\ofproto\ofproto-dpif-xlate.c	/^xlate_sample_action(struct xlate_ctx *ctx,$/;"	f	file:
xlate_select_group	.\ofproto\ofproto-dpif-xlate.c	/^xlate_select_group(struct xlate_ctx *ctx, struct group_dpif *group)$/;"	f	file:
xlate_send_packet	.\ofproto\ofproto-dpif-xlate.c	/^xlate_send_packet(const struct ofport_dpif *ofport, struct ofpbuf *packet)$/;"	f
xlate_set_queue_action	.\ofproto\ofproto-dpif-xlate.c	/^xlate_set_queue_action(struct xlate_ctx *ctx, uint32_t queue_id)$/;"	f	file:
xlate_table_action	.\ofproto\ofproto-dpif-xlate.c	/^xlate_table_action(struct xlate_ctx *ctx, ofp_port_t in_port, uint8_t table_id,$/;"	f	file:
xlate_write_actions	.\ofproto\ofproto-dpif-xlate.c	/^xlate_write_actions(struct xlate_ctx *ctx, const struct ofpact *a)$/;"	f	file:
xmalloc	.\lib\util.c	/^xmalloc(size_t size)$/;"	f
xmalloc_cacheline	.\lib\util.c	/^xmalloc_cacheline(size_t size)$/;"	f
xmemdup	.\lib\util.c	/^xmemdup(const void *p_, size_t size)$/;"	f
xmemdup0	.\lib\util.c	/^xmemdup0(const char *p_, size_t length)$/;"	f
xmlrpc	.\python\ovstest\rpcserver.py	/^from twisted.web import xmlrpc$/;"	i
xmlrpc_add_port_to_bridge	.\python\ovstest\rpcserver.py	/^    def xmlrpc_add_port_to_bridge(self, bridge, port):$/;"	m	class:TestArena
xmlrpc_close_tcp_listener	.\python\ovstest\rpcserver.py	/^    def xmlrpc_close_tcp_listener(self, handle):$/;"	m	class:TestArena
xmlrpc_close_tcp_sender	.\python\ovstest\rpcserver.py	/^    def xmlrpc_close_tcp_sender(self, handle):$/;"	m	class:TestArena
xmlrpc_close_udp_listener	.\python\ovstest\rpcserver.py	/^    def xmlrpc_close_udp_listener(self, handle):$/;"	m	class:TestArena
xmlrpc_close_udp_sender	.\python\ovstest\rpcserver.py	/^    def xmlrpc_close_udp_sender(self, handle):$/;"	m	class:TestArena
xmlrpc_create_bridge	.\python\ovstest\rpcserver.py	/^    def xmlrpc_create_bridge(self, brname):$/;"	m	class:TestArena
xmlrpc_create_tcp_listener	.\python\ovstest\rpcserver.py	/^    def xmlrpc_create_tcp_listener(self, port):$/;"	m	class:TestArena
xmlrpc_create_tcp_sender	.\python\ovstest\rpcserver.py	/^    def xmlrpc_create_tcp_sender(self, his_ip, his_port, duration):$/;"	m	class:TestArena
xmlrpc_create_test_bridge	.\python\ovstest\rpcserver.py	/^    def xmlrpc_create_test_bridge(self, bridge, iface):$/;"	m	class:TestArena
xmlrpc_create_udp_listener	.\python\ovstest\rpcserver.py	/^    def xmlrpc_create_udp_listener(self, port):$/;"	m	class:TestArena
xmlrpc_create_udp_sender	.\python\ovstest\rpcserver.py	/^    def xmlrpc_create_udp_sender(self, host, count, size, duration):$/;"	m	class:TestArena
xmlrpc_del_bridge	.\python\ovstest\rpcserver.py	/^    def xmlrpc_del_bridge(self, brname):$/;"	m	class:TestArena
xmlrpc_del_port_from_bridge	.\python\ovstest\rpcserver.py	/^    def xmlrpc_del_port_from_bridge(self, port):$/;"	m	class:TestArena
xmlrpc_del_test_bridge	.\python\ovstest\rpcserver.py	/^    def xmlrpc_del_test_bridge(self, bridge, iface):$/;"	m	class:TestArena
xmlrpc_get_driver	.\python\ovstest\rpcserver.py	/^    def xmlrpc_get_driver(self, iface):$/;"	m	class:TestArena
xmlrpc_get_iface_from_bridge	.\python\ovstest\rpcserver.py	/^    def xmlrpc_get_iface_from_bridge(self, brname):$/;"	m	class:TestArena
xmlrpc_get_interface	.\python\ovstest\rpcserver.py	/^    def xmlrpc_get_interface(self, address):$/;"	m	class:TestArena
xmlrpc_get_interface_from_routing_decision	.\python\ovstest\rpcserver.py	/^    def xmlrpc_get_interface_from_routing_decision(self, ip):$/;"	m	class:TestArena
xmlrpc_get_interface_mtu	.\python\ovstest\rpcserver.py	/^    def xmlrpc_get_interface_mtu(self, iface):$/;"	m	class:TestArena
xmlrpc_get_my_address	.\python\ovstest\rpcserver.py	/^    def xmlrpc_get_my_address(self):$/;"	m	class:TestArena
xmlrpc_get_my_address_from	.\python\ovstest\rpcserver.py	/^    def xmlrpc_get_my_address_from(self, his_ip, his_port):$/;"	m	class:TestArena
xmlrpc_get_tcp_listener_results	.\python\ovstest\rpcserver.py	/^    def xmlrpc_get_tcp_listener_results(self, handle):$/;"	m	class:TestArena
xmlrpc_get_tcp_sender_results	.\python\ovstest\rpcserver.py	/^    def xmlrpc_get_tcp_sender_results(self, handle):$/;"	m	class:TestArena
xmlrpc_get_udp_listener_results	.\python\ovstest\rpcserver.py	/^    def xmlrpc_get_udp_listener_results(self, handle):$/;"	m	class:TestArena
xmlrpc_get_udp_sender_results	.\python\ovstest\rpcserver.py	/^    def xmlrpc_get_udp_sender_results(self, handle):$/;"	m	class:TestArena
xmlrpc_interface_assign_ip	.\python\ovstest\rpcserver.py	/^    def xmlrpc_interface_assign_ip(self, iface, ip_address, mask):$/;"	m	class:TestArena
xmlrpc_interface_up	.\python\ovstest\rpcserver.py	/^    def xmlrpc_interface_up(self, iface):$/;"	m	class:TestArena
xmlrpc_is_ovs_bridge	.\python\ovstest\rpcserver.py	/^    def xmlrpc_is_ovs_bridge(self, bridge):$/;"	m	class:TestArena
xmlrpc_ovs_vsctl_set	.\python\ovstest\rpcserver.py	/^    def xmlrpc_ovs_vsctl_set(self, table, record, column, key, value):$/;"	m	class:TestArena
xmlrpc_uname	.\python\ovstest\rpcserver.py	/^    def xmlrpc_uname(self):$/;"	m	class:TestArena
xmlrpclib	.\python\ovstest\rpcserver.py	/^import xmlrpclib$/;"	i
xmlrpclib	.\python\ovstest\util.py	/^import xmlrpclib$/;"	i
xout	.\ofproto\ofproto-dpif-upcall.c	/^    struct xlate_out xout;$/;"	m	struct:flow_miss	typeref:struct:flow_miss::xlate_out	file:
xout	.\ofproto\ofproto-dpif-xlate.c	/^    struct xlate_out *xout;$/;"	m	struct:xlate_ctx	typeref:struct:xlate_ctx::xlate_out	file:
xout	.\ofproto\ofproto-dpif.c	/^    struct xlate_out xout;$/;"	m	struct:trace_ctx	typeref:struct:trace_ctx::xlate_out	file:
xpipe	.\lib\socket-util.c	/^xpipe(int fds[2])$/;"	f
xpipe_nonblocking	.\lib\socket-util.c	/^xpipe_nonblocking(int fds[2])$/;"	f
xport	.\ofproto\ofproto-dpif-xlate.c	/^struct xport {$/;"	s	file:
xport_get_stp_port	.\ofproto\ofproto-dpif-xlate.c	/^xport_get_stp_port(const struct xport *xport)$/;"	f	file:
xport_lookup	.\ofproto\ofproto-dpif-xlate.c	/^xport_lookup(const struct ofport_dpif *ofport)$/;"	f	file:
xport_stp_forward_state	.\ofproto\ofproto-dpif-xlate.c	/^xport_stp_forward_state(const struct xport *xport)$/;"	f	file:
xport_stp_learn_state	.\ofproto\ofproto-dpif-xlate.c	/^xport_stp_learn_state(const struct xport *xport)$/;"	f	file:
xport_stp_should_forward_bpdu	.\ofproto\ofproto-dpif-xlate.c	/^xport_stp_should_forward_bpdu(const struct xport *xport)$/;"	f	file:
xports	.\ofproto\ofproto-dpif-xlate.c	/^    struct hmap xports;           \/* Indexed by ofp_port. *\/$/;"	m	struct:xbridge	typeref:struct:xbridge::hmap	file:
xports	.\ofproto\ofproto-dpif-xlate.c	/^    struct list xports;            \/* Contains "struct xport"s. *\/$/;"	m	struct:xbundle	typeref:struct:xbundle::list	file:
xports	.\ofproto\ofproto-dpif-xlate.c	/^static struct hmap xports = HMAP_INITIALIZER(&xports);$/;"	v	typeref:struct:hmap	file:
xreadlink	.\lib\util.c	/^xreadlink(const char *filename)$/;"	f	file:
xrealloc	.\lib\util.c	/^xrealloc(void *p, size_t size)$/;"	f
xset_nonblocking	.\lib\socket-util.c	/^xset_nonblocking(int fd)$/;"	f
xsigaction	.\lib\signals.c	/^xsigaction(int signum, const struct sigaction *new, struct sigaction *old)$/;"	f
xsleep	.\lib\util.c	/^xsleep(unsigned int seconds)$/;"	f
xstrdup	.\lib\util.c	/^xstrdup(const char *s)$/;"	f
xvasprintf	.\lib\util.c	/^xvasprintf(const char *format, va_list args)$/;"	f
xzalloc	.\lib\util.c	/^xzalloc(size_t size)$/;"	f
xzalloc_cacheline	.\lib\util.c	/^xzalloc_cacheline(size_t size)$/;"	f
yiaddr	.\lib\dhcp.h	/^    ovs_be32 yiaddr;            \/* Client ("your") IP address. *\/$/;"	m	struct:dhcp_header
your_disc	.\lib\bfd.c	/^    ovs_be32 your_disc;   \/* Your discriminator. *\/$/;"	m	struct:msg	file:
zero	.\include\openflow\nicira-ext.h	/^    uint8_t zero;                   \/* Must be zero. *\/$/;"	m	struct:nx_action_controller
zero	.\include\openflow\nicira-ext.h	/^    uint8_t zero[4];            \/* Reserved. Must be zero. *\/$/;"	m	struct:nx_action_bundle
zero	.\include\openflow\nicira-ext.h	/^    uint8_t zero[6];                \/* Reserved, must be zero. *\/$/;"	m	struct:nx_action_stack
zero	.\include\openflow\nicira-ext.h	/^    uint8_t zero[6];            \/* Must be zero. *\/$/;"	m	struct:nx_controller_id
zero	.\include\openflow\nicira-ext.h	/^    uint8_t zero[6];            \/* Reserved, must be zero. *\/$/;"	m	struct:nx_action_output_reg
zero	.\python\ovs\ovsuuid.py	/^def zero():$/;"	f
zero_rightmost_1bit	.\lib\util.h	/^zero_rightmost_1bit(uintmax_t x)$/;"	f
zero_statistics	.\utilities\ovs-dpctl.c	/^static bool zero_statistics;$/;"	v	file:
zeros	.\include\openflow\nicira-ext.h	/^    uint8_t  zeros[2];               \/* Must be zero. *\/$/;"	m	struct:nx_action_mpls_label
zeros	.\include\openflow\nicira-ext.h	/^    uint8_t zeros[4];           \/* Must be zero. *\/$/;"	m	struct:nx_action_cnt_ids
zeros	.\include\openflow\nicira-ext.h	/^    uint8_t zeros[5];           \/* Align to 64 bits (must be zero). *\/$/;"	m	struct:nx_flow_monitor_request
zeros	.\include\openflow\nicira-ext.h	/^    uint8_t zeros[6];               \/* Must be zero. *\/$/;"	m	struct:nx_action_write_metadata
